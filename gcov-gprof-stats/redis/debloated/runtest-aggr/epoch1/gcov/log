Cleanup: may take some time... OK
Starting test server at port 11111
[ready]: 241
Testing unit/printver
[ready]: 242
Testing unit/dump
[ready]: 243
Testing unit/auth
[ready]: 240
Testing unit/protocol
[ready]: 245
Testing unit/keyspace
[ready]: 246
Testing unit/scan
[ready]: 247
Testing unit/type/string
[ready]: 248
Testing unit/type/incr
[ready]: 244
Testing unit/type/list
[ready]: 249
Testing unit/type/list-2
[ready]: 250
Testing unit/type/list-3
[ready]: 252
Testing unit/type/set
[ready]: 253
Testing unit/type/zset
[ready]: 254
Testing unit/type/hash
[ready]: 251
Testing unit/sort
[ready]: 255
Testing unit/expire
[ok]: Check encoding - ziplist
[ok]: ZSET basic ZADD and score update - ziplist
[ok]: ZSET element can't be set to NaN with ZADD - ziplist
[ok]: ZSET element can't be set to NaN with ZINCRBY
[ok]: ZADD with options syntax error with incomplete pair
[ok]: ZADD XX option without key - ziplist
[ok]: ZADD XX existing key - ziplist
[ok]: ZADD XX returns the number of elements actually added
[ok]: ZADD XX updates existing elements score
[ok]: ZADD XX and NX are not compatible
[ok]: ZADD NX with non exisitng key
[ok]: ZADD NX only add new elements without updating old ones
[ok]: ZADD INCR works like ZINCRBY
[ok]: ZADD INCR works with a single score-elemenet pair
[ok]: ZADD CH option changes return value to all changed elements
[ok]: ZINCRBY calls leading to NaN result in error
[ok]: ZADD - Variadic version base case
[ok]: ZADD - Return value is the number of actually added items
[ok]: ZADD - Variadic version does not add nothing on single parsing err
[ok]: ZADD - Variadic version will raise error on missing arg
[ok]: ZINCRBY does not work variadic even if shares ZADD implementation
[ok]: ZCARD basics - ziplist
[ok]: ZREM removes key after last element is removed
[ok]: ZREM variadic version
[ok]: ZREM variadic version -- remove elements after key deletion
[ok]: ZRANGE basics - ziplist
[ok]: ZREVRANGE basics - ziplist
[ok]: ZRANK/ZREVRANK basics - ziplist
[ok]: ZRANK - after deletion - ziplist
[ok]: ZINCRBY - can create a new sorted set - ziplist
[ok]: INCR against non existing key
[ok]: HSET/HLEN - Small hash creation
[ok]: Is the small hash encoded with a ziplist?
[ok]: INCR against key created by incr itself
[ok]: INCR against key originally set with SET
[ok]: INCR over 32bit value
[ok]: INCRBY over 32bit value with over 32bit increment
[ok]: INCR fails against key with spaces (left)
[ok]: INCR fails against key with spaces (right)
[ok]: INCR fails against key with spaces (both)
[ok]: INCR fails against a key holding a list
[ok]: DECRBY over 32bit value with over 32bit increment, negative res
[ok]: ZINCRBY - increment and decrement - ziplist
[ok]: INCR uses shared objects in the 0-9999 range
[ok]: ZINCRBY return value
[ok]: INCR can modify objects in-place
[ok]: INCRBYFLOAT against non existing key
[ok]: INCRBYFLOAT against key originally set with SET
[ok]: INCRBYFLOAT over 32bit value
[ok]: INCRBYFLOAT over 32bit value with over 32bit increment
[ok]: INCRBYFLOAT fails against key with spaces (left)
[ok]: INCRBYFLOAT fails against key with spaces (right)
[ok]: INCRBYFLOAT fails against key with spaces (both)
[ok]: INCRBYFLOAT fails against a key holding a list
[ok]: INCRBYFLOAT does not allow NaN or Infinity
[ok]: Explicit regression for a list bug
[ok]: INCRBYFLOAT decrement
[ok]: string to double with null terminator
[ok]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics
[ok]: ZRANGEBYSCORE with WITHSCORES
[ok]: ZRANGEBYSCORE with LIMIT
[ok]: Old Ziplist: SORT BY key
[ok]: ZRANGEBYSCORE with LIMIT and WITHSCORES
[ok]: DUMP / RESTORE are able to serialize / unserialize a simple key
[ok]: Old Ziplist: SORT BY key with limit
[ok]: ZRANGEBYSCORE with non-value min or max
[ok]: RESTORE can set an arbitrary expire to the materialized key
[ok]: Old Ziplist: SORT BY hash field
[ok]: RESTORE can set an expire that overflows a 32 bit integer
[ok]: SADD, SCARD, SISMEMBER, SMEMBERS basics - regular set
[ok]: RESTORE returns an error of the key already exists
[ok]: SADD, SCARD, SISMEMBER, SMEMBERS basics - intset
[ok]: SADD against non set
[ok]: SADD a non-integer against an intset
[ok]: RESTORE can overwrite an existing key with REPLACE
[ok]: RESTORE can detect a syntax error for unrecongized options
[ok]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics
[ok]: DUMP of non existing key returns nil
[ok]: SADD an integer larger than 64 bits
[ok]: ZLEXCOUNT advanced
[ok]: ZRANGEBYSLEX with LIMIT
[ok]: ZRANGEBYLEX with invalid lex range specifiers
[ok]: AUTH fails if there is no password configured server side
[ok]: DEL against a single item
[ok]: Vararg DEL
[ok]: KEYS with pattern
[ok]: KEYS to get all keys
[ok]: DBSIZE
[ok]: DEL all keys
Testing Redis version 4.0.14 (00000000)
[ok]: EXPIRE - set timeouts multiple times
[ok]: EXPIRE - It should be still possible to read 'x'
[ok]: SET and GET an item
[ok]: SET and GET an empty item
[ok]: SADD overflows the maximum allowed integers in an intset
[ok]: SCAN basic
[ok]: Variadic SADD
[ok]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - ziplist
[ok]: LPUSH, RPUSH, LLENGTH, LINDEX, LPOP - regular list
[ok]: R/LPOP against empty list
[ok]: Variadic RPUSH/LPUSH
[ok]: DEL a list
[ok]: ZREMRANGEBYSCORE basics
[ok]: ZREMRANGEBYSCORE with non-value min or max
[ok]: BLPOP, BRPOP: single existing list - linkedlist
[ok]: BLPOP, BRPOP: multiple existing lists - linkedlist
[ok]: BLPOP, BRPOP: second list has an entry - linkedlist
[ok]: ZREMRANGEBYRANK basics
[ok]: ZUNIONSTORE against non-existing key doesn't set destination - ziplist
[ok]: ZUNIONSTORE with empty set - ziplist
[ok]: BRPOPLPUSH - linkedlist
[ok]: ZUNIONSTORE basics - ziplist
[ok]: BLPOP, BRPOP: single existing list - ziplist
[ok]: ZUNIONSTORE with weights - ziplist
[ok]: ZUNIONSTORE with a regular set and weights - ziplist
[ok]: ZUNIONSTORE with AGGREGATE MIN - ziplist
[ok]: ZUNIONSTORE with AGGREGATE MAX - ziplist
[ok]: ZINTERSTORE basics - ziplist
[ok]: BLPOP, BRPOP: multiple existing lists - ziplist
[ok]: ZINTERSTORE with weights - ziplist
[ok]: BLPOP, BRPOP: second list has an entry - ziplist
[ok]: Handle an empty query
[ok]: ZINTERSTORE with a regular set and weights - ziplist
[ok]: ZINTERSTORE with AGGREGATE MIN - ziplist
[ok]: ZINTERSTORE with AGGREGATE MAX - ziplist
[ok]: BRPOPLPUSH - ziplist
[ok]: BLPOP, LPUSH + DEL should not awake blocked client
[ok]: ZUNIONSTORE with +inf/-inf scores - ziplist
[ok]: BLPOP, LPUSH + DEL + SET should not awake blocked client
[ok]: ZUNIONSTORE with NaN weights ziplist
[ok]: BLPOP with same key multiple times should work (issue #801)
[ok]: ZINTERSTORE with +inf/-inf scores - ziplist
[ok]: ZINTERSTORE with NaN weights ziplist
[ok]: MULTI/EXEC is isolated from the point of view of BLPOP
[ok]: Check encoding - skiplist
[ok]: BLPOP with variadic LPUSH
[ok]: ZSET basic ZADD and score update - skiplist
[ok]: ZSET element can't be set to NaN with ZADD - skiplist
[ok]: ZSET element can't be set to NaN with ZINCRBY
[ok]: ZADD with options syntax error with incomplete pair
[ok]: ZADD XX option without key - skiplist
[ok]: ZADD XX existing key - skiplist
[ok]: ZADD XX returns the number of elements actually added
[ok]: ZADD XX updates existing elements score
[ok]: ZADD XX and NX are not compatible
[ok]: ZADD NX with non exisitng key
[ok]: ZADD NX only add new elements without updating old ones
[ok]: ZADD INCR works like ZINCRBY
[ok]: ZADD INCR works with a single score-elemenet pair
[ok]: ZADD CH option changes return value to all changed elements
[ok]: ZINCRBY calls leading to NaN result in error
[ok]: ZADD - Variadic version base case
[ok]: ZADD - Return value is the number of actually added items
[ok]: ZADD - Variadic version does not add nothing on single parsing err
[ok]: ZADD - Variadic version will raise error on missing arg
[ok]: ZINCRBY does not work variadic even if shares ZADD implementation
[ok]: ZCARD basics - skiplist
[ok]: ZREM removes key after last element is removed
[ok]: ZREM variadic version
[ok]: ZREM variadic version -- remove elements after key deletion
[ok]: Regression for quicklist #3343 bug
[ok]: ZRANGE basics - skiplist
[ok]: ZREVRANGE basics - skiplist
[ok]: ZRANK/ZREVRANK basics - skiplist
[ok]: ZRANK - after deletion - skiplist
[ok]: ZINCRBY - can create a new sorted set - skiplist
[ok]: ZINCRBY - increment and decrement - skiplist
[ok]: ZINCRBY return value
[ok]: SCAN COUNT
[ok]: ZRANGEBYSCORE/ZREVRANGEBYSCORE/ZCOUNT basics
[ok]: ZRANGEBYSCORE with WITHSCORES
[ok]: ZRANGEBYSCORE with LIMIT
[ok]: ZRANGEBYSCORE with LIMIT and WITHSCORES
[ok]: ZRANGEBYSCORE with non-value min or max
[ok]: Negative multibulk length
[ok]: ZRANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT basics
[ok]: Out of range multibulk length
[ok]: Wrong multibulk payload header
[ok]: Negative multibulk payload length
[ok]: Out of range multibulk payload length
[ok]: Non-number multibulk payload length
[ok]: Multi bulk request not followed by bulk arguments
[ok]: ZLEXCOUNT advanced
[ok]: Generic wrong number of args
[ok]: Unbalanced number of quotes
[ok]: ZRANGEBYSLEX with LIMIT
[ok]: ZRANGEBYLEX with invalid lex range specifiers
[ok]: SCAN MATCH
[ok]: SSCAN with encoding intset
[ok]: SSCAN with encoding hashtable
[ok]: HSCAN with encoding ziplist
[ok]: ZREMRANGEBYSCORE basics
[ok]: ZREMRANGEBYSCORE with non-value min or max
[ok]: ZREMRANGEBYRANK basics
[ok]: ZUNIONSTORE against non-existing key doesn't set destination - skiplist
[ok]: ZUNIONSTORE with empty set - skiplist
[ok]: ZUNIONSTORE basics - skiplist
[ok]: ZUNIONSTORE with weights - skiplist
[ok]: ZUNIONSTORE with a regular set and weights - skiplist
[ok]: ZUNIONSTORE with AGGREGATE MIN - skiplist
[ok]: ZUNIONSTORE with AGGREGATE MAX - skiplist
[ok]: ZINTERSTORE basics - skiplist
[ok]: ZINTERSTORE with weights - skiplist
[ok]: ZINTERSTORE with a regular set and weights - skiplist
[ok]: ZINTERSTORE with AGGREGATE MIN - skiplist
[ok]: ZINTERSTORE with AGGREGATE MAX - skiplist
[ok]: ZUNIONSTORE with +inf/-inf scores - skiplist
[ok]: ZUNIONSTORE with NaN weights skiplist
[ok]: ZINTERSTORE with +inf/-inf scores - skiplist
[ok]: ZINTERSTORE with NaN weights skiplist
[ok]: ZINTERSTORE regression with two sets, intset+hashtable
[ok]: ZUNIONSTORE regression, should not create NaN in scores
[ok]: ZINTERSTORE #516 regression, mixed sets and ziplist zsets
[ok]: HSCAN with encoding hashtable
[ok]: ZSCAN with encoding ziplist
[ok]: Very big payload in GET/SET
[ok]: HSET/HLEN - Big hash creation
[1/46 done]: unit/printver (1 seconds)
Testing unit/other
[ok]: Is the big hash encoded with an hash table?
[ok]: Set encoding after DEBUG RELOAD
[ok]: HGET against the small hash
[ok]: SREM basics - regular set
[ok]: SREM basics - intset
[ok]: SREM with multiple arguments
[ok]: SREM variadic version with more args needed to destroy the key
[2/46 done]: unit/type/incr (1 seconds)
Testing unit/multi
[ok]: Generated sets must be encoded as hashtable
[ok]: SINTER with two sets - hashtable
[ok]: SINTERSTORE with two sets - hashtable
[ok]: ZUNIONSTORE result is sorted
[ok]: ZSET commands don't accept the empty strings as valid score
[ok]: ZSCAN with encoding skiplist
[ok]: HGET against the big hash
[ok]: HGET against non existing key
[ok]: HSET in update and insert mode
[ok]: HSETNX target key missing - small hash
[ok]: HSETNX target key exists - small hash
[ok]: HSETNX target key missing - big hash
[ok]: HSETNX target key exists - big hash
[ok]: HMSET wrong number of args
[ok]: HMSET - small hash
[ok]: Protocol desync regression test #1
[ok]: SCAN guarantees check under write load
[ok]: SSCAN with integer encoded object (issue #1345)
[ok]: SSCAN with PATTERN
[ok]: HSCAN with PATTERN
[ok]: ZSCAN with PATTERN
[ok]: SINTERSTORE with two sets, after a DEBUG RELOAD - hashtable
[ok]: SUNION with two sets - hashtable
[ok]: SUNIONSTORE with two sets - hashtable
[ok]: SINTER against three sets - hashtable
[ok]: SINTERSTORE with three sets - hashtable
[ok]: ZSCORE - ziplist
[ok]: HMSET - big hash
[ok]: HMGET against non existing key and fields
[ok]: HMGET against wrong type
[ok]: HMGET - small hash
[ok]: SUNION with non existing keys - hashtable
[ok]: SDIFF with two sets - hashtable
[ok]: SDIFF with three sets - hashtable
[ok]: SDIFFSTORE with three sets - hashtable
[ok]: Old Linked list: SORT BY key
[ok]: Old Linked list: SORT BY key with limit
[ok]: ZSCAN scores: regression test for issue #2175
[ok]: Old Linked list: SORT BY hash field
[ok]: HMGET - big hash
[ok]: HKEYS - small hash
[ok]: Generated sets must be encoded as intset
[ok]: SINTER with two sets - intset
[ok]: SINTERSTORE with two sets - intset
[ok]: HKEYS - big hash
[ok]: HVALS - small hash
[ok]: ZSCORE after a DEBUG RELOAD - ziplist
[ok]: MIGRATE is caching connections
[ok]: HVALS - big hash
[ok]: HGETALL - small hash
[ok]: SINTERSTORE with two sets, after a DEBUG RELOAD - intset
[ok]: MUTLI / EXEC basics
[ok]: DISCARD
[ok]: SUNION with two sets - intset
[ok]: Nested MULTI are not allowed
[ok]: MULTI where commands alter argc/argv
[ok]: WATCH inside MULTI is not allowed
[ok]: EXEC fails if there are errors while queueing commands #1
[ok]: EXEC fails if there are errors while queueing commands #2
[ok]: If EXEC aborts, the client MULTI state is cleared
[ok]: EXEC works on WATCHed key not modified
[ok]: EXEC fail on WATCHed key modified (1 key of 1 watched)
[ok]: EXEC fail on WATCHed key modified (1 key of 5 watched)
[ok]: EXEC fail on WATCHed key modified by SORT with STORE even if the result is empty
[ok]: After successful EXEC key is no longer watched
[ok]: After failed EXEC key is no longer watched
[ok]: It is possible to UNWATCH
[ok]: UNWATCH when there is nothing watched works as expected
[ok]: SUNIONSTORE with two sets - intset
[ok]: SINTER against three sets - intset
[ok]: SINTERSTORE with three sets - intset
[ok]: SUNION with non existing keys - intset
[ok]: SDIFF with two sets - intset
[ok]: SDIFF with three sets - intset
[ok]: SDIFFSTORE with three sets - intset
[ok]: SDIFF with first set empty
[ok]: ZSET sorting stresser - ziplist
[ok]: SDIFF with same set two times
[ok]: AUTH fails when a wrong password is given
[ok]: Arbitrary command gives an error when AUTH is required
[ok]: AUTH succeeds when the right password is given
[ok]: Once AUTH succeeded we can actually send commands to the server
[ok]: HGETALL - big hash
[ok]: Protocol desync regression test #2
[ok]: HDEL and return value
[ok]: HDEL - more than a single value
[ok]: HDEL - hash becomes empty before deleting all specified fields
[ok]: HEXISTS
[ok]: Is a ziplist encoded Hash promoted on big payload?
[ok]: HINCRBY against non existing database key
[ok]: HINCRBY against non existing hash key
[ok]: HINCRBY against hash key created by hincrby itself
[ok]: HINCRBY against hash key originally set with HSET
[ok]: HINCRBY over 32bit value
[ok]: HINCRBY over 32bit value with over 32bit increment
[ok]: FLUSHALL is able to touch the watched keys
[ok]: HINCRBY fails against hash value with spaces (left)
[ok]: HINCRBY fails against hash value with spaces (right)
[ok]: HINCRBY can detect overflows
[ok]: HINCRBYFLOAT against non existing database key
[ok]: HINCRBYFLOAT against non existing hash key
[ok]: HINCRBYFLOAT against hash key created by hincrby itself
[ok]: HINCRBYFLOAT against hash key originally set with HSET
[ok]: HINCRBYFLOAT over 32bit value
[ok]: HINCRBYFLOAT over 32bit value with over 32bit increment
[ok]: HINCRBYFLOAT fails against hash value with spaces (left)
[ok]: HINCRBYFLOAT fails against hash value with spaces (right)
[ok]: HSTRLEN against the small hash
[ok]: SAVE - make sure there are all the types as values
[ok]: FLUSHALL does not touch non affected keys
[ok]: FLUSHDB is able to touch the watched keys
[ok]: FLUSHDB does not touch non affected keys
[ok]: WATCH is able to remember the DB a key belongs to
[ok]: WATCH will consider touched keys target of EXPIRE
[3/46 done]: unit/scan (1 seconds)
Testing unit/quit
[ok]: HSTRLEN against the big hash
[ok]: HSTRLEN against non existing field
[ok]: HSTRLEN corner cases
[ok]: Hash ziplist regression test for large keys
[ok]: Protocol desync regression test #3
[4/46 done]: unit/auth (1 seconds)
Testing unit/aofrw
[ok]: Hash fuzzing #1 - 10 fields
[ok]: Hash fuzzing #2 - 10 fields
[ok]: QUIT returns OK
[ok]: Pipelined commands after QUIT must not be executed
[ok]: Pipelined commands after QUIT that exceed read buffer size
[ok]: Regression for a crash with blocking ops and pipelining
[ok]: BRPOPLPUSH with zero timeout should block indefinitely
[ok]: DEL against expired key
[ok]: EXISTS
[ok]: Zero length value in key. SET/GET/EXISTS
[ok]: Commands pipelining
[ok]: Non existing command
[ok]: RENAME basic usage
[ok]: RENAME source key should no longer exist
[ok]: RENAME against already existing key
[ok]: RENAMENX basic usage
[ok]: RENAMENX against already existing key
[ok]: RENAMENX against already existing key (2)
[ok]: RENAME against non existing source key
[ok]: RENAME where source and dest key are the same (existing)
[ok]: RENAMENX where source and dest key are the same (existing)
[ok]: RENAME where source and dest key are the same (non existing)
[ok]: RENAME with volatile key, should move the TTL as well
[ok]: RENAME with volatile key, should not inherit TTL of target key
[ok]: DEL all keys again (DB 0)
[ok]: DEL all keys again (DB 1)
[ok]: MOVE basic usage
[ok]: MOVE against key existing in the target DB
[ok]: MOVE against non-integer DB (#1428)
[ok]: MOVE can move key expire metadata as well
[ok]: MOVE does not create an expire if it does not exist
[ok]: SET/GET keys in different DBs
[ok]: RANDOMKEY
[ok]: RANDOMKEY against empty DB
[ok]: RANDOMKEY regression 1
[ok]: KEYS * two times with long key, Github issue #1208
[ok]: FUZZ stresser with data model binary
[5/46 done]: unit/quit (1 seconds)
Testing integration/replication
[6/46 done]: unit/protocol (2 seconds)
Testing integration/replication-2
[7/46 done]: unit/keyspace (2 seconds)
Testing integration/replication-3
[ok]: FUZZ stresser with data model alpha
[ok]: WATCH will not consider touched expired keys
[ok]: DISCARD should clear the WATCH dirty flag on the client
[ok]: DISCARD should UNWATCH all the keys
[ok]: MULTI / EXEC is propagated correctly (single write command)
[ok]: MULTI / EXEC is propagated correctly (empty transaction)
[ok]: MULTI / EXEC is propagated correctly (read-only commands)
[ok]: BRPOPLPUSH with a client BLPOPing the target list
[ok]: BRPOPLPUSH with wrong source type
[ok]: EXPIRE - After 2.1 seconds the key should no longer be here
[ok]: EXPIRE - write on expire should work
[ok]: EXPIREAT - Check for EXPIRE alike behavior
[ok]: SETEX - Set + Expire combo operation. Check for TTL
[ok]: SETEX - Check value
[ok]: SETEX - Overwrite old key
[ok]: MULTI / EXEC is propagated correctly (write command, no effect)
[8/46 done]: unit/multi (2 seconds)
Testing integration/replication-4
[ok]: First server should have role slave after SLAVEOF
[ok]: If min-slaves-to-write is honored, write is accepted
[ok]: No write if min-slaves-to-write is < attached slaves
[ok]: If min-slaves-to-write is honored, write is accepted (again)
[ok]: First server should have role slave after SLAVEOF
[ok]: Slave enters handshake
[ok]: Hash fuzzing #1 - 512 fields
[ok]: FUZZ stresser with data model compr
[ok]: BRPOPLPUSH with wrong destination type
[ok]: BRPOPLPUSH maintains order of elements after failure
[ok]: BRPOPLPUSH with multiple blocked clients
[ok]: Linked BRPOPLPUSH
[ok]: Circular BRPOPLPUSH
[ok]: Self-referential BRPOPLPUSH
[ok]: BRPOPLPUSH inside a transaction
[ok]: PUSH resulting from BRPOPLPUSH affect WATCH
[ok]: BRPOPLPUSH does not affect WATCH while still blocked
[ok]: SETEX - Wait for the key to expire
[ok]: SETEX - Wrong time parameter
[ok]: PERSIST can undo an EXPIRE
[ok]: PERSIST returns 0 against non existing or non volatile keys
[ok]: Old Big Linked list: SORT BY key
[ok]: Old Big Linked list: SORT BY key with limit
[ok]: BGSAVE
[ok]: SELECT an out of range DB
[ok]: First server should have role slave after SLAVEOF
[ok]: ZRANGEBYSCORE fuzzy test, 100 ranges in 128 element sorted set - ziplist
[ok]: ZRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist
[ok]: Hash fuzzing #2 - 512 fields
[ok]: EXPIRES after a reload (snapshot + append only file rewrite)
[ok]: Old Big Linked list: SORT BY hash field
[ok]: Intset: SORT BY key
[ok]: Intset: SORT BY key with limit
[ok]: Intset: SORT BY hash field
[ok]: BRPOPLPUSH timeout
[ok]: BLPOP when new key is moved into place
[ok]: BLPOP when result key is created by SORT..STORE
[ok]: BLPOP: with single empty list argument
[ok]: BLPOP: with negative timeout
[ok]: BLPOP: with non-integer timeout
[ok]: EXPIRE pricision is now the millisecond
[ok]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 128 element sorted set - ziplist
[ok]: ZSETs skiplist implementation backlink consistency test - ziplist
[ok]: Very big payload random access
[ok]: SDIFF fuzzing
[ok]: SINTER against non-set should throw error
[ok]: SUNION against non-set should throw error
[ok]: SINTER should handle non existing key as empty
[ok]: SINTER with same integer elements but different encoding
[ok]: SINTERSTORE against non existing keys should delete dstkey
[ok]: SUNIONSTORE against non existing keys should delete dstkey
[ok]: SPOP basics - hashtable
[ok]: SPOP with <count>=1 - hashtable
[ok]: SRANDMEMBER - hashtable
[ok]: SPOP basics - intset
[ok]: SPOP with <count>=1 - intset
[ok]: SRANDMEMBER - intset
[ok]: SPOP with <count>
[ok]: SPOP with <count>
[ok]: SPOP using integers, testing Knuth's and Floyd's algorithm
[ok]: SPOP using integers with Knuth's algorithm
[ok]: SPOP new implementation: code path #1
[ok]: SPOP new implementation: code path #2
[ok]: SPOP new implementation: code path #3
[ok]: SRANDMEMBER with <count> against non existing key
[ok]: SRANDMEMBER with <count> - hashtable
[ok]: SRANDMEMBER with <count> - intset
[ok]: SMOVE basics - from regular set to intset
[ok]: SMOVE basics - from intset to regular set
[ok]: SMOVE non existing key
[ok]: SMOVE non existing src set
[ok]: SMOVE from regular set to non existing destination set
[ok]: SMOVE from intset to non existing destination set
[ok]: SMOVE wrong src key type
[ok]: SMOVE wrong dst key type
[ok]: SMOVE with identical source and destination
[ok]: Hash table: SORT BY key
[ok]: Hash table: SORT BY key with limit
[ok]: Hash table: SORT BY hash field
[ok]: BLPOP: with zero timeout should block indefinitely
[ok]: BLPOP: second argument is not a list
[ok]: ZSETs ZRANK augmented skip list stress testing - ziplist
[ok]: ZSCORE - skiplist
[ok]: ZSCORE after a DEBUG RELOAD - skiplist
[ok]: PEXPIRE/PSETEX/PEXPIREAT can set sub-second expires
[ok]: TTL returns tiem to live in seconds
[ok]: PTTL returns time to live in milliseconds
[ok]: TTL / PTTL return -1 if key has no expire
[ok]: TTL / PTTL return -2 if key does not exit
[ok]: ZSET sorting stresser - skiplist
[ok]: Stress test the hash ziplist -> hashtable encoding conversion
[ok]: Test HINCRBYFLOAT for correct float representation (issue #2846)
[9/46 done]: unit/type/hash (8 seconds)
Testing integration/replication-psync
[ok]: SET 10000 numeric keys and access all them in reverse order
[ok]: DBSIZE should be 10000 now
[ok]: SETNX target key missing
[ok]: SETNX target key exists
[ok]: SETNX against not-expired volatile key
[ok]: BLPOP: timeout
[ok]: BLPOP: arguments are empty
[ok]: BRPOP: with single empty list argument
[ok]: BRPOP: with negative timeout
[ok]: BRPOP: with non-integer timeout
[ok]: EXPIRES after AOF reload (without rewrite)
[ok]: Redis should actively expire keys incrementally
[ok]: intsets implementation stress testing
[10/46 done]: unit/type/set (9 seconds)
Testing integration/aof
[ok]: No write if min-slaves-max-lag is > of the slave lag
[ok]: min-slaves-to-write is ignored by slaves
[ok]: Unfinished MULTI: Server should start if load-truncated is yes
[ok]: BRPOP: with zero timeout should block indefinitely
[ok]: BRPOP: second argument is not a list
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: Redis should lazy expire keys
[ok]: Short read: Server should start if load-truncated is yes
[ok]: Truncated AOF loaded: we expect foo to be equal to 5
[ok]: Append a new command after loading an incomplete AOF
[ok]: Test replication partial resync: no reconnection, just sync (diskless: no, reconnect: 0)
[ok]: Short read + command: Server should start
[ok]: Truncated AOF loaded: we expect foo to be equal to 6 now
[ok]: Bad format: Server should have logged an error
[ok]: EXPIRE should not resurrect keys (issue #1026)
[ok]: 5 keys in, 5 keys out
[ok]: EXPIRE with empty string as TTL should report an error
[ok]: Unfinished MULTI: Server should have logged an error
[ok]: ZRANGEBYSCORE fuzzy test, 100 ranges in 100 element sorted set - skiplist
[ok]: Short read: Server should have logged an error
[ok]: ZRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist
[ok]: Short read: Utility should confirm the AOF is not valid
[ok]: Short read: Utility should be able to fix the AOF
[ok]: ZREMRANGEBYLEX fuzzy test, 100 ranges in 100 element sorted set - skiplist
[ok]: ZSETs skiplist implementation backlink consistency test - skiplist
[ok]: BRPOP: timeout
[ok]: BRPOP: arguments are empty
[ok]: BLPOP inside a transaction
[ok]: LPUSHX, RPUSHX - generic
[ok]: LPUSHX, RPUSHX - linkedlist
[ok]: LINSERT - linkedlist
[ok]: LPUSHX, RPUSHX - ziplist
[ok]: LINSERT - ziplist
[ok]: LINSERT raise error on bad syntax
[ok]: Test replication with parallel clients writing in differnet DBs
[ok]: Big Hash table: SORT BY key
[ok]: Big Hash table: SORT BY key with limit
[ok]: Fixed AOF: Server should have been started
[ok]: Fixed AOF: Keyspace should contain values that were parseable
[ok]: LINDEX consistency test - quicklist
[ok]: LINDEX random access - quicklist
[ok]: SETNX against expired volatile key
[ok]: MGET
[ok]: MGET against non existing key
[ok]: MGET against non-string key
[ok]: GETSET (set new value)
[ok]: GETSET (replace old value)
[ok]: MSET base case
[ok]: MSET wrong number of args
[ok]: MSETNX with already existent key
[ok]: MSETNX with not existing keys
[ok]: STRLEN against non-existing key
[ok]: STRLEN against integer-encoded value
[ok]: STRLEN against plain string
[ok]: SETBIT against non-existing key
[ok]: SETBIT against string-encoded key
[ok]: SETBIT against integer-encoded key
[ok]: SETBIT against key with wrong type
[ok]: SETBIT with out of range bit offset
[ok]: SETBIT with non-bit argument
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: Check if list is still ok after a DEBUG RELOAD - quicklist
[ok]: LINDEX consistency test - quicklist
[ok]: AOF+SPOP: Server should have been started
[ok]: AOF+SPOP: Set should have 1 member
[ok]: LINDEX random access - quicklist
[ok]: PIPELINING stresser (also a regression for the old epoll bug)
[ok]: APPEND basics
[ok]: APPEND basics, integer encoded values
[ok]: Check if list is still ok after a DEBUG RELOAD - quicklist
[ok]: LLEN against non-list value error
[ok]: LLEN against non existing key
[ok]: LINDEX against non-list value error
[ok]: LINDEX against non existing key
[ok]: LPUSH against non-list value error
[ok]: RPUSH against non-list value error
[ok]: RPOPLPUSH base case - linkedlist
[ok]: RPOPLPUSH with the same list as src and dst - linkedlist
[ok]: RPOPLPUSH with linkedlist source and existing target linkedlist
[ok]: RPOPLPUSH with linkedlist source and existing target ziplist
[ok]: RPOPLPUSH base case - ziplist
[ok]: RPOPLPUSH with the same list as src and dst - ziplist
[ok]: RPOPLPUSH with ziplist source and existing target linkedlist
[ok]: RPOPLPUSH with ziplist source and existing target ziplist
[ok]: RPOPLPUSH against non existing key
[ok]: RPOPLPUSH against non list src key
[ok]: RPOPLPUSH against non list dst key
[ok]: RPOPLPUSH against non existing src key
[ok]: Basic LPOP/RPOP - linkedlist
[ok]: Basic LPOP/RPOP - ziplist
[ok]: LPOP/RPOP against non list value
[ok]: SETBIT fuzzing
[ok]: GETBIT against non-existing key
[ok]: GETBIT against string-encoded key
[ok]: GETBIT against integer-encoded key
[ok]: SETRANGE against non-existing key
[ok]: Mass RPOP/LPOP - quicklist
[ok]: SETRANGE against string-encoded key
[ok]: SETRANGE against integer-encoded key
[ok]: SETRANGE against key with wrong type
[ok]: SETRANGE with out of range offset
[ok]: GETRANGE against non-existing key
[ok]: GETRANGE against string value
[ok]: GETRANGE against integer-encoded value
[ok]: Mass RPOP/LPOP - quicklist
[ok]: LRANGE basics - linkedlist
[ok]: LRANGE inverted indexes - linkedlist
[ok]: LRANGE out of range indexes including the full list - linkedlist
[ok]: LRANGE out of range negative end index - linkedlist
[ok]: LRANGE basics - ziplist
[ok]: LRANGE inverted indexes - ziplist
[ok]: LRANGE out of range indexes including the full list - ziplist
[ok]: LRANGE out of range negative end index - ziplist
[ok]: LRANGE against non existing key
[ok]: LTRIM basics - linkedlist
[ok]: LTRIM out of range negative end index - linkedlist
[ok]: LTRIM basics - ziplist
[ok]: LTRIM out of range negative end index - ziplist
[ok]: LSET - linkedlist
[ok]: LSET out of range index - linkedlist
[ok]: LSET - ziplist
[ok]: LSET out of range index - ziplist
[ok]: LSET against non existing key
[ok]: LSET against non list value
[ok]: LREM remove all the occurrences - linkedlist
[ok]: LREM remove the first occurrence - linkedlist
[ok]: LREM remove non existing element - linkedlist
[ok]: LREM starting from tail with negative count - linkedlist
[ok]: ZSETs ZRANK augmented skip list stress testing - skiplist
[ok]: LREM starting from tail with negative count (2) - linkedlist
[ok]: LREM deleting objects that may be int encoded - linkedlist
[ok]: LREM remove all the occurrences - ziplist
[ok]: LREM remove the first occurrence - ziplist
[ok]: LREM remove non existing element - ziplist
[ok]: LREM starting from tail with negative count - ziplist
[ok]: LREM starting from tail with negative count (2) - ziplist
[ok]: LREM deleting objects that may be int encoded - ziplist
[ok]: AOF+SPOP: Server should have been started
[ok]: AOF+SPOP: Set should have 1 member
[ok]: APPEND fuzzing
[ok]: FLUSHDB
[ok]: Big Hash table: SORT BY hash field
[ok]: Perform a final SAVE to leave a clean DB on disk
[ok]: SORT GET #
[ok]: SORT GET <const>
[ok]: SORT GET (key and hash) with sanity check
[ok]: SORT BY key STORE
[ok]: SORT BY hash field STORE
[ok]: SORT extracts STORE correctly
[ok]: SORT extracts multiple STORE correctly
[ok]: SORT DESC
[ok]: SORT ALPHA against integer encoded strings
[ok]: SORT sorted set
[ok]: SORT sorted set BY nosort should retain ordering
[ok]: SORT sorted set BY nosort + LIMIT
[ok]: SORT sorted set BY nosort works as expected from scripts
[ok]: SORT sorted set: +inf and -inf handling
[11/46 done]: unit/type/zset (13 seconds)
Testing integration/rdb
[ok]: SORT regression for issue #19, sorting floats
[ok]: SORT with STORE returns zero if result is empty (github issue 224)
[ok]: SORT with STORE does not create empty lists (github issue 224)
[ok]: SORT with STORE removes key if result is empty (github issue 227)
[ok]: SORT with BY <constant> and STORE should still order output
[ok]: SORT will complain with numerical sorting and bad doubles (1)
[ok]: SORT will complain with numerical sorting and bad doubles (2)
[ok]: SORT BY sub-sorts lexicographically if score is the same
[ok]: SORT GET with pattern ending with just -> does not get hash field
[ok]: SORT by nosort retains native order for lists
[ok]: SORT by nosort plus store retains native order for lists
[ok]: SORT by nosort with limit returns based on original list order
[ok]: LTRIM stress testing - linkedlist
[12/46 done]: unit/other (12 seconds)
Testing integration/convert-zipmap-hash-on-load
[ok]: SORT speed, 100 element list BY key, 100 times
[ok]: SORT speed, 100 element list BY hash field, 100 times
[ok]: SORT speed, 100 element list directly, 100 times
[ok]: SORT speed, 100 element list BY <const>, 100 times
[ok]: RDB encoding loading test
[ok]: AOF+EXPIRE: Server should have been started
[ok]: AOF+EXPIRE: List should be empty
[ok]: Slave is able to detect timeout during handshake
[ok]: RDB load zipmap hash: converts to ziplist
[13/46 done]: unit/sort (13 seconds)
Testing integration/logging
[ok]: First server should have role slave after SLAVEOF
[ok]: With min-slaves-to-write (1,3): master should be writable
[ok]: With min-slaves-to-write (2,3): master should not be writable
[ok]: Regression for bug 593 - chaining BRPOPLPUSH with other blocking cmds
[ok]: Redis should not try to convert DEL into EXPIREAT for EXPIRE -1
[ok]: GETRANGE fuzzing
[ok]: Extended SET can detect syntax errors
[ok]: Extended SET NX option
[ok]: Extended SET XX option
[ok]: Extended SET EX option
[ok]: Extended SET PX option
[ok]: Extended SET using multiple options at once
[ok]: GETRANGE with huge ranges, Github issue #1844
[ok]: Server started empty with non-existing RDB file
[ok]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-entries is exceeded
[14/46 done]: integration/aof (5 seconds)
Testing integration/psync2
[15/46 done]: unit/type/list (14 seconds)
Testing integration/psync2-reg
[16/46 done]: unit/type/string (14 seconds)
Testing unit/pubsub
[ok]: Server is able to generate a stack trace on selected systems
[ok]: Pub/Sub PING
[ok]: PUBLISH/SUBSCRIBE basics
[ok]: PUBLISH/SUBSCRIBE with two clients
[ok]: PUBLISH/SUBSCRIBE after UNSUBSCRIBE without arguments
[ok]: SUBSCRIBE to one channel more than once
[ok]: UNSUBSCRIBE from non-subscribed channels
[ok]: PUBLISH/PSUBSCRIBE basics
[ok]: PUBLISH/PSUBSCRIBE with two clients
[ok]: PUBLISH/PSUBSCRIBE after PUNSUBSCRIBE without arguments
[ok]: PUNSUBSCRIBE from non-subscribed channels
[ok]: NUMSUB returns numbers, not strings (#1561)
[ok]: Mix SUBSCRIBE and PSUBSCRIBE
[ok]: PUNSUBSCRIBE and UNSUBSCRIBE should always reply
[ok]: Keyspace notifications: we receive keyspace notifications
[ok]: Keyspace notifications: we receive keyevent notifications
[ok]: Keyspace notifications: we can receive both kind of events
[ok]: Keyspace notifications: we are able to mask events
[ok]: Keyspace notifications: general events test
[ok]: Keyspace notifications: list events test
[ok]: Keyspace notifications: set events test
[ok]: Keyspace notifications: zset events test
[ok]: Keyspace notifications: hash events test
[ok]: RDB load zipmap hash: converts to hash table when hash-max-ziplist-value is exceeded
[ok]: Server started empty with empty RDB file
[ok]: Keyspace notifications: expired events (triggered expire)
[17/46 done]: integration/logging (1 seconds)
Testing unit/slowlog
[18/46 done]: integration/convert-zipmap-hash-on-load (1 seconds)
Testing unit/scripting
[ok]: Keyspace notifications: expired events (background expire)
[ok]: Keyspace notifications: evicted events
[ok]: Keyspace notifications: test CONFIG GET/SET of event flags
[ok]: SLOWLOG - check that it starts with an empty log
[ok]: EVAL - Does Lua interpreter replies to our requests?
[ok]: EVAL - Lua integer -> Redis protocol type conversion
[ok]: EVAL - Lua string -> Redis protocol type conversion
[ok]: EVAL - Lua true boolean -> Redis protocol type conversion
[ok]: EVAL - Lua false boolean -> Redis protocol type conversion
[ok]: EVAL - Lua status code reply -> Redis protocol type conversion
[ok]: EVAL - Lua error reply -> Redis protocol type conversion
[ok]: EVAL - Lua table -> Redis protocol type conversion
[ok]: EVAL - Are the KEYS and ARGV arrays populated correctly?
[ok]: EVAL - is Lua able to call Redis API?
[ok]: EVALSHA - Can we call a SHA1 if already defined?
[ok]: EVALSHA - Can we call a SHA1 in uppercase?
[ok]: EVALSHA - Do we get an error on invalid SHA1?
[ok]: EVALSHA - Do we get an error on non defined SHA1?
[ok]: EVAL - Redis integer -> Lua type conversion
[ok]: EVAL - Redis bulk -> Lua type conversion
[ok]: EVAL - Redis multi bulk -> Lua type conversion
[ok]: EVAL - Redis status reply -> Lua type conversion
[ok]: EVAL - Redis error reply -> Lua type conversion
[ok]: EVAL - Redis nil bulk reply -> Lua type conversion
[ok]: EVAL - Is the Lua client using the currently selected DB?
[ok]: EVAL - SELECT inside Lua should not affect the caller
[ok]: EVAL - Scripts can't run certain commands
[ok]: EVAL - Scripts can't run certain commands
[ok]: EVAL - No arguments to redis.call/pcall is considered an error
[ok]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[ok]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[ok]: EVAL - redis.call variant raises a Lua error on Redis cmd error (1)
[ok]: EVAL - JSON numeric decoding
[ok]: EVAL - JSON string decoding
[ok]: EVAL - cmsgpack can pack double?
[ok]: EVAL - cmsgpack can pack negative int64?
[ok]: EVAL - cmsgpack can pack and unpack circular references?
[ok]: EVAL - Numerical sanity check from bitop
[ok]: EVAL - Verify minimal bitop functionality
[ok]: EVAL - Able to parse trailing comments
[ok]: SCRIPTING FLUSH - is able to clear the scripts cache?
[ok]: SCRIPT EXISTS - can detect already defined scripts?
[ok]: SCRIPT LOAD - is able to register scripts in the scripting cache
[ok]: In the context of Lua the output of random commands gets ordered
[ok]: SORT is normally not alpha re-ordered for the scripting engine
[ok]: SORT BY <constant> output gets ordered for scripting
[ok]: SORT BY <constant> with GET gets ordered for scripting
[ok]: redis.sha1hex() implementation
[ok]: Globals protection reading an undeclared global variable
[ok]: Globals protection setting an undeclared global*
[ok]: Test an example script DECR_IF_GT
[ok]: Scripting engine resets PRNG at every script execution
[ok]: Scripting engine PRNG can be seeded correctly
[ok]: SLOWLOG - only logs commands taking more time than specified
[ok]: SLOWLOG - max entries is correctly handled
[ok]: SLOWLOG - GET optional argument to limit output len works
[ok]: SLOWLOG - RESET subcommand works
[19/46 done]: unit/pubsub (0 seconds)
Testing unit/maxmemory
[ok]: Server should not start if RDB is corrupted
[20/46 done]: integration/rdb (1 seconds)
Testing unit/introspection
[ok]: SET - use EX/PX option, TTL should not be reseted after loadaof
[ok]: PSYNC2: --- CYCLE 1 ---
[ok]: PSYNC2: [NEW LAYOUT] Set #3 as master
[ok]: PSYNC2: Set #4 to replicate from #3
[ok]: PSYNC2: Set #1 to replicate from #4
[ok]: PSYNC2: Set #0 to replicate from #4
[ok]: PSYNC2: Set #2 to replicate from #3
[ok]: SLOWLOG - logged entry sanity check
[ok]: SLOWLOG - commands with too many arguments are trimmed
[ok]: SLOWLOG - too long arguments are trimmed
[ok]: Without maxmemory small integers are shared
[ok]: With maxmemory and non-LRU policy integers are still shared
[ok]: With maxmemory and LRU policy integers are not shared
[ok]: CLIENT LIST
[ok]: MONITOR can log executed commands
[ok]: MONITOR can log commands issued by the scripting engine
[ok]: CLIENT GETNAME should return NIL if name is not assigned
[ok]: CLIENT LIST shows empty fields for unassigned names
[ok]: CLIENT SETNAME does not accept spaces
[ok]: CLIENT SETNAME can assign a name to this connection
[ok]: CLIENT SETNAME can change the name of an existing connection
[ok]: After CLIENT SETNAME, connection can still be closed
[ok]: SLOWLOG - EXEC is not logged, just executed commands
[21/46 done]: unit/expire (15 seconds)
Testing unit/introspection-2
[ok]: MASTER and SLAVE consistency with expire
[ok]: Set instance A as slave of B
[ok]: BRPOPLPUSH replication, when blocking against empty list
[22/46 done]: unit/introspection (1 seconds)
Testing unit/limits
[ok]: EVAL does not leak in the Lua stack
[ok]: SLOWLOG - can clean older entires
[23/46 done]: unit/slowlog (1 seconds)
Testing unit/obuf-limits
[ok]: PSYNC2 #3899 regression: setup
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: maxmemory - is the memory limit honoured? (policy allkeys-random)
[ok]: EVAL processes writes from AOF in read-only slaves
[ok]: We can call scripts rewriting client->argv from Lua
[ok]: Call Redis command with many args from Lua (issue #1764)
[ok]: Number conversion precision test (issue #1118)
[ok]: String containing number precision test (regression of issue #1118)
[ok]: Verify negative arg count is error instead of crash (issue #1842)
[ok]: Correct handling of reused argv (issue #1939)
[ok]: Functions in the Redis namespace are able to report errors
[ok]: PSYNC2: cluster is consistent after failover
[ok]: maxmemory - is the memory limit honoured? (policy allkeys-lru)
[ok]: BRPOPLPUSH replication, list exists
[ok]: MIGRATE cached connections are released after some time
[ok]: Check if maxclients works refusing connections
[ok]: Timedout read-only scripts can be killed by SCRIPT KILL
[24/46 done]: unit/limits (1 seconds)
Testing unit/bitops
[ok]: MIGRATE is able to migrate a key between two instances
[ok]: maxmemory - is the memory limit honoured? (policy allkeys-lfu)
[ok]: BITCOUNT returns 0 against non existing key
[ok]: BITCOUNT returns 0 with out of range indexes
[ok]: BITCOUNT returns 0 with negative indexes where start > end
[ok]: BITCOUNT against test vector #1
[ok]: BITCOUNT against test vector #2
[ok]: BITCOUNT against test vector #3
[ok]: BITCOUNT against test vector #4
[ok]: BITCOUNT against test vector #5
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: Timedout script link is still usable after Lua returns
[ok]: Timedout scripts that modified data can't be killed by SCRIPT KILL
[ok]: MIGRATE is able to copy a key between two instances
[ok]: SHUTDOWN NOSAVE can kill a timedout script anyway
[ok]: BLPOP followed by role change, issue #2473
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: maxmemory - is the memory limit honoured? (policy volatile-lru)
[ok]: MIGRATE will not overwrite existing keys, unless REPLACE is used
[ok]: With min-slaves-to-write: master not writable with lagged slave
[ok]: Before the slave connects we issue two EVAL commands (scripts replication)
[ok]: BITCOUNT fuzzing without start/end
[ok]: MIGRATE propagates TTL correctly
[ok]: Second server should have role master at first
[ok]: SLAVEOF should start with link status "down"
[ok]: The role should immediately be changed to "slave"
[ok]: BITCOUNT fuzzing with start/end
[ok]: BITCOUNT with start, end
[ok]: BITCOUNT syntax error #1
[ok]: BITCOUNT regression test for github issue #582
[ok]: BITCOUNT misaligned prefix
[ok]: BITCOUNT misaligned prefix + full words + remainder
[ok]: BITOP NOT (empty string)
[ok]: TTL and TYPYE do not alter the last access time of a key
[ok]: BITOP NOT (known string)
[ok]: BITOP where dest and target are the same key
[ok]: BITOP AND|OR|XOR don't change the string with single input key
[ok]: BITOP missing key is considered a stream of zero
[ok]: BITOP shorter keys are zero-padded to the key with max length
[ok]: maxmemory - is the memory limit honoured? (policy volatile-lfu)
[ok]: Connect a slave to the master instance (scripts replication)
[ok]: Now use EVALSHA against the master, with both SHAs (scripts replication)
[ok]: If EVALSHA was replicated as EVAL, 'x' should be '4' (scripts replication)
[ok]: Replication of script multiple pushes to list with BLPOP (scripts replication)
[ok]: EVALSHA replication when first call is readonly (scripts replication)
[ok]: Lua scripts using SELECT are replicated correctly (scripts replication)
[ok]: First server should have role slave after SLAVEOF
[ok]: Sync should have transferred keys from master
[ok]: The link status should be up
[ok]: SET on the master should immediately propagate
[ok]: FLUSHALL should replicate
[ok]: ROLE in master reports master with a slave
[ok]: ROLE in slave reports slave in connected state
[ok]: maxmemory - is the memory limit honoured? (policy volatile-random)
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: Before the slave connects we issue two EVAL commands (commmands replication)
[ok]: BITOP and fuzzing
[ok]: maxmemory - is the memory limit honoured? (policy volatile-ttl)
[ok]: Connect a slave to the master instance (commmands replication)
[ok]: Now use EVALSHA against the master, with both SHAs (commmands replication)
[ok]: If EVALSHA was replicated as EVAL, 'x' should be '4' (commmands replication)
[ok]: Replication of script multiple pushes to list with BLPOP (commmands replication)
[ok]: EVALSHA replication when first call is readonly (commmands replication)
[ok]: Lua scripts using SELECT are replicated correctly (commmands replication)
[ok]: BITOP or fuzzing
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-random)
[ok]: PSYNC2: generate load while killing replication links
[ok]: PSYNC2: cluster is consistent after load (x = 27617)
[ok]: PSYNC2: total sum of full synchronizations is exactly 4
[ok]: PSYNC2: --- CYCLE 2 ---
[ok]: PSYNC2: [NEW LAYOUT] Set #4 as master
[ok]: PSYNC2: Set #1 to replicate from #4
[ok]: PSYNC2: Set #2 to replicate from #1
[ok]: PSYNC2: Set #3 to replicate from #2
[ok]: PSYNC2: Set #0 to replicate from #2
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: Slave is able to evict keys created in writable slaves
[ok]: MASTER and SLAVE dataset should be identical after complex ops
[ok]: TOUCH alters the last access time of a key
[ok]: TOUCH returns the number of existing keys specified
[ok]: BITOP xor fuzzing
[ok]: maxmemory - only allkeys-* should remove non-volatile keys (allkeys-lru)
[25/46 done]: unit/introspection-2 (6 seconds)
Testing unit/bitfield
[26/46 done]: integration/replication-2 (19 seconds)
Testing unit/geo
[ok]: GEOADD create
[ok]: GEOADD update
[ok]: GEOADD invalid coordinates
[ok]: GEOADD multi add
[ok]: Check geoset values
[ok]: BITFIELD signed SET and GET basics
[ok]: BITFIELD unsigned SET and GET basics
[ok]: BITFIELD #<idx> form
[ok]: BITFIELD basic INCRBY form
[ok]: BITFIELD chaining of multiple commands
[ok]: BITFIELD unsigned overflow wrap
[ok]: BITFIELD unsigned overflow sat
[ok]: BITFIELD signed overflow wrap
[ok]: BITFIELD signed overflow sat
[ok]: Connect a slave to the master instance
[ok]: Redis.replicate_commands() must be issued before any write
[ok]: Redis.replicate_commands() must be issued before any write (2)
[ok]: Redis.set_repl() must be issued after replicate_commands()
[ok]: Redis.set_repl() don't accept invalid values
[ok]: Test selective replication of certain Redis commands from Lua
[ok]: PRNG is seeded randomly for command replication
[ok]: Using side effects is not a problem with command replication
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: GEORADIUS simple (sorted)
[ok]: GEORADIUS withdist (sorted)
[ok]: GEORADIUS with COUNT
[ok]: GEORADIUS with COUNT but missing integer argument
[ok]: GEORADIUS with COUNT DESC
[ok]: GEORADIUS HUGE, issue #2767
[ok]: GEORADIUSBYMEMBER simple (sorted)
[ok]: GEORADIUSBYMEMBER withdist (sorted)
[ok]: GEOHASH is able to return geohash strings
[ok]: GEOPOS simple
[ok]: GEOPOS missing element
[ok]: GEODIST simple & unit
[ok]: GEODIST missing elements
[ok]: GEORADIUS STORE option: syntax error
[ok]: GEORANGE STORE option: incompatible options
[ok]: GEORANGE STORE option: plain usage
[ok]: GEORANGE STOREDIST option: plain usage
[ok]: GEORANGE STOREDIST option: COUNT ASC and DESC
[ok]: BITOP NOT fuzzing
[ok]: BITOP with integer encoded source objects
[ok]: BITOP with non string source key
[ok]: BITOP with empty string after non empty string (issue #529)
[ok]: BITPOS bit=0 with empty key returns 0
[ok]: BITPOS bit=1 with empty key returns -1
[ok]: BITPOS bit=0 with string less than 1 word works
[ok]: BITPOS bit=1 with string less than 1 word works
[ok]: BITPOS bit=0 starting at unaligned address
[ok]: BITPOS bit=1 starting at unaligned address
[ok]: BITPOS bit=0 unaligned+full word+reminder
[ok]: BITPOS bit=1 unaligned+full word+reminder
[ok]: BITPOS bit=1 returns -1 if string is all 0 bits
[ok]: BITPOS bit=0 works with intervals
[ok]: BITPOS bit=1 works with intervals
[ok]: BITPOS bit=0 changes behavior if end is given
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: Test replication partial resync: ok psync (diskless: no, reconnect: 1)
[ok]: BITPOS bit=1 fuzzy testing using SETBIT
[27/46 done]: unit/scripting (8 seconds)
Testing unit/memefficiency
[ok]: BITFIELD overflow detection fuzzing
[ok]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-lru)
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: First server should have role slave after SLAVEOF
[ok]: BITPOS bit=0 fuzzy testing using SETBIT
[28/46 done]: unit/bitops (7 seconds)
Testing unit/hyperloglog
[ok]: BITFIELD overflow wrap fuzzing
[ok]: BITFIELD regression for #3221
[ok]: BITFIELD regression for #3564
[29/46 done]: unit/bitfield (2 seconds)
Testing unit/lazyfree
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: Memory efficiency with values in range 32
[ok]: PSYNC2: cluster is consistent after failover
[ok]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-random)
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: maxmemory - only allkeys-* should remove non-volatile keys (volatile-ttl)
[ok]: UNLINK can reclaim memory in background
[ok]: Memory efficiency with values in range 64
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: maxmemory - policy volatile-lru should only remove volatile keys.
[ok]: FLUSHDB ASYNC can reclaim memory in background
[ok]: Memory efficiency with values in range 128
[30/46 done]: unit/lazyfree (3 seconds)
Testing unit/wait
[ok]: maxmemory - policy volatile-lfu should only remove volatile keys.
[ok]: LTRIM stress testing - ziplist
[ok]: maxmemory - policy volatile-random should only remove volatile keys.
[ok]: PSYNC2 #3899 regression: kill first slave
[31/46 done]: unit/type/list-2 (28 seconds)
[ok]: Memory efficiency with values in range 1024
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: Setup slave
[ok]: WAIT should acknowledge 1 additional copy of the data
[ok]: maxmemory - policy volatile-ttl should only remove volatile keys.
[ok]: PSYNC2 #3899 regression: kill chained slave
[32/46 done]: unit/maxmemory (14 seconds)
[ok]: PSYNC2: generate load while killing replication links
[ok]: WAIT should not acknowledge 2 additional copies of the data
[ok]: AOF rewrite during write load: RDB preamble=yes
[ok]: PSYNC2: cluster is consistent after load (x = 54373)
[ok]: PSYNC2: total sum of full synchronizations is exactly 4
[ok]: PSYNC2: --- CYCLE 3 ---
[ok]: PSYNC2: [NEW LAYOUT] Set #0 as master
[ok]: PSYNC2: Set #2 to replicate from #0
[ok]: PSYNC2: Set #4 to replicate from #2
[ok]: PSYNC2: Set #3 to replicate from #2
[ok]: PSYNC2: Set #1 to replicate from #2
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: Memory efficiency with values in range 16384
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: PSYNC2: cluster is consistent after failover
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: MIGRATE can correctly transfer large values
[33/46 done]: unit/memefficiency (10 seconds)
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: MIGRATE can correctly transfer hashes
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: PSYNC2 #3899 regression: kill chained slave
[ok]: WAIT should not acknowledge 1 additional copy if slave is blocked
[ok]: PSYNC2 #3899 regression: kill first slave
[ok]: MIGRATE timeout actually works
[ok]: PSYNC2 #3899 regression: kill chained slave
[34/46 done]: unit/wait (8 seconds)
[ok]: MIGRATE can migrate multiple keys at once
[ok]: MIGRATE with multiple keys must have empty key arg
[ok]: MIGRATE with mutliple keys migrate just existing ones
[ok]: MIGRATE with multiple keys: stress command rewriting
[ok]: MIGRATE with multiple keys: delete just ack keys
[ok]: PSYNC2 #3899 regression: verify consistency
[ok]: Test replication partial resync: no backlog (diskless: no, reconnect: 1)
[ok]: MIGRATE AUTH: correct and wrong password cases
[ok]: HyperLogLog self test passes
[ok]: PFADD without arguments creates an HLL value
[ok]: Approximated cardinality after creation is zero
[ok]: PFADD returns 1 when at least 1 reg was modified
[ok]: PFADD returns 0 when no reg was modified
[ok]: PFADD works with empty string (regression)
[ok]: PFCOUNT returns approximated cardinality of set
[35/46 done]: unit/dump (36 seconds)
[36/46 done]: integration/psync2-reg (22 seconds)
[ok]: PSYNC2: generate load while killing replication links
[ok]: PSYNC2: cluster is consistent after load (x = 95276)
[ok]: PSYNC2: total sum of full synchronizations is exactly 4
[ok]: HyperLogLogs are promote from sparse to dense
[ok]: PSYNC2: Bring the master back again for next test
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: HyperLogLog sparse encoding stress test
[ok]: Corrupted sparse HyperLogLogs are detected: Additionl at tail
[ok]: Corrupted sparse HyperLogLogs are detected: Broken magic
[ok]: Corrupted sparse HyperLogLogs are detected: Invalid encoding
[ok]: Corrupted dense HyperLogLogs are detected: Wrong length
[ok]: PFADD, PFCOUNT, PFMERGE type checking works
[ok]: PFMERGE results on the cardinality of union of sets
[ok]: PSYNC2: Partial resync after restart using RDB aux fields
[ok]: PSYNC2: Slave RDB restart with EVALSHA in backlog issue #4483
[37/46 done]: integration/psync2 (28 seconds)
[ok]: PFCOUNT multiple-keys merge returns cardinality of union #1
[ok]: MASTER and SLAVE consistency with EVALSHA replication
[ok]: PFCOUNT multiple-keys merge returns cardinality of union #2
[ok]: Test replication partial resync: ok after delay (diskless: no, reconnect: 1)
[ok]: PFDEBUG GETREG returns the HyperLogLog raw registers
[ok]: PFADD / PFCOUNT cache invalidation works
[ok]: Connect multiple slaves at the same time (issue #141), diskless=no
[ok]: Replication: commands with many arguments (issue #1221)
[38/46 done]: unit/hyperloglog (27 seconds)
[ok]: GEOADD + GEORANGE randomized test
[39/46 done]: unit/geo (30 seconds)
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: Replication of SPOP command -- alsoPropagate() API
[ok]: SLAVE can reload "lua" AUX RDB fields of duplicated scripts
[40/46 done]: integration/replication-3 (52 seconds)
[41/46 done]: integration/replication-4 (52 seconds)
[ok]: AOF rewrite during write load: RDB preamble=no
[ok]: Client output buffer hard limit is enforced
Waiting for process 502 to exit...
[ok]: Test replication partial resync: backlog expired (diskless: no, reconnect: 1)
[ok]: Turning off AOF kills the background writing child if any
[ok]: AOF rewrite of list with quicklist encoding, string data
[ok]: AOF rewrite of list with quicklist encoding, int data
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: AOF rewrite of set with intset encoding, string data
[ok]: Test replication partial resync: no reconnection, just sync (diskless: yes, reconnect: 0)
[ok]: AOF rewrite of set with hashtable encoding, string data
[ok]: AOF rewrite of set with intset encoding, int data
[ok]: AOF rewrite of set with hashtable encoding, int data
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: AOF rewrite of hash with ziplist encoding, string data
[ok]: AOF rewrite of hash with hashtable encoding, string data
[ok]: AOF rewrite of hash with ziplist encoding, int data
[ok]: AOF rewrite of hash with hashtable encoding, int data
[ok]: AOF rewrite of zset with ziplist encoding, string data
[ok]: AOF rewrite of zset with skiplist encoding, string data
[ok]: AOF rewrite of zset with ziplist encoding, int data
[ok]: AOF rewrite of zset with skiplist encoding, int data
[ok]: Test replication partial resync: ok psync (diskless: yes, reconnect: 1)
[ok]: BGREWRITEAOF is delayed if BGSAVE is in progress
[ok]: BGREWRITEAOF is refused if already in progress
[42/46 done]: unit/aofrw (82 seconds)
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: Stress tester for #3343-alike bugs
[ok]: Client output buffer soft limit is not enforced if time is not overreached
[ok]: Connect multiple slaves at the same time (issue #141), diskless=yes
[ok]: Test replication partial resync: no backlog (diskless: yes, reconnect: 1)
[ok]: ziplist implementation: value encoding and backlink
Waiting for process 2494 to exit...
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: ziplist implementation: encoding stress testing
[43/46 done]: unit/type/list-3 (104 seconds)
[44/46 done]: integration/replication (103 seconds)
[ok]: Client output buffer soft limit is enforced if time is overreached
[45/46 done]: unit/obuf-limits (91 seconds)
[ok]: Test replication partial resync: ok after delay (diskless: yes, reconnect: 1)
[ok]: Slave should be able to synchronize with the master
[ok]: Detect write load to master
[ok]: Test replication partial resync: backlog expired (diskless: yes, reconnect: 1)
[46/46 done]: integration/replication-psync (124 seconds)

                   The End

Execution time of different units:
  1 seconds - unit/printver
  1 seconds - unit/type/incr
  1 seconds - unit/scan
  1 seconds - unit/auth
  1 seconds - unit/quit
  2 seconds - unit/protocol
  2 seconds - unit/keyspace
  2 seconds - unit/multi
  8 seconds - unit/type/hash
  9 seconds - unit/type/set
  13 seconds - unit/type/zset
  12 seconds - unit/other
  13 seconds - unit/sort
  5 seconds - integration/aof
  14 seconds - unit/type/list
  14 seconds - unit/type/string
  1 seconds - integration/logging
  1 seconds - integration/convert-zipmap-hash-on-load
  0 seconds - unit/pubsub
  1 seconds - integration/rdb
  15 seconds - unit/expire
  1 seconds - unit/introspection
  1 seconds - unit/slowlog
  1 seconds - unit/limits
  6 seconds - unit/introspection-2
  19 seconds - integration/replication-2
  8 seconds - unit/scripting
  7 seconds - unit/bitops
  2 seconds - unit/bitfield
  3 seconds - unit/lazyfree
  28 seconds - unit/type/list-2
  14 seconds - unit/maxmemory
  10 seconds - unit/memefficiency
  8 seconds - unit/wait
  36 seconds - unit/dump
  22 seconds - integration/psync2-reg
  28 seconds - integration/psync2
  27 seconds - unit/hyperloglog
  30 seconds - unit/geo
  52 seconds - integration/replication-3
  52 seconds - integration/replication-4
  82 seconds - unit/aofrw
  104 seconds - unit/type/list-3
  103 seconds - integration/replication
  91 seconds - unit/obuf-limits
  124 seconds - integration/replication-psync

\o/ All tests passed without errors!

Cleanup: may take some time... OK
