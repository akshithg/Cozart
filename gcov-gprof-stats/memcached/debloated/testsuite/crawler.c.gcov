        -:    0:Source:crawler.c
        -:    0:Programs:72
        -:    1:/*  Copyright 2016 Netflix.
        -:    2: *
        -:    3: *  Use and distribution licensed under the BSD license.  See
        -:    4: *  the LICENSE file for full text.
        -:    5: */
        -:    6:
        -:    7:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    8:#include "memcached.h"
        -:    9:#include <sys/stat.h>
        -:   10:#include <sys/socket.h>
        -:   11:#include <sys/resource.h>
        -:   12:#include <fcntl.h>
        -:   13:#include <netinet/in.h>
        -:   14:#include <errno.h>
        -:   15:#include <stdlib.h>
        -:   16:#include <stdio.h>
        -:   17:#include <signal.h>
        -:   18:#include <string.h>
        -:   19:#include <time.h>
        -:   20:#include <assert.h>
        -:   21:#include <unistd.h>
        -:   22:#include <poll.h>
        -:   23:
        -:   24:#define LARGEST_ID POWER_LARGEST
        -:   25:
        -:   26:typedef struct {
        -:   27:    void *c; /* original connection structure. still with source thread attached. */
        -:   28:    int sfd; /* client fd. */
        -:   29:    bipbuf_t *buf; /* output buffer */
        -:   30:    char *cbuf; /* current buffer */
        -:   31:} crawler_client_t;
        -:   32:
        -:   33:typedef struct _crawler_module_t crawler_module_t;
        -:   34:
        -:   35:typedef void (*crawler_eval_func)(crawler_module_t *cm, item *it, uint32_t hv, int slab_cls);
        -:   36:typedef int (*crawler_init_func)(crawler_module_t *cm, void *data); // TODO: init args?
        -:   37:typedef void (*crawler_deinit_func)(crawler_module_t *cm); // TODO: extra args?
        -:   38:typedef void (*crawler_doneclass_func)(crawler_module_t *cm, int slab_cls);
        -:   39:typedef void (*crawler_finalize_func)(crawler_module_t *cm);
        -:   40:
        -:   41:typedef struct {
        -:   42:    crawler_init_func init; /* run before crawl starts */
        -:   43:    crawler_eval_func eval; /* runs on an item. */
        -:   44:    crawler_doneclass_func doneclass; /* runs once per sub-crawler completion. */
        -:   45:    crawler_finalize_func finalize; /* runs once when all sub-crawlers are done. */
        -:   46:    bool needs_lock; /* whether or not we need the LRU lock held when eval is called */
        -:   47:    bool needs_client; /* whether or not to grab onto the remote client */
        -:   48:} crawler_module_reg_t;
        -:   49:
        -:   50:struct _crawler_module_t {
        -:   51:    void *data; /* opaque data pointer */
        -:   52:    crawler_client_t c;
        -:   53:    crawler_module_reg_t *mod;
        -:   54:};
        -:   55:
        -:   56:static int crawler_expired_init(crawler_module_t *cm, void *data);
        -:   57:static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls);
        -:   58:static void crawler_expired_finalize(crawler_module_t *cm);
        -:   59:static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i);
        -:   60:
        -:   61:crawler_module_reg_t crawler_expired_mod = {
        -:   62:    .init = crawler_expired_init,
        -:   63:    .eval = crawler_expired_eval,
        -:   64:    .doneclass = crawler_expired_doneclass,
        -:   65:    .finalize = crawler_expired_finalize,
        -:   66:    .needs_lock = true,
        -:   67:    .needs_client = false
        -:   68:};
        -:   69:
        -:   70:static void crawler_metadump_eval(crawler_module_t *cm, item *search, uint32_t hv, int i);
        -:   71:static void crawler_metadump_finalize(crawler_module_t *cm);
        -:   72:
        -:   73:crawler_module_reg_t crawler_metadump_mod = {
        -:   74:    .init = NULL,
        -:   75:    .eval = crawler_metadump_eval,
        -:   76:    .doneclass = NULL,
        -:   77:    .finalize = crawler_metadump_finalize,
        -:   78:    .needs_lock = false,
        -:   79:    .needs_client = true
        -:   80:};
        -:   81:
        -:   82:crawler_module_reg_t *crawler_mod_regs[3] = {
        -:   83:    &crawler_expired_mod,
        -:   84:    &crawler_expired_mod,
        -:   85:    &crawler_metadump_mod
        -:   86:};
        -:   87:
        -:   88:static int lru_crawler_client_getbuf(crawler_client_t *c);
        -:   89:crawler_module_t active_crawler_mod;
        -:   90:enum crawler_run_type active_crawler_type;
        -:   91:
        -:   92:static crawler crawlers[LARGEST_ID];
        -:   93:
        -:   94:static int crawler_count = 0;
        -:   95:static volatile int do_run_lru_crawler_thread = 0;
        -:   96:static int lru_crawler_initialized = 0;
        -:   97:static pthread_mutex_t lru_crawler_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   98:static pthread_cond_t  lru_crawler_cond = PTHREAD_COND_INITIALIZER;
        -:   99:#ifdef EXTSTORE
        -:  100:/* TODO: pass this around */
        -:  101:static void *storage;
        -:  102:#endif
        -:  103:
        -:  104:/* Will crawl all slab classes a minimum of once per hour */
        -:  105:#define MAX_MAINTCRAWL_WAIT 60 * 60
        -:  106:
        -:  107:/*** LRU CRAWLER THREAD ***/
        -:  108:
        -:  109:#define LRU_CRAWLER_WRITEBUF 8192
        -:  110:
    #####:  111:static void lru_crawler_close_client(crawler_client_t *c) {
        -:  112:    //fprintf(stderr, "CRAWLER: Closing client\n");
    #####:  113:    sidethread_conn_close(c->c);
    #####:  114:    c->c = NULL;
    #####:  115:    c->cbuf = NULL;
    #####:  116:    bipbuf_free(c->buf);
    #####:  117:    c->buf = NULL;
    #####:  118:}
------------------
lru_crawler_close_client:
    #####:  111:static void lru_crawler_close_client(crawler_client_t *c) {
        -:  112:    //fprintf(stderr, "CRAWLER: Closing client\n");
    #####:  113:    sidethread_conn_close(c->c);
    #####:  114:    c->c = NULL;
    #####:  115:    c->cbuf = NULL;
    #####:  116:    bipbuf_free(c->buf);
    #####:  117:    c->buf = NULL;
    #####:  118:}
------------------
lru_crawler_close_client:
    #####:  111:static void lru_crawler_close_client(crawler_client_t *c) {
        -:  112:    //fprintf(stderr, "CRAWLER: Closing client\n");
    #####:  113:    sidethread_conn_close(c->c);
    #####:  114:    c->c = NULL;
    #####:  115:    c->cbuf = NULL;
    #####:  116:    bipbuf_free(c->buf);
    #####:  117:    c->buf = NULL;
    #####:  118:}
------------------
lru_crawler_close_client:
    #####:  111:static void lru_crawler_close_client(crawler_client_t *c) {
        -:  112:    //fprintf(stderr, "CRAWLER: Closing client\n");
    #####:  113:    sidethread_conn_close(c->c);
    #####:  114:    c->c = NULL;
    #####:  115:    c->cbuf = NULL;
    #####:  116:    bipbuf_free(c->buf);
    #####:  117:    c->buf = NULL;
    #####:  118:}
------------------
lru_crawler_close_client:
    #####:  111:static void lru_crawler_close_client(crawler_client_t *c) {
        -:  112:    //fprintf(stderr, "CRAWLER: Closing client\n");
    #####:  113:    sidethread_conn_close(c->c);
    #####:  114:    c->c = NULL;
    #####:  115:    c->cbuf = NULL;
    #####:  116:    bipbuf_free(c->buf);
    #####:  117:    c->buf = NULL;
    #####:  118:}
------------------
        -:  119:
        4:  120:static void lru_crawler_release_client(crawler_client_t *c) {
        -:  121:    //fprintf(stderr, "CRAWLER: Closing client\n");
        4:  122:    redispatch_conn(c->c);
        4:  123:    c->c = NULL;
        4:  124:    c->cbuf = NULL;
        4:  125:    bipbuf_free(c->buf);
        4:  126:    c->buf = NULL;
        4:  127:}
------------------
lru_crawler_release_client:
        1:  120:static void lru_crawler_release_client(crawler_client_t *c) {
        -:  121:    //fprintf(stderr, "CRAWLER: Closing client\n");
        1:  122:    redispatch_conn(c->c);
        1:  123:    c->c = NULL;
        1:  124:    c->cbuf = NULL;
        1:  125:    bipbuf_free(c->buf);
        1:  126:    c->buf = NULL;
        1:  127:}
------------------
lru_crawler_release_client:
        1:  120:static void lru_crawler_release_client(crawler_client_t *c) {
        -:  121:    //fprintf(stderr, "CRAWLER: Closing client\n");
        1:  122:    redispatch_conn(c->c);
        1:  123:    c->c = NULL;
        1:  124:    c->cbuf = NULL;
        1:  125:    bipbuf_free(c->buf);
        1:  126:    c->buf = NULL;
        1:  127:}
------------------
lru_crawler_release_client:
        1:  120:static void lru_crawler_release_client(crawler_client_t *c) {
        -:  121:    //fprintf(stderr, "CRAWLER: Closing client\n");
        1:  122:    redispatch_conn(c->c);
        1:  123:    c->c = NULL;
        1:  124:    c->cbuf = NULL;
        1:  125:    bipbuf_free(c->buf);
        1:  126:    c->buf = NULL;
        1:  127:}
------------------
lru_crawler_release_client:
        1:  120:static void lru_crawler_release_client(crawler_client_t *c) {
        -:  121:    //fprintf(stderr, "CRAWLER: Closing client\n");
        1:  122:    redispatch_conn(c->c);
        1:  123:    c->c = NULL;
        1:  124:    c->cbuf = NULL;
        1:  125:    bipbuf_free(c->buf);
        1:  126:    c->buf = NULL;
        1:  127:}
------------------
        -:  128:
      360:  129:static int crawler_expired_init(crawler_module_t *cm, void *data) {
      360:  130:    struct crawler_expired_data *d;
      360:  131:    if (data != NULL) {
      352:  132:        d = data;
      352:  133:        d->is_external = true;
      352:  134:        cm->data = data;
        -:  135:    } else {
        -:  136:        // allocate data.
        8:  137:        d = calloc(1, sizeof(struct crawler_expired_data));
        8:  138:        if (d == NULL) {
        -:  139:            return -1;
        -:  140:        }
        -:  141:        // init lock.
        8:  142:        pthread_mutex_init(&d->lock, NULL);
        8:  143:        d->is_external = false;
        8:  144:        d->start_time = current_time;
        -:  145:
        8:  146:        cm->data = d;
        -:  147:    }
      360:  148:    pthread_mutex_lock(&d->lock);
      360:  149:    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    92520:  150:    for (int x = 0; x < POWER_LARGEST; x++) {
    92160:  151:        d->crawlerstats[x].start_time = current_time;
    92160:  152:        d->crawlerstats[x].run_complete = false;
        -:  153:    }
      360:  154:    pthread_mutex_unlock(&d->lock);
      360:  155:    return 0;
        -:  156:}
------------------
crawler_expired_init:
       90:  129:static int crawler_expired_init(crawler_module_t *cm, void *data) {
       90:  130:    struct crawler_expired_data *d;
       90:  131:    if (data != NULL) {
       88:  132:        d = data;
       88:  133:        d->is_external = true;
       88:  134:        cm->data = data;
        -:  135:    } else {
        -:  136:        // allocate data.
        2:  137:        d = calloc(1, sizeof(struct crawler_expired_data));
        2:  138:        if (d == NULL) {
        -:  139:            return -1;
        -:  140:        }
        -:  141:        // init lock.
        2:  142:        pthread_mutex_init(&d->lock, NULL);
        2:  143:        d->is_external = false;
        2:  144:        d->start_time = current_time;
        -:  145:
        2:  146:        cm->data = d;
        -:  147:    }
       90:  148:    pthread_mutex_lock(&d->lock);
       90:  149:    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    23130:  150:    for (int x = 0; x < POWER_LARGEST; x++) {
    23040:  151:        d->crawlerstats[x].start_time = current_time;
    23040:  152:        d->crawlerstats[x].run_complete = false;
        -:  153:    }
       90:  154:    pthread_mutex_unlock(&d->lock);
       90:  155:    return 0;
        -:  156:}
------------------
crawler_expired_init:
       90:  129:static int crawler_expired_init(crawler_module_t *cm, void *data) {
       90:  130:    struct crawler_expired_data *d;
       90:  131:    if (data != NULL) {
       88:  132:        d = data;
       88:  133:        d->is_external = true;
       88:  134:        cm->data = data;
        -:  135:    } else {
        -:  136:        // allocate data.
        2:  137:        d = calloc(1, sizeof(struct crawler_expired_data));
        2:  138:        if (d == NULL) {
        -:  139:            return -1;
        -:  140:        }
        -:  141:        // init lock.
        2:  142:        pthread_mutex_init(&d->lock, NULL);
        2:  143:        d->is_external = false;
        2:  144:        d->start_time = current_time;
        -:  145:
        2:  146:        cm->data = d;
        -:  147:    }
       90:  148:    pthread_mutex_lock(&d->lock);
       90:  149:    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    23130:  150:    for (int x = 0; x < POWER_LARGEST; x++) {
    23040:  151:        d->crawlerstats[x].start_time = current_time;
    23040:  152:        d->crawlerstats[x].run_complete = false;
        -:  153:    }
       90:  154:    pthread_mutex_unlock(&d->lock);
       90:  155:    return 0;
        -:  156:}
------------------
crawler_expired_init:
       90:  129:static int crawler_expired_init(crawler_module_t *cm, void *data) {
       90:  130:    struct crawler_expired_data *d;
       90:  131:    if (data != NULL) {
       88:  132:        d = data;
       88:  133:        d->is_external = true;
       88:  134:        cm->data = data;
        -:  135:    } else {
        -:  136:        // allocate data.
        2:  137:        d = calloc(1, sizeof(struct crawler_expired_data));
        2:  138:        if (d == NULL) {
        -:  139:            return -1;
        -:  140:        }
        -:  141:        // init lock.
        2:  142:        pthread_mutex_init(&d->lock, NULL);
        2:  143:        d->is_external = false;
        2:  144:        d->start_time = current_time;
        -:  145:
        2:  146:        cm->data = d;
        -:  147:    }
       90:  148:    pthread_mutex_lock(&d->lock);
       90:  149:    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    23130:  150:    for (int x = 0; x < POWER_LARGEST; x++) {
    23040:  151:        d->crawlerstats[x].start_time = current_time;
    23040:  152:        d->crawlerstats[x].run_complete = false;
        -:  153:    }
       90:  154:    pthread_mutex_unlock(&d->lock);
       90:  155:    return 0;
        -:  156:}
------------------
crawler_expired_init:
       90:  129:static int crawler_expired_init(crawler_module_t *cm, void *data) {
       90:  130:    struct crawler_expired_data *d;
       90:  131:    if (data != NULL) {
       88:  132:        d = data;
       88:  133:        d->is_external = true;
       88:  134:        cm->data = data;
        -:  135:    } else {
        -:  136:        // allocate data.
        2:  137:        d = calloc(1, sizeof(struct crawler_expired_data));
        2:  138:        if (d == NULL) {
        -:  139:            return -1;
        -:  140:        }
        -:  141:        // init lock.
        2:  142:        pthread_mutex_init(&d->lock, NULL);
        2:  143:        d->is_external = false;
        2:  144:        d->start_time = current_time;
        -:  145:
        2:  146:        cm->data = d;
        -:  147:    }
       90:  148:    pthread_mutex_lock(&d->lock);
       90:  149:    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    23130:  150:    for (int x = 0; x < POWER_LARGEST; x++) {
    23040:  151:        d->crawlerstats[x].start_time = current_time;
    23040:  152:        d->crawlerstats[x].run_complete = false;
        -:  153:    }
       90:  154:    pthread_mutex_unlock(&d->lock);
       90:  155:    return 0;
        -:  156:}
------------------
        -:  157:
    89792:  158:static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {
    89792:  159:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    89792:  160:    pthread_mutex_lock(&d->lock);
    89792:  161:    d->crawlerstats[slab_cls].end_time = current_time;
    89792:  162:    d->crawlerstats[slab_cls].run_complete = true;
    89792:  163:    pthread_mutex_unlock(&d->lock);
    89792:  164:}
------------------
crawler_expired_doneclass:
    22448:  158:static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {
    22448:  159:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    22448:  160:    pthread_mutex_lock(&d->lock);
    22448:  161:    d->crawlerstats[slab_cls].end_time = current_time;
    22448:  162:    d->crawlerstats[slab_cls].run_complete = true;
    22448:  163:    pthread_mutex_unlock(&d->lock);
    22448:  164:}
------------------
crawler_expired_doneclass:
    22448:  158:static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {
    22448:  159:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    22448:  160:    pthread_mutex_lock(&d->lock);
    22448:  161:    d->crawlerstats[slab_cls].end_time = current_time;
    22448:  162:    d->crawlerstats[slab_cls].run_complete = true;
    22448:  163:    pthread_mutex_unlock(&d->lock);
    22448:  164:}
------------------
crawler_expired_doneclass:
    22448:  158:static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {
    22448:  159:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    22448:  160:    pthread_mutex_lock(&d->lock);
    22448:  161:    d->crawlerstats[slab_cls].end_time = current_time;
    22448:  162:    d->crawlerstats[slab_cls].run_complete = true;
    22448:  163:    pthread_mutex_unlock(&d->lock);
    22448:  164:}
------------------
crawler_expired_doneclass:
    22448:  158:static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {
    22448:  159:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    22448:  160:    pthread_mutex_lock(&d->lock);
    22448:  161:    d->crawlerstats[slab_cls].end_time = current_time;
    22448:  162:    d->crawlerstats[slab_cls].run_complete = true;
    22448:  163:    pthread_mutex_unlock(&d->lock);
    22448:  164:}
------------------
        -:  165:
      360:  166:static void crawler_expired_finalize(crawler_module_t *cm) {
      360:  167:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
      360:  168:    pthread_mutex_lock(&d->lock);
      360:  169:    d->end_time = current_time;
      360:  170:    d->crawl_complete = true;
      360:  171:    pthread_mutex_unlock(&d->lock);
        -:  172:
      360:  173:    if (!d->is_external) {
        8:  174:        free(d);
        -:  175:    }
      360:  176:}
------------------
crawler_expired_finalize:
       90:  166:static void crawler_expired_finalize(crawler_module_t *cm) {
       90:  167:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
       90:  168:    pthread_mutex_lock(&d->lock);
       90:  169:    d->end_time = current_time;
       90:  170:    d->crawl_complete = true;
       90:  171:    pthread_mutex_unlock(&d->lock);
        -:  172:
       90:  173:    if (!d->is_external) {
        2:  174:        free(d);
        -:  175:    }
       90:  176:}
------------------
crawler_expired_finalize:
       90:  166:static void crawler_expired_finalize(crawler_module_t *cm) {
       90:  167:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
       90:  168:    pthread_mutex_lock(&d->lock);
       90:  169:    d->end_time = current_time;
       90:  170:    d->crawl_complete = true;
       90:  171:    pthread_mutex_unlock(&d->lock);
        -:  172:
       90:  173:    if (!d->is_external) {
        2:  174:        free(d);
        -:  175:    }
       90:  176:}
------------------
crawler_expired_finalize:
       90:  166:static void crawler_expired_finalize(crawler_module_t *cm) {
       90:  167:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
       90:  168:    pthread_mutex_lock(&d->lock);
       90:  169:    d->end_time = current_time;
       90:  170:    d->crawl_complete = true;
       90:  171:    pthread_mutex_unlock(&d->lock);
        -:  172:
       90:  173:    if (!d->is_external) {
        2:  174:        free(d);
        -:  175:    }
       90:  176:}
------------------
crawler_expired_finalize:
       90:  166:static void crawler_expired_finalize(crawler_module_t *cm) {
       90:  167:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
       90:  168:    pthread_mutex_lock(&d->lock);
       90:  169:    d->end_time = current_time;
       90:  170:    d->crawl_complete = true;
       90:  171:    pthread_mutex_unlock(&d->lock);
        -:  172:
       90:  173:    if (!d->is_external) {
        2:  174:        free(d);
        -:  175:    }
       90:  176:}
------------------
        -:  177:
        -:  178:/* I pulled this out to make the main thread clearer, but it reaches into the
        -:  179: * main thread's values too much. Should rethink again.
        -:  180: */
      480:  181:static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {
      480:  182:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
      480:  183:    pthread_mutex_lock(&d->lock);
      480:  184:    crawlerstats_t *s = &d->crawlerstats[i];
      480:  185:    int is_flushed = item_is_flushed(search);
        -:  186:#ifdef EXTSTORE
        -:  187:    bool is_valid = true;
        -:  188:    if (search->it_flags & ITEM_HDR) {
        -:  189:        item_hdr *hdr = (item_hdr *)ITEM_data(search);
        -:  190:        if (extstore_check(storage, hdr->page_id, hdr->page_version) != 0)
        -:  191:            is_valid = false;
        -:  192:    }
        -:  193:#endif
      480:  194:    if ((search->exptime != 0 && search->exptime < current_time)
      240:  195:        || is_flushed
        -:  196:#ifdef EXTSTORE
        -:  197:        || !is_valid
        -:  198:#endif
        -:  199:        ) {
      240:  200:        crawlers[i].reclaimed++;
      240:  201:        s->reclaimed++;
        -:  202:
      240:  203:        if (settings.verbose > 1) {
    #####:  204:            int ii;
    #####:  205:            char *key = ITEM_key(search);
    #####:  206:            fprintf(stderr, "LRU crawler found an expired item (flags: %d, slab: %d): ",
    #####:  207:                search->it_flags, search->slabs_clsid);
    #####:  208:            for (ii = 0; ii < search->nkey; ++ii) {
    #####:  209:                fprintf(stderr, "%c", key[ii]);
        -:  210:            }
    #####:  211:            fprintf(stderr, "\n");
        -:  212:        }
      240:  213:        if ((search->it_flags & ITEM_FETCHED) == 0 && !is_flushed) {
      240:  214:            crawlers[i].unfetched++;
        -:  215:        }
        -:  216:#ifdef EXTSTORE
        -:  217:        STORAGE_delete(storage, search);
        -:  218:#endif
      240:  219:        do_item_unlink_nolock(search, hv);
      240:  220:        do_item_remove(search);
        -:  221:    } else {
      240:  222:        s->seen++;
      240:  223:        refcount_decr(search);
      240:  224:        if (search->exptime == 0) {
      120:  225:            s->noexp++;
      120:  226:        } else if (search->exptime - current_time > 3599) {
    #####:  227:            s->ttl_hourplus++;
        -:  228:        } else {
      120:  229:            rel_time_t ttl_remain = search->exptime - current_time;
      120:  230:            int bucket = ttl_remain / 60;
      120:  231:            if (bucket <= 60) {
      120:  232:                s->histo[bucket]++;
        -:  233:            }
        -:  234:        }
        -:  235:    }
      480:  236:    pthread_mutex_unlock(&d->lock);
      480:  237:}
------------------
crawler_expired_eval:
      120:  181:static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {
      120:  182:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
      120:  183:    pthread_mutex_lock(&d->lock);
      120:  184:    crawlerstats_t *s = &d->crawlerstats[i];
      120:  185:    int is_flushed = item_is_flushed(search);
        -:  186:#ifdef EXTSTORE
        -:  187:    bool is_valid = true;
        -:  188:    if (search->it_flags & ITEM_HDR) {
        -:  189:        item_hdr *hdr = (item_hdr *)ITEM_data(search);
        -:  190:        if (extstore_check(storage, hdr->page_id, hdr->page_version) != 0)
        -:  191:            is_valid = false;
        -:  192:    }
        -:  193:#endif
      120:  194:    if ((search->exptime != 0 && search->exptime < current_time)
       60:  195:        || is_flushed
        -:  196:#ifdef EXTSTORE
        -:  197:        || !is_valid
        -:  198:#endif
        -:  199:        ) {
       60:  200:        crawlers[i].reclaimed++;
       60:  201:        s->reclaimed++;
        -:  202:
       60:  203:        if (settings.verbose > 1) {
    #####:  204:            int ii;
    #####:  205:            char *key = ITEM_key(search);
    #####:  206:            fprintf(stderr, "LRU crawler found an expired item (flags: %d, slab: %d): ",
    #####:  207:                search->it_flags, search->slabs_clsid);
    #####:  208:            for (ii = 0; ii < search->nkey; ++ii) {
    #####:  209:                fprintf(stderr, "%c", key[ii]);
        -:  210:            }
    #####:  211:            fprintf(stderr, "\n");
        -:  212:        }
       60:  213:        if ((search->it_flags & ITEM_FETCHED) == 0 && !is_flushed) {
       60:  214:            crawlers[i].unfetched++;
        -:  215:        }
        -:  216:#ifdef EXTSTORE
        -:  217:        STORAGE_delete(storage, search);
        -:  218:#endif
       60:  219:        do_item_unlink_nolock(search, hv);
       60:  220:        do_item_remove(search);
        -:  221:    } else {
       60:  222:        s->seen++;
       60:  223:        refcount_decr(search);
       60:  224:        if (search->exptime == 0) {
       30:  225:            s->noexp++;
       30:  226:        } else if (search->exptime - current_time > 3599) {
    #####:  227:            s->ttl_hourplus++;
        -:  228:        } else {
       30:  229:            rel_time_t ttl_remain = search->exptime - current_time;
       30:  230:            int bucket = ttl_remain / 60;
       30:  231:            if (bucket <= 60) {
       30:  232:                s->histo[bucket]++;
        -:  233:            }
        -:  234:        }
        -:  235:    }
      120:  236:    pthread_mutex_unlock(&d->lock);
      120:  237:}
------------------
crawler_expired_eval:
      120:  181:static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {
      120:  182:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
      120:  183:    pthread_mutex_lock(&d->lock);
      120:  184:    crawlerstats_t *s = &d->crawlerstats[i];
      120:  185:    int is_flushed = item_is_flushed(search);
        -:  186:#ifdef EXTSTORE
        -:  187:    bool is_valid = true;
        -:  188:    if (search->it_flags & ITEM_HDR) {
        -:  189:        item_hdr *hdr = (item_hdr *)ITEM_data(search);
        -:  190:        if (extstore_check(storage, hdr->page_id, hdr->page_version) != 0)
        -:  191:            is_valid = false;
        -:  192:    }
        -:  193:#endif
      120:  194:    if ((search->exptime != 0 && search->exptime < current_time)
       60:  195:        || is_flushed
        -:  196:#ifdef EXTSTORE
        -:  197:        || !is_valid
        -:  198:#endif
        -:  199:        ) {
       60:  200:        crawlers[i].reclaimed++;
       60:  201:        s->reclaimed++;
        -:  202:
       60:  203:        if (settings.verbose > 1) {
    #####:  204:            int ii;
    #####:  205:            char *key = ITEM_key(search);
    #####:  206:            fprintf(stderr, "LRU crawler found an expired item (flags: %d, slab: %d): ",
    #####:  207:                search->it_flags, search->slabs_clsid);
    #####:  208:            for (ii = 0; ii < search->nkey; ++ii) {
    #####:  209:                fprintf(stderr, "%c", key[ii]);
        -:  210:            }
    #####:  211:            fprintf(stderr, "\n");
        -:  212:        }
       60:  213:        if ((search->it_flags & ITEM_FETCHED) == 0 && !is_flushed) {
       60:  214:            crawlers[i].unfetched++;
        -:  215:        }
        -:  216:#ifdef EXTSTORE
        -:  217:        STORAGE_delete(storage, search);
        -:  218:#endif
       60:  219:        do_item_unlink_nolock(search, hv);
       60:  220:        do_item_remove(search);
        -:  221:    } else {
       60:  222:        s->seen++;
       60:  223:        refcount_decr(search);
       60:  224:        if (search->exptime == 0) {
       30:  225:            s->noexp++;
       30:  226:        } else if (search->exptime - current_time > 3599) {
    #####:  227:            s->ttl_hourplus++;
        -:  228:        } else {
       30:  229:            rel_time_t ttl_remain = search->exptime - current_time;
       30:  230:            int bucket = ttl_remain / 60;
       30:  231:            if (bucket <= 60) {
       30:  232:                s->histo[bucket]++;
        -:  233:            }
        -:  234:        }
        -:  235:    }
      120:  236:    pthread_mutex_unlock(&d->lock);
      120:  237:}
------------------
crawler_expired_eval:
      120:  181:static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {
      120:  182:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
      120:  183:    pthread_mutex_lock(&d->lock);
      120:  184:    crawlerstats_t *s = &d->crawlerstats[i];
      120:  185:    int is_flushed = item_is_flushed(search);
        -:  186:#ifdef EXTSTORE
        -:  187:    bool is_valid = true;
        -:  188:    if (search->it_flags & ITEM_HDR) {
        -:  189:        item_hdr *hdr = (item_hdr *)ITEM_data(search);
        -:  190:        if (extstore_check(storage, hdr->page_id, hdr->page_version) != 0)
        -:  191:            is_valid = false;
        -:  192:    }
        -:  193:#endif
      120:  194:    if ((search->exptime != 0 && search->exptime < current_time)
       60:  195:        || is_flushed
        -:  196:#ifdef EXTSTORE
        -:  197:        || !is_valid
        -:  198:#endif
        -:  199:        ) {
       60:  200:        crawlers[i].reclaimed++;
       60:  201:        s->reclaimed++;
        -:  202:
       60:  203:        if (settings.verbose > 1) {
    #####:  204:            int ii;
    #####:  205:            char *key = ITEM_key(search);
    #####:  206:            fprintf(stderr, "LRU crawler found an expired item (flags: %d, slab: %d): ",
    #####:  207:                search->it_flags, search->slabs_clsid);
    #####:  208:            for (ii = 0; ii < search->nkey; ++ii) {
    #####:  209:                fprintf(stderr, "%c", key[ii]);
        -:  210:            }
    #####:  211:            fprintf(stderr, "\n");
        -:  212:        }
       60:  213:        if ((search->it_flags & ITEM_FETCHED) == 0 && !is_flushed) {
       60:  214:            crawlers[i].unfetched++;
        -:  215:        }
        -:  216:#ifdef EXTSTORE
        -:  217:        STORAGE_delete(storage, search);
        -:  218:#endif
       60:  219:        do_item_unlink_nolock(search, hv);
       60:  220:        do_item_remove(search);
        -:  221:    } else {
       60:  222:        s->seen++;
       60:  223:        refcount_decr(search);
       60:  224:        if (search->exptime == 0) {
       30:  225:            s->noexp++;
       30:  226:        } else if (search->exptime - current_time > 3599) {
    #####:  227:            s->ttl_hourplus++;
        -:  228:        } else {
       30:  229:            rel_time_t ttl_remain = search->exptime - current_time;
       30:  230:            int bucket = ttl_remain / 60;
       30:  231:            if (bucket <= 60) {
       30:  232:                s->histo[bucket]++;
        -:  233:            }
        -:  234:        }
        -:  235:    }
      120:  236:    pthread_mutex_unlock(&d->lock);
      120:  237:}
------------------
crawler_expired_eval:
      120:  181:static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {
      120:  182:    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
      120:  183:    pthread_mutex_lock(&d->lock);
      120:  184:    crawlerstats_t *s = &d->crawlerstats[i];
      120:  185:    int is_flushed = item_is_flushed(search);
        -:  186:#ifdef EXTSTORE
        -:  187:    bool is_valid = true;
        -:  188:    if (search->it_flags & ITEM_HDR) {
        -:  189:        item_hdr *hdr = (item_hdr *)ITEM_data(search);
        -:  190:        if (extstore_check(storage, hdr->page_id, hdr->page_version) != 0)
        -:  191:            is_valid = false;
        -:  192:    }
        -:  193:#endif
      120:  194:    if ((search->exptime != 0 && search->exptime < current_time)
       60:  195:        || is_flushed
        -:  196:#ifdef EXTSTORE
        -:  197:        || !is_valid
        -:  198:#endif
        -:  199:        ) {
       60:  200:        crawlers[i].reclaimed++;
       60:  201:        s->reclaimed++;
        -:  202:
       60:  203:        if (settings.verbose > 1) {
    #####:  204:            int ii;
    #####:  205:            char *key = ITEM_key(search);
    #####:  206:            fprintf(stderr, "LRU crawler found an expired item (flags: %d, slab: %d): ",
    #####:  207:                search->it_flags, search->slabs_clsid);
    #####:  208:            for (ii = 0; ii < search->nkey; ++ii) {
    #####:  209:                fprintf(stderr, "%c", key[ii]);
        -:  210:            }
    #####:  211:            fprintf(stderr, "\n");
        -:  212:        }
       60:  213:        if ((search->it_flags & ITEM_FETCHED) == 0 && !is_flushed) {
       60:  214:            crawlers[i].unfetched++;
        -:  215:        }
        -:  216:#ifdef EXTSTORE
        -:  217:        STORAGE_delete(storage, search);
        -:  218:#endif
       60:  219:        do_item_unlink_nolock(search, hv);
       60:  220:        do_item_remove(search);
        -:  221:    } else {
       60:  222:        s->seen++;
       60:  223:        refcount_decr(search);
       60:  224:        if (search->exptime == 0) {
       30:  225:            s->noexp++;
       30:  226:        } else if (search->exptime - current_time > 3599) {
    #####:  227:            s->ttl_hourplus++;
        -:  228:        } else {
       30:  229:            rel_time_t ttl_remain = search->exptime - current_time;
       30:  230:            int bucket = ttl_remain / 60;
       30:  231:            if (bucket <= 60) {
       30:  232:                s->histo[bucket]++;
        -:  233:            }
        -:  234:        }
        -:  235:    }
      120:  236:    pthread_mutex_unlock(&d->lock);
      120:  237:}
------------------
        -:  238:
      240:  239:static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {
        -:  240:    //int slab_id = CLEAR_LRU(i);
      240:  241:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
      240:  242:    int is_flushed = item_is_flushed(it);
        -:  243:    /* Ignore expired content. */
      240:  244:    if ((it->exptime != 0 && it->exptime < current_time)
      240:  245:        || is_flushed) {
    #####:  246:        refcount_decr(it);
    #####:  247:        return;
        -:  248:    }
        -:  249:    // TODO: uriencode directly into the buffer.
      240:  250:    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      480:  251:    int total = snprintf(cm->c.cbuf, 4096,
        -:  252:            "key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n",
        -:  253:            keybuf,
      120:  254:            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
      240:  255:            (unsigned long long)(it->time + process_started),
        -:  256:            (unsigned long long)ITEM_get_cas(it),
        -:  257:            (it->it_flags & ITEM_FETCHED) ? "yes" : "no",
      240:  258:            ITEM_clsid(it),
      240:  259:            (unsigned long) ITEM_ntotal(it));
      240:  260:    refcount_decr(it);
        -:  261:    // TODO: some way of tracking the errors. these are very unlikely though.
      240:  262:    if (total >= LRU_CRAWLER_WRITEBUF - 1 || total <= 0) {
        -:  263:        /* Failed to write, don't push it. */
        -:  264:        return;
        -:  265:    }
      240:  266:    bipbuf_push(cm->c.buf, total);
        -:  267:}
------------------
crawler_metadump_eval:
       60:  239:static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {
        -:  240:    //int slab_id = CLEAR_LRU(i);
       60:  241:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       60:  242:    int is_flushed = item_is_flushed(it);
        -:  243:    /* Ignore expired content. */
       60:  244:    if ((it->exptime != 0 && it->exptime < current_time)
       60:  245:        || is_flushed) {
    #####:  246:        refcount_decr(it);
    #####:  247:        return;
        -:  248:    }
        -:  249:    // TODO: uriencode directly into the buffer.
       60:  250:    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      120:  251:    int total = snprintf(cm->c.cbuf, 4096,
        -:  252:            "key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n",
        -:  253:            keybuf,
       30:  254:            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
       60:  255:            (unsigned long long)(it->time + process_started),
        -:  256:            (unsigned long long)ITEM_get_cas(it),
        -:  257:            (it->it_flags & ITEM_FETCHED) ? "yes" : "no",
       60:  258:            ITEM_clsid(it),
       60:  259:            (unsigned long) ITEM_ntotal(it));
       60:  260:    refcount_decr(it);
        -:  261:    // TODO: some way of tracking the errors. these are very unlikely though.
       60:  262:    if (total >= LRU_CRAWLER_WRITEBUF - 1 || total <= 0) {
        -:  263:        /* Failed to write, don't push it. */
        -:  264:        return;
        -:  265:    }
       60:  266:    bipbuf_push(cm->c.buf, total);
        -:  267:}
------------------
crawler_metadump_eval:
       60:  239:static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {
        -:  240:    //int slab_id = CLEAR_LRU(i);
       60:  241:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       60:  242:    int is_flushed = item_is_flushed(it);
        -:  243:    /* Ignore expired content. */
       60:  244:    if ((it->exptime != 0 && it->exptime < current_time)
       60:  245:        || is_flushed) {
    #####:  246:        refcount_decr(it);
    #####:  247:        return;
        -:  248:    }
        -:  249:    // TODO: uriencode directly into the buffer.
       60:  250:    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      120:  251:    int total = snprintf(cm->c.cbuf, 4096,
        -:  252:            "key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n",
        -:  253:            keybuf,
       30:  254:            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
       60:  255:            (unsigned long long)(it->time + process_started),
        -:  256:            (unsigned long long)ITEM_get_cas(it),
        -:  257:            (it->it_flags & ITEM_FETCHED) ? "yes" : "no",
       60:  258:            ITEM_clsid(it),
       60:  259:            (unsigned long) ITEM_ntotal(it));
       60:  260:    refcount_decr(it);
        -:  261:    // TODO: some way of tracking the errors. these are very unlikely though.
       60:  262:    if (total >= LRU_CRAWLER_WRITEBUF - 1 || total <= 0) {
        -:  263:        /* Failed to write, don't push it. */
        -:  264:        return;
        -:  265:    }
       60:  266:    bipbuf_push(cm->c.buf, total);
        -:  267:}
------------------
crawler_metadump_eval:
       60:  239:static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {
        -:  240:    //int slab_id = CLEAR_LRU(i);
       60:  241:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       60:  242:    int is_flushed = item_is_flushed(it);
        -:  243:    /* Ignore expired content. */
       60:  244:    if ((it->exptime != 0 && it->exptime < current_time)
       60:  245:        || is_flushed) {
    #####:  246:        refcount_decr(it);
    #####:  247:        return;
        -:  248:    }
        -:  249:    // TODO: uriencode directly into the buffer.
       60:  250:    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      120:  251:    int total = snprintf(cm->c.cbuf, 4096,
        -:  252:            "key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n",
        -:  253:            keybuf,
       30:  254:            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
       60:  255:            (unsigned long long)(it->time + process_started),
        -:  256:            (unsigned long long)ITEM_get_cas(it),
        -:  257:            (it->it_flags & ITEM_FETCHED) ? "yes" : "no",
       60:  258:            ITEM_clsid(it),
       60:  259:            (unsigned long) ITEM_ntotal(it));
       60:  260:    refcount_decr(it);
        -:  261:    // TODO: some way of tracking the errors. these are very unlikely though.
       60:  262:    if (total >= LRU_CRAWLER_WRITEBUF - 1 || total <= 0) {
        -:  263:        /* Failed to write, don't push it. */
        -:  264:        return;
        -:  265:    }
       60:  266:    bipbuf_push(cm->c.buf, total);
        -:  267:}
------------------
crawler_metadump_eval:
       60:  239:static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {
        -:  240:    //int slab_id = CLEAR_LRU(i);
       60:  241:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       60:  242:    int is_flushed = item_is_flushed(it);
        -:  243:    /* Ignore expired content. */
       60:  244:    if ((it->exptime != 0 && it->exptime < current_time)
       60:  245:        || is_flushed) {
    #####:  246:        refcount_decr(it);
    #####:  247:        return;
        -:  248:    }
        -:  249:    // TODO: uriencode directly into the buffer.
       60:  250:    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      120:  251:    int total = snprintf(cm->c.cbuf, 4096,
        -:  252:            "key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n",
        -:  253:            keybuf,
       30:  254:            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
       60:  255:            (unsigned long long)(it->time + process_started),
        -:  256:            (unsigned long long)ITEM_get_cas(it),
        -:  257:            (it->it_flags & ITEM_FETCHED) ? "yes" : "no",
       60:  258:            ITEM_clsid(it),
       60:  259:            (unsigned long) ITEM_ntotal(it));
       60:  260:    refcount_decr(it);
        -:  261:    // TODO: some way of tracking the errors. these are very unlikely though.
       60:  262:    if (total >= LRU_CRAWLER_WRITEBUF - 1 || total <= 0) {
        -:  263:        /* Failed to write, don't push it. */
        -:  264:        return;
        -:  265:    }
       60:  266:    bipbuf_push(cm->c.buf, total);
        -:  267:}
------------------
        -:  268:
        4:  269:static void crawler_metadump_finalize(crawler_module_t *cm) {
        4:  270:    if (cm->c.c != NULL) {
        -:  271:        // Ensure space for final message.
        4:  272:        lru_crawler_client_getbuf(&cm->c);
        4:  273:        memcpy(cm->c.cbuf, "END\r\n", 5);
        4:  274:        bipbuf_push(cm->c.buf, 5);
        -:  275:    }
        4:  276:}
------------------
crawler_metadump_finalize:
        1:  269:static void crawler_metadump_finalize(crawler_module_t *cm) {
        1:  270:    if (cm->c.c != NULL) {
        -:  271:        // Ensure space for final message.
        1:  272:        lru_crawler_client_getbuf(&cm->c);
        1:  273:        memcpy(cm->c.cbuf, "END\r\n", 5);
        1:  274:        bipbuf_push(cm->c.buf, 5);
        -:  275:    }
        1:  276:}
------------------
crawler_metadump_finalize:
        1:  269:static void crawler_metadump_finalize(crawler_module_t *cm) {
        1:  270:    if (cm->c.c != NULL) {
        -:  271:        // Ensure space for final message.
        1:  272:        lru_crawler_client_getbuf(&cm->c);
        1:  273:        memcpy(cm->c.cbuf, "END\r\n", 5);
        1:  274:        bipbuf_push(cm->c.buf, 5);
        -:  275:    }
        1:  276:}
------------------
crawler_metadump_finalize:
        1:  269:static void crawler_metadump_finalize(crawler_module_t *cm) {
        1:  270:    if (cm->c.c != NULL) {
        -:  271:        // Ensure space for final message.
        1:  272:        lru_crawler_client_getbuf(&cm->c);
        1:  273:        memcpy(cm->c.cbuf, "END\r\n", 5);
        1:  274:        bipbuf_push(cm->c.buf, 5);
        -:  275:    }
        1:  276:}
------------------
crawler_metadump_finalize:
        1:  269:static void crawler_metadump_finalize(crawler_module_t *cm) {
        1:  270:    if (cm->c.c != NULL) {
        -:  271:        // Ensure space for final message.
        1:  272:        lru_crawler_client_getbuf(&cm->c);
        1:  273:        memcpy(cm->c.cbuf, "END\r\n", 5);
        1:  274:        bipbuf_push(cm->c.buf, 5);
        -:  275:    }
        1:  276:}
------------------
        -:  277:
        4:  278:static int lru_crawler_poll(crawler_client_t *c) {
        4:  279:    unsigned char *data;
        4:  280:    unsigned int data_size = 0;
        4:  281:    struct pollfd to_poll[1];
        4:  282:    to_poll[0].fd = c->sfd;
        4:  283:    to_poll[0].events = POLLOUT;
        -:  284:
        4:  285:    int ret = poll(to_poll, 1, 1000);
        -:  286:
        4:  287:    if (ret < 0) {
        -:  288:        // fatal.
        -:  289:        return -1;
        -:  290:    }
        -:  291:
        4:  292:    if (ret == 0) return 0;
        -:  293:
        4:  294:    if (to_poll[0].revents & POLLIN) {
    #####:  295:        char buf[1];
    #####:  296:        int res = ((conn*)c->c)->read(c->c, buf, 1);
    #####:  297:        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  298:            lru_crawler_close_client(c);
    #####:  299:            return -1;
        -:  300:        }
        -:  301:    }
        4:  302:    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        4:  303:        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
    #####:  304:            lru_crawler_close_client(c);
    #####:  305:            return -1;
        4:  306:        } else if (to_poll[0].revents & POLLOUT) {
        4:  307:            int total = ((conn*)c->c)->write(c->c, data, data_size);
        4:  308:            if (total == -1) {
    #####:  309:                if (errno != EAGAIN && errno != EWOULDBLOCK) {
    #####:  310:                    lru_crawler_close_client(c);
    #####:  311:                    return -1;
        -:  312:                }
        4:  313:            } else if (total == 0) {
    #####:  314:                lru_crawler_close_client(c);
    #####:  315:                return -1;
        -:  316:            } else {
        4:  317:                bipbuf_poll(c->buf, total);
        -:  318:            }
        -:  319:        }
        -:  320:    }
        -:  321:    return 0;
        -:  322:}
------------------
lru_crawler_poll:
        1:  278:static int lru_crawler_poll(crawler_client_t *c) {
        1:  279:    unsigned char *data;
        1:  280:    unsigned int data_size = 0;
        1:  281:    struct pollfd to_poll[1];
        1:  282:    to_poll[0].fd = c->sfd;
        1:  283:    to_poll[0].events = POLLOUT;
        -:  284:
        1:  285:    int ret = poll(to_poll, 1, 1000);
        -:  286:
        1:  287:    if (ret < 0) {
        -:  288:        // fatal.
        -:  289:        return -1;
        -:  290:    }
        -:  291:
        1:  292:    if (ret == 0) return 0;
        -:  293:
        1:  294:    if (to_poll[0].revents & POLLIN) {
    #####:  295:        char buf[1];
    #####:  296:        int res = ((conn*)c->c)->read(c->c, buf, 1);
    #####:  297:        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  298:            lru_crawler_close_client(c);
    #####:  299:            return -1;
        -:  300:        }
        -:  301:    }
        1:  302:    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        1:  303:        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
    #####:  304:            lru_crawler_close_client(c);
    #####:  305:            return -1;
        1:  306:        } else if (to_poll[0].revents & POLLOUT) {
        1:  307:            int total = ((conn*)c->c)->write(c->c, data, data_size);
        1:  308:            if (total == -1) {
    #####:  309:                if (errno != EAGAIN && errno != EWOULDBLOCK) {
    #####:  310:                    lru_crawler_close_client(c);
    #####:  311:                    return -1;
        -:  312:                }
        1:  313:            } else if (total == 0) {
    #####:  314:                lru_crawler_close_client(c);
    #####:  315:                return -1;
        -:  316:            } else {
        1:  317:                bipbuf_poll(c->buf, total);
        -:  318:            }
        -:  319:        }
        -:  320:    }
        -:  321:    return 0;
        -:  322:}
------------------
lru_crawler_poll:
        1:  278:static int lru_crawler_poll(crawler_client_t *c) {
        1:  279:    unsigned char *data;
        1:  280:    unsigned int data_size = 0;
        1:  281:    struct pollfd to_poll[1];
        1:  282:    to_poll[0].fd = c->sfd;
        1:  283:    to_poll[0].events = POLLOUT;
        -:  284:
        1:  285:    int ret = poll(to_poll, 1, 1000);
        -:  286:
        1:  287:    if (ret < 0) {
        -:  288:        // fatal.
        -:  289:        return -1;
        -:  290:    }
        -:  291:
        1:  292:    if (ret == 0) return 0;
        -:  293:
        1:  294:    if (to_poll[0].revents & POLLIN) {
    #####:  295:        char buf[1];
    #####:  296:        int res = ((conn*)c->c)->read(c->c, buf, 1);
    #####:  297:        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  298:            lru_crawler_close_client(c);
    #####:  299:            return -1;
        -:  300:        }
        -:  301:    }
        1:  302:    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        1:  303:        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
    #####:  304:            lru_crawler_close_client(c);
    #####:  305:            return -1;
        1:  306:        } else if (to_poll[0].revents & POLLOUT) {
        1:  307:            int total = ((conn*)c->c)->write(c->c, data, data_size);
        1:  308:            if (total == -1) {
    #####:  309:                if (errno != EAGAIN && errno != EWOULDBLOCK) {
    #####:  310:                    lru_crawler_close_client(c);
    #####:  311:                    return -1;
        -:  312:                }
        1:  313:            } else if (total == 0) {
    #####:  314:                lru_crawler_close_client(c);
    #####:  315:                return -1;
        -:  316:            } else {
        1:  317:                bipbuf_poll(c->buf, total);
        -:  318:            }
        -:  319:        }
        -:  320:    }
        -:  321:    return 0;
        -:  322:}
------------------
lru_crawler_poll:
        1:  278:static int lru_crawler_poll(crawler_client_t *c) {
        1:  279:    unsigned char *data;
        1:  280:    unsigned int data_size = 0;
        1:  281:    struct pollfd to_poll[1];
        1:  282:    to_poll[0].fd = c->sfd;
        1:  283:    to_poll[0].events = POLLOUT;
        -:  284:
        1:  285:    int ret = poll(to_poll, 1, 1000);
        -:  286:
        1:  287:    if (ret < 0) {
        -:  288:        // fatal.
        -:  289:        return -1;
        -:  290:    }
        -:  291:
        1:  292:    if (ret == 0) return 0;
        -:  293:
        1:  294:    if (to_poll[0].revents & POLLIN) {
    #####:  295:        char buf[1];
    #####:  296:        int res = ((conn*)c->c)->read(c->c, buf, 1);
    #####:  297:        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  298:            lru_crawler_close_client(c);
    #####:  299:            return -1;
        -:  300:        }
        -:  301:    }
        1:  302:    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        1:  303:        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
    #####:  304:            lru_crawler_close_client(c);
    #####:  305:            return -1;
        1:  306:        } else if (to_poll[0].revents & POLLOUT) {
        1:  307:            int total = ((conn*)c->c)->write(c->c, data, data_size);
        1:  308:            if (total == -1) {
    #####:  309:                if (errno != EAGAIN && errno != EWOULDBLOCK) {
    #####:  310:                    lru_crawler_close_client(c);
    #####:  311:                    return -1;
        -:  312:                }
        1:  313:            } else if (total == 0) {
    #####:  314:                lru_crawler_close_client(c);
    #####:  315:                return -1;
        -:  316:            } else {
        1:  317:                bipbuf_poll(c->buf, total);
        -:  318:            }
        -:  319:        }
        -:  320:    }
        -:  321:    return 0;
        -:  322:}
------------------
lru_crawler_poll:
        1:  278:static int lru_crawler_poll(crawler_client_t *c) {
        1:  279:    unsigned char *data;
        1:  280:    unsigned int data_size = 0;
        1:  281:    struct pollfd to_poll[1];
        1:  282:    to_poll[0].fd = c->sfd;
        1:  283:    to_poll[0].events = POLLOUT;
        -:  284:
        1:  285:    int ret = poll(to_poll, 1, 1000);
        -:  286:
        1:  287:    if (ret < 0) {
        -:  288:        // fatal.
        -:  289:        return -1;
        -:  290:    }
        -:  291:
        1:  292:    if (ret == 0) return 0;
        -:  293:
        1:  294:    if (to_poll[0].revents & POLLIN) {
    #####:  295:        char buf[1];
    #####:  296:        int res = ((conn*)c->c)->read(c->c, buf, 1);
    #####:  297:        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  298:            lru_crawler_close_client(c);
    #####:  299:            return -1;
        -:  300:        }
        -:  301:    }
        1:  302:    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        1:  303:        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
    #####:  304:            lru_crawler_close_client(c);
    #####:  305:            return -1;
        1:  306:        } else if (to_poll[0].revents & POLLOUT) {
        1:  307:            int total = ((conn*)c->c)->write(c->c, data, data_size);
        1:  308:            if (total == -1) {
    #####:  309:                if (errno != EAGAIN && errno != EWOULDBLOCK) {
    #####:  310:                    lru_crawler_close_client(c);
    #####:  311:                    return -1;
        -:  312:                }
        1:  313:            } else if (total == 0) {
    #####:  314:                lru_crawler_close_client(c);
    #####:  315:                return -1;
        -:  316:            } else {
        1:  317:                bipbuf_poll(c->buf, total);
        -:  318:            }
        -:  319:        }
        -:  320:    }
        -:  321:    return 0;
        -:  322:}
------------------
        -:  323:
        -:  324:/* Grab some space to work with, if none exists, run the poll() loop and wait
        -:  325: * for it to clear up or close.
        -:  326: * Return NULL if closed.
        -:  327: */
     1264:  328:static int lru_crawler_client_getbuf(crawler_client_t *c) {
     1264:  329:    void *buf = NULL;
     1264:  330:    if (c->c == NULL) return -1;
        -:  331:    /* not enough space. */
     1264:  332:    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        -:  333:        // TODO: max loops before closing.
    #####:  334:        int ret = lru_crawler_poll(c);
    #####:  335:        if (ret < 0) return ret;
        -:  336:    }
        -:  337:
     1264:  338:    c->cbuf = buf;
     1264:  339:    return 0;
        -:  340:}
------------------
lru_crawler_client_getbuf:
      316:  328:static int lru_crawler_client_getbuf(crawler_client_t *c) {
      316:  329:    void *buf = NULL;
      316:  330:    if (c->c == NULL) return -1;
        -:  331:    /* not enough space. */
      316:  332:    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        -:  333:        // TODO: max loops before closing.
    #####:  334:        int ret = lru_crawler_poll(c);
    #####:  335:        if (ret < 0) return ret;
        -:  336:    }
        -:  337:
      316:  338:    c->cbuf = buf;
      316:  339:    return 0;
        -:  340:}
------------------
lru_crawler_client_getbuf:
      316:  328:static int lru_crawler_client_getbuf(crawler_client_t *c) {
      316:  329:    void *buf = NULL;
      316:  330:    if (c->c == NULL) return -1;
        -:  331:    /* not enough space. */
      316:  332:    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        -:  333:        // TODO: max loops before closing.
    #####:  334:        int ret = lru_crawler_poll(c);
    #####:  335:        if (ret < 0) return ret;
        -:  336:    }
        -:  337:
      316:  338:    c->cbuf = buf;
      316:  339:    return 0;
        -:  340:}
------------------
lru_crawler_client_getbuf:
      316:  328:static int lru_crawler_client_getbuf(crawler_client_t *c) {
      316:  329:    void *buf = NULL;
      316:  330:    if (c->c == NULL) return -1;
        -:  331:    /* not enough space. */
      316:  332:    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        -:  333:        // TODO: max loops before closing.
    #####:  334:        int ret = lru_crawler_poll(c);
    #####:  335:        if (ret < 0) return ret;
        -:  336:    }
        -:  337:
      316:  338:    c->cbuf = buf;
      316:  339:    return 0;
        -:  340:}
------------------
lru_crawler_client_getbuf:
      316:  328:static int lru_crawler_client_getbuf(crawler_client_t *c) {
      316:  329:    void *buf = NULL;
      316:  330:    if (c->c == NULL) return -1;
        -:  331:    /* not enough space. */
      316:  332:    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        -:  333:        // TODO: max loops before closing.
    #####:  334:        int ret = lru_crawler_poll(c);
    #####:  335:        if (ret < 0) return ret;
        -:  336:    }
        -:  337:
      316:  338:    c->cbuf = buf;
      316:  339:    return 0;
        -:  340:}
------------------
        -:  341:
    90812:  342:static void lru_crawler_class_done(int i) {
    90812:  343:    crawlers[i].it_flags = 0;
    90812:  344:    crawler_count--;
    90812:  345:    do_item_unlinktail_q((item *)&crawlers[i]);
    90812:  346:    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
        -:  347:            crawlers[i].unfetched, crawlers[i].checked);
    90812:  348:    pthread_mutex_unlock(&lru_locks[i]);
    90812:  349:    if (active_crawler_mod.mod->doneclass != NULL)
    89792:  350:        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
    90812:  351:}
------------------
lru_crawler_class_done:
    22703:  342:static void lru_crawler_class_done(int i) {
    22703:  343:    crawlers[i].it_flags = 0;
    22703:  344:    crawler_count--;
    22703:  345:    do_item_unlinktail_q((item *)&crawlers[i]);
    22703:  346:    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
        -:  347:            crawlers[i].unfetched, crawlers[i].checked);
    22703:  348:    pthread_mutex_unlock(&lru_locks[i]);
    22703:  349:    if (active_crawler_mod.mod->doneclass != NULL)
    22448:  350:        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
    22703:  351:}
------------------
lru_crawler_class_done:
    22703:  342:static void lru_crawler_class_done(int i) {
    22703:  343:    crawlers[i].it_flags = 0;
    22703:  344:    crawler_count--;
    22703:  345:    do_item_unlinktail_q((item *)&crawlers[i]);
    22703:  346:    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
        -:  347:            crawlers[i].unfetched, crawlers[i].checked);
    22703:  348:    pthread_mutex_unlock(&lru_locks[i]);
    22703:  349:    if (active_crawler_mod.mod->doneclass != NULL)
    22448:  350:        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
    22703:  351:}
------------------
lru_crawler_class_done:
    22703:  342:static void lru_crawler_class_done(int i) {
    22703:  343:    crawlers[i].it_flags = 0;
    22703:  344:    crawler_count--;
    22703:  345:    do_item_unlinktail_q((item *)&crawlers[i]);
    22703:  346:    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
        -:  347:            crawlers[i].unfetched, crawlers[i].checked);
    22703:  348:    pthread_mutex_unlock(&lru_locks[i]);
    22703:  349:    if (active_crawler_mod.mod->doneclass != NULL)
    22448:  350:        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
    22703:  351:}
------------------
lru_crawler_class_done:
    22703:  342:static void lru_crawler_class_done(int i) {
    22703:  343:    crawlers[i].it_flags = 0;
    22703:  344:    crawler_count--;
    22703:  345:    do_item_unlinktail_q((item *)&crawlers[i]);
    22703:  346:    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
        -:  347:            crawlers[i].unfetched, crawlers[i].checked);
    22703:  348:    pthread_mutex_unlock(&lru_locks[i]);
    22703:  349:    if (active_crawler_mod.mod->doneclass != NULL)
    22448:  350:        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
    22703:  351:}
------------------
        -:  352:
      360:  353:static void *item_crawler_thread(void *arg) {
      360:  354:    int i;
      360:  355:    int crawls_persleep = settings.crawls_persleep;
        -:  356:
      360:  357:    pthread_mutex_lock(&lru_crawler_lock);
      360:  358:    pthread_cond_signal(&lru_crawler_cond);
      360:  359:    settings.lru_crawler = true;
      360:  360:    if (settings.verbose > 2)
    #####:  361:        fprintf(stderr, "Starting LRU crawler background thread\n");
      728:  362:    while (do_run_lru_crawler_thread) {
      724:  363:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
        -:  364:
     1808:  365:    while (crawler_count) {
        -:  366:        item *search = NULL;
        -:  367:        void *hold_lock = NULL;
        -:  368:
   277504:  369:        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
   276420:  370:            if (crawlers[i].it_flags != 1) {
        -:  371:                continue;
        -:  372:            }
        -:  373:
        -:  374:            /* Get memory from bipbuf, if client has no space, flush. */
    91532:  375:            if (active_crawler_mod.c.c != NULL) {
     1260:  376:                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
     1260:  377:                if (ret != 0) {
    #####:  378:                    lru_crawler_class_done(i);
    #####:  379:                    continue;
        -:  380:                }
    90272:  381:            } else if (active_crawler_mod.mod->needs_client) {
    #####:  382:                lru_crawler_class_done(i);
    #####:  383:                continue;
        -:  384:            }
    91532:  385:            pthread_mutex_lock(&lru_locks[i]);
    91532:  386:            search = do_item_crawl_q((item *)&crawlers[i]);
    91532:  387:            if (search == NULL ||
      720:  388:                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
    90812:  389:                if (settings.verbose > 2)
    #####:  390:                    fprintf(stderr, "Nothing left to crawl for %d\n", i);
    90812:  391:                lru_crawler_class_done(i);
    90812:  392:                continue;
        -:  393:            }
      720:  394:            uint32_t hv = hash(ITEM_key(search), search->nkey);
        -:  395:            /* Attempt to hash item lock the "search" item. If locked, no
        -:  396:             * other callers can incr the refcount
        -:  397:             */
      720:  398:            if ((hold_lock = item_trylock(hv)) == NULL) {
    #####:  399:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  400:                continue;
        -:  401:            }
        -:  402:            /* Now see if the item is refcount locked */
      720:  403:            if (refcount_incr(search) != 2) {
    #####:  404:                refcount_decr(search);
    #####:  405:                if (hold_lock)
    #####:  406:                    item_trylock_unlock(hold_lock);
    #####:  407:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  408:                continue;
        -:  409:            }
        -:  410:
      720:  411:            crawlers[i].checked++;
        -:  412:            /* Frees the item or decrements the refcount. */
        -:  413:            /* Interface for this could improve: do the free/decr here
        -:  414:             * instead? */
      720:  415:            if (!active_crawler_mod.mod->needs_lock) {
      240:  416:                pthread_mutex_unlock(&lru_locks[i]);
        -:  417:            }
        -:  418:
      720:  419:            active_crawler_mod.mod->eval(&active_crawler_mod, search, hv, i);
        -:  420:
      720:  421:            if (hold_lock)
      720:  422:                item_trylock_unlock(hold_lock);
      720:  423:            if (active_crawler_mod.mod->needs_lock) {
      480:  424:                pthread_mutex_unlock(&lru_locks[i]);
        -:  425:            }
        -:  426:
     720*:  427:            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
    #####:  428:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  429:                usleep(settings.lru_crawler_sleep);
    #####:  430:                pthread_mutex_lock(&lru_crawler_lock);
    #####:  431:                crawls_persleep = settings.crawls_persleep;
      720:  432:            } else if (!settings.lru_crawler_sleep) {
        -:  433:                // TODO: only cycle lock every N?
    #####:  434:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  435:                pthread_mutex_lock(&lru_crawler_lock);
        -:  436:            }
        -:  437:        }
        -:  438:    }
        -:  439:
      368:  440:    if (active_crawler_mod.mod != NULL) {
      364:  441:        if (active_crawler_mod.mod->finalize != NULL)
      364:  442:            active_crawler_mod.mod->finalize(&active_crawler_mod);
      368:  443:        while (active_crawler_mod.c.c != NULL && bipbuf_used(active_crawler_mod.c.buf)) {
        4:  444:            lru_crawler_poll(&active_crawler_mod.c);
        -:  445:        }
        -:  446:        // Double checking in case the client closed during the poll
      364:  447:        if (active_crawler_mod.c.c != NULL) {
        4:  448:            lru_crawler_release_client(&active_crawler_mod.c);
        -:  449:        }
      364:  450:        active_crawler_mod.mod = NULL;
        -:  451:    }
        -:  452:
      368:  453:    if (settings.verbose > 2)
    #####:  454:        fprintf(stderr, "LRU crawler thread sleeping\n");
        -:  455:
      368:  456:    STATS_LOCK();
      368:  457:    stats_state.lru_crawler_running = false;
      368:  458:    STATS_UNLOCK();
        -:  459:    }
        4:  460:    pthread_mutex_unlock(&lru_crawler_lock);
        4:  461:    if (settings.verbose > 2)
    #####:  462:        fprintf(stderr, "LRU crawler thread stopping\n");
        -:  463:
        4:  464:    return NULL;
        -:  465:}
------------------
item_crawler_thread:
       90:  353:static void *item_crawler_thread(void *arg) {
       90:  354:    int i;
       90:  355:    int crawls_persleep = settings.crawls_persleep;
        -:  356:
       90:  357:    pthread_mutex_lock(&lru_crawler_lock);
       90:  358:    pthread_cond_signal(&lru_crawler_cond);
       90:  359:    settings.lru_crawler = true;
       90:  360:    if (settings.verbose > 2)
    #####:  361:        fprintf(stderr, "Starting LRU crawler background thread\n");
      182:  362:    while (do_run_lru_crawler_thread) {
      181:  363:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
        -:  364:
      452:  365:    while (crawler_count) {
        -:  366:        item *search = NULL;
        -:  367:        void *hold_lock = NULL;
        -:  368:
    69376:  369:        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
    69105:  370:            if (crawlers[i].it_flags != 1) {
        -:  371:                continue;
        -:  372:            }
        -:  373:
        -:  374:            /* Get memory from bipbuf, if client has no space, flush. */
    22883:  375:            if (active_crawler_mod.c.c != NULL) {
      315:  376:                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
      315:  377:                if (ret != 0) {
    #####:  378:                    lru_crawler_class_done(i);
    #####:  379:                    continue;
        -:  380:                }
    22568:  381:            } else if (active_crawler_mod.mod->needs_client) {
    #####:  382:                lru_crawler_class_done(i);
    #####:  383:                continue;
        -:  384:            }
    22883:  385:            pthread_mutex_lock(&lru_locks[i]);
    22883:  386:            search = do_item_crawl_q((item *)&crawlers[i]);
    22883:  387:            if (search == NULL ||
      180:  388:                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
    22703:  389:                if (settings.verbose > 2)
    #####:  390:                    fprintf(stderr, "Nothing left to crawl for %d\n", i);
    22703:  391:                lru_crawler_class_done(i);
    22703:  392:                continue;
        -:  393:            }
      180:  394:            uint32_t hv = hash(ITEM_key(search), search->nkey);
        -:  395:            /* Attempt to hash item lock the "search" item. If locked, no
        -:  396:             * other callers can incr the refcount
        -:  397:             */
      180:  398:            if ((hold_lock = item_trylock(hv)) == NULL) {
    #####:  399:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  400:                continue;
        -:  401:            }
        -:  402:            /* Now see if the item is refcount locked */
      180:  403:            if (refcount_incr(search) != 2) {
    #####:  404:                refcount_decr(search);
    #####:  405:                if (hold_lock)
    #####:  406:                    item_trylock_unlock(hold_lock);
    #####:  407:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  408:                continue;
        -:  409:            }
        -:  410:
      180:  411:            crawlers[i].checked++;
        -:  412:            /* Frees the item or decrements the refcount. */
        -:  413:            /* Interface for this could improve: do the free/decr here
        -:  414:             * instead? */
      180:  415:            if (!active_crawler_mod.mod->needs_lock) {
       60:  416:                pthread_mutex_unlock(&lru_locks[i]);
        -:  417:            }
        -:  418:
      180:  419:            active_crawler_mod.mod->eval(&active_crawler_mod, search, hv, i);
        -:  420:
      180:  421:            if (hold_lock)
      180:  422:                item_trylock_unlock(hold_lock);
      180:  423:            if (active_crawler_mod.mod->needs_lock) {
      120:  424:                pthread_mutex_unlock(&lru_locks[i]);
        -:  425:            }
        -:  426:
     180*:  427:            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
    #####:  428:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  429:                usleep(settings.lru_crawler_sleep);
    #####:  430:                pthread_mutex_lock(&lru_crawler_lock);
    #####:  431:                crawls_persleep = settings.crawls_persleep;
      180:  432:            } else if (!settings.lru_crawler_sleep) {
        -:  433:                // TODO: only cycle lock every N?
    #####:  434:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  435:                pthread_mutex_lock(&lru_crawler_lock);
        -:  436:            }
        -:  437:        }
        -:  438:    }
        -:  439:
       92:  440:    if (active_crawler_mod.mod != NULL) {
       91:  441:        if (active_crawler_mod.mod->finalize != NULL)
       91:  442:            active_crawler_mod.mod->finalize(&active_crawler_mod);
       92:  443:        while (active_crawler_mod.c.c != NULL && bipbuf_used(active_crawler_mod.c.buf)) {
        1:  444:            lru_crawler_poll(&active_crawler_mod.c);
        -:  445:        }
        -:  446:        // Double checking in case the client closed during the poll
       91:  447:        if (active_crawler_mod.c.c != NULL) {
        1:  448:            lru_crawler_release_client(&active_crawler_mod.c);
        -:  449:        }
       91:  450:        active_crawler_mod.mod = NULL;
        -:  451:    }
        -:  452:
       92:  453:    if (settings.verbose > 2)
    #####:  454:        fprintf(stderr, "LRU crawler thread sleeping\n");
        -:  455:
       92:  456:    STATS_LOCK();
       92:  457:    stats_state.lru_crawler_running = false;
       92:  458:    STATS_UNLOCK();
        -:  459:    }
        1:  460:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  461:    if (settings.verbose > 2)
    #####:  462:        fprintf(stderr, "LRU crawler thread stopping\n");
        -:  463:
        1:  464:    return NULL;
        -:  465:}
------------------
item_crawler_thread:
       90:  353:static void *item_crawler_thread(void *arg) {
       90:  354:    int i;
       90:  355:    int crawls_persleep = settings.crawls_persleep;
        -:  356:
       90:  357:    pthread_mutex_lock(&lru_crawler_lock);
       90:  358:    pthread_cond_signal(&lru_crawler_cond);
       90:  359:    settings.lru_crawler = true;
       90:  360:    if (settings.verbose > 2)
    #####:  361:        fprintf(stderr, "Starting LRU crawler background thread\n");
      182:  362:    while (do_run_lru_crawler_thread) {
      181:  363:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
        -:  364:
      452:  365:    while (crawler_count) {
        -:  366:        item *search = NULL;
        -:  367:        void *hold_lock = NULL;
        -:  368:
    69376:  369:        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
    69105:  370:            if (crawlers[i].it_flags != 1) {
        -:  371:                continue;
        -:  372:            }
        -:  373:
        -:  374:            /* Get memory from bipbuf, if client has no space, flush. */
    22883:  375:            if (active_crawler_mod.c.c != NULL) {
      315:  376:                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
      315:  377:                if (ret != 0) {
    #####:  378:                    lru_crawler_class_done(i);
    #####:  379:                    continue;
        -:  380:                }
    22568:  381:            } else if (active_crawler_mod.mod->needs_client) {
    #####:  382:                lru_crawler_class_done(i);
    #####:  383:                continue;
        -:  384:            }
    22883:  385:            pthread_mutex_lock(&lru_locks[i]);
    22883:  386:            search = do_item_crawl_q((item *)&crawlers[i]);
    22883:  387:            if (search == NULL ||
      180:  388:                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
    22703:  389:                if (settings.verbose > 2)
    #####:  390:                    fprintf(stderr, "Nothing left to crawl for %d\n", i);
    22703:  391:                lru_crawler_class_done(i);
    22703:  392:                continue;
        -:  393:            }
      180:  394:            uint32_t hv = hash(ITEM_key(search), search->nkey);
        -:  395:            /* Attempt to hash item lock the "search" item. If locked, no
        -:  396:             * other callers can incr the refcount
        -:  397:             */
      180:  398:            if ((hold_lock = item_trylock(hv)) == NULL) {
    #####:  399:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  400:                continue;
        -:  401:            }
        -:  402:            /* Now see if the item is refcount locked */
      180:  403:            if (refcount_incr(search) != 2) {
    #####:  404:                refcount_decr(search);
    #####:  405:                if (hold_lock)
    #####:  406:                    item_trylock_unlock(hold_lock);
    #####:  407:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  408:                continue;
        -:  409:            }
        -:  410:
      180:  411:            crawlers[i].checked++;
        -:  412:            /* Frees the item or decrements the refcount. */
        -:  413:            /* Interface for this could improve: do the free/decr here
        -:  414:             * instead? */
      180:  415:            if (!active_crawler_mod.mod->needs_lock) {
       60:  416:                pthread_mutex_unlock(&lru_locks[i]);
        -:  417:            }
        -:  418:
      180:  419:            active_crawler_mod.mod->eval(&active_crawler_mod, search, hv, i);
        -:  420:
      180:  421:            if (hold_lock)
      180:  422:                item_trylock_unlock(hold_lock);
      180:  423:            if (active_crawler_mod.mod->needs_lock) {
      120:  424:                pthread_mutex_unlock(&lru_locks[i]);
        -:  425:            }
        -:  426:
     180*:  427:            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
    #####:  428:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  429:                usleep(settings.lru_crawler_sleep);
    #####:  430:                pthread_mutex_lock(&lru_crawler_lock);
    #####:  431:                crawls_persleep = settings.crawls_persleep;
      180:  432:            } else if (!settings.lru_crawler_sleep) {
        -:  433:                // TODO: only cycle lock every N?
    #####:  434:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  435:                pthread_mutex_lock(&lru_crawler_lock);
        -:  436:            }
        -:  437:        }
        -:  438:    }
        -:  439:
       92:  440:    if (active_crawler_mod.mod != NULL) {
       91:  441:        if (active_crawler_mod.mod->finalize != NULL)
       91:  442:            active_crawler_mod.mod->finalize(&active_crawler_mod);
       92:  443:        while (active_crawler_mod.c.c != NULL && bipbuf_used(active_crawler_mod.c.buf)) {
        1:  444:            lru_crawler_poll(&active_crawler_mod.c);
        -:  445:        }
        -:  446:        // Double checking in case the client closed during the poll
       91:  447:        if (active_crawler_mod.c.c != NULL) {
        1:  448:            lru_crawler_release_client(&active_crawler_mod.c);
        -:  449:        }
       91:  450:        active_crawler_mod.mod = NULL;
        -:  451:    }
        -:  452:
       92:  453:    if (settings.verbose > 2)
    #####:  454:        fprintf(stderr, "LRU crawler thread sleeping\n");
        -:  455:
       92:  456:    STATS_LOCK();
       92:  457:    stats_state.lru_crawler_running = false;
       92:  458:    STATS_UNLOCK();
        -:  459:    }
        1:  460:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  461:    if (settings.verbose > 2)
    #####:  462:        fprintf(stderr, "LRU crawler thread stopping\n");
        -:  463:
        1:  464:    return NULL;
        -:  465:}
------------------
item_crawler_thread:
       90:  353:static void *item_crawler_thread(void *arg) {
       90:  354:    int i;
       90:  355:    int crawls_persleep = settings.crawls_persleep;
        -:  356:
       90:  357:    pthread_mutex_lock(&lru_crawler_lock);
       90:  358:    pthread_cond_signal(&lru_crawler_cond);
       90:  359:    settings.lru_crawler = true;
       90:  360:    if (settings.verbose > 2)
    #####:  361:        fprintf(stderr, "Starting LRU crawler background thread\n");
      182:  362:    while (do_run_lru_crawler_thread) {
      181:  363:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
        -:  364:
      452:  365:    while (crawler_count) {
        -:  366:        item *search = NULL;
        -:  367:        void *hold_lock = NULL;
        -:  368:
    69376:  369:        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
    69105:  370:            if (crawlers[i].it_flags != 1) {
        -:  371:                continue;
        -:  372:            }
        -:  373:
        -:  374:            /* Get memory from bipbuf, if client has no space, flush. */
    22883:  375:            if (active_crawler_mod.c.c != NULL) {
      315:  376:                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
      315:  377:                if (ret != 0) {
    #####:  378:                    lru_crawler_class_done(i);
    #####:  379:                    continue;
        -:  380:                }
    22568:  381:            } else if (active_crawler_mod.mod->needs_client) {
    #####:  382:                lru_crawler_class_done(i);
    #####:  383:                continue;
        -:  384:            }
    22883:  385:            pthread_mutex_lock(&lru_locks[i]);
    22883:  386:            search = do_item_crawl_q((item *)&crawlers[i]);
    22883:  387:            if (search == NULL ||
      180:  388:                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
    22703:  389:                if (settings.verbose > 2)
    #####:  390:                    fprintf(stderr, "Nothing left to crawl for %d\n", i);
    22703:  391:                lru_crawler_class_done(i);
    22703:  392:                continue;
        -:  393:            }
      180:  394:            uint32_t hv = hash(ITEM_key(search), search->nkey);
        -:  395:            /* Attempt to hash item lock the "search" item. If locked, no
        -:  396:             * other callers can incr the refcount
        -:  397:             */
      180:  398:            if ((hold_lock = item_trylock(hv)) == NULL) {
    #####:  399:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  400:                continue;
        -:  401:            }
        -:  402:            /* Now see if the item is refcount locked */
      180:  403:            if (refcount_incr(search) != 2) {
    #####:  404:                refcount_decr(search);
    #####:  405:                if (hold_lock)
    #####:  406:                    item_trylock_unlock(hold_lock);
    #####:  407:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  408:                continue;
        -:  409:            }
        -:  410:
      180:  411:            crawlers[i].checked++;
        -:  412:            /* Frees the item or decrements the refcount. */
        -:  413:            /* Interface for this could improve: do the free/decr here
        -:  414:             * instead? */
      180:  415:            if (!active_crawler_mod.mod->needs_lock) {
       60:  416:                pthread_mutex_unlock(&lru_locks[i]);
        -:  417:            }
        -:  418:
      180:  419:            active_crawler_mod.mod->eval(&active_crawler_mod, search, hv, i);
        -:  420:
      180:  421:            if (hold_lock)
      180:  422:                item_trylock_unlock(hold_lock);
      180:  423:            if (active_crawler_mod.mod->needs_lock) {
      120:  424:                pthread_mutex_unlock(&lru_locks[i]);
        -:  425:            }
        -:  426:
     180*:  427:            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
    #####:  428:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  429:                usleep(settings.lru_crawler_sleep);
    #####:  430:                pthread_mutex_lock(&lru_crawler_lock);
    #####:  431:                crawls_persleep = settings.crawls_persleep;
      180:  432:            } else if (!settings.lru_crawler_sleep) {
        -:  433:                // TODO: only cycle lock every N?
    #####:  434:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  435:                pthread_mutex_lock(&lru_crawler_lock);
        -:  436:            }
        -:  437:        }
        -:  438:    }
        -:  439:
       92:  440:    if (active_crawler_mod.mod != NULL) {
       91:  441:        if (active_crawler_mod.mod->finalize != NULL)
       91:  442:            active_crawler_mod.mod->finalize(&active_crawler_mod);
       92:  443:        while (active_crawler_mod.c.c != NULL && bipbuf_used(active_crawler_mod.c.buf)) {
        1:  444:            lru_crawler_poll(&active_crawler_mod.c);
        -:  445:        }
        -:  446:        // Double checking in case the client closed during the poll
       91:  447:        if (active_crawler_mod.c.c != NULL) {
        1:  448:            lru_crawler_release_client(&active_crawler_mod.c);
        -:  449:        }
       91:  450:        active_crawler_mod.mod = NULL;
        -:  451:    }
        -:  452:
       92:  453:    if (settings.verbose > 2)
    #####:  454:        fprintf(stderr, "LRU crawler thread sleeping\n");
        -:  455:
       92:  456:    STATS_LOCK();
       92:  457:    stats_state.lru_crawler_running = false;
       92:  458:    STATS_UNLOCK();
        -:  459:    }
        1:  460:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  461:    if (settings.verbose > 2)
    #####:  462:        fprintf(stderr, "LRU crawler thread stopping\n");
        -:  463:
        1:  464:    return NULL;
        -:  465:}
------------------
item_crawler_thread:
       90:  353:static void *item_crawler_thread(void *arg) {
       90:  354:    int i;
       90:  355:    int crawls_persleep = settings.crawls_persleep;
        -:  356:
       90:  357:    pthread_mutex_lock(&lru_crawler_lock);
       90:  358:    pthread_cond_signal(&lru_crawler_cond);
       90:  359:    settings.lru_crawler = true;
       90:  360:    if (settings.verbose > 2)
    #####:  361:        fprintf(stderr, "Starting LRU crawler background thread\n");
      182:  362:    while (do_run_lru_crawler_thread) {
      181:  363:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
        -:  364:
      452:  365:    while (crawler_count) {
        -:  366:        item *search = NULL;
        -:  367:        void *hold_lock = NULL;
        -:  368:
    69376:  369:        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
    69105:  370:            if (crawlers[i].it_flags != 1) {
        -:  371:                continue;
        -:  372:            }
        -:  373:
        -:  374:            /* Get memory from bipbuf, if client has no space, flush. */
    22883:  375:            if (active_crawler_mod.c.c != NULL) {
      315:  376:                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
      315:  377:                if (ret != 0) {
    #####:  378:                    lru_crawler_class_done(i);
    #####:  379:                    continue;
        -:  380:                }
    22568:  381:            } else if (active_crawler_mod.mod->needs_client) {
    #####:  382:                lru_crawler_class_done(i);
    #####:  383:                continue;
        -:  384:            }
    22883:  385:            pthread_mutex_lock(&lru_locks[i]);
    22883:  386:            search = do_item_crawl_q((item *)&crawlers[i]);
    22883:  387:            if (search == NULL ||
      180:  388:                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
    22703:  389:                if (settings.verbose > 2)
    #####:  390:                    fprintf(stderr, "Nothing left to crawl for %d\n", i);
    22703:  391:                lru_crawler_class_done(i);
    22703:  392:                continue;
        -:  393:            }
      180:  394:            uint32_t hv = hash(ITEM_key(search), search->nkey);
        -:  395:            /* Attempt to hash item lock the "search" item. If locked, no
        -:  396:             * other callers can incr the refcount
        -:  397:             */
      180:  398:            if ((hold_lock = item_trylock(hv)) == NULL) {
    #####:  399:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  400:                continue;
        -:  401:            }
        -:  402:            /* Now see if the item is refcount locked */
      180:  403:            if (refcount_incr(search) != 2) {
    #####:  404:                refcount_decr(search);
    #####:  405:                if (hold_lock)
    #####:  406:                    item_trylock_unlock(hold_lock);
    #####:  407:                pthread_mutex_unlock(&lru_locks[i]);
    #####:  408:                continue;
        -:  409:            }
        -:  410:
      180:  411:            crawlers[i].checked++;
        -:  412:            /* Frees the item or decrements the refcount. */
        -:  413:            /* Interface for this could improve: do the free/decr here
        -:  414:             * instead? */
      180:  415:            if (!active_crawler_mod.mod->needs_lock) {
       60:  416:                pthread_mutex_unlock(&lru_locks[i]);
        -:  417:            }
        -:  418:
      180:  419:            active_crawler_mod.mod->eval(&active_crawler_mod, search, hv, i);
        -:  420:
      180:  421:            if (hold_lock)
      180:  422:                item_trylock_unlock(hold_lock);
      180:  423:            if (active_crawler_mod.mod->needs_lock) {
      120:  424:                pthread_mutex_unlock(&lru_locks[i]);
        -:  425:            }
        -:  426:
     180*:  427:            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
    #####:  428:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  429:                usleep(settings.lru_crawler_sleep);
    #####:  430:                pthread_mutex_lock(&lru_crawler_lock);
    #####:  431:                crawls_persleep = settings.crawls_persleep;
      180:  432:            } else if (!settings.lru_crawler_sleep) {
        -:  433:                // TODO: only cycle lock every N?
    #####:  434:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  435:                pthread_mutex_lock(&lru_crawler_lock);
        -:  436:            }
        -:  437:        }
        -:  438:    }
        -:  439:
       92:  440:    if (active_crawler_mod.mod != NULL) {
       91:  441:        if (active_crawler_mod.mod->finalize != NULL)
       91:  442:            active_crawler_mod.mod->finalize(&active_crawler_mod);
       92:  443:        while (active_crawler_mod.c.c != NULL && bipbuf_used(active_crawler_mod.c.buf)) {
        1:  444:            lru_crawler_poll(&active_crawler_mod.c);
        -:  445:        }
        -:  446:        // Double checking in case the client closed during the poll
       91:  447:        if (active_crawler_mod.c.c != NULL) {
        1:  448:            lru_crawler_release_client(&active_crawler_mod.c);
        -:  449:        }
       91:  450:        active_crawler_mod.mod = NULL;
        -:  451:    }
        -:  452:
       92:  453:    if (settings.verbose > 2)
    #####:  454:        fprintf(stderr, "LRU crawler thread sleeping\n");
        -:  455:
       92:  456:    STATS_LOCK();
       92:  457:    stats_state.lru_crawler_running = false;
       92:  458:    STATS_UNLOCK();
        -:  459:    }
        1:  460:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  461:    if (settings.verbose > 2)
    #####:  462:        fprintf(stderr, "LRU crawler thread stopping\n");
        -:  463:
        1:  464:    return NULL;
        -:  465:}
------------------
        -:  466:
        -:  467:static pthread_t item_crawler_tid;
        -:  468:
        4:  469:int stop_item_crawler_thread(void) {
        4:  470:    int ret;
        4:  471:    pthread_mutex_lock(&lru_crawler_lock);
        4:  472:    do_run_lru_crawler_thread = 0;
        4:  473:    pthread_cond_signal(&lru_crawler_cond);
        4:  474:    pthread_mutex_unlock(&lru_crawler_lock);
        4:  475:    if ((ret = pthread_join(item_crawler_tid, NULL)) != 0) {
    #####:  476:        fprintf(stderr, "Failed to stop LRU crawler thread: %s\n", strerror(ret));
    #####:  477:        return -1;
        -:  478:    }
        4:  479:    settings.lru_crawler = false;
        4:  480:    return 0;
        -:  481:}
------------------
stop_item_crawler_thread:
        1:  469:int stop_item_crawler_thread(void) {
        1:  470:    int ret;
        1:  471:    pthread_mutex_lock(&lru_crawler_lock);
        1:  472:    do_run_lru_crawler_thread = 0;
        1:  473:    pthread_cond_signal(&lru_crawler_cond);
        1:  474:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  475:    if ((ret = pthread_join(item_crawler_tid, NULL)) != 0) {
    #####:  476:        fprintf(stderr, "Failed to stop LRU crawler thread: %s\n", strerror(ret));
    #####:  477:        return -1;
        -:  478:    }
        1:  479:    settings.lru_crawler = false;
        1:  480:    return 0;
        -:  481:}
------------------
stop_item_crawler_thread:
        1:  469:int stop_item_crawler_thread(void) {
        1:  470:    int ret;
        1:  471:    pthread_mutex_lock(&lru_crawler_lock);
        1:  472:    do_run_lru_crawler_thread = 0;
        1:  473:    pthread_cond_signal(&lru_crawler_cond);
        1:  474:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  475:    if ((ret = pthread_join(item_crawler_tid, NULL)) != 0) {
    #####:  476:        fprintf(stderr, "Failed to stop LRU crawler thread: %s\n", strerror(ret));
    #####:  477:        return -1;
        -:  478:    }
        1:  479:    settings.lru_crawler = false;
        1:  480:    return 0;
        -:  481:}
------------------
stop_item_crawler_thread:
        1:  469:int stop_item_crawler_thread(void) {
        1:  470:    int ret;
        1:  471:    pthread_mutex_lock(&lru_crawler_lock);
        1:  472:    do_run_lru_crawler_thread = 0;
        1:  473:    pthread_cond_signal(&lru_crawler_cond);
        1:  474:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  475:    if ((ret = pthread_join(item_crawler_tid, NULL)) != 0) {
    #####:  476:        fprintf(stderr, "Failed to stop LRU crawler thread: %s\n", strerror(ret));
    #####:  477:        return -1;
        -:  478:    }
        1:  479:    settings.lru_crawler = false;
        1:  480:    return 0;
        -:  481:}
------------------
stop_item_crawler_thread:
        1:  469:int stop_item_crawler_thread(void) {
        1:  470:    int ret;
        1:  471:    pthread_mutex_lock(&lru_crawler_lock);
        1:  472:    do_run_lru_crawler_thread = 0;
        1:  473:    pthread_cond_signal(&lru_crawler_cond);
        1:  474:    pthread_mutex_unlock(&lru_crawler_lock);
        1:  475:    if ((ret = pthread_join(item_crawler_tid, NULL)) != 0) {
    #####:  476:        fprintf(stderr, "Failed to stop LRU crawler thread: %s\n", strerror(ret));
    #####:  477:        return -1;
        -:  478:    }
        1:  479:    settings.lru_crawler = false;
        1:  480:    return 0;
        -:  481:}
------------------
        -:  482:
        -:  483:/* Lock dance to "block" until thread is waiting on its condition:
        -:  484: * caller locks mtx. caller spawns thread.
        -:  485: * thread blocks on mutex.
        -:  486: * caller waits on condition, releases lock.
        -:  487: * thread gets lock, sends signal.
        -:  488: * caller can't wait, as thread has lock.
        -:  489: * thread waits on condition, releases lock
        -:  490: * caller wakes on condition, gets lock.
        -:  491: * caller immediately releases lock.
        -:  492: * thread is now safely waiting on condition before the caller returns.
        -:  493: */
      360:  494:int start_item_crawler_thread(void) {
      360:  495:    int ret;
        -:  496:
      360:  497:    if (settings.lru_crawler)
        -:  498:        return -1;
      360:  499:    pthread_mutex_lock(&lru_crawler_lock);
      360:  500:    do_run_lru_crawler_thread = 1;
      360:  501:    if ((ret = pthread_create(&item_crawler_tid, NULL,
        -:  502:        item_crawler_thread, NULL)) != 0) {
    #####:  503:        fprintf(stderr, "Can't create LRU crawler thread: %s\n",
        -:  504:            strerror(ret));
    #####:  505:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  506:        return -1;
        -:  507:    }
        -:  508:    /* Avoid returning until the crawler has actually started */
      360:  509:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
      360:  510:    pthread_mutex_unlock(&lru_crawler_lock);
        -:  511:
      360:  512:    return 0;
        -:  513:}
------------------
start_item_crawler_thread:
       90:  494:int start_item_crawler_thread(void) {
       90:  495:    int ret;
        -:  496:
       90:  497:    if (settings.lru_crawler)
        -:  498:        return -1;
       90:  499:    pthread_mutex_lock(&lru_crawler_lock);
       90:  500:    do_run_lru_crawler_thread = 1;
       90:  501:    if ((ret = pthread_create(&item_crawler_tid, NULL,
        -:  502:        item_crawler_thread, NULL)) != 0) {
    #####:  503:        fprintf(stderr, "Can't create LRU crawler thread: %s\n",
        -:  504:            strerror(ret));
    #####:  505:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  506:        return -1;
        -:  507:    }
        -:  508:    /* Avoid returning until the crawler has actually started */
       90:  509:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
       90:  510:    pthread_mutex_unlock(&lru_crawler_lock);
        -:  511:
       90:  512:    return 0;
        -:  513:}
------------------
start_item_crawler_thread:
       90:  494:int start_item_crawler_thread(void) {
       90:  495:    int ret;
        -:  496:
       90:  497:    if (settings.lru_crawler)
        -:  498:        return -1;
       90:  499:    pthread_mutex_lock(&lru_crawler_lock);
       90:  500:    do_run_lru_crawler_thread = 1;
       90:  501:    if ((ret = pthread_create(&item_crawler_tid, NULL,
        -:  502:        item_crawler_thread, NULL)) != 0) {
    #####:  503:        fprintf(stderr, "Can't create LRU crawler thread: %s\n",
        -:  504:            strerror(ret));
    #####:  505:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  506:        return -1;
        -:  507:    }
        -:  508:    /* Avoid returning until the crawler has actually started */
       90:  509:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
       90:  510:    pthread_mutex_unlock(&lru_crawler_lock);
        -:  511:
       90:  512:    return 0;
        -:  513:}
------------------
start_item_crawler_thread:
       90:  494:int start_item_crawler_thread(void) {
       90:  495:    int ret;
        -:  496:
       90:  497:    if (settings.lru_crawler)
        -:  498:        return -1;
       90:  499:    pthread_mutex_lock(&lru_crawler_lock);
       90:  500:    do_run_lru_crawler_thread = 1;
       90:  501:    if ((ret = pthread_create(&item_crawler_tid, NULL,
        -:  502:        item_crawler_thread, NULL)) != 0) {
    #####:  503:        fprintf(stderr, "Can't create LRU crawler thread: %s\n",
        -:  504:            strerror(ret));
    #####:  505:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  506:        return -1;
        -:  507:    }
        -:  508:    /* Avoid returning until the crawler has actually started */
       90:  509:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
       90:  510:    pthread_mutex_unlock(&lru_crawler_lock);
        -:  511:
       90:  512:    return 0;
        -:  513:}
------------------
start_item_crawler_thread:
       90:  494:int start_item_crawler_thread(void) {
       90:  495:    int ret;
        -:  496:
       90:  497:    if (settings.lru_crawler)
        -:  498:        return -1;
       90:  499:    pthread_mutex_lock(&lru_crawler_lock);
       90:  500:    do_run_lru_crawler_thread = 1;
       90:  501:    if ((ret = pthread_create(&item_crawler_tid, NULL,
        -:  502:        item_crawler_thread, NULL)) != 0) {
    #####:  503:        fprintf(stderr, "Can't create LRU crawler thread: %s\n",
        -:  504:            strerror(ret));
    #####:  505:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  506:        return -1;
        -:  507:    }
        -:  508:    /* Avoid returning until the crawler has actually started */
       90:  509:    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
       90:  510:    pthread_mutex_unlock(&lru_crawler_lock);
        -:  511:
       90:  512:    return 0;
        -:  513:}
------------------
        -:  514:
        -:  515:/* 'remaining' is passed in so the LRU maintainer thread can scrub the whole
        -:  516: * LRU every time.
        -:  517: */
    90812:  518:static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    90812:  519:    uint32_t sid = id;
    90812:  520:    int starts = 0;
        -:  521:
    90812:  522:    pthread_mutex_lock(&lru_locks[sid]);
    90812:  523:    if (crawlers[sid].it_flags == 0) {
    90812:  524:        if (settings.verbose > 2)
    #####:  525:            fprintf(stderr, "Kicking LRU crawler off for LRU %u\n", sid);
    90812:  526:        crawlers[sid].nbytes = 0;
    90812:  527:        crawlers[sid].nkey = 0;
    90812:  528:        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
    90812:  529:        crawlers[sid].next = 0;
    90812:  530:        crawlers[sid].prev = 0;
    90812:  531:        crawlers[sid].time = 0;
    90812:  532:        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
     1020:  533:            remaining = do_get_lru_size(sid);
        -:  534:        }
        -:  535:        /* Values for remaining:
        -:  536:         * remaining = 0
        -:  537:         * - scan all elements, until a NULL is reached
        -:  538:         * - if empty, NULL is reached right away
        -:  539:         * remaining = n + 1
        -:  540:         * - first n elements are parsed (or until a NULL is reached)
        -:  541:         */
    90812:  542:        if (remaining) remaining++;
    90812:  543:        crawlers[sid].remaining = remaining;
    90812:  544:        crawlers[sid].slabs_clsid = sid;
    90812:  545:        crawlers[sid].reclaimed = 0;
    90812:  546:        crawlers[sid].unfetched = 0;
    90812:  547:        crawlers[sid].checked = 0;
    90812:  548:        do_item_linktail_q((item *)&crawlers[sid]);
    90812:  549:        crawler_count++;
    90812:  550:        starts++;
        -:  551:    }
    90812:  552:    pthread_mutex_unlock(&lru_locks[sid]);
    90812:  553:    if (starts) {
    90812:  554:        STATS_LOCK();
    90812:  555:        stats_state.lru_crawler_running = true;
    90812:  556:        stats.lru_crawler_starts++;
    90812:  557:        STATS_UNLOCK();
        -:  558:    }
    90812:  559:    return starts;
        -:  560:}
------------------
do_lru_crawler_start:
    22703:  518:static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    22703:  519:    uint32_t sid = id;
    22703:  520:    int starts = 0;
        -:  521:
    22703:  522:    pthread_mutex_lock(&lru_locks[sid]);
    22703:  523:    if (crawlers[sid].it_flags == 0) {
    22703:  524:        if (settings.verbose > 2)
    #####:  525:            fprintf(stderr, "Kicking LRU crawler off for LRU %u\n", sid);
    22703:  526:        crawlers[sid].nbytes = 0;
    22703:  527:        crawlers[sid].nkey = 0;
    22703:  528:        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
    22703:  529:        crawlers[sid].next = 0;
    22703:  530:        crawlers[sid].prev = 0;
    22703:  531:        crawlers[sid].time = 0;
    22703:  532:        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
      255:  533:            remaining = do_get_lru_size(sid);
        -:  534:        }
        -:  535:        /* Values for remaining:
        -:  536:         * remaining = 0
        -:  537:         * - scan all elements, until a NULL is reached
        -:  538:         * - if empty, NULL is reached right away
        -:  539:         * remaining = n + 1
        -:  540:         * - first n elements are parsed (or until a NULL is reached)
        -:  541:         */
    22703:  542:        if (remaining) remaining++;
    22703:  543:        crawlers[sid].remaining = remaining;
    22703:  544:        crawlers[sid].slabs_clsid = sid;
    22703:  545:        crawlers[sid].reclaimed = 0;
    22703:  546:        crawlers[sid].unfetched = 0;
    22703:  547:        crawlers[sid].checked = 0;
    22703:  548:        do_item_linktail_q((item *)&crawlers[sid]);
    22703:  549:        crawler_count++;
    22703:  550:        starts++;
        -:  551:    }
    22703:  552:    pthread_mutex_unlock(&lru_locks[sid]);
    22703:  553:    if (starts) {
    22703:  554:        STATS_LOCK();
    22703:  555:        stats_state.lru_crawler_running = true;
    22703:  556:        stats.lru_crawler_starts++;
    22703:  557:        STATS_UNLOCK();
        -:  558:    }
    22703:  559:    return starts;
        -:  560:}
------------------
do_lru_crawler_start:
    22703:  518:static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    22703:  519:    uint32_t sid = id;
    22703:  520:    int starts = 0;
        -:  521:
    22703:  522:    pthread_mutex_lock(&lru_locks[sid]);
    22703:  523:    if (crawlers[sid].it_flags == 0) {
    22703:  524:        if (settings.verbose > 2)
    #####:  525:            fprintf(stderr, "Kicking LRU crawler off for LRU %u\n", sid);
    22703:  526:        crawlers[sid].nbytes = 0;
    22703:  527:        crawlers[sid].nkey = 0;
    22703:  528:        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
    22703:  529:        crawlers[sid].next = 0;
    22703:  530:        crawlers[sid].prev = 0;
    22703:  531:        crawlers[sid].time = 0;
    22703:  532:        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
      255:  533:            remaining = do_get_lru_size(sid);
        -:  534:        }
        -:  535:        /* Values for remaining:
        -:  536:         * remaining = 0
        -:  537:         * - scan all elements, until a NULL is reached
        -:  538:         * - if empty, NULL is reached right away
        -:  539:         * remaining = n + 1
        -:  540:         * - first n elements are parsed (or until a NULL is reached)
        -:  541:         */
    22703:  542:        if (remaining) remaining++;
    22703:  543:        crawlers[sid].remaining = remaining;
    22703:  544:        crawlers[sid].slabs_clsid = sid;
    22703:  545:        crawlers[sid].reclaimed = 0;
    22703:  546:        crawlers[sid].unfetched = 0;
    22703:  547:        crawlers[sid].checked = 0;
    22703:  548:        do_item_linktail_q((item *)&crawlers[sid]);
    22703:  549:        crawler_count++;
    22703:  550:        starts++;
        -:  551:    }
    22703:  552:    pthread_mutex_unlock(&lru_locks[sid]);
    22703:  553:    if (starts) {
    22703:  554:        STATS_LOCK();
    22703:  555:        stats_state.lru_crawler_running = true;
    22703:  556:        stats.lru_crawler_starts++;
    22703:  557:        STATS_UNLOCK();
        -:  558:    }
    22703:  559:    return starts;
        -:  560:}
------------------
do_lru_crawler_start:
    22703:  518:static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    22703:  519:    uint32_t sid = id;
    22703:  520:    int starts = 0;
        -:  521:
    22703:  522:    pthread_mutex_lock(&lru_locks[sid]);
    22703:  523:    if (crawlers[sid].it_flags == 0) {
    22703:  524:        if (settings.verbose > 2)
    #####:  525:            fprintf(stderr, "Kicking LRU crawler off for LRU %u\n", sid);
    22703:  526:        crawlers[sid].nbytes = 0;
    22703:  527:        crawlers[sid].nkey = 0;
    22703:  528:        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
    22703:  529:        crawlers[sid].next = 0;
    22703:  530:        crawlers[sid].prev = 0;
    22703:  531:        crawlers[sid].time = 0;
    22703:  532:        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
      255:  533:            remaining = do_get_lru_size(sid);
        -:  534:        }
        -:  535:        /* Values for remaining:
        -:  536:         * remaining = 0
        -:  537:         * - scan all elements, until a NULL is reached
        -:  538:         * - if empty, NULL is reached right away
        -:  539:         * remaining = n + 1
        -:  540:         * - first n elements are parsed (or until a NULL is reached)
        -:  541:         */
    22703:  542:        if (remaining) remaining++;
    22703:  543:        crawlers[sid].remaining = remaining;
    22703:  544:        crawlers[sid].slabs_clsid = sid;
    22703:  545:        crawlers[sid].reclaimed = 0;
    22703:  546:        crawlers[sid].unfetched = 0;
    22703:  547:        crawlers[sid].checked = 0;
    22703:  548:        do_item_linktail_q((item *)&crawlers[sid]);
    22703:  549:        crawler_count++;
    22703:  550:        starts++;
        -:  551:    }
    22703:  552:    pthread_mutex_unlock(&lru_locks[sid]);
    22703:  553:    if (starts) {
    22703:  554:        STATS_LOCK();
    22703:  555:        stats_state.lru_crawler_running = true;
    22703:  556:        stats.lru_crawler_starts++;
    22703:  557:        STATS_UNLOCK();
        -:  558:    }
    22703:  559:    return starts;
        -:  560:}
------------------
do_lru_crawler_start:
    22703:  518:static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    22703:  519:    uint32_t sid = id;
    22703:  520:    int starts = 0;
        -:  521:
    22703:  522:    pthread_mutex_lock(&lru_locks[sid]);
    22703:  523:    if (crawlers[sid].it_flags == 0) {
    22703:  524:        if (settings.verbose > 2)
    #####:  525:            fprintf(stderr, "Kicking LRU crawler off for LRU %u\n", sid);
    22703:  526:        crawlers[sid].nbytes = 0;
    22703:  527:        crawlers[sid].nkey = 0;
    22703:  528:        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
    22703:  529:        crawlers[sid].next = 0;
    22703:  530:        crawlers[sid].prev = 0;
    22703:  531:        crawlers[sid].time = 0;
    22703:  532:        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
      255:  533:            remaining = do_get_lru_size(sid);
        -:  534:        }
        -:  535:        /* Values for remaining:
        -:  536:         * remaining = 0
        -:  537:         * - scan all elements, until a NULL is reached
        -:  538:         * - if empty, NULL is reached right away
        -:  539:         * remaining = n + 1
        -:  540:         * - first n elements are parsed (or until a NULL is reached)
        -:  541:         */
    22703:  542:        if (remaining) remaining++;
    22703:  543:        crawlers[sid].remaining = remaining;
    22703:  544:        crawlers[sid].slabs_clsid = sid;
    22703:  545:        crawlers[sid].reclaimed = 0;
    22703:  546:        crawlers[sid].unfetched = 0;
    22703:  547:        crawlers[sid].checked = 0;
    22703:  548:        do_item_linktail_q((item *)&crawlers[sid]);
    22703:  549:        crawler_count++;
    22703:  550:        starts++;
        -:  551:    }
    22703:  552:    pthread_mutex_unlock(&lru_locks[sid]);
    22703:  553:    if (starts) {
    22703:  554:        STATS_LOCK();
    22703:  555:        stats_state.lru_crawler_running = true;
    22703:  556:        stats.lru_crawler_starts++;
    22703:  557:        STATS_UNLOCK();
        -:  558:    }
    22703:  559:    return starts;
        -:  560:}
------------------
        -:  561:
        -:  562:static int lru_crawler_set_client(crawler_module_t *cm, void *c, const int sfd) {
        4:  563:    crawler_client_t *crawlc = &cm->c;
        4:  564:    if (crawlc->c != NULL) {
        -:  565:        return -1;
        -:  566:    }
        4:  567:    crawlc->c = c;
        4:  568:    crawlc->sfd = sfd;
        -:  569:
        4:  570:    crawlc->buf = bipbuf_new(1024 * 128);
        4:  571:    if (crawlc->buf == NULL) {
        -:  572:        return -2;
        -:  573:    }
        -:  574:    return 0;
        -:  575:}
        -:  576:
      364:  577:int lru_crawler_start(uint8_t *ids, uint32_t remaining,
        -:  578:                             const enum crawler_run_type type, void *data,
        -:  579:                             void *c, const int sfd) {
      364:  580:    int starts = 0;
      364:  581:    bool is_running;
      364:  582:    static rel_time_t block_ae_until = 0;
      364:  583:    pthread_mutex_lock(&lru_crawler_lock);
      364:  584:    STATS_LOCK();
      364:  585:    is_running = stats_state.lru_crawler_running;
      364:  586:    STATS_UNLOCK();
     364*:  587:    if (is_running &&
    #####:  588:            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
    #####:  589:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  590:        block_ae_until = current_time + 60;
    #####:  591:        return -1;
        -:  592:    }
        -:  593:
      364:  594:    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
    #####:  595:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  596:        return -1;
        -:  597:    }
        -:  598:
        -:  599:    /* Configure the module */
      364:  600:    if (!is_running) {
     364*:  601:        assert(crawler_mod_regs[type] != NULL);
      364:  602:        active_crawler_mod.mod = crawler_mod_regs[type];
      364:  603:        active_crawler_type = type;
      364:  604:        if (active_crawler_mod.mod->init != NULL) {
      360:  605:            active_crawler_mod.mod->init(&active_crawler_mod, data);
        -:  606:        }
      364:  607:        if (active_crawler_mod.mod->needs_client) {
        4:  608:            if (c == NULL || sfd == 0) {
    #####:  609:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  610:                return -2;
        -:  611:            }
        4:  612:            if (lru_crawler_set_client(&active_crawler_mod, c, sfd) != 0) {
    #####:  613:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  614:                return -2;
        -:  615:            }
        -:  616:        }
        -:  617:    }
        -:  618:
        -:  619:    /* we allow the autocrawler to restart sub-LRU's before completion */
    93184:  620:    for (int sid = POWER_SMALLEST; sid < POWER_LARGEST; sid++) {
    92820:  621:        if (ids[sid])
    90812:  622:            starts += do_lru_crawler_start(sid, remaining);
        -:  623:    }
      364:  624:    if (starts) {
      364:  625:        pthread_cond_signal(&lru_crawler_cond);
        -:  626:    }
      364:  627:    pthread_mutex_unlock(&lru_crawler_lock);
      364:  628:    return starts;
        -:  629:}
------------------
lru_crawler_start:
       91:  577:int lru_crawler_start(uint8_t *ids, uint32_t remaining,
        -:  578:                             const enum crawler_run_type type, void *data,
        -:  579:                             void *c, const int sfd) {
       91:  580:    int starts = 0;
       91:  581:    bool is_running;
       91:  582:    static rel_time_t block_ae_until = 0;
       91:  583:    pthread_mutex_lock(&lru_crawler_lock);
       91:  584:    STATS_LOCK();
       91:  585:    is_running = stats_state.lru_crawler_running;
       91:  586:    STATS_UNLOCK();
      91*:  587:    if (is_running &&
    #####:  588:            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
    #####:  589:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  590:        block_ae_until = current_time + 60;
    #####:  591:        return -1;
        -:  592:    }
        -:  593:
       91:  594:    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
    #####:  595:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  596:        return -1;
        -:  597:    }
        -:  598:
        -:  599:    /* Configure the module */
       91:  600:    if (!is_running) {
      91*:  601:        assert(crawler_mod_regs[type] != NULL);
       91:  602:        active_crawler_mod.mod = crawler_mod_regs[type];
       91:  603:        active_crawler_type = type;
       91:  604:        if (active_crawler_mod.mod->init != NULL) {
       90:  605:            active_crawler_mod.mod->init(&active_crawler_mod, data);
        -:  606:        }
       91:  607:        if (active_crawler_mod.mod->needs_client) {
        1:  608:            if (c == NULL || sfd == 0) {
    #####:  609:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  610:                return -2;
        -:  611:            }
        1:  612:            if (lru_crawler_set_client(&active_crawler_mod, c, sfd) != 0) {
    #####:  613:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  614:                return -2;
        -:  615:            }
        -:  616:        }
        -:  617:    }
        -:  618:
        -:  619:    /* we allow the autocrawler to restart sub-LRU's before completion */
    23296:  620:    for (int sid = POWER_SMALLEST; sid < POWER_LARGEST; sid++) {
    23205:  621:        if (ids[sid])
    22703:  622:            starts += do_lru_crawler_start(sid, remaining);
        -:  623:    }
       91:  624:    if (starts) {
       91:  625:        pthread_cond_signal(&lru_crawler_cond);
        -:  626:    }
       91:  627:    pthread_mutex_unlock(&lru_crawler_lock);
       91:  628:    return starts;
        -:  629:}
------------------
lru_crawler_start:
       91:  577:int lru_crawler_start(uint8_t *ids, uint32_t remaining,
        -:  578:                             const enum crawler_run_type type, void *data,
        -:  579:                             void *c, const int sfd) {
       91:  580:    int starts = 0;
       91:  581:    bool is_running;
       91:  582:    static rel_time_t block_ae_until = 0;
       91:  583:    pthread_mutex_lock(&lru_crawler_lock);
       91:  584:    STATS_LOCK();
       91:  585:    is_running = stats_state.lru_crawler_running;
       91:  586:    STATS_UNLOCK();
      91*:  587:    if (is_running &&
    #####:  588:            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
    #####:  589:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  590:        block_ae_until = current_time + 60;
    #####:  591:        return -1;
        -:  592:    }
        -:  593:
       91:  594:    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
    #####:  595:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  596:        return -1;
        -:  597:    }
        -:  598:
        -:  599:    /* Configure the module */
       91:  600:    if (!is_running) {
      91*:  601:        assert(crawler_mod_regs[type] != NULL);
       91:  602:        active_crawler_mod.mod = crawler_mod_regs[type];
       91:  603:        active_crawler_type = type;
       91:  604:        if (active_crawler_mod.mod->init != NULL) {
       90:  605:            active_crawler_mod.mod->init(&active_crawler_mod, data);
        -:  606:        }
       91:  607:        if (active_crawler_mod.mod->needs_client) {
        1:  608:            if (c == NULL || sfd == 0) {
    #####:  609:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  610:                return -2;
        -:  611:            }
        1:  612:            if (lru_crawler_set_client(&active_crawler_mod, c, sfd) != 0) {
    #####:  613:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  614:                return -2;
        -:  615:            }
        -:  616:        }
        -:  617:    }
        -:  618:
        -:  619:    /* we allow the autocrawler to restart sub-LRU's before completion */
    23296:  620:    for (int sid = POWER_SMALLEST; sid < POWER_LARGEST; sid++) {
    23205:  621:        if (ids[sid])
    22703:  622:            starts += do_lru_crawler_start(sid, remaining);
        -:  623:    }
       91:  624:    if (starts) {
       91:  625:        pthread_cond_signal(&lru_crawler_cond);
        -:  626:    }
       91:  627:    pthread_mutex_unlock(&lru_crawler_lock);
       91:  628:    return starts;
        -:  629:}
------------------
lru_crawler_start:
       91:  577:int lru_crawler_start(uint8_t *ids, uint32_t remaining,
        -:  578:                             const enum crawler_run_type type, void *data,
        -:  579:                             void *c, const int sfd) {
       91:  580:    int starts = 0;
       91:  581:    bool is_running;
       91:  582:    static rel_time_t block_ae_until = 0;
       91:  583:    pthread_mutex_lock(&lru_crawler_lock);
       91:  584:    STATS_LOCK();
       91:  585:    is_running = stats_state.lru_crawler_running;
       91:  586:    STATS_UNLOCK();
      91*:  587:    if (is_running &&
    #####:  588:            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
    #####:  589:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  590:        block_ae_until = current_time + 60;
    #####:  591:        return -1;
        -:  592:    }
        -:  593:
       91:  594:    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
    #####:  595:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  596:        return -1;
        -:  597:    }
        -:  598:
        -:  599:    /* Configure the module */
       91:  600:    if (!is_running) {
      91*:  601:        assert(crawler_mod_regs[type] != NULL);
       91:  602:        active_crawler_mod.mod = crawler_mod_regs[type];
       91:  603:        active_crawler_type = type;
       91:  604:        if (active_crawler_mod.mod->init != NULL) {
       90:  605:            active_crawler_mod.mod->init(&active_crawler_mod, data);
        -:  606:        }
       91:  607:        if (active_crawler_mod.mod->needs_client) {
        1:  608:            if (c == NULL || sfd == 0) {
    #####:  609:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  610:                return -2;
        -:  611:            }
        1:  612:            if (lru_crawler_set_client(&active_crawler_mod, c, sfd) != 0) {
    #####:  613:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  614:                return -2;
        -:  615:            }
        -:  616:        }
        -:  617:    }
        -:  618:
        -:  619:    /* we allow the autocrawler to restart sub-LRU's before completion */
    23296:  620:    for (int sid = POWER_SMALLEST; sid < POWER_LARGEST; sid++) {
    23205:  621:        if (ids[sid])
    22703:  622:            starts += do_lru_crawler_start(sid, remaining);
        -:  623:    }
       91:  624:    if (starts) {
       91:  625:        pthread_cond_signal(&lru_crawler_cond);
        -:  626:    }
       91:  627:    pthread_mutex_unlock(&lru_crawler_lock);
       91:  628:    return starts;
        -:  629:}
------------------
lru_crawler_start:
       91:  577:int lru_crawler_start(uint8_t *ids, uint32_t remaining,
        -:  578:                             const enum crawler_run_type type, void *data,
        -:  579:                             void *c, const int sfd) {
       91:  580:    int starts = 0;
       91:  581:    bool is_running;
       91:  582:    static rel_time_t block_ae_until = 0;
       91:  583:    pthread_mutex_lock(&lru_crawler_lock);
       91:  584:    STATS_LOCK();
       91:  585:    is_running = stats_state.lru_crawler_running;
       91:  586:    STATS_UNLOCK();
      91*:  587:    if (is_running &&
    #####:  588:            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
    #####:  589:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  590:        block_ae_until = current_time + 60;
    #####:  591:        return -1;
        -:  592:    }
        -:  593:
       91:  594:    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
    #####:  595:        pthread_mutex_unlock(&lru_crawler_lock);
    #####:  596:        return -1;
        -:  597:    }
        -:  598:
        -:  599:    /* Configure the module */
       91:  600:    if (!is_running) {
      91*:  601:        assert(crawler_mod_regs[type] != NULL);
       91:  602:        active_crawler_mod.mod = crawler_mod_regs[type];
       91:  603:        active_crawler_type = type;
       91:  604:        if (active_crawler_mod.mod->init != NULL) {
       90:  605:            active_crawler_mod.mod->init(&active_crawler_mod, data);
        -:  606:        }
       91:  607:        if (active_crawler_mod.mod->needs_client) {
        1:  608:            if (c == NULL || sfd == 0) {
    #####:  609:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  610:                return -2;
        -:  611:            }
        1:  612:            if (lru_crawler_set_client(&active_crawler_mod, c, sfd) != 0) {
    #####:  613:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  614:                return -2;
        -:  615:            }
        -:  616:        }
        -:  617:    }
        -:  618:
        -:  619:    /* we allow the autocrawler to restart sub-LRU's before completion */
    23296:  620:    for (int sid = POWER_SMALLEST; sid < POWER_LARGEST; sid++) {
    23205:  621:        if (ids[sid])
    22703:  622:            starts += do_lru_crawler_start(sid, remaining);
        -:  623:    }
       91:  624:    if (starts) {
       91:  625:        pthread_cond_signal(&lru_crawler_cond);
        -:  626:    }
       91:  627:    pthread_mutex_unlock(&lru_crawler_lock);
       91:  628:    return starts;
        -:  629:}
------------------
        -:  630:
        -:  631:/*
        -:  632: * Also only clear the crawlerstats once per sid.
        -:  633: */
       12:  634:enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        -:  635:        void *c, const int sfd, unsigned int remaining) {
       12:  636:    char *b = NULL;
       12:  637:    uint32_t sid = 0;
       12:  638:    int starts = 0;
       12:  639:    uint8_t tocrawl[POWER_LARGEST];
        -:  640:
        -:  641:    /* FIXME: I added this while debugging. Don't think it's needed? */
       12:  642:    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
       12:  643:    if (strcmp(slabs, "all") == 0) {
     1028:  644:        for (sid = 0; sid < POWER_LARGEST; sid++) {
     1024:  645:            tocrawl[sid] = 1;
        -:  646:        }
        -:  647:    } else {
       16:  648:        for (char *p = strtok_r(slabs, ",", &b);
        -:  649:             p != NULL;
        8:  650:             p = strtok_r(NULL, ",", &b)) {
        -:  651:
        8:  652:            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
        8:  653:                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####:  654:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  655:                return CRAWLER_BADCLASS;
        -:  656:            }
        8:  657:            tocrawl[sid | TEMP_LRU] = 1;
        8:  658:            tocrawl[sid | HOT_LRU] = 1;
        8:  659:            tocrawl[sid | WARM_LRU] = 1;
        8:  660:            tocrawl[sid | COLD_LRU] = 1;
        -:  661:        }
        -:  662:    }
        -:  663:
       12:  664:    starts = lru_crawler_start(tocrawl, remaining, type, NULL, c, sfd);
       12:  665:    if (starts == -1) {
        -:  666:        return CRAWLER_RUNNING;
       12:  667:    } else if (starts == -2) {
        -:  668:        return CRAWLER_ERROR; /* FIXME: not very helpful. */
       12:  669:    } else if (starts) {
        -:  670:        return CRAWLER_OK;
        -:  671:    } else {
    #####:  672:        return CRAWLER_NOTSTARTED;
        -:  673:    }
        -:  674:}
------------------
lru_crawler_crawl:
        3:  634:enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        -:  635:        void *c, const int sfd, unsigned int remaining) {
        3:  636:    char *b = NULL;
        3:  637:    uint32_t sid = 0;
        3:  638:    int starts = 0;
        3:  639:    uint8_t tocrawl[POWER_LARGEST];
        -:  640:
        -:  641:    /* FIXME: I added this while debugging. Don't think it's needed? */
        3:  642:    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
        3:  643:    if (strcmp(slabs, "all") == 0) {
      257:  644:        for (sid = 0; sid < POWER_LARGEST; sid++) {
      256:  645:            tocrawl[sid] = 1;
        -:  646:        }
        -:  647:    } else {
        4:  648:        for (char *p = strtok_r(slabs, ",", &b);
        -:  649:             p != NULL;
        2:  650:             p = strtok_r(NULL, ",", &b)) {
        -:  651:
        2:  652:            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
        2:  653:                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####:  654:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  655:                return CRAWLER_BADCLASS;
        -:  656:            }
        2:  657:            tocrawl[sid | TEMP_LRU] = 1;
        2:  658:            tocrawl[sid | HOT_LRU] = 1;
        2:  659:            tocrawl[sid | WARM_LRU] = 1;
        2:  660:            tocrawl[sid | COLD_LRU] = 1;
        -:  661:        }
        -:  662:    }
        -:  663:
        3:  664:    starts = lru_crawler_start(tocrawl, remaining, type, NULL, c, sfd);
        3:  665:    if (starts == -1) {
        -:  666:        return CRAWLER_RUNNING;
        3:  667:    } else if (starts == -2) {
        -:  668:        return CRAWLER_ERROR; /* FIXME: not very helpful. */
        3:  669:    } else if (starts) {
        -:  670:        return CRAWLER_OK;
        -:  671:    } else {
    #####:  672:        return CRAWLER_NOTSTARTED;
        -:  673:    }
        -:  674:}
------------------
lru_crawler_crawl:
        3:  634:enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        -:  635:        void *c, const int sfd, unsigned int remaining) {
        3:  636:    char *b = NULL;
        3:  637:    uint32_t sid = 0;
        3:  638:    int starts = 0;
        3:  639:    uint8_t tocrawl[POWER_LARGEST];
        -:  640:
        -:  641:    /* FIXME: I added this while debugging. Don't think it's needed? */
        3:  642:    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
        3:  643:    if (strcmp(slabs, "all") == 0) {
      257:  644:        for (sid = 0; sid < POWER_LARGEST; sid++) {
      256:  645:            tocrawl[sid] = 1;
        -:  646:        }
        -:  647:    } else {
        4:  648:        for (char *p = strtok_r(slabs, ",", &b);
        -:  649:             p != NULL;
        2:  650:             p = strtok_r(NULL, ",", &b)) {
        -:  651:
        2:  652:            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
        2:  653:                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####:  654:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  655:                return CRAWLER_BADCLASS;
        -:  656:            }
        2:  657:            tocrawl[sid | TEMP_LRU] = 1;
        2:  658:            tocrawl[sid | HOT_LRU] = 1;
        2:  659:            tocrawl[sid | WARM_LRU] = 1;
        2:  660:            tocrawl[sid | COLD_LRU] = 1;
        -:  661:        }
        -:  662:    }
        -:  663:
        3:  664:    starts = lru_crawler_start(tocrawl, remaining, type, NULL, c, sfd);
        3:  665:    if (starts == -1) {
        -:  666:        return CRAWLER_RUNNING;
        3:  667:    } else if (starts == -2) {
        -:  668:        return CRAWLER_ERROR; /* FIXME: not very helpful. */
        3:  669:    } else if (starts) {
        -:  670:        return CRAWLER_OK;
        -:  671:    } else {
    #####:  672:        return CRAWLER_NOTSTARTED;
        -:  673:    }
        -:  674:}
------------------
lru_crawler_crawl:
        3:  634:enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        -:  635:        void *c, const int sfd, unsigned int remaining) {
        3:  636:    char *b = NULL;
        3:  637:    uint32_t sid = 0;
        3:  638:    int starts = 0;
        3:  639:    uint8_t tocrawl[POWER_LARGEST];
        -:  640:
        -:  641:    /* FIXME: I added this while debugging. Don't think it's needed? */
        3:  642:    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
        3:  643:    if (strcmp(slabs, "all") == 0) {
      257:  644:        for (sid = 0; sid < POWER_LARGEST; sid++) {
      256:  645:            tocrawl[sid] = 1;
        -:  646:        }
        -:  647:    } else {
        4:  648:        for (char *p = strtok_r(slabs, ",", &b);
        -:  649:             p != NULL;
        2:  650:             p = strtok_r(NULL, ",", &b)) {
        -:  651:
        2:  652:            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
        2:  653:                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####:  654:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  655:                return CRAWLER_BADCLASS;
        -:  656:            }
        2:  657:            tocrawl[sid | TEMP_LRU] = 1;
        2:  658:            tocrawl[sid | HOT_LRU] = 1;
        2:  659:            tocrawl[sid | WARM_LRU] = 1;
        2:  660:            tocrawl[sid | COLD_LRU] = 1;
        -:  661:        }
        -:  662:    }
        -:  663:
        3:  664:    starts = lru_crawler_start(tocrawl, remaining, type, NULL, c, sfd);
        3:  665:    if (starts == -1) {
        -:  666:        return CRAWLER_RUNNING;
        3:  667:    } else if (starts == -2) {
        -:  668:        return CRAWLER_ERROR; /* FIXME: not very helpful. */
        3:  669:    } else if (starts) {
        -:  670:        return CRAWLER_OK;
        -:  671:    } else {
    #####:  672:        return CRAWLER_NOTSTARTED;
        -:  673:    }
        -:  674:}
------------------
lru_crawler_crawl:
        3:  634:enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        -:  635:        void *c, const int sfd, unsigned int remaining) {
        3:  636:    char *b = NULL;
        3:  637:    uint32_t sid = 0;
        3:  638:    int starts = 0;
        3:  639:    uint8_t tocrawl[POWER_LARGEST];
        -:  640:
        -:  641:    /* FIXME: I added this while debugging. Don't think it's needed? */
        3:  642:    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
        3:  643:    if (strcmp(slabs, "all") == 0) {
      257:  644:        for (sid = 0; sid < POWER_LARGEST; sid++) {
      256:  645:            tocrawl[sid] = 1;
        -:  646:        }
        -:  647:    } else {
        4:  648:        for (char *p = strtok_r(slabs, ",", &b);
        -:  649:             p != NULL;
        2:  650:             p = strtok_r(NULL, ",", &b)) {
        -:  651:
        2:  652:            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
        2:  653:                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####:  654:                pthread_mutex_unlock(&lru_crawler_lock);
    #####:  655:                return CRAWLER_BADCLASS;
        -:  656:            }
        2:  657:            tocrawl[sid | TEMP_LRU] = 1;
        2:  658:            tocrawl[sid | HOT_LRU] = 1;
        2:  659:            tocrawl[sid | WARM_LRU] = 1;
        2:  660:            tocrawl[sid | COLD_LRU] = 1;
        -:  661:        }
        -:  662:    }
        -:  663:
        3:  664:    starts = lru_crawler_start(tocrawl, remaining, type, NULL, c, sfd);
        3:  665:    if (starts == -1) {
        -:  666:        return CRAWLER_RUNNING;
        3:  667:    } else if (starts == -2) {
        -:  668:        return CRAWLER_ERROR; /* FIXME: not very helpful. */
        3:  669:    } else if (starts) {
        -:  670:        return CRAWLER_OK;
        -:  671:    } else {
    #####:  672:        return CRAWLER_NOTSTARTED;
        -:  673:    }
        -:  674:}
------------------
        -:  675:
        -:  676:/* If we hold this lock, crawler can't wake up or move */
    #####:  677:void lru_crawler_pause(void) {
    #####:  678:    pthread_mutex_lock(&lru_crawler_lock);
    #####:  679:}
------------------
lru_crawler_pause:
    #####:  677:void lru_crawler_pause(void) {
    #####:  678:    pthread_mutex_lock(&lru_crawler_lock);
    #####:  679:}
------------------
lru_crawler_pause:
    #####:  677:void lru_crawler_pause(void) {
    #####:  678:    pthread_mutex_lock(&lru_crawler_lock);
    #####:  679:}
------------------
lru_crawler_pause:
    #####:  677:void lru_crawler_pause(void) {
    #####:  678:    pthread_mutex_lock(&lru_crawler_lock);
    #####:  679:}
------------------
lru_crawler_pause:
    #####:  677:void lru_crawler_pause(void) {
    #####:  678:    pthread_mutex_lock(&lru_crawler_lock);
    #####:  679:}
------------------
        -:  680:
    #####:  681:void lru_crawler_resume(void) {
    #####:  682:    pthread_mutex_unlock(&lru_crawler_lock);
    #####:  683:}
------------------
lru_crawler_resume:
    #####:  681:void lru_crawler_resume(void) {
    #####:  682:    pthread_mutex_unlock(&lru_crawler_lock);
    #####:  683:}
------------------
lru_crawler_resume:
    #####:  681:void lru_crawler_resume(void) {
    #####:  682:    pthread_mutex_unlock(&lru_crawler_lock);
    #####:  683:}
------------------
lru_crawler_resume:
    #####:  681:void lru_crawler_resume(void) {
    #####:  682:    pthread_mutex_unlock(&lru_crawler_lock);
    #####:  683:}
------------------
lru_crawler_resume:
    #####:  681:void lru_crawler_resume(void) {
    #####:  682:    pthread_mutex_unlock(&lru_crawler_lock);
    #####:  683:}
------------------
        -:  684:
      384:  685:int init_lru_crawler(void *arg) {
      384:  686:    if (lru_crawler_initialized == 0) {
        -:  687:#ifdef EXTSTORE
        -:  688:        storage = arg;
        -:  689:#endif
      384:  690:        if (pthread_cond_init(&lru_crawler_cond, NULL) != 0) {
    #####:  691:            fprintf(stderr, "Can't initialize lru crawler condition\n");
    #####:  692:            return -1;
        -:  693:        }
      384:  694:        pthread_mutex_init(&lru_crawler_lock, NULL);
      384:  695:        active_crawler_mod.c.c = NULL;
      384:  696:        active_crawler_mod.mod = NULL;
      384:  697:        active_crawler_mod.data = NULL;
      384:  698:        lru_crawler_initialized = 1;
        -:  699:    }
        -:  700:    return 0;
        -:  701:}
