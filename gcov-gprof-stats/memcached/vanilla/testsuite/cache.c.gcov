        -:    0:Source:cache.c
        -:    0:Programs:72
        -:    0:Source is newer than graph
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <inttypes.h>
        -:    5:
        -:    6:#ifndef NDEBUG
        -:    7:#include <signal.h>
        -:    8:#endif
        -:    9:
        -:   10:#include "cache.h"
        -:   11:
        -:   12:#ifndef NDEBUG
        -:   13:const uint64_t redzone_pattern = 0xdeadbeefcafebabe;
        -:   14:int cache_error = 0;
        -:   15:#endif
        -:   16:
        -:   17:const int initial_pool_size = 64;
        -:   18:
     1920:   19:cache_t* cache_create(const char *name, size_t bufsize, size_t align,
        -:   20:                      cache_constructor_t* constructor,
        -:   21:                      cache_destructor_t* destructor) {
     1920:   22:    cache_t* ret = calloc(1, sizeof(cache_t));
     1920:   23:    char* nm = strdup(name);
     1920:   24:    void** ptr = calloc(initial_pool_size, sizeof(void*));
     3840:   25:    if (ret == NULL || nm == NULL || ptr == NULL ||
     1920:   26:        pthread_mutex_init(&ret->mutex, NULL) == -1) {
    #####:   27:        free(ret);
    #####:   28:        free(nm);
    #####:   29:        free(ptr);
    #####:   30:        return NULL;
        -:   31:    }
        -:   32:
     1920:   33:    ret->name = nm;
     1920:   34:    ret->ptr = ptr;
     1920:   35:    ret->freetotal = initial_pool_size;
     1920:   36:    ret->constructor = constructor;
     1920:   37:    ret->destructor = destructor;
        -:   38:
        -:   39:#ifndef NDEBUG
     1920:   40:    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
        -:   41:#else
        -:   42:    ret->bufsize = bufsize;
        -:   43:#endif
        -:   44:
     1920:   45:    return ret;
        -:   46:}
------------------
cache_create:
      384:   19:cache_t* cache_create(const char *name, size_t bufsize, size_t align,
        -:   20:                      cache_constructor_t* constructor,
        -:   21:                      cache_destructor_t* destructor) {
      384:   22:    cache_t* ret = calloc(1, sizeof(cache_t));
      384:   23:    char* nm = strdup(name);
      384:   24:    void** ptr = calloc(initial_pool_size, sizeof(void*));
      768:   25:    if (ret == NULL || nm == NULL || ptr == NULL ||
      384:   26:        pthread_mutex_init(&ret->mutex, NULL) == -1) {
    #####:   27:        free(ret);
    #####:   28:        free(nm);
    #####:   29:        free(ptr);
    #####:   30:        return NULL;
        -:   31:    }
        -:   32:
      384:   33:    ret->name = nm;
      384:   34:    ret->ptr = ptr;
      384:   35:    ret->freetotal = initial_pool_size;
      384:   36:    ret->constructor = constructor;
      384:   37:    ret->destructor = destructor;
        -:   38:
        -:   39:#ifndef NDEBUG
      384:   40:    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
        -:   41:#else
        -:   42:    ret->bufsize = bufsize;
        -:   43:#endif
        -:   44:
      384:   45:    return ret;
        -:   46:}
------------------
cache_create:
      384:   19:cache_t* cache_create(const char *name, size_t bufsize, size_t align,
        -:   20:                      cache_constructor_t* constructor,
        -:   21:                      cache_destructor_t* destructor) {
      384:   22:    cache_t* ret = calloc(1, sizeof(cache_t));
      384:   23:    char* nm = strdup(name);
      384:   24:    void** ptr = calloc(initial_pool_size, sizeof(void*));
      768:   25:    if (ret == NULL || nm == NULL || ptr == NULL ||
      384:   26:        pthread_mutex_init(&ret->mutex, NULL) == -1) {
    #####:   27:        free(ret);
    #####:   28:        free(nm);
    #####:   29:        free(ptr);
    #####:   30:        return NULL;
        -:   31:    }
        -:   32:
      384:   33:    ret->name = nm;
      384:   34:    ret->ptr = ptr;
      384:   35:    ret->freetotal = initial_pool_size;
      384:   36:    ret->constructor = constructor;
      384:   37:    ret->destructor = destructor;
        -:   38:
        -:   39:#ifndef NDEBUG
      384:   40:    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
        -:   41:#else
        -:   42:    ret->bufsize = bufsize;
        -:   43:#endif
        -:   44:
      384:   45:    return ret;
        -:   46:}
------------------
cache_create:
      384:   19:cache_t* cache_create(const char *name, size_t bufsize, size_t align,
        -:   20:                      cache_constructor_t* constructor,
        -:   21:                      cache_destructor_t* destructor) {
      384:   22:    cache_t* ret = calloc(1, sizeof(cache_t));
      384:   23:    char* nm = strdup(name);
      384:   24:    void** ptr = calloc(initial_pool_size, sizeof(void*));
      768:   25:    if (ret == NULL || nm == NULL || ptr == NULL ||
      384:   26:        pthread_mutex_init(&ret->mutex, NULL) == -1) {
    #####:   27:        free(ret);
    #####:   28:        free(nm);
    #####:   29:        free(ptr);
    #####:   30:        return NULL;
        -:   31:    }
        -:   32:
      384:   33:    ret->name = nm;
      384:   34:    ret->ptr = ptr;
      384:   35:    ret->freetotal = initial_pool_size;
      384:   36:    ret->constructor = constructor;
      384:   37:    ret->destructor = destructor;
        -:   38:
        -:   39:#ifndef NDEBUG
      384:   40:    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
        -:   41:#else
        -:   42:    ret->bufsize = bufsize;
        -:   43:#endif
        -:   44:
      384:   45:    return ret;
        -:   46:}
------------------
cache_create:
      384:   19:cache_t* cache_create(const char *name, size_t bufsize, size_t align,
        -:   20:                      cache_constructor_t* constructor,
        -:   21:                      cache_destructor_t* destructor) {
      384:   22:    cache_t* ret = calloc(1, sizeof(cache_t));
      384:   23:    char* nm = strdup(name);
      384:   24:    void** ptr = calloc(initial_pool_size, sizeof(void*));
      768:   25:    if (ret == NULL || nm == NULL || ptr == NULL ||
      384:   26:        pthread_mutex_init(&ret->mutex, NULL) == -1) {
    #####:   27:        free(ret);
    #####:   28:        free(nm);
    #####:   29:        free(ptr);
    #####:   30:        return NULL;
        -:   31:    }
        -:   32:
      384:   33:    ret->name = nm;
      384:   34:    ret->ptr = ptr;
      384:   35:    ret->freetotal = initial_pool_size;
      384:   36:    ret->constructor = constructor;
      384:   37:    ret->destructor = destructor;
        -:   38:
        -:   39:#ifndef NDEBUG
      384:   40:    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
        -:   41:#else
        -:   42:    ret->bufsize = bufsize;
        -:   43:#endif
        -:   44:
      384:   45:    return ret;
        -:   46:}
------------------
cache_create:
      384:   19:cache_t* cache_create(const char *name, size_t bufsize, size_t align,
        -:   20:                      cache_constructor_t* constructor,
        -:   21:                      cache_destructor_t* destructor) {
      384:   22:    cache_t* ret = calloc(1, sizeof(cache_t));
      384:   23:    char* nm = strdup(name);
      384:   24:    void** ptr = calloc(initial_pool_size, sizeof(void*));
      768:   25:    if (ret == NULL || nm == NULL || ptr == NULL ||
      384:   26:        pthread_mutex_init(&ret->mutex, NULL) == -1) {
    #####:   27:        free(ret);
    #####:   28:        free(nm);
    #####:   29:        free(ptr);
    #####:   30:        return NULL;
        -:   31:    }
        -:   32:
      384:   33:    ret->name = nm;
      384:   34:    ret->ptr = ptr;
      384:   35:    ret->freetotal = initial_pool_size;
      384:   36:    ret->constructor = constructor;
      384:   37:    ret->destructor = destructor;
        -:   38:
        -:   39:#ifndef NDEBUG
      384:   40:    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
        -:   41:#else
        -:   42:    ret->bufsize = bufsize;
        -:   43:#endif
        -:   44:
      384:   45:    return ret;
        -:   46:}
------------------
        -:   47:
        -:   48:static inline void* get_object(void *ptr) {
        -:   49:#ifndef NDEBUG
  157115*:   50:    uint64_t *pre = ptr;
  157115*:   51:    return pre + 1;
        -:   52:#else
        -:   53:    return ptr;
        -:   54:#endif
        -:   55:}
        -:   56:
    #####:   57:void cache_destroy(cache_t *cache) {
    #####:   58:    while (cache->freecurr > 0) {
    #####:   59:        void *ptr = cache->ptr[--cache->freecurr];
    #####:   60:        if (cache->destructor) {
    #####:   61:            cache->destructor(get_object(ptr), NULL);
        -:   62:        }
    #####:   63:        free(ptr);
        -:   64:    }
    #####:   65:    free(cache->name);
    #####:   66:    free(cache->ptr);
    #####:   67:    pthread_mutex_destroy(&cache->mutex);
    #####:   68:    free(cache);
    #####:   69:}
------------------
cache_destroy:
    #####:   57:void cache_destroy(cache_t *cache) {
    #####:   58:    while (cache->freecurr > 0) {
    #####:   59:        void *ptr = cache->ptr[--cache->freecurr];
    #####:   60:        if (cache->destructor) {
    #####:   61:            cache->destructor(get_object(ptr), NULL);
        -:   62:        }
    #####:   63:        free(ptr);
        -:   64:    }
    #####:   65:    free(cache->name);
    #####:   66:    free(cache->ptr);
    #####:   67:    pthread_mutex_destroy(&cache->mutex);
    #####:   68:    free(cache);
    #####:   69:}
------------------
cache_destroy:
    #####:   57:void cache_destroy(cache_t *cache) {
    #####:   58:    while (cache->freecurr > 0) {
    #####:   59:        void *ptr = cache->ptr[--cache->freecurr];
    #####:   60:        if (cache->destructor) {
    #####:   61:            cache->destructor(get_object(ptr), NULL);
        -:   62:        }
    #####:   63:        free(ptr);
        -:   64:    }
    #####:   65:    free(cache->name);
    #####:   66:    free(cache->ptr);
    #####:   67:    pthread_mutex_destroy(&cache->mutex);
    #####:   68:    free(cache);
    #####:   69:}
------------------
cache_destroy:
    #####:   57:void cache_destroy(cache_t *cache) {
    #####:   58:    while (cache->freecurr > 0) {
    #####:   59:        void *ptr = cache->ptr[--cache->freecurr];
    #####:   60:        if (cache->destructor) {
    #####:   61:            cache->destructor(get_object(ptr), NULL);
        -:   62:        }
    #####:   63:        free(ptr);
        -:   64:    }
    #####:   65:    free(cache->name);
    #####:   66:    free(cache->ptr);
    #####:   67:    pthread_mutex_destroy(&cache->mutex);
    #####:   68:    free(cache);
    #####:   69:}
------------------
cache_destroy:
    #####:   57:void cache_destroy(cache_t *cache) {
    #####:   58:    while (cache->freecurr > 0) {
    #####:   59:        void *ptr = cache->ptr[--cache->freecurr];
    #####:   60:        if (cache->destructor) {
    #####:   61:            cache->destructor(get_object(ptr), NULL);
        -:   62:        }
    #####:   63:        free(ptr);
        -:   64:    }
    #####:   65:    free(cache->name);
    #####:   66:    free(cache->ptr);
    #####:   67:    pthread_mutex_destroy(&cache->mutex);
    #####:   68:    free(cache);
    #####:   69:}
------------------
cache_destroy:
    #####:   57:void cache_destroy(cache_t *cache) {
    #####:   58:    while (cache->freecurr > 0) {
    #####:   59:        void *ptr = cache->ptr[--cache->freecurr];
    #####:   60:        if (cache->destructor) {
    #####:   61:            cache->destructor(get_object(ptr), NULL);
        -:   62:        }
    #####:   63:        free(ptr);
        -:   64:    }
    #####:   65:    free(cache->name);
    #####:   66:    free(cache->ptr);
    #####:   67:    pthread_mutex_destroy(&cache->mutex);
    #####:   68:    free(cache);
    #####:   69:}
------------------
        -:   70:
    #####:   71:void* cache_alloc(cache_t *cache) {
    #####:   72:    void *ret;
    #####:   73:    pthread_mutex_lock(&cache->mutex);
    #####:   74:    ret = do_cache_alloc(cache);
    #####:   75:    pthread_mutex_unlock(&cache->mutex);
    #####:   76:    return ret;
        -:   77:}
------------------
cache_alloc:
    #####:   71:void* cache_alloc(cache_t *cache) {
    #####:   72:    void *ret;
    #####:   73:    pthread_mutex_lock(&cache->mutex);
    #####:   74:    ret = do_cache_alloc(cache);
    #####:   75:    pthread_mutex_unlock(&cache->mutex);
    #####:   76:    return ret;
        -:   77:}
------------------
cache_alloc:
    #####:   71:void* cache_alloc(cache_t *cache) {
    #####:   72:    void *ret;
    #####:   73:    pthread_mutex_lock(&cache->mutex);
    #####:   74:    ret = do_cache_alloc(cache);
    #####:   75:    pthread_mutex_unlock(&cache->mutex);
    #####:   76:    return ret;
        -:   77:}
------------------
cache_alloc:
    #####:   71:void* cache_alloc(cache_t *cache) {
    #####:   72:    void *ret;
    #####:   73:    pthread_mutex_lock(&cache->mutex);
    #####:   74:    ret = do_cache_alloc(cache);
    #####:   75:    pthread_mutex_unlock(&cache->mutex);
    #####:   76:    return ret;
        -:   77:}
------------------
cache_alloc:
    #####:   71:void* cache_alloc(cache_t *cache) {
    #####:   72:    void *ret;
    #####:   73:    pthread_mutex_lock(&cache->mutex);
    #####:   74:    ret = do_cache_alloc(cache);
    #####:   75:    pthread_mutex_unlock(&cache->mutex);
    #####:   76:    return ret;
        -:   77:}
------------------
cache_alloc:
    #####:   71:void* cache_alloc(cache_t *cache) {
    #####:   72:    void *ret;
    #####:   73:    pthread_mutex_lock(&cache->mutex);
    #####:   74:    ret = do_cache_alloc(cache);
    #####:   75:    pthread_mutex_unlock(&cache->mutex);
    #####:   76:    return ret;
        -:   77:}
------------------
        -:   78:
   157115:   79:void* do_cache_alloc(cache_t *cache) {
   157115:   80:    void *ret;
   157115:   81:    void *object;
   157115:   82:    if (cache->freecurr > 0) {
   156935:   83:        ret = cache->ptr[--cache->freecurr];
   156935:   84:        object = get_object(ret);
        -:   85:    } else {
      180:   86:        object = ret = malloc(cache->bufsize);
      180:   87:        if (ret != NULL) {
      360:   88:            object = get_object(ret);
        -:   89:
     180*:   90:            if (cache->constructor != NULL &&
    #####:   91:                cache->constructor(object, NULL, 0) != 0) {
    #####:   92:                free(ret);
    #####:   93:                object = NULL;
        -:   94:            }
        -:   95:        }
        -:   96:    }
        -:   97:
        -:   98:#ifndef NDEBUG
  157115*:   99:    if (object != NULL) {
        -:  100:        /* add a simple form of buffer-check */
   157115:  101:        uint64_t *pre = ret;
   157115:  102:        *pre = redzone_pattern;
   157115:  103:        ret = pre+1;
   157115:  104:        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
        -:  105:               &redzone_pattern, sizeof(redzone_pattern));
        -:  106:    }
        -:  107:#endif
        -:  108:
   157115:  109:    return object;
        -:  110:}
------------------
do_cache_alloc:
    31423:   79:void* do_cache_alloc(cache_t *cache) {
    31423:   80:    void *ret;
    31423:   81:    void *object;
    31423:   82:    if (cache->freecurr > 0) {
    31387:   83:        ret = cache->ptr[--cache->freecurr];
    31387:   84:        object = get_object(ret);
        -:   85:    } else {
       36:   86:        object = ret = malloc(cache->bufsize);
       36:   87:        if (ret != NULL) {
       72:   88:            object = get_object(ret);
        -:   89:
      36*:   90:            if (cache->constructor != NULL &&
    #####:   91:                cache->constructor(object, NULL, 0) != 0) {
    #####:   92:                free(ret);
    #####:   93:                object = NULL;
        -:   94:            }
        -:   95:        }
        -:   96:    }
        -:   97:
        -:   98:#ifndef NDEBUG
   31423*:   99:    if (object != NULL) {
        -:  100:        /* add a simple form of buffer-check */
    31423:  101:        uint64_t *pre = ret;
    31423:  102:        *pre = redzone_pattern;
    31423:  103:        ret = pre+1;
    31423:  104:        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
        -:  105:               &redzone_pattern, sizeof(redzone_pattern));
        -:  106:    }
        -:  107:#endif
        -:  108:
    31423:  109:    return object;
        -:  110:}
------------------
do_cache_alloc:
    31423:   79:void* do_cache_alloc(cache_t *cache) {
    31423:   80:    void *ret;
    31423:   81:    void *object;
    31423:   82:    if (cache->freecurr > 0) {
    31387:   83:        ret = cache->ptr[--cache->freecurr];
    31387:   84:        object = get_object(ret);
        -:   85:    } else {
       36:   86:        object = ret = malloc(cache->bufsize);
       36:   87:        if (ret != NULL) {
       72:   88:            object = get_object(ret);
        -:   89:
      36*:   90:            if (cache->constructor != NULL &&
    #####:   91:                cache->constructor(object, NULL, 0) != 0) {
    #####:   92:                free(ret);
    #####:   93:                object = NULL;
        -:   94:            }
        -:   95:        }
        -:   96:    }
        -:   97:
        -:   98:#ifndef NDEBUG
   31423*:   99:    if (object != NULL) {
        -:  100:        /* add a simple form of buffer-check */
    31423:  101:        uint64_t *pre = ret;
    31423:  102:        *pre = redzone_pattern;
    31423:  103:        ret = pre+1;
    31423:  104:        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
        -:  105:               &redzone_pattern, sizeof(redzone_pattern));
        -:  106:    }
        -:  107:#endif
        -:  108:
    31423:  109:    return object;
        -:  110:}
------------------
do_cache_alloc:
    31423:   79:void* do_cache_alloc(cache_t *cache) {
    31423:   80:    void *ret;
    31423:   81:    void *object;
    31423:   82:    if (cache->freecurr > 0) {
    31387:   83:        ret = cache->ptr[--cache->freecurr];
    31387:   84:        object = get_object(ret);
        -:   85:    } else {
       36:   86:        object = ret = malloc(cache->bufsize);
       36:   87:        if (ret != NULL) {
       72:   88:            object = get_object(ret);
        -:   89:
      36*:   90:            if (cache->constructor != NULL &&
    #####:   91:                cache->constructor(object, NULL, 0) != 0) {
    #####:   92:                free(ret);
    #####:   93:                object = NULL;
        -:   94:            }
        -:   95:        }
        -:   96:    }
        -:   97:
        -:   98:#ifndef NDEBUG
   31423*:   99:    if (object != NULL) {
        -:  100:        /* add a simple form of buffer-check */
    31423:  101:        uint64_t *pre = ret;
    31423:  102:        *pre = redzone_pattern;
    31423:  103:        ret = pre+1;
    31423:  104:        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
        -:  105:               &redzone_pattern, sizeof(redzone_pattern));
        -:  106:    }
        -:  107:#endif
        -:  108:
    31423:  109:    return object;
        -:  110:}
------------------
do_cache_alloc:
    31423:   79:void* do_cache_alloc(cache_t *cache) {
    31423:   80:    void *ret;
    31423:   81:    void *object;
    31423:   82:    if (cache->freecurr > 0) {
    31387:   83:        ret = cache->ptr[--cache->freecurr];
    31387:   84:        object = get_object(ret);
        -:   85:    } else {
       36:   86:        object = ret = malloc(cache->bufsize);
       36:   87:        if (ret != NULL) {
       72:   88:            object = get_object(ret);
        -:   89:
      36*:   90:            if (cache->constructor != NULL &&
    #####:   91:                cache->constructor(object, NULL, 0) != 0) {
    #####:   92:                free(ret);
    #####:   93:                object = NULL;
        -:   94:            }
        -:   95:        }
        -:   96:    }
        -:   97:
        -:   98:#ifndef NDEBUG
   31423*:   99:    if (object != NULL) {
        -:  100:        /* add a simple form of buffer-check */
    31423:  101:        uint64_t *pre = ret;
    31423:  102:        *pre = redzone_pattern;
    31423:  103:        ret = pre+1;
    31423:  104:        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
        -:  105:               &redzone_pattern, sizeof(redzone_pattern));
        -:  106:    }
        -:  107:#endif
        -:  108:
    31423:  109:    return object;
        -:  110:}
------------------
do_cache_alloc:
    31423:   79:void* do_cache_alloc(cache_t *cache) {
    31423:   80:    void *ret;
    31423:   81:    void *object;
    31423:   82:    if (cache->freecurr > 0) {
    31387:   83:        ret = cache->ptr[--cache->freecurr];
    31387:   84:        object = get_object(ret);
        -:   85:    } else {
       36:   86:        object = ret = malloc(cache->bufsize);
       36:   87:        if (ret != NULL) {
       72:   88:            object = get_object(ret);
        -:   89:
      36*:   90:            if (cache->constructor != NULL &&
    #####:   91:                cache->constructor(object, NULL, 0) != 0) {
    #####:   92:                free(ret);
    #####:   93:                object = NULL;
        -:   94:            }
        -:   95:        }
        -:   96:    }
        -:   97:
        -:   98:#ifndef NDEBUG
   31423*:   99:    if (object != NULL) {
        -:  100:        /* add a simple form of buffer-check */
    31423:  101:        uint64_t *pre = ret;
    31423:  102:        *pre = redzone_pattern;
    31423:  103:        ret = pre+1;
    31423:  104:        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
        -:  105:               &redzone_pattern, sizeof(redzone_pattern));
        -:  106:    }
        -:  107:#endif
        -:  108:
    31423:  109:    return object;
        -:  110:}
------------------
        -:  111:
    #####:  112:void cache_free(cache_t *cache, void *ptr) {
    #####:  113:    pthread_mutex_lock(&cache->mutex);
    #####:  114:    do_cache_free(cache, ptr);
    #####:  115:    pthread_mutex_unlock(&cache->mutex);
    #####:  116:}
------------------
cache_free:
    #####:  112:void cache_free(cache_t *cache, void *ptr) {
    #####:  113:    pthread_mutex_lock(&cache->mutex);
    #####:  114:    do_cache_free(cache, ptr);
    #####:  115:    pthread_mutex_unlock(&cache->mutex);
    #####:  116:}
------------------
cache_free:
    #####:  112:void cache_free(cache_t *cache, void *ptr) {
    #####:  113:    pthread_mutex_lock(&cache->mutex);
    #####:  114:    do_cache_free(cache, ptr);
    #####:  115:    pthread_mutex_unlock(&cache->mutex);
    #####:  116:}
------------------
cache_free:
    #####:  112:void cache_free(cache_t *cache, void *ptr) {
    #####:  113:    pthread_mutex_lock(&cache->mutex);
    #####:  114:    do_cache_free(cache, ptr);
    #####:  115:    pthread_mutex_unlock(&cache->mutex);
    #####:  116:}
------------------
cache_free:
    #####:  112:void cache_free(cache_t *cache, void *ptr) {
    #####:  113:    pthread_mutex_lock(&cache->mutex);
    #####:  114:    do_cache_free(cache, ptr);
    #####:  115:    pthread_mutex_unlock(&cache->mutex);
    #####:  116:}
------------------
cache_free:
    #####:  112:void cache_free(cache_t *cache, void *ptr) {
    #####:  113:    pthread_mutex_lock(&cache->mutex);
    #####:  114:    do_cache_free(cache, ptr);
    #####:  115:    pthread_mutex_unlock(&cache->mutex);
    #####:  116:}
------------------
        -:  117:
   157115:  118:void do_cache_free(cache_t *cache, void *ptr) {
        -:  119:#ifndef NDEBUG
        -:  120:    /* validate redzone... */
   157115:  121:    if (memcmp(((char*)ptr) + cache->bufsize - (2 * sizeof(redzone_pattern)),
        -:  122:               &redzone_pattern, sizeof(redzone_pattern)) != 0) {
    #####:  123:        raise(SIGABRT);
    #####:  124:        cache_error = 1;
    #####:  125:        return;
        -:  126:    }
   157115:  127:    uint64_t *pre = ptr;
   157115:  128:    --pre;
   157115:  129:    if (*pre != redzone_pattern) {
    #####:  130:        raise(SIGABRT);
    #####:  131:        cache_error = -1;
    #####:  132:        return;
        -:  133:    }
   157115:  134:    ptr = pre;
        -:  135:#endif
   157115:  136:    if (cache->freecurr < cache->freetotal) {
   157115:  137:        cache->ptr[cache->freecurr++] = ptr;
        -:  138:    } else {
        -:  139:        /* try to enlarge free connections array */
    #####:  140:        size_t newtotal = cache->freetotal * 2;
    #####:  141:        void **new_free = realloc(cache->ptr, sizeof(char *) * newtotal);
    #####:  142:        if (new_free) {
    #####:  143:            cache->freetotal = newtotal;
    #####:  144:            cache->ptr = new_free;
    #####:  145:            cache->ptr[cache->freecurr++] = ptr;
        -:  146:        } else {
    #####:  147:            if (cache->destructor) {
    #####:  148:                cache->destructor(ptr, NULL);
        -:  149:            }
    #####:  150:            free(ptr);
        -:  151:
        -:  152:        }
        -:  153:    }
        -:  154:}
        -:  155:
