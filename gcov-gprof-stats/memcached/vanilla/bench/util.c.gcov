        -:    0:Source:util.c
        -:    0:Programs:54
        -:    1:#include <stdio.h>
        -:    2:#include <assert.h>
        -:    3:#include <ctype.h>
        -:    4:#include <errno.h>
        -:    5:#include <string.h>
        -:    6:#include <stdlib.h>
        -:    7:#include <stdarg.h>
        -:    8:
        -:    9:#include "memcached.h"
        -:   10:
        -:   11:static char *uriencode_map[256];
        -:   12:static char uriencode_str[768];
        -:   13:
        3:   14:void uriencode_init(void) {
        3:   15:    int x;
        3:   16:    char *str = uriencode_str;
      771:   17:    for (x = 0; x < 256; x++) {
      768:   18:        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
      198:   19:            uriencode_map[x] = NULL;
        -:   20:        } else {
      570:   21:            snprintf(str, 4, "%%%02hhX", (unsigned char)x);
      570:   22:            uriencode_map[x] = str;
      570:   23:            str += 3; /* lobbing off the \0 is fine */
        -:   24:        }
        -:   25:    }
        3:   26:}
------------------
uriencode_init:
        1:   14:void uriencode_init(void) {
        1:   15:    int x;
        1:   16:    char *str = uriencode_str;
      257:   17:    for (x = 0; x < 256; x++) {
      256:   18:        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
       66:   19:            uriencode_map[x] = NULL;
        -:   20:        } else {
      190:   21:            snprintf(str, 4, "%%%02hhX", (unsigned char)x);
      190:   22:            uriencode_map[x] = str;
      190:   23:            str += 3; /* lobbing off the \0 is fine */
        -:   24:        }
        -:   25:    }
        1:   26:}
------------------
uriencode_init:
        1:   14:void uriencode_init(void) {
        1:   15:    int x;
        1:   16:    char *str = uriencode_str;
      257:   17:    for (x = 0; x < 256; x++) {
      256:   18:        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
       66:   19:            uriencode_map[x] = NULL;
        -:   20:        } else {
      190:   21:            snprintf(str, 4, "%%%02hhX", (unsigned char)x);
      190:   22:            uriencode_map[x] = str;
      190:   23:            str += 3; /* lobbing off the \0 is fine */
        -:   24:        }
        -:   25:    }
        1:   26:}
------------------
uriencode_init:
        1:   14:void uriencode_init(void) {
        1:   15:    int x;
        1:   16:    char *str = uriencode_str;
      257:   17:    for (x = 0; x < 256; x++) {
      256:   18:        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
       66:   19:            uriencode_map[x] = NULL;
        -:   20:        } else {
      190:   21:            snprintf(str, 4, "%%%02hhX", (unsigned char)x);
      190:   22:            uriencode_map[x] = str;
      190:   23:            str += 3; /* lobbing off the \0 is fine */
        -:   24:        }
        -:   25:    }
        1:   26:}
------------------
        -:   27:
    #####:   28:bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    #####:   29:    int x;
    #####:   30:    size_t d = 0;
    #####:   31:    for (x = 0; x < srclen; x++) {
    #####:   32:        if (d + 4 > dstlen)
        -:   33:            return false;
    #####:   34:        if (uriencode_map[(unsigned char) src[x]] != NULL) {
    #####:   35:            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
    #####:   36:            d += 3;
        -:   37:        } else {
    #####:   38:            dst[d] = src[x];
    #####:   39:            d++;
        -:   40:        }
        -:   41:    }
    #####:   42:    dst[d] = '\0';
    #####:   43:    return true;
        -:   44:}
------------------
uriencode:
    #####:   28:bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    #####:   29:    int x;
    #####:   30:    size_t d = 0;
    #####:   31:    for (x = 0; x < srclen; x++) {
    #####:   32:        if (d + 4 > dstlen)
        -:   33:            return false;
    #####:   34:        if (uriencode_map[(unsigned char) src[x]] != NULL) {
    #####:   35:            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
    #####:   36:            d += 3;
        -:   37:        } else {
    #####:   38:            dst[d] = src[x];
    #####:   39:            d++;
        -:   40:        }
        -:   41:    }
    #####:   42:    dst[d] = '\0';
    #####:   43:    return true;
        -:   44:}
------------------
uriencode:
    #####:   28:bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    #####:   29:    int x;
    #####:   30:    size_t d = 0;
    #####:   31:    for (x = 0; x < srclen; x++) {
    #####:   32:        if (d + 4 > dstlen)
        -:   33:            return false;
    #####:   34:        if (uriencode_map[(unsigned char) src[x]] != NULL) {
    #####:   35:            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
    #####:   36:            d += 3;
        -:   37:        } else {
    #####:   38:            dst[d] = src[x];
    #####:   39:            d++;
        -:   40:        }
        -:   41:    }
    #####:   42:    dst[d] = '\0';
    #####:   43:    return true;
        -:   44:}
------------------
uriencode:
    #####:   28:bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    #####:   29:    int x;
    #####:   30:    size_t d = 0;
    #####:   31:    for (x = 0; x < srclen; x++) {
    #####:   32:        if (d + 4 > dstlen)
        -:   33:            return false;
    #####:   34:        if (uriencode_map[(unsigned char) src[x]] != NULL) {
    #####:   35:            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
    #####:   36:            d += 3;
        -:   37:        } else {
    #####:   38:            dst[d] = src[x];
    #####:   39:            d++;
        -:   40:        }
        -:   41:    }
    #####:   42:    dst[d] = '\0';
    #####:   43:    return true;
        -:   44:}
------------------
        -:   45:
        -:   46:/* Avoid warnings on solaris, where isspace() is an index into an array, and gcc uses signed chars */
        -:   47:#define xisspace(c) isspace((unsigned char)c)
        -:   48:
    #####:   49:bool safe_strtoull(const char *str, uint64_t *out) {
    #####:   50:    assert(out != NULL);
    #####:   51:    errno = 0;
    #####:   52:    *out = 0;
    #####:   53:    char *endptr;
    #####:   54:    unsigned long long ull = strtoull(str, &endptr, 10);
    #####:   55:    if ((errno == ERANGE) || (str == endptr)) {
        -:   56:        return false;
        -:   57:    }
        -:   58:
    #####:   59:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   60:        if ((long long) ull < 0) {
        -:   61:            /* only check for negative signs in the uncommon case when
        -:   62:             * the unsigned number is so big that it's negative as a
        -:   63:             * signed number. */
    #####:   64:            if (strchr(str, '-') != NULL) {
        -:   65:                return false;
        -:   66:            }
        -:   67:        }
    #####:   68:        *out = ull;
    #####:   69:        return true;
        -:   70:    }
        -:   71:    return false;
        -:   72:}
------------------
safe_strtoull:
    #####:   49:bool safe_strtoull(const char *str, uint64_t *out) {
    #####:   50:    assert(out != NULL);
    #####:   51:    errno = 0;
    #####:   52:    *out = 0;
    #####:   53:    char *endptr;
    #####:   54:    unsigned long long ull = strtoull(str, &endptr, 10);
    #####:   55:    if ((errno == ERANGE) || (str == endptr)) {
        -:   56:        return false;
        -:   57:    }
        -:   58:
    #####:   59:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   60:        if ((long long) ull < 0) {
        -:   61:            /* only check for negative signs in the uncommon case when
        -:   62:             * the unsigned number is so big that it's negative as a
        -:   63:             * signed number. */
    #####:   64:            if (strchr(str, '-') != NULL) {
        -:   65:                return false;
        -:   66:            }
        -:   67:        }
    #####:   68:        *out = ull;
    #####:   69:        return true;
        -:   70:    }
        -:   71:    return false;
        -:   72:}
------------------
safe_strtoull:
    #####:   49:bool safe_strtoull(const char *str, uint64_t *out) {
    #####:   50:    assert(out != NULL);
    #####:   51:    errno = 0;
    #####:   52:    *out = 0;
    #####:   53:    char *endptr;
    #####:   54:    unsigned long long ull = strtoull(str, &endptr, 10);
    #####:   55:    if ((errno == ERANGE) || (str == endptr)) {
        -:   56:        return false;
        -:   57:    }
        -:   58:
    #####:   59:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   60:        if ((long long) ull < 0) {
        -:   61:            /* only check for negative signs in the uncommon case when
        -:   62:             * the unsigned number is so big that it's negative as a
        -:   63:             * signed number. */
    #####:   64:            if (strchr(str, '-') != NULL) {
        -:   65:                return false;
        -:   66:            }
        -:   67:        }
    #####:   68:        *out = ull;
    #####:   69:        return true;
        -:   70:    }
        -:   71:    return false;
        -:   72:}
------------------
safe_strtoull:
    #####:   49:bool safe_strtoull(const char *str, uint64_t *out) {
    #####:   50:    assert(out != NULL);
    #####:   51:    errno = 0;
    #####:   52:    *out = 0;
    #####:   53:    char *endptr;
    #####:   54:    unsigned long long ull = strtoull(str, &endptr, 10);
    #####:   55:    if ((errno == ERANGE) || (str == endptr)) {
        -:   56:        return false;
        -:   57:    }
        -:   58:
    #####:   59:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   60:        if ((long long) ull < 0) {
        -:   61:            /* only check for negative signs in the uncommon case when
        -:   62:             * the unsigned number is so big that it's negative as a
        -:   63:             * signed number. */
    #####:   64:            if (strchr(str, '-') != NULL) {
        -:   65:                return false;
        -:   66:            }
        -:   67:        }
    #####:   68:        *out = ull;
    #####:   69:        return true;
        -:   70:    }
        -:   71:    return false;
        -:   72:}
------------------
        -:   73:
    #####:   74:bool safe_strtoll(const char *str, int64_t *out) {
    #####:   75:    assert(out != NULL);
    #####:   76:    errno = 0;
    #####:   77:    *out = 0;
    #####:   78:    char *endptr;
    #####:   79:    long long ll = strtoll(str, &endptr, 10);
    #####:   80:    if ((errno == ERANGE) || (str == endptr)) {
        -:   81:        return false;
        -:   82:    }
        -:   83:
    #####:   84:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   85:        *out = ll;
    #####:   86:        return true;
        -:   87:    }
        -:   88:    return false;
        -:   89:}
------------------
safe_strtoll:
    #####:   74:bool safe_strtoll(const char *str, int64_t *out) {
    #####:   75:    assert(out != NULL);
    #####:   76:    errno = 0;
    #####:   77:    *out = 0;
    #####:   78:    char *endptr;
    #####:   79:    long long ll = strtoll(str, &endptr, 10);
    #####:   80:    if ((errno == ERANGE) || (str == endptr)) {
        -:   81:        return false;
        -:   82:    }
        -:   83:
    #####:   84:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   85:        *out = ll;
    #####:   86:        return true;
        -:   87:    }
        -:   88:    return false;
        -:   89:}
------------------
safe_strtoll:
    #####:   74:bool safe_strtoll(const char *str, int64_t *out) {
    #####:   75:    assert(out != NULL);
    #####:   76:    errno = 0;
    #####:   77:    *out = 0;
    #####:   78:    char *endptr;
    #####:   79:    long long ll = strtoll(str, &endptr, 10);
    #####:   80:    if ((errno == ERANGE) || (str == endptr)) {
        -:   81:        return false;
        -:   82:    }
        -:   83:
    #####:   84:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   85:        *out = ll;
    #####:   86:        return true;
        -:   87:    }
        -:   88:    return false;
        -:   89:}
------------------
safe_strtoll:
    #####:   74:bool safe_strtoll(const char *str, int64_t *out) {
    #####:   75:    assert(out != NULL);
    #####:   76:    errno = 0;
    #####:   77:    *out = 0;
    #####:   78:    char *endptr;
    #####:   79:    long long ll = strtoll(str, &endptr, 10);
    #####:   80:    if ((errno == ERANGE) || (str == endptr)) {
        -:   81:        return false;
        -:   82:    }
        -:   83:
    #####:   84:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:   85:        *out = ll;
    #####:   86:        return true;
        -:   87:    }
        -:   88:    return false;
        -:   89:}
------------------
        -:   90:
    #####:   91:bool safe_strtoul(const char *str, uint32_t *out) {
    #####:   92:    char *endptr = NULL;
    #####:   93:    unsigned long l = 0;
    #####:   94:    assert(out);
    #####:   95:    assert(str);
    #####:   96:    *out = 0;
    #####:   97:    errno = 0;
        -:   98:
    #####:   99:    l = strtoul(str, &endptr, 10);
    #####:  100:    if ((errno == ERANGE) || (str == endptr)) {
        -:  101:        return false;
        -:  102:    }
        -:  103:
    #####:  104:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  105:        if ((long) l < 0) {
        -:  106:            /* only check for negative signs in the uncommon case when
        -:  107:             * the unsigned number is so big that it's negative as a
        -:  108:             * signed number. */
    #####:  109:            if (strchr(str, '-') != NULL) {
        -:  110:                return false;
        -:  111:            }
        -:  112:        }
    #####:  113:        *out = l;
    #####:  114:        return true;
        -:  115:    }
        -:  116:
        -:  117:    return false;
        -:  118:}
------------------
safe_strtoul:
    #####:   91:bool safe_strtoul(const char *str, uint32_t *out) {
    #####:   92:    char *endptr = NULL;
    #####:   93:    unsigned long l = 0;
    #####:   94:    assert(out);
    #####:   95:    assert(str);
    #####:   96:    *out = 0;
    #####:   97:    errno = 0;
        -:   98:
    #####:   99:    l = strtoul(str, &endptr, 10);
    #####:  100:    if ((errno == ERANGE) || (str == endptr)) {
        -:  101:        return false;
        -:  102:    }
        -:  103:
    #####:  104:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  105:        if ((long) l < 0) {
        -:  106:            /* only check for negative signs in the uncommon case when
        -:  107:             * the unsigned number is so big that it's negative as a
        -:  108:             * signed number. */
    #####:  109:            if (strchr(str, '-') != NULL) {
        -:  110:                return false;
        -:  111:            }
        -:  112:        }
    #####:  113:        *out = l;
    #####:  114:        return true;
        -:  115:    }
        -:  116:
        -:  117:    return false;
        -:  118:}
------------------
safe_strtoul:
    #####:   91:bool safe_strtoul(const char *str, uint32_t *out) {
    #####:   92:    char *endptr = NULL;
    #####:   93:    unsigned long l = 0;
    #####:   94:    assert(out);
    #####:   95:    assert(str);
    #####:   96:    *out = 0;
    #####:   97:    errno = 0;
        -:   98:
    #####:   99:    l = strtoul(str, &endptr, 10);
    #####:  100:    if ((errno == ERANGE) || (str == endptr)) {
        -:  101:        return false;
        -:  102:    }
        -:  103:
    #####:  104:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  105:        if ((long) l < 0) {
        -:  106:            /* only check for negative signs in the uncommon case when
        -:  107:             * the unsigned number is so big that it's negative as a
        -:  108:             * signed number. */
    #####:  109:            if (strchr(str, '-') != NULL) {
        -:  110:                return false;
        -:  111:            }
        -:  112:        }
    #####:  113:        *out = l;
    #####:  114:        return true;
        -:  115:    }
        -:  116:
        -:  117:    return false;
        -:  118:}
------------------
safe_strtoul:
    #####:   91:bool safe_strtoul(const char *str, uint32_t *out) {
    #####:   92:    char *endptr = NULL;
    #####:   93:    unsigned long l = 0;
    #####:   94:    assert(out);
    #####:   95:    assert(str);
    #####:   96:    *out = 0;
    #####:   97:    errno = 0;
        -:   98:
    #####:   99:    l = strtoul(str, &endptr, 10);
    #####:  100:    if ((errno == ERANGE) || (str == endptr)) {
        -:  101:        return false;
        -:  102:    }
        -:  103:
    #####:  104:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  105:        if ((long) l < 0) {
        -:  106:            /* only check for negative signs in the uncommon case when
        -:  107:             * the unsigned number is so big that it's negative as a
        -:  108:             * signed number. */
    #####:  109:            if (strchr(str, '-') != NULL) {
        -:  110:                return false;
        -:  111:            }
        -:  112:        }
    #####:  113:        *out = l;
    #####:  114:        return true;
        -:  115:    }
        -:  116:
        -:  117:    return false;
        -:  118:}
------------------
        -:  119:
    #####:  120:bool safe_strtol(const char *str, int32_t *out) {
    #####:  121:    assert(out != NULL);
    #####:  122:    errno = 0;
    #####:  123:    *out = 0;
    #####:  124:    char *endptr;
    #####:  125:    long l = strtol(str, &endptr, 10);
    #####:  126:    if ((errno == ERANGE) || (str == endptr)) {
        -:  127:        return false;
        -:  128:    }
        -:  129:
    #####:  130:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  131:        *out = l;
    #####:  132:        return true;
        -:  133:    }
        -:  134:    return false;
        -:  135:}
------------------
safe_strtol:
    #####:  120:bool safe_strtol(const char *str, int32_t *out) {
    #####:  121:    assert(out != NULL);
    #####:  122:    errno = 0;
    #####:  123:    *out = 0;
    #####:  124:    char *endptr;
    #####:  125:    long l = strtol(str, &endptr, 10);
    #####:  126:    if ((errno == ERANGE) || (str == endptr)) {
        -:  127:        return false;
        -:  128:    }
        -:  129:
    #####:  130:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  131:        *out = l;
    #####:  132:        return true;
        -:  133:    }
        -:  134:    return false;
        -:  135:}
------------------
safe_strtol:
    #####:  120:bool safe_strtol(const char *str, int32_t *out) {
    #####:  121:    assert(out != NULL);
    #####:  122:    errno = 0;
    #####:  123:    *out = 0;
    #####:  124:    char *endptr;
    #####:  125:    long l = strtol(str, &endptr, 10);
    #####:  126:    if ((errno == ERANGE) || (str == endptr)) {
        -:  127:        return false;
        -:  128:    }
        -:  129:
    #####:  130:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  131:        *out = l;
    #####:  132:        return true;
        -:  133:    }
        -:  134:    return false;
        -:  135:}
------------------
safe_strtol:
    #####:  120:bool safe_strtol(const char *str, int32_t *out) {
    #####:  121:    assert(out != NULL);
    #####:  122:    errno = 0;
    #####:  123:    *out = 0;
    #####:  124:    char *endptr;
    #####:  125:    long l = strtol(str, &endptr, 10);
    #####:  126:    if ((errno == ERANGE) || (str == endptr)) {
        -:  127:        return false;
        -:  128:    }
        -:  129:
    #####:  130:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  131:        *out = l;
    #####:  132:        return true;
        -:  133:    }
        -:  134:    return false;
        -:  135:}
------------------
        -:  136:
    #####:  137:bool safe_strtod(const char *str, double *out) {
    #####:  138:    assert(out != NULL);
    #####:  139:    errno = 0;
    #####:  140:    *out = 0;
    #####:  141:    char *endptr;
    #####:  142:    double d = strtod(str, &endptr);
    #####:  143:    if ((errno == ERANGE) || (str == endptr)) {
        -:  144:        return false;
        -:  145:    }
        -:  146:
    #####:  147:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  148:        *out = d;
    #####:  149:        return true;
        -:  150:    }
        -:  151:    return false;
        -:  152:}
------------------
safe_strtod:
    #####:  137:bool safe_strtod(const char *str, double *out) {
    #####:  138:    assert(out != NULL);
    #####:  139:    errno = 0;
    #####:  140:    *out = 0;
    #####:  141:    char *endptr;
    #####:  142:    double d = strtod(str, &endptr);
    #####:  143:    if ((errno == ERANGE) || (str == endptr)) {
        -:  144:        return false;
        -:  145:    }
        -:  146:
    #####:  147:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  148:        *out = d;
    #####:  149:        return true;
        -:  150:    }
        -:  151:    return false;
        -:  152:}
------------------
safe_strtod:
    #####:  137:bool safe_strtod(const char *str, double *out) {
    #####:  138:    assert(out != NULL);
    #####:  139:    errno = 0;
    #####:  140:    *out = 0;
    #####:  141:    char *endptr;
    #####:  142:    double d = strtod(str, &endptr);
    #####:  143:    if ((errno == ERANGE) || (str == endptr)) {
        -:  144:        return false;
        -:  145:    }
        -:  146:
    #####:  147:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  148:        *out = d;
    #####:  149:        return true;
        -:  150:    }
        -:  151:    return false;
        -:  152:}
------------------
safe_strtod:
    #####:  137:bool safe_strtod(const char *str, double *out) {
    #####:  138:    assert(out != NULL);
    #####:  139:    errno = 0;
    #####:  140:    *out = 0;
    #####:  141:    char *endptr;
    #####:  142:    double d = strtod(str, &endptr);
    #####:  143:    if ((errno == ERANGE) || (str == endptr)) {
        -:  144:        return false;
        -:  145:    }
        -:  146:
    #####:  147:    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
    #####:  148:        *out = d;
    #####:  149:        return true;
        -:  150:    }
        -:  151:    return false;
        -:  152:}
------------------
        -:  153:
    #####:  154:void vperror(const char *fmt, ...) {
    #####:  155:    int old_errno = errno;
    #####:  156:    char buf[1024];
    #####:  157:    va_list ap;
        -:  158:
    #####:  159:    va_start(ap, fmt);
    #####:  160:    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
    #####:  161:        buf[sizeof(buf) - 1] = '\0';
        -:  162:    }
    #####:  163:    va_end(ap);
        -:  164:
    #####:  165:    errno = old_errno;
        -:  166:
    #####:  167:    perror(buf);
    #####:  168:}
------------------
vperror:
    #####:  154:void vperror(const char *fmt, ...) {
    #####:  155:    int old_errno = errno;
    #####:  156:    char buf[1024];
    #####:  157:    va_list ap;
        -:  158:
    #####:  159:    va_start(ap, fmt);
    #####:  160:    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
    #####:  161:        buf[sizeof(buf) - 1] = '\0';
        -:  162:    }
    #####:  163:    va_end(ap);
        -:  164:
    #####:  165:    errno = old_errno;
        -:  166:
    #####:  167:    perror(buf);
    #####:  168:}
------------------
vperror:
    #####:  154:void vperror(const char *fmt, ...) {
    #####:  155:    int old_errno = errno;
    #####:  156:    char buf[1024];
    #####:  157:    va_list ap;
        -:  158:
    #####:  159:    va_start(ap, fmt);
    #####:  160:    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
    #####:  161:        buf[sizeof(buf) - 1] = '\0';
        -:  162:    }
    #####:  163:    va_end(ap);
        -:  164:
    #####:  165:    errno = old_errno;
        -:  166:
    #####:  167:    perror(buf);
    #####:  168:}
------------------
vperror:
    #####:  154:void vperror(const char *fmt, ...) {
    #####:  155:    int old_errno = errno;
    #####:  156:    char buf[1024];
    #####:  157:    va_list ap;
        -:  158:
    #####:  159:    va_start(ap, fmt);
    #####:  160:    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
    #####:  161:        buf[sizeof(buf) - 1] = '\0';
        -:  162:    }
    #####:  163:    va_end(ap);
        -:  164:
    #####:  165:    errno = old_errno;
        -:  166:
    #####:  167:    perror(buf);
    #####:  168:}
------------------
        -:  169:
        -:  170:#ifndef HAVE_HTONLL
        -:  171:static uint64_t mc_swap64(uint64_t in) {
        -:  172:#ifdef ENDIAN_LITTLE
        -:  173:    /* Little endian, flip the bytes around until someone makes a faster/better
        -:  174:    * way to do this. */
   600000:  175:    int64_t rv = 0;
   600000:  176:    int i = 0;
  5400000:  177:     for(i = 0; i<8; i++) {
  4800000:  178:        rv = (rv << 8) | (in & 0xff);
  4800000:  179:        in >>= 8;
        -:  180:     }
   600000:  181:    return rv;
        -:  182:#else
        -:  183:    /* big-endian machines don't need byte swapping */
        -:  184:    return in;
        -:  185:#endif
        -:  186:}
        -:  187:
   300000:  188:uint64_t ntohll(uint64_t val) {
   300000:  189:   return mc_swap64(val);
        -:  190:}
------------------
ntohll:
   100000:  188:uint64_t ntohll(uint64_t val) {
   100000:  189:   return mc_swap64(val);
        -:  190:}
------------------
ntohll:
   100000:  188:uint64_t ntohll(uint64_t val) {
   100000:  189:   return mc_swap64(val);
        -:  190:}
------------------
ntohll:
   100000:  188:uint64_t ntohll(uint64_t val) {
   100000:  189:   return mc_swap64(val);
        -:  190:}
------------------
        -:  191:
   300000:  192:uint64_t htonll(uint64_t val) {
   300000:  193:   return mc_swap64(val);
        -:  194:}
        -:  195:#endif
        -:  196:
