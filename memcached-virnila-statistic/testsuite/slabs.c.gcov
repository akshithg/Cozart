        -:    0:Source:slabs.c
        -:    0:Programs:54
        -:    0:Source is newer than graph
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: * Slabs memory allocation, based on powers-of-N. Slabs are up to 1MB in size
        -:    4: * and are divided into chunks. The chunk sizes start off at the size of the
        -:    5: * "item" structure plus space for a small key and value. They increase by
        -:    6: * a multiplier factor from there, up to half the maximum slab size. The last
        -:    7: * slab size is always 1MB, since that's the maximum item size allowed by the
        -:    8: * memcached protocol.
        -:    9: */
        -:   10:#include "memcached.h"
        -:   11:#include <sys/mman.h>
        -:   12:#include <sys/stat.h>
        -:   13:#include <sys/socket.h>
        -:   14:#include <sys/resource.h>
        -:   15:#include <fcntl.h>
        -:   16:#include <netinet/in.h>
        -:   17:#include <errno.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <stdio.h>
        -:   20:#include <string.h>
        -:   21:#include <signal.h>
        -:   22:#include <assert.h>
        -:   23:#include <pthread.h>
        -:   24:
        -:   25://#define DEBUG_SLAB_MOVER
        -:   26:/* powers-of-N allocation structures */
        -:   27:
        -:   28:typedef struct {
        -:   29:    unsigned int size;      /* sizes of items */
        -:   30:    unsigned int perslab;   /* how many items per slab */
        -:   31:
        -:   32:    void *slots;           /* list of item ptrs */
        -:   33:    unsigned int sl_curr;   /* total free items in list */
        -:   34:
        -:   35:    unsigned int slabs;     /* how many slabs were allocated for this class */
        -:   36:
        -:   37:    void **slab_list;       /* array of slab pointers */
        -:   38:    unsigned int list_size; /* size of prev array */
        -:   39:
        -:   40:    size_t requested; /* The number of requested bytes */
        -:   41:} slabclass_t;
        -:   42:
        -:   43:static slabclass_t slabclass[MAX_NUMBER_OF_SLAB_CLASSES];
        -:   44:static size_t mem_limit = 0;
        -:   45:static size_t mem_malloced = 0;
        -:   46:/* If the memory limit has been hit once. Used as a hint to decide when to
        -:   47: * early-wake the LRU maintenance thread */
        -:   48:static bool mem_limit_reached = false;
        -:   49:static int power_largest;
        -:   50:
        -:   51:static void *mem_base = NULL;
        -:   52:static void *mem_current = NULL;
        -:   53:static size_t mem_avail = 0;
        -:   54:#ifdef EXTSTORE
        -:   55:static void *storage  = NULL;
        -:   56:#endif
        -:   57:/**
        -:   58: * Access to the slab allocator is protected by this lock
        -:   59: */
        -:   60:static pthread_mutex_t slabs_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   61:static pthread_mutex_t slabs_rebalance_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   62:
        -:   63:/*
        -:   64: * Forward Declarations
        -:   65: */
        -:   66:static int grow_slab_list (const unsigned int id);
        -:   67:static int do_slabs_newslab(const unsigned int id);
        -:   68:static void *memory_allocate(size_t size);
        -:   69:static void do_slabs_free(void *ptr, const size_t size, unsigned int id);
        -:   70:
        -:   71:/* Preallocate as many slab pages as possible (called from slabs_init)
        -:   72:   on start-up, so users don't get confused out-of-memory errors when
        -:   73:   they do have free (in-slab) space, but no space to make new slabs.
        -:   74:   if maxslabs is 18 (POWER_LARGEST - POWER_SMALLEST + 1), then all
        -:   75:   slab types can be made.  if max memory is less than 18 MB, only the
        -:   76:   smaller ones will be made.  */
        -:   77:static void slabs_preallocate (const unsigned int maxslabs);
        -:   78:#ifdef EXTSTORE
        -:   79:void slabs_set_storage(void *arg) {
        -:   80:    storage = arg;
        -:   81:}
        -:   82:#endif
        -:   83:/*
        -:   84: * Figures out which slab class (chunk size) is required to store an item of
        -:   85: * a given size.
        -:   86: *
        -:   87: * Given object size, return id to use when allocating/freeing memory for object
        -:   88: * 0 means error: can't store such a large object
        -:   89: */
        -:   90:
   824988:   91:unsigned int slabs_clsid(const size_t size) {
   824988:   92:    int res = POWER_SMALLEST;
        -:   93:
   824988:   94:    if (size == 0 || size > settings.item_size_max)
        -:   95:        return 0;
 11314851:   96:    while (size > slabclass[res].size)
 10548786:   97:        if (res++ == power_largest)     /* won't fit in the biggest slab */
    58899:   98:            return power_largest;
   766065:   99:    return res;
        -:  100:}
------------------
slabs_clsid:
   274996:   91:unsigned int slabs_clsid(const size_t size) {
   274996:   92:    int res = POWER_SMALLEST;
        -:   93:
   274996:   94:    if (size == 0 || size > settings.item_size_max)
        -:   95:        return 0;
  3771617:   96:    while (size > slabclass[res].size)
  3516262:   97:        if (res++ == power_largest)     /* won't fit in the biggest slab */
    19633:   98:            return power_largest;
   255355:   99:    return res;
        -:  100:}
------------------
slabs_clsid:
   274996:   91:unsigned int slabs_clsid(const size_t size) {
   274996:   92:    int res = POWER_SMALLEST;
        -:   93:
   274996:   94:    if (size == 0 || size > settings.item_size_max)
        -:   95:        return 0;
  3771617:   96:    while (size > slabclass[res].size)
  3516262:   97:        if (res++ == power_largest)     /* won't fit in the biggest slab */
    19633:   98:            return power_largest;
   255355:   99:    return res;
        -:  100:}
------------------
slabs_clsid:
   274996:   91:unsigned int slabs_clsid(const size_t size) {
   274996:   92:    int res = POWER_SMALLEST;
        -:   93:
   274996:   94:    if (size == 0 || size > settings.item_size_max)
        -:   95:        return 0;
  3771617:   96:    while (size > slabclass[res].size)
  3516262:   97:        if (res++ == power_largest)     /* won't fit in the biggest slab */
    19633:   98:            return power_largest;
   255355:   99:    return res;
        -:  100:}
------------------
        -:  101:
        -:  102:#if defined(__linux__) && defined(MADV_HUGEPAGE)
        -:  103:/* Function split out for better error path handling */
    #####:  104:static void * alloc_large_chunk_linux(const size_t limit)
        -:  105:{
    #####:  106:    size_t pagesize = 0;
    #####:  107:    void *ptr = NULL;
    #####:  108:    FILE *fp;
    #####:  109:    int ret;
        -:  110:
        -:  111:    /* Get the size of huge pages */
    #####:  112:    fp = fopen("/proc/meminfo", "r");
    #####:  113:    if (fp != NULL) {
        -:  114:        char buf[64];
        -:  115:
    #####:  116:        while ((fgets(buf, sizeof(buf), fp)))
    #####:  117:            if (!strncmp(buf, "Hugepagesize:", 13)) {
    #####:  118:                ret = sscanf(buf + 13, "%zu\n", &pagesize);
        -:  119:
        -:  120:                /* meminfo huge page size is in KiBs */
    #####:  121:                pagesize <<= 10;
        -:  122:            }
    #####:  123:        fclose(fp);
        -:  124:    }
        -:  125:
    #####:  126:    if (!pagesize) {
    #####:  127:        fprintf(stderr, "Failed to get supported huge page size\n");
    #####:  128:        return NULL;
        -:  129:    }
        -:  130:
    #####:  131:    if (settings.verbose > 1)
    #####:  132:        fprintf(stderr, "huge page size: %zu\n", pagesize);
        -:  133:
        -:  134:    /* This works because glibc simply uses mmap when the alignment is
        -:  135:     * above a certain limit. */
    #####:  136:    ret = posix_memalign(&ptr, pagesize, limit);
    #####:  137:    if (ret != 0) {
    #####:  138:        fprintf(stderr, "Failed to get aligned memory chunk: %d\n", ret);
    #####:  139:        return NULL;
        -:  140:    }
        -:  141:
    #####:  142:    ret = madvise(ptr, limit, MADV_HUGEPAGE);
    #####:  143:    if (ret < 0) {
    #####:  144:        fprintf(stderr, "Failed to set transparent hugepage hint: %d\n", ret);
    #####:  145:        free(ptr);
    #####:  146:        ptr = NULL;
        -:  147:    }
        -:  148:
        -:  149:    return ptr;
        -:  150:}
------------------
alloc_large_chunk_linux:
    #####:  104:static void * alloc_large_chunk_linux(const size_t limit)
        -:  105:{
    #####:  106:    size_t pagesize = 0;
    #####:  107:    void *ptr = NULL;
    #####:  108:    FILE *fp;
    #####:  109:    int ret;
        -:  110:
        -:  111:    /* Get the size of huge pages */
    #####:  112:    fp = fopen("/proc/meminfo", "r");
    #####:  113:    if (fp != NULL) {
        -:  114:        char buf[64];
        -:  115:
    #####:  116:        while ((fgets(buf, sizeof(buf), fp)))
    #####:  117:            if (!strncmp(buf, "Hugepagesize:", 13)) {
    #####:  118:                ret = sscanf(buf + 13, "%zu\n", &pagesize);
        -:  119:
        -:  120:                /* meminfo huge page size is in KiBs */
    #####:  121:                pagesize <<= 10;
        -:  122:            }
    #####:  123:        fclose(fp);
        -:  124:    }
        -:  125:
    #####:  126:    if (!pagesize) {
    #####:  127:        fprintf(stderr, "Failed to get supported huge page size\n");
    #####:  128:        return NULL;
        -:  129:    }
        -:  130:
    #####:  131:    if (settings.verbose > 1)
    #####:  132:        fprintf(stderr, "huge page size: %zu\n", pagesize);
        -:  133:
        -:  134:    /* This works because glibc simply uses mmap when the alignment is
        -:  135:     * above a certain limit. */
    #####:  136:    ret = posix_memalign(&ptr, pagesize, limit);
    #####:  137:    if (ret != 0) {
    #####:  138:        fprintf(stderr, "Failed to get aligned memory chunk: %d\n", ret);
    #####:  139:        return NULL;
        -:  140:    }
        -:  141:
    #####:  142:    ret = madvise(ptr, limit, MADV_HUGEPAGE);
    #####:  143:    if (ret < 0) {
    #####:  144:        fprintf(stderr, "Failed to set transparent hugepage hint: %d\n", ret);
    #####:  145:        free(ptr);
    #####:  146:        ptr = NULL;
        -:  147:    }
        -:  148:
        -:  149:    return ptr;
        -:  150:}
------------------
alloc_large_chunk_linux:
    #####:  104:static void * alloc_large_chunk_linux(const size_t limit)
        -:  105:{
    #####:  106:    size_t pagesize = 0;
    #####:  107:    void *ptr = NULL;
    #####:  108:    FILE *fp;
    #####:  109:    int ret;
        -:  110:
        -:  111:    /* Get the size of huge pages */
    #####:  112:    fp = fopen("/proc/meminfo", "r");
    #####:  113:    if (fp != NULL) {
        -:  114:        char buf[64];
        -:  115:
    #####:  116:        while ((fgets(buf, sizeof(buf), fp)))
    #####:  117:            if (!strncmp(buf, "Hugepagesize:", 13)) {
    #####:  118:                ret = sscanf(buf + 13, "%zu\n", &pagesize);
        -:  119:
        -:  120:                /* meminfo huge page size is in KiBs */
    #####:  121:                pagesize <<= 10;
        -:  122:            }
    #####:  123:        fclose(fp);
        -:  124:    }
        -:  125:
    #####:  126:    if (!pagesize) {
    #####:  127:        fprintf(stderr, "Failed to get supported huge page size\n");
    #####:  128:        return NULL;
        -:  129:    }
        -:  130:
    #####:  131:    if (settings.verbose > 1)
    #####:  132:        fprintf(stderr, "huge page size: %zu\n", pagesize);
        -:  133:
        -:  134:    /* This works because glibc simply uses mmap when the alignment is
        -:  135:     * above a certain limit. */
    #####:  136:    ret = posix_memalign(&ptr, pagesize, limit);
    #####:  137:    if (ret != 0) {
    #####:  138:        fprintf(stderr, "Failed to get aligned memory chunk: %d\n", ret);
    #####:  139:        return NULL;
        -:  140:    }
        -:  141:
    #####:  142:    ret = madvise(ptr, limit, MADV_HUGEPAGE);
    #####:  143:    if (ret < 0) {
    #####:  144:        fprintf(stderr, "Failed to set transparent hugepage hint: %d\n", ret);
    #####:  145:        free(ptr);
    #####:  146:        ptr = NULL;
        -:  147:    }
        -:  148:
        -:  149:    return ptr;
        -:  150:}
------------------
alloc_large_chunk_linux:
    #####:  104:static void * alloc_large_chunk_linux(const size_t limit)
        -:  105:{
    #####:  106:    size_t pagesize = 0;
    #####:  107:    void *ptr = NULL;
    #####:  108:    FILE *fp;
    #####:  109:    int ret;
        -:  110:
        -:  111:    /* Get the size of huge pages */
    #####:  112:    fp = fopen("/proc/meminfo", "r");
    #####:  113:    if (fp != NULL) {
        -:  114:        char buf[64];
        -:  115:
    #####:  116:        while ((fgets(buf, sizeof(buf), fp)))
    #####:  117:            if (!strncmp(buf, "Hugepagesize:", 13)) {
    #####:  118:                ret = sscanf(buf + 13, "%zu\n", &pagesize);
        -:  119:
        -:  120:                /* meminfo huge page size is in KiBs */
    #####:  121:                pagesize <<= 10;
        -:  122:            }
    #####:  123:        fclose(fp);
        -:  124:    }
        -:  125:
    #####:  126:    if (!pagesize) {
    #####:  127:        fprintf(stderr, "Failed to get supported huge page size\n");
    #####:  128:        return NULL;
        -:  129:    }
        -:  130:
    #####:  131:    if (settings.verbose > 1)
    #####:  132:        fprintf(stderr, "huge page size: %zu\n", pagesize);
        -:  133:
        -:  134:    /* This works because glibc simply uses mmap when the alignment is
        -:  135:     * above a certain limit. */
    #####:  136:    ret = posix_memalign(&ptr, pagesize, limit);
    #####:  137:    if (ret != 0) {
    #####:  138:        fprintf(stderr, "Failed to get aligned memory chunk: %d\n", ret);
    #####:  139:        return NULL;
        -:  140:    }
        -:  141:
    #####:  142:    ret = madvise(ptr, limit, MADV_HUGEPAGE);
    #####:  143:    if (ret < 0) {
    #####:  144:        fprintf(stderr, "Failed to set transparent hugepage hint: %d\n", ret);
    #####:  145:        free(ptr);
    #####:  146:        ptr = NULL;
        -:  147:    }
        -:  148:
        -:  149:    return ptr;
        -:  150:}
------------------
        -:  151:#endif
        -:  152:
        -:  153:/**
        -:  154: * Determines the chunk sizes and initializes the slab class descriptors
        -:  155: * accordingly.
        -:  156: */
      285:  157:void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes) {
      285:  158:    int i = POWER_SMALLEST - 1;
      285:  159:    unsigned int size = sizeof(item) + settings.chunk_size;
        -:  160:
        -:  161:    /* Some platforms use runtime transparent hugepages. If for any reason
        -:  162:     * the initial allocation fails, the required settings do not persist
        -:  163:     * for remaining allocations. As such it makes little sense to do slab
        -:  164:     * preallocation. */
      285:  165:    bool __attribute__ ((unused)) do_slab_prealloc = false;
        -:  166:
      285:  167:    mem_limit = limit;
        -:  168:
      285:  169:    if (prealloc) {
        -:  170:#if defined(__linux__) && defined(MADV_HUGEPAGE)
    #####:  171:        mem_base = alloc_large_chunk_linux(mem_limit);
    #####:  172:        if (mem_base)
    #####:  173:            do_slab_prealloc = true;
        -:  174:#else
        -:  175:        /* Allocate everything in a big chunk with malloc */
        -:  176:        mem_base = malloc(mem_limit);
        -:  177:        do_slab_prealloc = true;
        -:  178:#endif
    #####:  179:        if (mem_base != NULL) {
    #####:  180:            mem_current = mem_base;
    #####:  181:            mem_avail = mem_limit;
        -:  182:        } else {
    #####:  183:            fprintf(stderr, "Warning: Failed to allocate requested memory in"
        -:  184:                    " one large chunk.\nWill allocate in smaller chunks\n");
        -:  185:        }
        -:  186:    }
        -:  187:
      285:  188:    memset(slabclass, 0, sizeof(slabclass));
        -:  189:
    10857:  190:    while (++i < MAX_NUMBER_OF_SLAB_CLASSES-1) {
    10857:  191:        if (slab_sizes != NULL) {
    #####:  192:            if (slab_sizes[i-1] == 0)
        -:  193:                break;
        -:  194:            size = slab_sizes[i-1];
    10857:  195:        } else if (size >= settings.slab_chunk_size_max / factor) {
        -:  196:            break;
        -:  197:        }
        -:  198:        /* Make sure items are always n-byte aligned */
    10572:  199:        if (size % CHUNK_ALIGN_BYTES)
     6951:  200:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  201:
    10572:  202:        slabclass[i].size = size;
    10572:  203:        slabclass[i].perslab = settings.slab_page_size / slabclass[i].size;
    10572:  204:        if (slab_sizes == NULL)
    10572:  205:            size *= factor;
    10572:  206:        if (settings.verbose > 1) {
      342:  207:            fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  208:                    i, slabclass[i].size, slabclass[i].perslab);
        -:  209:        }
        -:  210:    }
        -:  211:
      285:  212:    power_largest = i;
      285:  213:    slabclass[power_largest].size = settings.slab_chunk_size_max;
      285:  214:    slabclass[power_largest].perslab = settings.slab_page_size / settings.slab_chunk_size_max;
      285:  215:    if (settings.verbose > 1) {
        9:  216:        fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  217:                i, slabclass[i].size, slabclass[i].perslab);
        -:  218:    }
        -:  219:
        -:  220:    /* for the test suite:  faking of how much we've already malloc'd */
        -:  221:    {
      285:  222:        char *t_initial_malloc = getenv("T_MEMD_INITIAL_MALLOC");
      285:  223:        if (t_initial_malloc) {
        3:  224:            mem_malloced = (size_t)atol(t_initial_malloc);
        -:  225:        }
        -:  226:
        -:  227:    }
        -:  228:
      285:  229:    if (prealloc && do_slab_prealloc) {
    #####:  230:        slabs_preallocate(power_largest);
        -:  231:    }
      285:  232:}
------------------
slabs_init:
       95:  157:void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes) {
       95:  158:    int i = POWER_SMALLEST - 1;
       95:  159:    unsigned int size = sizeof(item) + settings.chunk_size;
        -:  160:
        -:  161:    /* Some platforms use runtime transparent hugepages. If for any reason
        -:  162:     * the initial allocation fails, the required settings do not persist
        -:  163:     * for remaining allocations. As such it makes little sense to do slab
        -:  164:     * preallocation. */
       95:  165:    bool __attribute__ ((unused)) do_slab_prealloc = false;
        -:  166:
       95:  167:    mem_limit = limit;
        -:  168:
       95:  169:    if (prealloc) {
        -:  170:#if defined(__linux__) && defined(MADV_HUGEPAGE)
    #####:  171:        mem_base = alloc_large_chunk_linux(mem_limit);
    #####:  172:        if (mem_base)
    #####:  173:            do_slab_prealloc = true;
        -:  174:#else
        -:  175:        /* Allocate everything in a big chunk with malloc */
        -:  176:        mem_base = malloc(mem_limit);
        -:  177:        do_slab_prealloc = true;
        -:  178:#endif
    #####:  179:        if (mem_base != NULL) {
    #####:  180:            mem_current = mem_base;
    #####:  181:            mem_avail = mem_limit;
        -:  182:        } else {
    #####:  183:            fprintf(stderr, "Warning: Failed to allocate requested memory in"
        -:  184:                    " one large chunk.\nWill allocate in smaller chunks\n");
        -:  185:        }
        -:  186:    }
        -:  187:
       95:  188:    memset(slabclass, 0, sizeof(slabclass));
        -:  189:
     3619:  190:    while (++i < MAX_NUMBER_OF_SLAB_CLASSES-1) {
     3619:  191:        if (slab_sizes != NULL) {
    #####:  192:            if (slab_sizes[i-1] == 0)
        -:  193:                break;
        -:  194:            size = slab_sizes[i-1];
     3619:  195:        } else if (size >= settings.slab_chunk_size_max / factor) {
        -:  196:            break;
        -:  197:        }
        -:  198:        /* Make sure items are always n-byte aligned */
     3524:  199:        if (size % CHUNK_ALIGN_BYTES)
     2317:  200:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  201:
     3524:  202:        slabclass[i].size = size;
     3524:  203:        slabclass[i].perslab = settings.slab_page_size / slabclass[i].size;
     3524:  204:        if (slab_sizes == NULL)
     3524:  205:            size *= factor;
     3524:  206:        if (settings.verbose > 1) {
      114:  207:            fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  208:                    i, slabclass[i].size, slabclass[i].perslab);
        -:  209:        }
        -:  210:    }
        -:  211:
       95:  212:    power_largest = i;
       95:  213:    slabclass[power_largest].size = settings.slab_chunk_size_max;
       95:  214:    slabclass[power_largest].perslab = settings.slab_page_size / settings.slab_chunk_size_max;
       95:  215:    if (settings.verbose > 1) {
        3:  216:        fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  217:                i, slabclass[i].size, slabclass[i].perslab);
        -:  218:    }
        -:  219:
        -:  220:    /* for the test suite:  faking of how much we've already malloc'd */
        -:  221:    {
       95:  222:        char *t_initial_malloc = getenv("T_MEMD_INITIAL_MALLOC");
       95:  223:        if (t_initial_malloc) {
        1:  224:            mem_malloced = (size_t)atol(t_initial_malloc);
        -:  225:        }
        -:  226:
        -:  227:    }
        -:  228:
       95:  229:    if (prealloc && do_slab_prealloc) {
    #####:  230:        slabs_preallocate(power_largest);
        -:  231:    }
       95:  232:}
------------------
slabs_init:
       95:  157:void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes) {
       95:  158:    int i = POWER_SMALLEST - 1;
       95:  159:    unsigned int size = sizeof(item) + settings.chunk_size;
        -:  160:
        -:  161:    /* Some platforms use runtime transparent hugepages. If for any reason
        -:  162:     * the initial allocation fails, the required settings do not persist
        -:  163:     * for remaining allocations. As such it makes little sense to do slab
        -:  164:     * preallocation. */
       95:  165:    bool __attribute__ ((unused)) do_slab_prealloc = false;
        -:  166:
       95:  167:    mem_limit = limit;
        -:  168:
       95:  169:    if (prealloc) {
        -:  170:#if defined(__linux__) && defined(MADV_HUGEPAGE)
    #####:  171:        mem_base = alloc_large_chunk_linux(mem_limit);
    #####:  172:        if (mem_base)
    #####:  173:            do_slab_prealloc = true;
        -:  174:#else
        -:  175:        /* Allocate everything in a big chunk with malloc */
        -:  176:        mem_base = malloc(mem_limit);
        -:  177:        do_slab_prealloc = true;
        -:  178:#endif
    #####:  179:        if (mem_base != NULL) {
    #####:  180:            mem_current = mem_base;
    #####:  181:            mem_avail = mem_limit;
        -:  182:        } else {
    #####:  183:            fprintf(stderr, "Warning: Failed to allocate requested memory in"
        -:  184:                    " one large chunk.\nWill allocate in smaller chunks\n");
        -:  185:        }
        -:  186:    }
        -:  187:
       95:  188:    memset(slabclass, 0, sizeof(slabclass));
        -:  189:
     3619:  190:    while (++i < MAX_NUMBER_OF_SLAB_CLASSES-1) {
     3619:  191:        if (slab_sizes != NULL) {
    #####:  192:            if (slab_sizes[i-1] == 0)
        -:  193:                break;
        -:  194:            size = slab_sizes[i-1];
     3619:  195:        } else if (size >= settings.slab_chunk_size_max / factor) {
        -:  196:            break;
        -:  197:        }
        -:  198:        /* Make sure items are always n-byte aligned */
     3524:  199:        if (size % CHUNK_ALIGN_BYTES)
     2317:  200:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  201:
     3524:  202:        slabclass[i].size = size;
     3524:  203:        slabclass[i].perslab = settings.slab_page_size / slabclass[i].size;
     3524:  204:        if (slab_sizes == NULL)
     3524:  205:            size *= factor;
     3524:  206:        if (settings.verbose > 1) {
      114:  207:            fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  208:                    i, slabclass[i].size, slabclass[i].perslab);
        -:  209:        }
        -:  210:    }
        -:  211:
       95:  212:    power_largest = i;
       95:  213:    slabclass[power_largest].size = settings.slab_chunk_size_max;
       95:  214:    slabclass[power_largest].perslab = settings.slab_page_size / settings.slab_chunk_size_max;
       95:  215:    if (settings.verbose > 1) {
        3:  216:        fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  217:                i, slabclass[i].size, slabclass[i].perslab);
        -:  218:    }
        -:  219:
        -:  220:    /* for the test suite:  faking of how much we've already malloc'd */
        -:  221:    {
       95:  222:        char *t_initial_malloc = getenv("T_MEMD_INITIAL_MALLOC");
       95:  223:        if (t_initial_malloc) {
        1:  224:            mem_malloced = (size_t)atol(t_initial_malloc);
        -:  225:        }
        -:  226:
        -:  227:    }
        -:  228:
       95:  229:    if (prealloc && do_slab_prealloc) {
    #####:  230:        slabs_preallocate(power_largest);
        -:  231:    }
       95:  232:}
------------------
slabs_init:
       95:  157:void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes) {
       95:  158:    int i = POWER_SMALLEST - 1;
       95:  159:    unsigned int size = sizeof(item) + settings.chunk_size;
        -:  160:
        -:  161:    /* Some platforms use runtime transparent hugepages. If for any reason
        -:  162:     * the initial allocation fails, the required settings do not persist
        -:  163:     * for remaining allocations. As such it makes little sense to do slab
        -:  164:     * preallocation. */
       95:  165:    bool __attribute__ ((unused)) do_slab_prealloc = false;
        -:  166:
       95:  167:    mem_limit = limit;
        -:  168:
       95:  169:    if (prealloc) {
        -:  170:#if defined(__linux__) && defined(MADV_HUGEPAGE)
    #####:  171:        mem_base = alloc_large_chunk_linux(mem_limit);
    #####:  172:        if (mem_base)
    #####:  173:            do_slab_prealloc = true;
        -:  174:#else
        -:  175:        /* Allocate everything in a big chunk with malloc */
        -:  176:        mem_base = malloc(mem_limit);
        -:  177:        do_slab_prealloc = true;
        -:  178:#endif
    #####:  179:        if (mem_base != NULL) {
    #####:  180:            mem_current = mem_base;
    #####:  181:            mem_avail = mem_limit;
        -:  182:        } else {
    #####:  183:            fprintf(stderr, "Warning: Failed to allocate requested memory in"
        -:  184:                    " one large chunk.\nWill allocate in smaller chunks\n");
        -:  185:        }
        -:  186:    }
        -:  187:
       95:  188:    memset(slabclass, 0, sizeof(slabclass));
        -:  189:
     3619:  190:    while (++i < MAX_NUMBER_OF_SLAB_CLASSES-1) {
     3619:  191:        if (slab_sizes != NULL) {
    #####:  192:            if (slab_sizes[i-1] == 0)
        -:  193:                break;
        -:  194:            size = slab_sizes[i-1];
     3619:  195:        } else if (size >= settings.slab_chunk_size_max / factor) {
        -:  196:            break;
        -:  197:        }
        -:  198:        /* Make sure items are always n-byte aligned */
     3524:  199:        if (size % CHUNK_ALIGN_BYTES)
     2317:  200:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  201:
     3524:  202:        slabclass[i].size = size;
     3524:  203:        slabclass[i].perslab = settings.slab_page_size / slabclass[i].size;
     3524:  204:        if (slab_sizes == NULL)
     3524:  205:            size *= factor;
     3524:  206:        if (settings.verbose > 1) {
      114:  207:            fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  208:                    i, slabclass[i].size, slabclass[i].perslab);
        -:  209:        }
        -:  210:    }
        -:  211:
       95:  212:    power_largest = i;
       95:  213:    slabclass[power_largest].size = settings.slab_chunk_size_max;
       95:  214:    slabclass[power_largest].perslab = settings.slab_page_size / settings.slab_chunk_size_max;
       95:  215:    if (settings.verbose > 1) {
        3:  216:        fprintf(stderr, "slab class %3d: chunk size %9u perslab %7u\n",
        -:  217:                i, slabclass[i].size, slabclass[i].perslab);
        -:  218:    }
        -:  219:
        -:  220:    /* for the test suite:  faking of how much we've already malloc'd */
        -:  221:    {
       95:  222:        char *t_initial_malloc = getenv("T_MEMD_INITIAL_MALLOC");
       95:  223:        if (t_initial_malloc) {
        1:  224:            mem_malloced = (size_t)atol(t_initial_malloc);
        -:  225:        }
        -:  226:
        -:  227:    }
        -:  228:
       95:  229:    if (prealloc && do_slab_prealloc) {
    #####:  230:        slabs_preallocate(power_largest);
        -:  231:    }
       95:  232:}
------------------
        -:  233:
    #####:  234:void slabs_prefill_global(void) {
    #####:  235:    void *ptr;
    #####:  236:    slabclass_t *p = &slabclass[0];
    #####:  237:    int len = settings.slab_page_size;
        -:  238:
    #####:  239:    while (mem_malloced < mem_limit
    #####:  240:            && (ptr = memory_allocate(len)) != NULL) {
    #####:  241:        grow_slab_list(0);
    #####:  242:        p->slab_list[p->slabs++] = ptr;
        -:  243:    }
    #####:  244:    mem_limit_reached = true;
    #####:  245:}
------------------
slabs_prefill_global:
    #####:  234:void slabs_prefill_global(void) {
    #####:  235:    void *ptr;
    #####:  236:    slabclass_t *p = &slabclass[0];
    #####:  237:    int len = settings.slab_page_size;
        -:  238:
    #####:  239:    while (mem_malloced < mem_limit
    #####:  240:            && (ptr = memory_allocate(len)) != NULL) {
    #####:  241:        grow_slab_list(0);
    #####:  242:        p->slab_list[p->slabs++] = ptr;
        -:  243:    }
    #####:  244:    mem_limit_reached = true;
    #####:  245:}
------------------
slabs_prefill_global:
    #####:  234:void slabs_prefill_global(void) {
    #####:  235:    void *ptr;
    #####:  236:    slabclass_t *p = &slabclass[0];
    #####:  237:    int len = settings.slab_page_size;
        -:  238:
    #####:  239:    while (mem_malloced < mem_limit
    #####:  240:            && (ptr = memory_allocate(len)) != NULL) {
    #####:  241:        grow_slab_list(0);
    #####:  242:        p->slab_list[p->slabs++] = ptr;
        -:  243:    }
    #####:  244:    mem_limit_reached = true;
    #####:  245:}
------------------
slabs_prefill_global:
    #####:  234:void slabs_prefill_global(void) {
    #####:  235:    void *ptr;
    #####:  236:    slabclass_t *p = &slabclass[0];
    #####:  237:    int len = settings.slab_page_size;
        -:  238:
    #####:  239:    while (mem_malloced < mem_limit
    #####:  240:            && (ptr = memory_allocate(len)) != NULL) {
    #####:  241:        grow_slab_list(0);
    #####:  242:        p->slab_list[p->slabs++] = ptr;
        -:  243:    }
    #####:  244:    mem_limit_reached = true;
    #####:  245:}
------------------
        -:  246:
    #####:  247:static void slabs_preallocate (const unsigned int maxslabs) {
    #####:  248:    int i;
    #####:  249:    unsigned int prealloc = 0;
        -:  250:
        -:  251:    /* pre-allocate a 1MB slab in every size class so people don't get
        -:  252:       confused by non-intuitive "SERVER_ERROR out of memory"
        -:  253:       messages.  this is the most common question on the mailing
        -:  254:       list.  if you really don't want this, you can rebuild without
        -:  255:       these three lines.  */
        -:  256:
    #####:  257:    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
    #####:  258:        if (++prealloc > maxslabs)
        -:  259:            return;
    #####:  260:        if (do_slabs_newslab(i) == 0) {
    #####:  261:            fprintf(stderr, "Error while preallocating slab memory!\n"
        -:  262:                "If using -L or other prealloc options, max memory must be "
        -:  263:                "at least %d megabytes.\n", power_largest);
    #####:  264:            exit(1);
        -:  265:        }
        -:  266:    }
        -:  267:}
------------------
slabs_preallocate:
    #####:  247:static void slabs_preallocate (const unsigned int maxslabs) {
    #####:  248:    int i;
    #####:  249:    unsigned int prealloc = 0;
        -:  250:
        -:  251:    /* pre-allocate a 1MB slab in every size class so people don't get
        -:  252:       confused by non-intuitive "SERVER_ERROR out of memory"
        -:  253:       messages.  this is the most common question on the mailing
        -:  254:       list.  if you really don't want this, you can rebuild without
        -:  255:       these three lines.  */
        -:  256:
    #####:  257:    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
    #####:  258:        if (++prealloc > maxslabs)
        -:  259:            return;
    #####:  260:        if (do_slabs_newslab(i) == 0) {
    #####:  261:            fprintf(stderr, "Error while preallocating slab memory!\n"
        -:  262:                "If using -L or other prealloc options, max memory must be "
        -:  263:                "at least %d megabytes.\n", power_largest);
    #####:  264:            exit(1);
        -:  265:        }
        -:  266:    }
        -:  267:}
------------------
slabs_preallocate:
    #####:  247:static void slabs_preallocate (const unsigned int maxslabs) {
    #####:  248:    int i;
    #####:  249:    unsigned int prealloc = 0;
        -:  250:
        -:  251:    /* pre-allocate a 1MB slab in every size class so people don't get
        -:  252:       confused by non-intuitive "SERVER_ERROR out of memory"
        -:  253:       messages.  this is the most common question on the mailing
        -:  254:       list.  if you really don't want this, you can rebuild without
        -:  255:       these three lines.  */
        -:  256:
    #####:  257:    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
    #####:  258:        if (++prealloc > maxslabs)
        -:  259:            return;
    #####:  260:        if (do_slabs_newslab(i) == 0) {
    #####:  261:            fprintf(stderr, "Error while preallocating slab memory!\n"
        -:  262:                "If using -L or other prealloc options, max memory must be "
        -:  263:                "at least %d megabytes.\n", power_largest);
    #####:  264:            exit(1);
        -:  265:        }
        -:  266:    }
        -:  267:}
------------------
slabs_preallocate:
    #####:  247:static void slabs_preallocate (const unsigned int maxslabs) {
    #####:  248:    int i;
    #####:  249:    unsigned int prealloc = 0;
        -:  250:
        -:  251:    /* pre-allocate a 1MB slab in every size class so people don't get
        -:  252:       confused by non-intuitive "SERVER_ERROR out of memory"
        -:  253:       messages.  this is the most common question on the mailing
        -:  254:       list.  if you really don't want this, you can rebuild without
        -:  255:       these three lines.  */
        -:  256:
    #####:  257:    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
    #####:  258:        if (++prealloc > maxslabs)
        -:  259:            return;
    #####:  260:        if (do_slabs_newslab(i) == 0) {
    #####:  261:            fprintf(stderr, "Error while preallocating slab memory!\n"
        -:  262:                "If using -L or other prealloc options, max memory must be "
        -:  263:                "at least %d megabytes.\n", power_largest);
    #####:  264:            exit(1);
        -:  265:        }
        -:  266:    }
        -:  267:}
------------------
        -:  268:
     2427:  269:static int grow_slab_list (const unsigned int id) {
     2427:  270:    slabclass_t *p = &slabclass[id];
     2427:  271:    if (p->slabs == p->list_size) {
      543:  272:        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
      543:  273:        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
      543:  274:        if (new_list == 0) return 0;
      543:  275:        p->list_size = new_size;
      543:  276:        p->slab_list = new_list;
        -:  277:    }
        -:  278:    return 1;
        -:  279:}
------------------
grow_slab_list:
      809:  269:static int grow_slab_list (const unsigned int id) {
      809:  270:    slabclass_t *p = &slabclass[id];
      809:  271:    if (p->slabs == p->list_size) {
      181:  272:        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
      181:  273:        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
      181:  274:        if (new_list == 0) return 0;
      181:  275:        p->list_size = new_size;
      181:  276:        p->slab_list = new_list;
        -:  277:    }
        -:  278:    return 1;
        -:  279:}
------------------
grow_slab_list:
      809:  269:static int grow_slab_list (const unsigned int id) {
      809:  270:    slabclass_t *p = &slabclass[id];
      809:  271:    if (p->slabs == p->list_size) {
      181:  272:        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
      181:  273:        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
      181:  274:        if (new_list == 0) return 0;
      181:  275:        p->list_size = new_size;
      181:  276:        p->slab_list = new_list;
        -:  277:    }
        -:  278:    return 1;
        -:  279:}
------------------
grow_slab_list:
      809:  269:static int grow_slab_list (const unsigned int id) {
      809:  270:    slabclass_t *p = &slabclass[id];
      809:  271:    if (p->slabs == p->list_size) {
      181:  272:        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
      181:  273:        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
      181:  274:        if (new_list == 0) return 0;
      181:  275:        p->list_size = new_size;
      181:  276:        p->slab_list = new_list;
        -:  277:    }
        -:  278:    return 1;
        -:  279:}
------------------
        -:  280:
        -:  281:static void split_slab_page_into_freelist(char *ptr, const unsigned int id) {
        -:  282:    slabclass_t *p = &slabclass[id];
        -:  283:    int x;
  1960221:  284:    for (x = 0; x < p->perslab; x++) {
  1958079:  285:        do_slabs_free(ptr, 0, id);
  1958079:  286:        ptr += p->size;
        -:  287:    }
        -:  288:}
        -:  289:
        -:  290:/* Fast FIFO queue */
        -:  291:static void *get_page_from_global_pool(void) {
     2166:  292:    slabclass_t *p = &slabclass[SLAB_GLOBAL_PAGE_POOL];
     2166:  293:    if (p->slabs < 1) {
        -:  294:        return NULL;
        -:  295:    }
      264:  296:    char *ret = p->slab_list[p->slabs - 1];
      264:  297:    p->slabs--;
      264:  298:    return ret;
        -:  299:}
        -:  300:
    86952:  301:static int do_slabs_newslab(const unsigned int id) {
    86952:  302:    slabclass_t *p = &slabclass[id];
    86952:  303:    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
      630:  304:    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        -:  305:        ? settings.slab_page_size
    87582:  306:        : p->size * p->perslab;
    86952:  307:    char *ptr;
        -:  308:
    86952:  309:    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
    84987:  310:         && g->slabs == 0)) {
    84816:  311:        mem_limit_reached = true;
    84816:  312:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    84816:  313:        return 0;
        -:  314:    }
        -:  315:
     2136:  316:    if ((grow_slab_list(id) == 0) ||
     2136:  317:        (((ptr = get_page_from_global_pool()) == NULL) &&
     1887:  318:        ((ptr = memory_allocate((size_t)len)) == 0))) {
        -:  319:
    #####:  320:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    #####:  321:        return 0;
        -:  322:    }
        -:  323:
     2136:  324:    memset(ptr, 0, (size_t)len);
     2136:  325:    split_slab_page_into_freelist(ptr, id);
        -:  326:
     2136:  327:    p->slab_list[p->slabs++] = ptr;
     2136:  328:    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);
        -:  329:
     2136:  330:    return 1;
        -:  331:}
------------------
do_slabs_newslab:
    28984:  301:static int do_slabs_newslab(const unsigned int id) {
    28984:  302:    slabclass_t *p = &slabclass[id];
    28984:  303:    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
      210:  304:    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        -:  305:        ? settings.slab_page_size
    29194:  306:        : p->size * p->perslab;
    28984:  307:    char *ptr;
        -:  308:
    28984:  309:    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
    28329:  310:         && g->slabs == 0)) {
    28272:  311:        mem_limit_reached = true;
    28272:  312:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    28272:  313:        return 0;
        -:  314:    }
        -:  315:
      712:  316:    if ((grow_slab_list(id) == 0) ||
      712:  317:        (((ptr = get_page_from_global_pool()) == NULL) &&
      629:  318:        ((ptr = memory_allocate((size_t)len)) == 0))) {
        -:  319:
    #####:  320:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    #####:  321:        return 0;
        -:  322:    }
        -:  323:
      712:  324:    memset(ptr, 0, (size_t)len);
      712:  325:    split_slab_page_into_freelist(ptr, id);
        -:  326:
      712:  327:    p->slab_list[p->slabs++] = ptr;
      712:  328:    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);
        -:  329:
      712:  330:    return 1;
        -:  331:}
------------------
do_slabs_newslab:
    28984:  301:static int do_slabs_newslab(const unsigned int id) {
    28984:  302:    slabclass_t *p = &slabclass[id];
    28984:  303:    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
      210:  304:    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        -:  305:        ? settings.slab_page_size
    29194:  306:        : p->size * p->perslab;
    28984:  307:    char *ptr;
        -:  308:
    28984:  309:    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
    28329:  310:         && g->slabs == 0)) {
    28272:  311:        mem_limit_reached = true;
    28272:  312:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    28272:  313:        return 0;
        -:  314:    }
        -:  315:
      712:  316:    if ((grow_slab_list(id) == 0) ||
      712:  317:        (((ptr = get_page_from_global_pool()) == NULL) &&
      629:  318:        ((ptr = memory_allocate((size_t)len)) == 0))) {
        -:  319:
    #####:  320:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    #####:  321:        return 0;
        -:  322:    }
        -:  323:
      712:  324:    memset(ptr, 0, (size_t)len);
      712:  325:    split_slab_page_into_freelist(ptr, id);
        -:  326:
      712:  327:    p->slab_list[p->slabs++] = ptr;
      712:  328:    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);
        -:  329:
      712:  330:    return 1;
        -:  331:}
------------------
do_slabs_newslab:
    28984:  301:static int do_slabs_newslab(const unsigned int id) {
    28984:  302:    slabclass_t *p = &slabclass[id];
    28984:  303:    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
      210:  304:    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        -:  305:        ? settings.slab_page_size
    29194:  306:        : p->size * p->perslab;
    28984:  307:    char *ptr;
        -:  308:
    28984:  309:    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
    28329:  310:         && g->slabs == 0)) {
    28272:  311:        mem_limit_reached = true;
    28272:  312:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    28272:  313:        return 0;
        -:  314:    }
        -:  315:
      712:  316:    if ((grow_slab_list(id) == 0) ||
      712:  317:        (((ptr = get_page_from_global_pool()) == NULL) &&
      629:  318:        ((ptr = memory_allocate((size_t)len)) == 0))) {
        -:  319:
    #####:  320:        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
    #####:  321:        return 0;
        -:  322:    }
        -:  323:
      712:  324:    memset(ptr, 0, (size_t)len);
      712:  325:    split_slab_page_into_freelist(ptr, id);
        -:  326:
      712:  327:    p->slab_list[p->slabs++] = ptr;
      712:  328:    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);
        -:  329:
      712:  330:    return 1;
        -:  331:}
------------------
        -:  332:
        -:  333:/*@null@*/
   857448:  334:static void *do_slabs_alloc(const size_t size, unsigned int id, uint64_t *total_bytes,
        -:  335:        unsigned int flags) {
   857448:  336:    slabclass_t *p;
   857448:  337:    void *ret = NULL;
   857448:  338:    item *it = NULL;
        -:  339:
   857448:  340:    if (id < POWER_SMALLEST || id > power_largest) {
        -:  341:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        -:  342:        return NULL;
        -:  343:    }
   857448:  344:    p = &slabclass[id];
  857448*:  345:    assert(p->sl_curr == 0 || ((item *)p->slots)->slabs_clsid == 0);
   857448:  346:    if (total_bytes != NULL) {
   850851:  347:        *total_bytes = p->requested;
        -:  348:    }
        -:  349:
  857448*:  350:    assert(size <= p->size);
        -:  351:    /* fail unless we have space at the end of a recently allocated page,
        -:  352:       we have something on our freelist, or we could allocate a new page */
   857448:  353:    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
    86952:  354:        do_slabs_newslab(id);
        -:  355:    }
        -:  356:
   857448:  357:    if (p->sl_curr != 0) {
        -:  358:        /* return off our freelist */
   771375:  359:        it = (item *)p->slots;
   771375:  360:        p->slots = it->next;
   771375:  361:        if (it->next) it->next->prev = 0;
        -:  362:        /* Kill flag and initialize refcount here for lock safety in slab
        -:  363:         * mover's freeness detection. */
   771375:  364:        it->it_flags &= ~ITEM_SLABBED;
   771375:  365:        it->refcount = 1;
   771375:  366:        p->sl_curr--;
   771375:  367:        ret = (void *)it;
        -:  368:    } else {
        -:  369:        ret = NULL;
        -:  370:    }
        -:  371:
   771375:  372:    if (ret) {
   771375:  373:        p->requested += size;
   771375:  374:        MEMCACHED_SLABS_ALLOCATE(size, id, p->size, ret);
        -:  375:    } else {
        -:  376:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);
        -:  377:    }
        -:  378:
        -:  379:    return ret;
        -:  380:}
------------------
do_slabs_alloc:
   285816:  334:static void *do_slabs_alloc(const size_t size, unsigned int id, uint64_t *total_bytes,
        -:  335:        unsigned int flags) {
   285816:  336:    slabclass_t *p;
   285816:  337:    void *ret = NULL;
   285816:  338:    item *it = NULL;
        -:  339:
   285816:  340:    if (id < POWER_SMALLEST || id > power_largest) {
        -:  341:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        -:  342:        return NULL;
        -:  343:    }
   285816:  344:    p = &slabclass[id];
  285816*:  345:    assert(p->sl_curr == 0 || ((item *)p->slots)->slabs_clsid == 0);
   285816:  346:    if (total_bytes != NULL) {
   283617:  347:        *total_bytes = p->requested;
        -:  348:    }
        -:  349:
  285816*:  350:    assert(size <= p->size);
        -:  351:    /* fail unless we have space at the end of a recently allocated page,
        -:  352:       we have something on our freelist, or we could allocate a new page */
   285816:  353:    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
    28984:  354:        do_slabs_newslab(id);
        -:  355:    }
        -:  356:
   285816:  357:    if (p->sl_curr != 0) {
        -:  358:        /* return off our freelist */
   257125:  359:        it = (item *)p->slots;
   257125:  360:        p->slots = it->next;
   257125:  361:        if (it->next) it->next->prev = 0;
        -:  362:        /* Kill flag and initialize refcount here for lock safety in slab
        -:  363:         * mover's freeness detection. */
   257125:  364:        it->it_flags &= ~ITEM_SLABBED;
   257125:  365:        it->refcount = 1;
   257125:  366:        p->sl_curr--;
   257125:  367:        ret = (void *)it;
        -:  368:    } else {
        -:  369:        ret = NULL;
        -:  370:    }
        -:  371:
   257125:  372:    if (ret) {
   257125:  373:        p->requested += size;
   257125:  374:        MEMCACHED_SLABS_ALLOCATE(size, id, p->size, ret);
        -:  375:    } else {
        -:  376:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);
        -:  377:    }
        -:  378:
        -:  379:    return ret;
        -:  380:}
------------------
do_slabs_alloc:
   285816:  334:static void *do_slabs_alloc(const size_t size, unsigned int id, uint64_t *total_bytes,
        -:  335:        unsigned int flags) {
   285816:  336:    slabclass_t *p;
   285816:  337:    void *ret = NULL;
   285816:  338:    item *it = NULL;
        -:  339:
   285816:  340:    if (id < POWER_SMALLEST || id > power_largest) {
        -:  341:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        -:  342:        return NULL;
        -:  343:    }
   285816:  344:    p = &slabclass[id];
  285816*:  345:    assert(p->sl_curr == 0 || ((item *)p->slots)->slabs_clsid == 0);
   285816:  346:    if (total_bytes != NULL) {
   283617:  347:        *total_bytes = p->requested;
        -:  348:    }
        -:  349:
  285816*:  350:    assert(size <= p->size);
        -:  351:    /* fail unless we have space at the end of a recently allocated page,
        -:  352:       we have something on our freelist, or we could allocate a new page */
   285816:  353:    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
    28984:  354:        do_slabs_newslab(id);
        -:  355:    }
        -:  356:
   285816:  357:    if (p->sl_curr != 0) {
        -:  358:        /* return off our freelist */
   257125:  359:        it = (item *)p->slots;
   257125:  360:        p->slots = it->next;
   257125:  361:        if (it->next) it->next->prev = 0;
        -:  362:        /* Kill flag and initialize refcount here for lock safety in slab
        -:  363:         * mover's freeness detection. */
   257125:  364:        it->it_flags &= ~ITEM_SLABBED;
   257125:  365:        it->refcount = 1;
   257125:  366:        p->sl_curr--;
   257125:  367:        ret = (void *)it;
        -:  368:    } else {
        -:  369:        ret = NULL;
        -:  370:    }
        -:  371:
   257125:  372:    if (ret) {
   257125:  373:        p->requested += size;
   257125:  374:        MEMCACHED_SLABS_ALLOCATE(size, id, p->size, ret);
        -:  375:    } else {
        -:  376:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);
        -:  377:    }
        -:  378:
        -:  379:    return ret;
        -:  380:}
------------------
do_slabs_alloc:
   285816:  334:static void *do_slabs_alloc(const size_t size, unsigned int id, uint64_t *total_bytes,
        -:  335:        unsigned int flags) {
   285816:  336:    slabclass_t *p;
   285816:  337:    void *ret = NULL;
   285816:  338:    item *it = NULL;
        -:  339:
   285816:  340:    if (id < POWER_SMALLEST || id > power_largest) {
        -:  341:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        -:  342:        return NULL;
        -:  343:    }
   285816:  344:    p = &slabclass[id];
  285816*:  345:    assert(p->sl_curr == 0 || ((item *)p->slots)->slabs_clsid == 0);
   285816:  346:    if (total_bytes != NULL) {
   283617:  347:        *total_bytes = p->requested;
        -:  348:    }
        -:  349:
  285816*:  350:    assert(size <= p->size);
        -:  351:    /* fail unless we have space at the end of a recently allocated page,
        -:  352:       we have something on our freelist, or we could allocate a new page */
   285816:  353:    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
    28984:  354:        do_slabs_newslab(id);
        -:  355:    }
        -:  356:
   285816:  357:    if (p->sl_curr != 0) {
        -:  358:        /* return off our freelist */
   257125:  359:        it = (item *)p->slots;
   257125:  360:        p->slots = it->next;
   257125:  361:        if (it->next) it->next->prev = 0;
        -:  362:        /* Kill flag and initialize refcount here for lock safety in slab
        -:  363:         * mover's freeness detection. */
   257125:  364:        it->it_flags &= ~ITEM_SLABBED;
   257125:  365:        it->refcount = 1;
   257125:  366:        p->sl_curr--;
   257125:  367:        ret = (void *)it;
        -:  368:    } else {
        -:  369:        ret = NULL;
        -:  370:    }
        -:  371:
   257125:  372:    if (ret) {
   257125:  373:        p->requested += size;
   257125:  374:        MEMCACHED_SLABS_ALLOCATE(size, id, p->size, ret);
        -:  375:    } else {
        -:  376:        MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);
        -:  377:    }
        -:  378:
        -:  379:    return ret;
        -:  380:}
------------------
        -:  381:
    #####:  382:static void do_slabs_free_chunked(item *it, const size_t size) {
    #####:  383:    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    #####:  384:    slabclass_t *p;
        -:  385:
    #####:  386:    it->it_flags = ITEM_SLABBED;
    #####:  387:    it->slabs_clsid = 0;
    #####:  388:    it->prev = 0;
        -:  389:    // header object's original classid is stored in chunk.
    #####:  390:    p = &slabclass[chunk->orig_clsid];
    #####:  391:    if (chunk->next) {
    #####:  392:        chunk = chunk->next;
    #####:  393:        chunk->prev = 0;
        -:  394:    } else {
        -:  395:        // header with no attached chunk
        -:  396:        chunk = NULL;
        -:  397:    }
        -:  398:
        -:  399:    // return the header object.
        -:  400:    // TODO: This is in three places, here and in do_slabs_free().
    #####:  401:    it->prev = 0;
    #####:  402:    it->next = p->slots;
    #####:  403:    if (it->next) it->next->prev = it;
    #####:  404:    p->slots = it;
    #####:  405:    p->sl_curr++;
        -:  406:    // TODO: macro
        -:  407:#ifdef NEED_ALIGN
        -:  408:    int total = it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  409:    if (total % 8 != 0) {
        -:  410:        total += 8 - (total % 8);
        -:  411:    }
        -:  412:    p->requested -= total;
        -:  413:#else
    #####:  414:    p->requested -= it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  415:#endif
    #####:  416:    if (settings.use_cas) {
    #####:  417:        p->requested -= sizeof(uint64_t);
        -:  418:    }
        -:  419:
        -:  420:    item_chunk *next_chunk;
    #####:  421:    while (chunk) {
    #####:  422:        assert(chunk->it_flags == ITEM_CHUNK);
    #####:  423:        chunk->it_flags = ITEM_SLABBED;
    #####:  424:        p = &slabclass[chunk->slabs_clsid];
    #####:  425:        chunk->slabs_clsid = 0;
    #####:  426:        next_chunk = chunk->next;
        -:  427:
    #####:  428:        chunk->prev = 0;
    #####:  429:        chunk->next = p->slots;
    #####:  430:        if (chunk->next) chunk->next->prev = chunk;
    #####:  431:        p->slots = chunk;
    #####:  432:        p->sl_curr++;
    #####:  433:        p->requested -= chunk->size + sizeof(item_chunk);
        -:  434:
    #####:  435:        chunk = next_chunk;
        -:  436:    }
        -:  437:
    #####:  438:    return;
        -:  439:}
------------------
do_slabs_free_chunked:
    #####:  382:static void do_slabs_free_chunked(item *it, const size_t size) {
    #####:  383:    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    #####:  384:    slabclass_t *p;
        -:  385:
    #####:  386:    it->it_flags = ITEM_SLABBED;
    #####:  387:    it->slabs_clsid = 0;
    #####:  388:    it->prev = 0;
        -:  389:    // header object's original classid is stored in chunk.
    #####:  390:    p = &slabclass[chunk->orig_clsid];
    #####:  391:    if (chunk->next) {
    #####:  392:        chunk = chunk->next;
    #####:  393:        chunk->prev = 0;
        -:  394:    } else {
        -:  395:        // header with no attached chunk
        -:  396:        chunk = NULL;
        -:  397:    }
        -:  398:
        -:  399:    // return the header object.
        -:  400:    // TODO: This is in three places, here and in do_slabs_free().
    #####:  401:    it->prev = 0;
    #####:  402:    it->next = p->slots;
    #####:  403:    if (it->next) it->next->prev = it;
    #####:  404:    p->slots = it;
    #####:  405:    p->sl_curr++;
        -:  406:    // TODO: macro
        -:  407:#ifdef NEED_ALIGN
        -:  408:    int total = it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  409:    if (total % 8 != 0) {
        -:  410:        total += 8 - (total % 8);
        -:  411:    }
        -:  412:    p->requested -= total;
        -:  413:#else
    #####:  414:    p->requested -= it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  415:#endif
    #####:  416:    if (settings.use_cas) {
    #####:  417:        p->requested -= sizeof(uint64_t);
        -:  418:    }
        -:  419:
        -:  420:    item_chunk *next_chunk;
    #####:  421:    while (chunk) {
    #####:  422:        assert(chunk->it_flags == ITEM_CHUNK);
    #####:  423:        chunk->it_flags = ITEM_SLABBED;
    #####:  424:        p = &slabclass[chunk->slabs_clsid];
    #####:  425:        chunk->slabs_clsid = 0;
    #####:  426:        next_chunk = chunk->next;
        -:  427:
    #####:  428:        chunk->prev = 0;
    #####:  429:        chunk->next = p->slots;
    #####:  430:        if (chunk->next) chunk->next->prev = chunk;
    #####:  431:        p->slots = chunk;
    #####:  432:        p->sl_curr++;
    #####:  433:        p->requested -= chunk->size + sizeof(item_chunk);
        -:  434:
    #####:  435:        chunk = next_chunk;
        -:  436:    }
        -:  437:
    #####:  438:    return;
        -:  439:}
------------------
do_slabs_free_chunked:
    #####:  382:static void do_slabs_free_chunked(item *it, const size_t size) {
    #####:  383:    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    #####:  384:    slabclass_t *p;
        -:  385:
    #####:  386:    it->it_flags = ITEM_SLABBED;
    #####:  387:    it->slabs_clsid = 0;
    #####:  388:    it->prev = 0;
        -:  389:    // header object's original classid is stored in chunk.
    #####:  390:    p = &slabclass[chunk->orig_clsid];
    #####:  391:    if (chunk->next) {
    #####:  392:        chunk = chunk->next;
    #####:  393:        chunk->prev = 0;
        -:  394:    } else {
        -:  395:        // header with no attached chunk
        -:  396:        chunk = NULL;
        -:  397:    }
        -:  398:
        -:  399:    // return the header object.
        -:  400:    // TODO: This is in three places, here and in do_slabs_free().
    #####:  401:    it->prev = 0;
    #####:  402:    it->next = p->slots;
    #####:  403:    if (it->next) it->next->prev = it;
    #####:  404:    p->slots = it;
    #####:  405:    p->sl_curr++;
        -:  406:    // TODO: macro
        -:  407:#ifdef NEED_ALIGN
        -:  408:    int total = it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  409:    if (total % 8 != 0) {
        -:  410:        total += 8 - (total % 8);
        -:  411:    }
        -:  412:    p->requested -= total;
        -:  413:#else
    #####:  414:    p->requested -= it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  415:#endif
    #####:  416:    if (settings.use_cas) {
    #####:  417:        p->requested -= sizeof(uint64_t);
        -:  418:    }
        -:  419:
        -:  420:    item_chunk *next_chunk;
    #####:  421:    while (chunk) {
    #####:  422:        assert(chunk->it_flags == ITEM_CHUNK);
    #####:  423:        chunk->it_flags = ITEM_SLABBED;
    #####:  424:        p = &slabclass[chunk->slabs_clsid];
    #####:  425:        chunk->slabs_clsid = 0;
    #####:  426:        next_chunk = chunk->next;
        -:  427:
    #####:  428:        chunk->prev = 0;
    #####:  429:        chunk->next = p->slots;
    #####:  430:        if (chunk->next) chunk->next->prev = chunk;
    #####:  431:        p->slots = chunk;
    #####:  432:        p->sl_curr++;
    #####:  433:        p->requested -= chunk->size + sizeof(item_chunk);
        -:  434:
    #####:  435:        chunk = next_chunk;
        -:  436:    }
        -:  437:
    #####:  438:    return;
        -:  439:}
------------------
do_slabs_free_chunked:
    #####:  382:static void do_slabs_free_chunked(item *it, const size_t size) {
    #####:  383:    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    #####:  384:    slabclass_t *p;
        -:  385:
    #####:  386:    it->it_flags = ITEM_SLABBED;
    #####:  387:    it->slabs_clsid = 0;
    #####:  388:    it->prev = 0;
        -:  389:    // header object's original classid is stored in chunk.
    #####:  390:    p = &slabclass[chunk->orig_clsid];
    #####:  391:    if (chunk->next) {
    #####:  392:        chunk = chunk->next;
    #####:  393:        chunk->prev = 0;
        -:  394:    } else {
        -:  395:        // header with no attached chunk
        -:  396:        chunk = NULL;
        -:  397:    }
        -:  398:
        -:  399:    // return the header object.
        -:  400:    // TODO: This is in three places, here and in do_slabs_free().
    #####:  401:    it->prev = 0;
    #####:  402:    it->next = p->slots;
    #####:  403:    if (it->next) it->next->prev = it;
    #####:  404:    p->slots = it;
    #####:  405:    p->sl_curr++;
        -:  406:    // TODO: macro
        -:  407:#ifdef NEED_ALIGN
        -:  408:    int total = it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  409:    if (total % 8 != 0) {
        -:  410:        total += 8 - (total % 8);
        -:  411:    }
        -:  412:    p->requested -= total;
        -:  413:#else
    #####:  414:    p->requested -= it->nkey + 1 + FLAGS_SIZE(it) + sizeof(item) + sizeof(item_chunk);
        -:  415:#endif
    #####:  416:    if (settings.use_cas) {
    #####:  417:        p->requested -= sizeof(uint64_t);
        -:  418:    }
        -:  419:
        -:  420:    item_chunk *next_chunk;
    #####:  421:    while (chunk) {
    #####:  422:        assert(chunk->it_flags == ITEM_CHUNK);
    #####:  423:        chunk->it_flags = ITEM_SLABBED;
    #####:  424:        p = &slabclass[chunk->slabs_clsid];
    #####:  425:        chunk->slabs_clsid = 0;
    #####:  426:        next_chunk = chunk->next;
        -:  427:
    #####:  428:        chunk->prev = 0;
    #####:  429:        chunk->next = p->slots;
    #####:  430:        if (chunk->next) chunk->next->prev = chunk;
    #####:  431:        p->slots = chunk;
    #####:  432:        p->sl_curr++;
    #####:  433:        p->requested -= chunk->size + sizeof(item_chunk);
        -:  434:
    #####:  435:        chunk = next_chunk;
        -:  436:    }
        -:  437:
    #####:  438:    return;
        -:  439:}
------------------
        -:  440:
        -:  441:
  2197659:  442:static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
  2197659:  443:    slabclass_t *p;
  2197659:  444:    item *it;
        -:  445:
 2197659*:  446:    assert(id >= POWER_SMALLEST && id <= power_largest);
  2197659:  447:    if (id < POWER_SMALLEST || id > power_largest)
        -:  448:        return;
        -:  449:
  2197659:  450:    MEMCACHED_SLABS_FREE(size, id, ptr);
  2197659:  451:    p = &slabclass[id];
        -:  452:
  2197659:  453:    it = (item *)ptr;
  2197659:  454:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -:  455:#ifdef EXTSTORE
        -:  456:        bool is_hdr = it->it_flags & ITEM_HDR;
        -:  457:#endif
  2148924:  458:        it->it_flags = ITEM_SLABBED;
  2148924:  459:        it->slabs_clsid = 0;
  2148924:  460:        it->prev = 0;
  2148924:  461:        it->next = p->slots;
  2148924:  462:        if (it->next) it->next->prev = it;
  2148924:  463:        p->slots = it;
        -:  464:
  2148924:  465:        p->sl_curr++;
        -:  466:#ifdef EXTSTORE
        -:  467:        if (!is_hdr) {
        -:  468:            p->requested -= size;
        -:  469:        } else {
        -:  470:            p->requested -= (size - it->nbytes) + sizeof(item_hdr);
        -:  471:        }
        -:  472:#else
  2148924:  473:        p->requested -= size;
        -:  474:#endif
        -:  475:    } else {
    48735:  476:        do_slabs_free_chunked(it, size);
        -:  477:    }
        -:  478:    return;
        -:  479:}
------------------
do_slabs_free:
   732553:  442:static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
   732553:  443:    slabclass_t *p;
   732553:  444:    item *it;
        -:  445:
  732553*:  446:    assert(id >= POWER_SMALLEST && id <= power_largest);
   732553:  447:    if (id < POWER_SMALLEST || id > power_largest)
        -:  448:        return;
        -:  449:
   732553:  450:    MEMCACHED_SLABS_FREE(size, id, ptr);
   732553:  451:    p = &slabclass[id];
        -:  452:
   732553:  453:    it = (item *)ptr;
   732553:  454:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -:  455:#ifdef EXTSTORE
        -:  456:        bool is_hdr = it->it_flags & ITEM_HDR;
        -:  457:#endif
   716308:  458:        it->it_flags = ITEM_SLABBED;
   716308:  459:        it->slabs_clsid = 0;
   716308:  460:        it->prev = 0;
   716308:  461:        it->next = p->slots;
   716308:  462:        if (it->next) it->next->prev = it;
   716308:  463:        p->slots = it;
        -:  464:
   716308:  465:        p->sl_curr++;
        -:  466:#ifdef EXTSTORE
        -:  467:        if (!is_hdr) {
        -:  468:            p->requested -= size;
        -:  469:        } else {
        -:  470:            p->requested -= (size - it->nbytes) + sizeof(item_hdr);
        -:  471:        }
        -:  472:#else
   716308:  473:        p->requested -= size;
        -:  474:#endif
        -:  475:    } else {
    16245:  476:        do_slabs_free_chunked(it, size);
        -:  477:    }
        -:  478:    return;
        -:  479:}
------------------
do_slabs_free:
   732553:  442:static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
   732553:  443:    slabclass_t *p;
   732553:  444:    item *it;
        -:  445:
  732553*:  446:    assert(id >= POWER_SMALLEST && id <= power_largest);
   732553:  447:    if (id < POWER_SMALLEST || id > power_largest)
        -:  448:        return;
        -:  449:
   732553:  450:    MEMCACHED_SLABS_FREE(size, id, ptr);
   732553:  451:    p = &slabclass[id];
        -:  452:
   732553:  453:    it = (item *)ptr;
   732553:  454:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -:  455:#ifdef EXTSTORE
        -:  456:        bool is_hdr = it->it_flags & ITEM_HDR;
        -:  457:#endif
   716308:  458:        it->it_flags = ITEM_SLABBED;
   716308:  459:        it->slabs_clsid = 0;
   716308:  460:        it->prev = 0;
   716308:  461:        it->next = p->slots;
   716308:  462:        if (it->next) it->next->prev = it;
   716308:  463:        p->slots = it;
        -:  464:
   716308:  465:        p->sl_curr++;
        -:  466:#ifdef EXTSTORE
        -:  467:        if (!is_hdr) {
        -:  468:            p->requested -= size;
        -:  469:        } else {
        -:  470:            p->requested -= (size - it->nbytes) + sizeof(item_hdr);
        -:  471:        }
        -:  472:#else
   716308:  473:        p->requested -= size;
        -:  474:#endif
        -:  475:    } else {
    16245:  476:        do_slabs_free_chunked(it, size);
        -:  477:    }
        -:  478:    return;
        -:  479:}
------------------
do_slabs_free:
   732553:  442:static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
   732553:  443:    slabclass_t *p;
   732553:  444:    item *it;
        -:  445:
  732553*:  446:    assert(id >= POWER_SMALLEST && id <= power_largest);
   732553:  447:    if (id < POWER_SMALLEST || id > power_largest)
        -:  448:        return;
        -:  449:
   732553:  450:    MEMCACHED_SLABS_FREE(size, id, ptr);
   732553:  451:    p = &slabclass[id];
        -:  452:
   732553:  453:    it = (item *)ptr;
   732553:  454:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -:  455:#ifdef EXTSTORE
        -:  456:        bool is_hdr = it->it_flags & ITEM_HDR;
        -:  457:#endif
   716308:  458:        it->it_flags = ITEM_SLABBED;
   716308:  459:        it->slabs_clsid = 0;
   716308:  460:        it->prev = 0;
   716308:  461:        it->next = p->slots;
   716308:  462:        if (it->next) it->next->prev = it;
   716308:  463:        p->slots = it;
        -:  464:
   716308:  465:        p->sl_curr++;
        -:  466:#ifdef EXTSTORE
        -:  467:        if (!is_hdr) {
        -:  468:            p->requested -= size;
        -:  469:        } else {
        -:  470:            p->requested -= (size - it->nbytes) + sizeof(item_hdr);
        -:  471:        }
        -:  472:#else
   716308:  473:        p->requested -= size;
        -:  474:#endif
        -:  475:    } else {
    16245:  476:        do_slabs_free_chunked(it, size);
        -:  477:    }
        -:  478:    return;
        -:  479:}
------------------
        -:  480:
        -:  481:/* With refactoring of the various stats code the automover won't need a
        -:  482: * custom function here.
        -:  483: */
     1092:  484:void fill_slab_stats_automove(slab_stats_automove *am) {
     1092:  485:    int n;
     1092:  486:    pthread_mutex_lock(&slabs_lock);
    70980:  487:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    69888:  488:        slabclass_t *p = &slabclass[n];
    69888:  489:        slab_stats_automove *cur = &am[n];
    69888:  490:        cur->chunks_per_page = p->perslab;
    69888:  491:        cur->free_chunks = p->sl_curr;
    69888:  492:        cur->total_pages = p->slabs;
    69888:  493:        cur->chunk_size = p->size;
        -:  494:    }
     1092:  495:    pthread_mutex_unlock(&slabs_lock);
     1092:  496:}
------------------
fill_slab_stats_automove:
      364:  484:void fill_slab_stats_automove(slab_stats_automove *am) {
      364:  485:    int n;
      364:  486:    pthread_mutex_lock(&slabs_lock);
    23660:  487:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    23296:  488:        slabclass_t *p = &slabclass[n];
    23296:  489:        slab_stats_automove *cur = &am[n];
    23296:  490:        cur->chunks_per_page = p->perslab;
    23296:  491:        cur->free_chunks = p->sl_curr;
    23296:  492:        cur->total_pages = p->slabs;
    23296:  493:        cur->chunk_size = p->size;
        -:  494:    }
      364:  495:    pthread_mutex_unlock(&slabs_lock);
      364:  496:}
------------------
fill_slab_stats_automove:
      364:  484:void fill_slab_stats_automove(slab_stats_automove *am) {
      364:  485:    int n;
      364:  486:    pthread_mutex_lock(&slabs_lock);
    23660:  487:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    23296:  488:        slabclass_t *p = &slabclass[n];
    23296:  489:        slab_stats_automove *cur = &am[n];
    23296:  490:        cur->chunks_per_page = p->perslab;
    23296:  491:        cur->free_chunks = p->sl_curr;
    23296:  492:        cur->total_pages = p->slabs;
    23296:  493:        cur->chunk_size = p->size;
        -:  494:    }
      364:  495:    pthread_mutex_unlock(&slabs_lock);
      364:  496:}
------------------
fill_slab_stats_automove:
      364:  484:void fill_slab_stats_automove(slab_stats_automove *am) {
      364:  485:    int n;
      364:  486:    pthread_mutex_lock(&slabs_lock);
    23660:  487:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    23296:  488:        slabclass_t *p = &slabclass[n];
    23296:  489:        slab_stats_automove *cur = &am[n];
    23296:  490:        cur->chunks_per_page = p->perslab;
    23296:  491:        cur->free_chunks = p->sl_curr;
    23296:  492:        cur->total_pages = p->slabs;
    23296:  493:        cur->chunk_size = p->size;
        -:  494:    }
      364:  495:    pthread_mutex_unlock(&slabs_lock);
      364:  496:}
------------------
        -:  497:
        -:  498:/* TODO: slabs_available_chunks should grow up to encompass this.
        -:  499: * mem_flag is redundant with the other function.
        -:  500: */
    #####:  501:unsigned int global_page_pool_size(bool *mem_flag) {
    #####:  502:    unsigned int ret = 0;
    #####:  503:    pthread_mutex_lock(&slabs_lock);
    #####:  504:    if (mem_flag != NULL)
    #####:  505:        *mem_flag = mem_malloced >= mem_limit ? true : false;
    #####:  506:    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    #####:  507:    pthread_mutex_unlock(&slabs_lock);
    #####:  508:    return ret;
        -:  509:}
------------------
global_page_pool_size:
    #####:  501:unsigned int global_page_pool_size(bool *mem_flag) {
    #####:  502:    unsigned int ret = 0;
    #####:  503:    pthread_mutex_lock(&slabs_lock);
    #####:  504:    if (mem_flag != NULL)
    #####:  505:        *mem_flag = mem_malloced >= mem_limit ? true : false;
    #####:  506:    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    #####:  507:    pthread_mutex_unlock(&slabs_lock);
    #####:  508:    return ret;
        -:  509:}
------------------
global_page_pool_size:
    #####:  501:unsigned int global_page_pool_size(bool *mem_flag) {
    #####:  502:    unsigned int ret = 0;
    #####:  503:    pthread_mutex_lock(&slabs_lock);
    #####:  504:    if (mem_flag != NULL)
    #####:  505:        *mem_flag = mem_malloced >= mem_limit ? true : false;
    #####:  506:    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    #####:  507:    pthread_mutex_unlock(&slabs_lock);
    #####:  508:    return ret;
        -:  509:}
------------------
global_page_pool_size:
    #####:  501:unsigned int global_page_pool_size(bool *mem_flag) {
    #####:  502:    unsigned int ret = 0;
    #####:  503:    pthread_mutex_lock(&slabs_lock);
    #####:  504:    if (mem_flag != NULL)
    #####:  505:        *mem_flag = mem_malloced >= mem_limit ? true : false;
    #####:  506:    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    #####:  507:    pthread_mutex_unlock(&slabs_lock);
    #####:  508:    return ret;
        -:  509:}
------------------
        -:  510:
      189:  511:static int nz_strcmp(int nzlength, const char *nz, const char *z) {
      189:  512:    int zlength=strlen(z);
      189:  513:    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
        -:  514:}
------------------
nz_strcmp:
       63:  511:static int nz_strcmp(int nzlength, const char *nz, const char *z) {
       63:  512:    int zlength=strlen(z);
       63:  513:    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
        -:  514:}
------------------
nz_strcmp:
       63:  511:static int nz_strcmp(int nzlength, const char *nz, const char *z) {
       63:  512:    int zlength=strlen(z);
       63:  513:    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
        -:  514:}
------------------
nz_strcmp:
       63:  511:static int nz_strcmp(int nzlength, const char *nz, const char *z) {
       63:  512:    int zlength=strlen(z);
       63:  513:    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
        -:  514:}
------------------
        -:  515:
     8085:  516:bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
     8085:  517:    bool ret = true;
        -:  518:
     8085:  519:    if (add_stats != NULL) {
     8085:  520:        if (!stat_type) {
        -:  521:            /* prepare general statistics for the engine */
     7974:  522:            STATS_LOCK();
     7974:  523:            APPEND_STAT("bytes", "%llu", (unsigned long long)stats_state.curr_bytes);
     7974:  524:            APPEND_STAT("curr_items", "%llu", (unsigned long long)stats_state.curr_items);
     7974:  525:            APPEND_STAT("total_items", "%llu", (unsigned long long)stats.total_items);
     7974:  526:            STATS_UNLOCK();
     7974:  527:            pthread_mutex_lock(&slabs_lock);
     7974:  528:            APPEND_STAT("slab_global_page_pool", "%u", slabclass[SLAB_GLOBAL_PAGE_POOL].slabs);
     7974:  529:            pthread_mutex_unlock(&slabs_lock);
     7974:  530:            item_stats_totals(add_stats, c);
      111:  531:        } else if (nz_strcmp(nkey, stat_type, "items") == 0) {
       33:  532:            item_stats(add_stats, c);
       78:  533:        } else if (nz_strcmp(nkey, stat_type, "slabs") == 0) {
       78:  534:            slabs_stats(add_stats, c);
    #####:  535:        } else if (nz_strcmp(nkey, stat_type, "sizes") == 0) {
    #####:  536:            item_stats_sizes(add_stats, c);
    #####:  537:        } else if (nz_strcmp(nkey, stat_type, "sizes_enable") == 0) {
    #####:  538:            item_stats_sizes_enable(add_stats, c);
    #####:  539:        } else if (nz_strcmp(nkey, stat_type, "sizes_disable") == 0) {
    #####:  540:            item_stats_sizes_disable(add_stats, c);
        -:  541:        } else {
        -:  542:            ret = false;
        -:  543:        }
        -:  544:    } else {
        -:  545:        ret = false;
        -:  546:    }
        -:  547:
     8085:  548:    return ret;
        -:  549:}
------------------
get_stats:
     2695:  516:bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
     2695:  517:    bool ret = true;
        -:  518:
     2695:  519:    if (add_stats != NULL) {
     2695:  520:        if (!stat_type) {
        -:  521:            /* prepare general statistics for the engine */
     2658:  522:            STATS_LOCK();
     2658:  523:            APPEND_STAT("bytes", "%llu", (unsigned long long)stats_state.curr_bytes);
     2658:  524:            APPEND_STAT("curr_items", "%llu", (unsigned long long)stats_state.curr_items);
     2658:  525:            APPEND_STAT("total_items", "%llu", (unsigned long long)stats.total_items);
     2658:  526:            STATS_UNLOCK();
     2658:  527:            pthread_mutex_lock(&slabs_lock);
     2658:  528:            APPEND_STAT("slab_global_page_pool", "%u", slabclass[SLAB_GLOBAL_PAGE_POOL].slabs);
     2658:  529:            pthread_mutex_unlock(&slabs_lock);
     2658:  530:            item_stats_totals(add_stats, c);
       37:  531:        } else if (nz_strcmp(nkey, stat_type, "items") == 0) {
       11:  532:            item_stats(add_stats, c);
       26:  533:        } else if (nz_strcmp(nkey, stat_type, "slabs") == 0) {
       26:  534:            slabs_stats(add_stats, c);
    #####:  535:        } else if (nz_strcmp(nkey, stat_type, "sizes") == 0) {
    #####:  536:            item_stats_sizes(add_stats, c);
    #####:  537:        } else if (nz_strcmp(nkey, stat_type, "sizes_enable") == 0) {
    #####:  538:            item_stats_sizes_enable(add_stats, c);
    #####:  539:        } else if (nz_strcmp(nkey, stat_type, "sizes_disable") == 0) {
    #####:  540:            item_stats_sizes_disable(add_stats, c);
        -:  541:        } else {
        -:  542:            ret = false;
        -:  543:        }
        -:  544:    } else {
        -:  545:        ret = false;
        -:  546:    }
        -:  547:
     2695:  548:    return ret;
        -:  549:}
------------------
get_stats:
     2695:  516:bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
     2695:  517:    bool ret = true;
        -:  518:
     2695:  519:    if (add_stats != NULL) {
     2695:  520:        if (!stat_type) {
        -:  521:            /* prepare general statistics for the engine */
     2658:  522:            STATS_LOCK();
     2658:  523:            APPEND_STAT("bytes", "%llu", (unsigned long long)stats_state.curr_bytes);
     2658:  524:            APPEND_STAT("curr_items", "%llu", (unsigned long long)stats_state.curr_items);
     2658:  525:            APPEND_STAT("total_items", "%llu", (unsigned long long)stats.total_items);
     2658:  526:            STATS_UNLOCK();
     2658:  527:            pthread_mutex_lock(&slabs_lock);
     2658:  528:            APPEND_STAT("slab_global_page_pool", "%u", slabclass[SLAB_GLOBAL_PAGE_POOL].slabs);
     2658:  529:            pthread_mutex_unlock(&slabs_lock);
     2658:  530:            item_stats_totals(add_stats, c);
       37:  531:        } else if (nz_strcmp(nkey, stat_type, "items") == 0) {
       11:  532:            item_stats(add_stats, c);
       26:  533:        } else if (nz_strcmp(nkey, stat_type, "slabs") == 0) {
       26:  534:            slabs_stats(add_stats, c);
    #####:  535:        } else if (nz_strcmp(nkey, stat_type, "sizes") == 0) {
    #####:  536:            item_stats_sizes(add_stats, c);
    #####:  537:        } else if (nz_strcmp(nkey, stat_type, "sizes_enable") == 0) {
    #####:  538:            item_stats_sizes_enable(add_stats, c);
    #####:  539:        } else if (nz_strcmp(nkey, stat_type, "sizes_disable") == 0) {
    #####:  540:            item_stats_sizes_disable(add_stats, c);
        -:  541:        } else {
        -:  542:            ret = false;
        -:  543:        }
        -:  544:    } else {
        -:  545:        ret = false;
        -:  546:    }
        -:  547:
     2695:  548:    return ret;
        -:  549:}
------------------
get_stats:
     2695:  516:bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
     2695:  517:    bool ret = true;
        -:  518:
     2695:  519:    if (add_stats != NULL) {
     2695:  520:        if (!stat_type) {
        -:  521:            /* prepare general statistics for the engine */
     2658:  522:            STATS_LOCK();
     2658:  523:            APPEND_STAT("bytes", "%llu", (unsigned long long)stats_state.curr_bytes);
     2658:  524:            APPEND_STAT("curr_items", "%llu", (unsigned long long)stats_state.curr_items);
     2658:  525:            APPEND_STAT("total_items", "%llu", (unsigned long long)stats.total_items);
     2658:  526:            STATS_UNLOCK();
     2658:  527:            pthread_mutex_lock(&slabs_lock);
     2658:  528:            APPEND_STAT("slab_global_page_pool", "%u", slabclass[SLAB_GLOBAL_PAGE_POOL].slabs);
     2658:  529:            pthread_mutex_unlock(&slabs_lock);
     2658:  530:            item_stats_totals(add_stats, c);
       37:  531:        } else if (nz_strcmp(nkey, stat_type, "items") == 0) {
       11:  532:            item_stats(add_stats, c);
       26:  533:        } else if (nz_strcmp(nkey, stat_type, "slabs") == 0) {
       26:  534:            slabs_stats(add_stats, c);
    #####:  535:        } else if (nz_strcmp(nkey, stat_type, "sizes") == 0) {
    #####:  536:            item_stats_sizes(add_stats, c);
    #####:  537:        } else if (nz_strcmp(nkey, stat_type, "sizes_enable") == 0) {
    #####:  538:            item_stats_sizes_enable(add_stats, c);
    #####:  539:        } else if (nz_strcmp(nkey, stat_type, "sizes_disable") == 0) {
    #####:  540:            item_stats_sizes_disable(add_stats, c);
        -:  541:        } else {
        -:  542:            ret = false;
        -:  543:        }
        -:  544:    } else {
        -:  545:        ret = false;
        -:  546:    }
        -:  547:
     2695:  548:    return ret;
        -:  549:}
------------------
        -:  550:
        -:  551:/*@null@*/
       78:  552:static void do_slabs_stats(ADD_STAT add_stats, void *c) {
       78:  553:    int i, total;
        -:  554:    /* Get the per-thread stats which contain some interesting aggregates */
       78:  555:    struct thread_stats thread_stats;
       78:  556:    threadlocal_stats_aggregate(&thread_stats);
        -:  557:
       78:  558:    total = 0;
     3090:  559:    for(i = POWER_SMALLEST; i <= power_largest; i++) {
     3012:  560:        slabclass_t *p = &slabclass[i];
     3012:  561:        if (p->slabs != 0) {
      216:  562:            uint32_t perslab, slabs;
      216:  563:            slabs = p->slabs;
      216:  564:            perslab = p->perslab;
        -:  565:
      216:  566:            char key_str[STAT_KEY_LEN];
      216:  567:            char val_str[STAT_VAL_LEN];
      216:  568:            int klen = 0, vlen = 0;
        -:  569:
      648:  570:            APPEND_NUM_STAT(i, "chunk_size", "%u", p->size);
      648:  571:            APPEND_NUM_STAT(i, "chunks_per_page", "%u", perslab);
      648:  572:            APPEND_NUM_STAT(i, "total_pages", "%u", slabs);
      648:  573:            APPEND_NUM_STAT(i, "total_chunks", "%u", slabs * perslab);
      648:  574:            APPEND_NUM_STAT(i, "used_chunks", "%u",
      216:  575:                            slabs*perslab - p->sl_curr);
      648:  576:            APPEND_NUM_STAT(i, "free_chunks", "%u", p->sl_curr);
        -:  577:            /* Stat is dead, but displaying zero instead of removing it. */
      648:  578:            APPEND_NUM_STAT(i, "free_chunks_end", "%u", 0);
      648:  579:            APPEND_NUM_STAT(i, "mem_requested", "%llu",
      216:  580:                            (unsigned long long)p->requested);
      648:  581:            APPEND_NUM_STAT(i, "get_hits", "%llu",
      216:  582:                    (unsigned long long)thread_stats.slab_stats[i].get_hits);
      648:  583:            APPEND_NUM_STAT(i, "cmd_set", "%llu",
      216:  584:                    (unsigned long long)thread_stats.slab_stats[i].set_cmds);
      648:  585:            APPEND_NUM_STAT(i, "delete_hits", "%llu",
      216:  586:                    (unsigned long long)thread_stats.slab_stats[i].delete_hits);
      648:  587:            APPEND_NUM_STAT(i, "incr_hits", "%llu",
      216:  588:                    (unsigned long long)thread_stats.slab_stats[i].incr_hits);
      648:  589:            APPEND_NUM_STAT(i, "decr_hits", "%llu",
      216:  590:                    (unsigned long long)thread_stats.slab_stats[i].decr_hits);
      648:  591:            APPEND_NUM_STAT(i, "cas_hits", "%llu",
      216:  592:                    (unsigned long long)thread_stats.slab_stats[i].cas_hits);
      648:  593:            APPEND_NUM_STAT(i, "cas_badval", "%llu",
      216:  594:                    (unsigned long long)thread_stats.slab_stats[i].cas_badval);
      648:  595:            APPEND_NUM_STAT(i, "touch_hits", "%llu",
      216:  596:                    (unsigned long long)thread_stats.slab_stats[i].touch_hits);
      216:  597:            total++;
        -:  598:        }
        -:  599:    }
        -:  600:
        -:  601:    /* add overall slab stats and append terminator */
        -:  602:
       78:  603:    APPEND_STAT("active_slabs", "%d", total);
       78:  604:    APPEND_STAT("total_malloced", "%llu", (unsigned long long)mem_malloced);
       78:  605:    add_stats(NULL, 0, NULL, 0, c);
       78:  606:}
------------------
do_slabs_stats:
       26:  552:static void do_slabs_stats(ADD_STAT add_stats, void *c) {
       26:  553:    int i, total;
        -:  554:    /* Get the per-thread stats which contain some interesting aggregates */
       26:  555:    struct thread_stats thread_stats;
       26:  556:    threadlocal_stats_aggregate(&thread_stats);
        -:  557:
       26:  558:    total = 0;
     1030:  559:    for(i = POWER_SMALLEST; i <= power_largest; i++) {
     1004:  560:        slabclass_t *p = &slabclass[i];
     1004:  561:        if (p->slabs != 0) {
       72:  562:            uint32_t perslab, slabs;
       72:  563:            slabs = p->slabs;
       72:  564:            perslab = p->perslab;
        -:  565:
       72:  566:            char key_str[STAT_KEY_LEN];
       72:  567:            char val_str[STAT_VAL_LEN];
       72:  568:            int klen = 0, vlen = 0;
        -:  569:
      216:  570:            APPEND_NUM_STAT(i, "chunk_size", "%u", p->size);
      216:  571:            APPEND_NUM_STAT(i, "chunks_per_page", "%u", perslab);
      216:  572:            APPEND_NUM_STAT(i, "total_pages", "%u", slabs);
      216:  573:            APPEND_NUM_STAT(i, "total_chunks", "%u", slabs * perslab);
      216:  574:            APPEND_NUM_STAT(i, "used_chunks", "%u",
       72:  575:                            slabs*perslab - p->sl_curr);
      216:  576:            APPEND_NUM_STAT(i, "free_chunks", "%u", p->sl_curr);
        -:  577:            /* Stat is dead, but displaying zero instead of removing it. */
      216:  578:            APPEND_NUM_STAT(i, "free_chunks_end", "%u", 0);
      216:  579:            APPEND_NUM_STAT(i, "mem_requested", "%llu",
       72:  580:                            (unsigned long long)p->requested);
      216:  581:            APPEND_NUM_STAT(i, "get_hits", "%llu",
       72:  582:                    (unsigned long long)thread_stats.slab_stats[i].get_hits);
      216:  583:            APPEND_NUM_STAT(i, "cmd_set", "%llu",
       72:  584:                    (unsigned long long)thread_stats.slab_stats[i].set_cmds);
      216:  585:            APPEND_NUM_STAT(i, "delete_hits", "%llu",
       72:  586:                    (unsigned long long)thread_stats.slab_stats[i].delete_hits);
      216:  587:            APPEND_NUM_STAT(i, "incr_hits", "%llu",
       72:  588:                    (unsigned long long)thread_stats.slab_stats[i].incr_hits);
      216:  589:            APPEND_NUM_STAT(i, "decr_hits", "%llu",
       72:  590:                    (unsigned long long)thread_stats.slab_stats[i].decr_hits);
      216:  591:            APPEND_NUM_STAT(i, "cas_hits", "%llu",
       72:  592:                    (unsigned long long)thread_stats.slab_stats[i].cas_hits);
      216:  593:            APPEND_NUM_STAT(i, "cas_badval", "%llu",
       72:  594:                    (unsigned long long)thread_stats.slab_stats[i].cas_badval);
      216:  595:            APPEND_NUM_STAT(i, "touch_hits", "%llu",
       72:  596:                    (unsigned long long)thread_stats.slab_stats[i].touch_hits);
       72:  597:            total++;
        -:  598:        }
        -:  599:    }
        -:  600:
        -:  601:    /* add overall slab stats and append terminator */
        -:  602:
       26:  603:    APPEND_STAT("active_slabs", "%d", total);
       26:  604:    APPEND_STAT("total_malloced", "%llu", (unsigned long long)mem_malloced);
       26:  605:    add_stats(NULL, 0, NULL, 0, c);
       26:  606:}
------------------
do_slabs_stats:
       26:  552:static void do_slabs_stats(ADD_STAT add_stats, void *c) {
       26:  553:    int i, total;
        -:  554:    /* Get the per-thread stats which contain some interesting aggregates */
       26:  555:    struct thread_stats thread_stats;
       26:  556:    threadlocal_stats_aggregate(&thread_stats);
        -:  557:
       26:  558:    total = 0;
     1030:  559:    for(i = POWER_SMALLEST; i <= power_largest; i++) {
     1004:  560:        slabclass_t *p = &slabclass[i];
     1004:  561:        if (p->slabs != 0) {
       72:  562:            uint32_t perslab, slabs;
       72:  563:            slabs = p->slabs;
       72:  564:            perslab = p->perslab;
        -:  565:
       72:  566:            char key_str[STAT_KEY_LEN];
       72:  567:            char val_str[STAT_VAL_LEN];
       72:  568:            int klen = 0, vlen = 0;
        -:  569:
      216:  570:            APPEND_NUM_STAT(i, "chunk_size", "%u", p->size);
      216:  571:            APPEND_NUM_STAT(i, "chunks_per_page", "%u", perslab);
      216:  572:            APPEND_NUM_STAT(i, "total_pages", "%u", slabs);
      216:  573:            APPEND_NUM_STAT(i, "total_chunks", "%u", slabs * perslab);
      216:  574:            APPEND_NUM_STAT(i, "used_chunks", "%u",
       72:  575:                            slabs*perslab - p->sl_curr);
      216:  576:            APPEND_NUM_STAT(i, "free_chunks", "%u", p->sl_curr);
        -:  577:            /* Stat is dead, but displaying zero instead of removing it. */
      216:  578:            APPEND_NUM_STAT(i, "free_chunks_end", "%u", 0);
      216:  579:            APPEND_NUM_STAT(i, "mem_requested", "%llu",
       72:  580:                            (unsigned long long)p->requested);
      216:  581:            APPEND_NUM_STAT(i, "get_hits", "%llu",
       72:  582:                    (unsigned long long)thread_stats.slab_stats[i].get_hits);
      216:  583:            APPEND_NUM_STAT(i, "cmd_set", "%llu",
       72:  584:                    (unsigned long long)thread_stats.slab_stats[i].set_cmds);
      216:  585:            APPEND_NUM_STAT(i, "delete_hits", "%llu",
       72:  586:                    (unsigned long long)thread_stats.slab_stats[i].delete_hits);
      216:  587:            APPEND_NUM_STAT(i, "incr_hits", "%llu",
       72:  588:                    (unsigned long long)thread_stats.slab_stats[i].incr_hits);
      216:  589:            APPEND_NUM_STAT(i, "decr_hits", "%llu",
       72:  590:                    (unsigned long long)thread_stats.slab_stats[i].decr_hits);
      216:  591:            APPEND_NUM_STAT(i, "cas_hits", "%llu",
       72:  592:                    (unsigned long long)thread_stats.slab_stats[i].cas_hits);
      216:  593:            APPEND_NUM_STAT(i, "cas_badval", "%llu",
       72:  594:                    (unsigned long long)thread_stats.slab_stats[i].cas_badval);
      216:  595:            APPEND_NUM_STAT(i, "touch_hits", "%llu",
       72:  596:                    (unsigned long long)thread_stats.slab_stats[i].touch_hits);
       72:  597:            total++;
        -:  598:        }
        -:  599:    }
        -:  600:
        -:  601:    /* add overall slab stats and append terminator */
        -:  602:
       26:  603:    APPEND_STAT("active_slabs", "%d", total);
       26:  604:    APPEND_STAT("total_malloced", "%llu", (unsigned long long)mem_malloced);
       26:  605:    add_stats(NULL, 0, NULL, 0, c);
       26:  606:}
------------------
do_slabs_stats:
       26:  552:static void do_slabs_stats(ADD_STAT add_stats, void *c) {
       26:  553:    int i, total;
        -:  554:    /* Get the per-thread stats which contain some interesting aggregates */
       26:  555:    struct thread_stats thread_stats;
       26:  556:    threadlocal_stats_aggregate(&thread_stats);
        -:  557:
       26:  558:    total = 0;
     1030:  559:    for(i = POWER_SMALLEST; i <= power_largest; i++) {
     1004:  560:        slabclass_t *p = &slabclass[i];
     1004:  561:        if (p->slabs != 0) {
       72:  562:            uint32_t perslab, slabs;
       72:  563:            slabs = p->slabs;
       72:  564:            perslab = p->perslab;
        -:  565:
       72:  566:            char key_str[STAT_KEY_LEN];
       72:  567:            char val_str[STAT_VAL_LEN];
       72:  568:            int klen = 0, vlen = 0;
        -:  569:
      216:  570:            APPEND_NUM_STAT(i, "chunk_size", "%u", p->size);
      216:  571:            APPEND_NUM_STAT(i, "chunks_per_page", "%u", perslab);
      216:  572:            APPEND_NUM_STAT(i, "total_pages", "%u", slabs);
      216:  573:            APPEND_NUM_STAT(i, "total_chunks", "%u", slabs * perslab);
      216:  574:            APPEND_NUM_STAT(i, "used_chunks", "%u",
       72:  575:                            slabs*perslab - p->sl_curr);
      216:  576:            APPEND_NUM_STAT(i, "free_chunks", "%u", p->sl_curr);
        -:  577:            /* Stat is dead, but displaying zero instead of removing it. */
      216:  578:            APPEND_NUM_STAT(i, "free_chunks_end", "%u", 0);
      216:  579:            APPEND_NUM_STAT(i, "mem_requested", "%llu",
       72:  580:                            (unsigned long long)p->requested);
      216:  581:            APPEND_NUM_STAT(i, "get_hits", "%llu",
       72:  582:                    (unsigned long long)thread_stats.slab_stats[i].get_hits);
      216:  583:            APPEND_NUM_STAT(i, "cmd_set", "%llu",
       72:  584:                    (unsigned long long)thread_stats.slab_stats[i].set_cmds);
      216:  585:            APPEND_NUM_STAT(i, "delete_hits", "%llu",
       72:  586:                    (unsigned long long)thread_stats.slab_stats[i].delete_hits);
      216:  587:            APPEND_NUM_STAT(i, "incr_hits", "%llu",
       72:  588:                    (unsigned long long)thread_stats.slab_stats[i].incr_hits);
      216:  589:            APPEND_NUM_STAT(i, "decr_hits", "%llu",
       72:  590:                    (unsigned long long)thread_stats.slab_stats[i].decr_hits);
      216:  591:            APPEND_NUM_STAT(i, "cas_hits", "%llu",
       72:  592:                    (unsigned long long)thread_stats.slab_stats[i].cas_hits);
      216:  593:            APPEND_NUM_STAT(i, "cas_badval", "%llu",
       72:  594:                    (unsigned long long)thread_stats.slab_stats[i].cas_badval);
      216:  595:            APPEND_NUM_STAT(i, "touch_hits", "%llu",
       72:  596:                    (unsigned long long)thread_stats.slab_stats[i].touch_hits);
       72:  597:            total++;
        -:  598:        }
        -:  599:    }
        -:  600:
        -:  601:    /* add overall slab stats and append terminator */
        -:  602:
       26:  603:    APPEND_STAT("active_slabs", "%d", total);
       26:  604:    APPEND_STAT("total_malloced", "%llu", (unsigned long long)mem_malloced);
       26:  605:    add_stats(NULL, 0, NULL, 0, c);
       26:  606:}
------------------
        -:  607:
     1887:  608:static void *memory_allocate(size_t size) {
     1887:  609:    void *ret;
        -:  610:
     1887:  611:    if (mem_base == NULL) {
        -:  612:        /* We are not using a preallocated large memory chunk */
     1887:  613:        ret = malloc(size);
        -:  614:    } else {
    #####:  615:        ret = mem_current;
        -:  616:
    #####:  617:        if (size > mem_avail) {
        -:  618:            return NULL;
        -:  619:        }
        -:  620:
        -:  621:        /* mem_current pointer _must_ be aligned!!! */
    #####:  622:        if (size % CHUNK_ALIGN_BYTES) {
    #####:  623:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  624:        }
        -:  625:
    #####:  626:        mem_current = ((char*)mem_current) + size;
    #####:  627:        if (size < mem_avail) {
    #####:  628:            mem_avail -= size;
        -:  629:        } else {
    #####:  630:            mem_avail = 0;
        -:  631:        }
        -:  632:    }
     1887:  633:    mem_malloced += size;
        -:  634:
     1887:  635:    return ret;
        -:  636:}
------------------
memory_allocate:
      629:  608:static void *memory_allocate(size_t size) {
      629:  609:    void *ret;
        -:  610:
      629:  611:    if (mem_base == NULL) {
        -:  612:        /* We are not using a preallocated large memory chunk */
      629:  613:        ret = malloc(size);
        -:  614:    } else {
    #####:  615:        ret = mem_current;
        -:  616:
    #####:  617:        if (size > mem_avail) {
        -:  618:            return NULL;
        -:  619:        }
        -:  620:
        -:  621:        /* mem_current pointer _must_ be aligned!!! */
    #####:  622:        if (size % CHUNK_ALIGN_BYTES) {
    #####:  623:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  624:        }
        -:  625:
    #####:  626:        mem_current = ((char*)mem_current) + size;
    #####:  627:        if (size < mem_avail) {
    #####:  628:            mem_avail -= size;
        -:  629:        } else {
    #####:  630:            mem_avail = 0;
        -:  631:        }
        -:  632:    }
      629:  633:    mem_malloced += size;
        -:  634:
      629:  635:    return ret;
        -:  636:}
------------------
memory_allocate:
      629:  608:static void *memory_allocate(size_t size) {
      629:  609:    void *ret;
        -:  610:
      629:  611:    if (mem_base == NULL) {
        -:  612:        /* We are not using a preallocated large memory chunk */
      629:  613:        ret = malloc(size);
        -:  614:    } else {
    #####:  615:        ret = mem_current;
        -:  616:
    #####:  617:        if (size > mem_avail) {
        -:  618:            return NULL;
        -:  619:        }
        -:  620:
        -:  621:        /* mem_current pointer _must_ be aligned!!! */
    #####:  622:        if (size % CHUNK_ALIGN_BYTES) {
    #####:  623:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  624:        }
        -:  625:
    #####:  626:        mem_current = ((char*)mem_current) + size;
    #####:  627:        if (size < mem_avail) {
    #####:  628:            mem_avail -= size;
        -:  629:        } else {
    #####:  630:            mem_avail = 0;
        -:  631:        }
        -:  632:    }
      629:  633:    mem_malloced += size;
        -:  634:
      629:  635:    return ret;
        -:  636:}
------------------
memory_allocate:
      629:  608:static void *memory_allocate(size_t size) {
      629:  609:    void *ret;
        -:  610:
      629:  611:    if (mem_base == NULL) {
        -:  612:        /* We are not using a preallocated large memory chunk */
      629:  613:        ret = malloc(size);
        -:  614:    } else {
    #####:  615:        ret = mem_current;
        -:  616:
    #####:  617:        if (size > mem_avail) {
        -:  618:            return NULL;
        -:  619:        }
        -:  620:
        -:  621:        /* mem_current pointer _must_ be aligned!!! */
    #####:  622:        if (size % CHUNK_ALIGN_BYTES) {
    #####:  623:            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        -:  624:        }
        -:  625:
    #####:  626:        mem_current = ((char*)mem_current) + size;
    #####:  627:        if (size < mem_avail) {
    #####:  628:            mem_avail -= size;
        -:  629:        } else {
    #####:  630:            mem_avail = 0;
        -:  631:        }
        -:  632:    }
      629:  633:    mem_malloced += size;
        -:  634:
      629:  635:    return ret;
        -:  636:}
------------------
        -:  637:
        -:  638:/* Must only be used if all pages are item_size_max */
      291:  639:static void memory_release() {
      291:  640:    void *p = NULL;
      291:  641:    if (mem_base != NULL)
        -:  642:        return;
        -:  643:
      291:  644:    if (!settings.slab_reassign)
        -:  645:        return;
        -:  646:
      306:  647:    while (mem_malloced > mem_limit &&
       30:  648:            (p = get_page_from_global_pool()) != NULL) {
       15:  649:        free(p);
       15:  650:        mem_malloced -= settings.slab_page_size;
        -:  651:    }
        -:  652:}
------------------
memory_release:
       97:  639:static void memory_release() {
       97:  640:    void *p = NULL;
       97:  641:    if (mem_base != NULL)
        -:  642:        return;
        -:  643:
       97:  644:    if (!settings.slab_reassign)
        -:  645:        return;
        -:  646:
      102:  647:    while (mem_malloced > mem_limit &&
       10:  648:            (p = get_page_from_global_pool()) != NULL) {
        5:  649:        free(p);
        5:  650:        mem_malloced -= settings.slab_page_size;
        -:  651:    }
        -:  652:}
------------------
memory_release:
       97:  639:static void memory_release() {
       97:  640:    void *p = NULL;
       97:  641:    if (mem_base != NULL)
        -:  642:        return;
        -:  643:
       97:  644:    if (!settings.slab_reassign)
        -:  645:        return;
        -:  646:
      102:  647:    while (mem_malloced > mem_limit &&
       10:  648:            (p = get_page_from_global_pool()) != NULL) {
        5:  649:        free(p);
        5:  650:        mem_malloced -= settings.slab_page_size;
        -:  651:    }
        -:  652:}
------------------
memory_release:
       97:  639:static void memory_release() {
       97:  640:    void *p = NULL;
       97:  641:    if (mem_base != NULL)
        -:  642:        return;
        -:  643:
       97:  644:    if (!settings.slab_reassign)
        -:  645:        return;
        -:  646:
      102:  647:    while (mem_malloced > mem_limit &&
       10:  648:            (p = get_page_from_global_pool()) != NULL) {
        5:  649:        free(p);
        5:  650:        mem_malloced -= settings.slab_page_size;
        -:  651:    }
        -:  652:}
------------------
        -:  653:
   850851:  654:void *slabs_alloc(size_t size, unsigned int id, uint64_t *total_bytes,
        -:  655:        unsigned int flags) {
   850851:  656:    void *ret;
        -:  657:
   850851:  658:    pthread_mutex_lock(&slabs_lock);
   850851:  659:    ret = do_slabs_alloc(size, id, total_bytes, flags);
   850851:  660:    pthread_mutex_unlock(&slabs_lock);
   850851:  661:    return ret;
        -:  662:}
------------------
slabs_alloc:
   283617:  654:void *slabs_alloc(size_t size, unsigned int id, uint64_t *total_bytes,
        -:  655:        unsigned int flags) {
   283617:  656:    void *ret;
        -:  657:
   283617:  658:    pthread_mutex_lock(&slabs_lock);
   283617:  659:    ret = do_slabs_alloc(size, id, total_bytes, flags);
   283617:  660:    pthread_mutex_unlock(&slabs_lock);
   283617:  661:    return ret;
        -:  662:}
------------------
slabs_alloc:
   283617:  654:void *slabs_alloc(size_t size, unsigned int id, uint64_t *total_bytes,
        -:  655:        unsigned int flags) {
   283617:  656:    void *ret;
        -:  657:
   283617:  658:    pthread_mutex_lock(&slabs_lock);
   283617:  659:    ret = do_slabs_alloc(size, id, total_bytes, flags);
   283617:  660:    pthread_mutex_unlock(&slabs_lock);
   283617:  661:    return ret;
        -:  662:}
------------------
slabs_alloc:
   283617:  654:void *slabs_alloc(size_t size, unsigned int id, uint64_t *total_bytes,
        -:  655:        unsigned int flags) {
   283617:  656:    void *ret;
        -:  657:
   283617:  658:    pthread_mutex_lock(&slabs_lock);
   283617:  659:    ret = do_slabs_alloc(size, id, total_bytes, flags);
   283617:  660:    pthread_mutex_unlock(&slabs_lock);
   283617:  661:    return ret;
        -:  662:}
------------------
        -:  663:
   239580:  664:void slabs_free(void *ptr, size_t size, unsigned int id) {
   239580:  665:    pthread_mutex_lock(&slabs_lock);
   239580:  666:    do_slabs_free(ptr, size, id);
   239580:  667:    pthread_mutex_unlock(&slabs_lock);
   239580:  668:}
------------------
slabs_free:
    79860:  664:void slabs_free(void *ptr, size_t size, unsigned int id) {
    79860:  665:    pthread_mutex_lock(&slabs_lock);
    79860:  666:    do_slabs_free(ptr, size, id);
    79860:  667:    pthread_mutex_unlock(&slabs_lock);
    79860:  668:}
------------------
slabs_free:
    79860:  664:void slabs_free(void *ptr, size_t size, unsigned int id) {
    79860:  665:    pthread_mutex_lock(&slabs_lock);
    79860:  666:    do_slabs_free(ptr, size, id);
    79860:  667:    pthread_mutex_unlock(&slabs_lock);
    79860:  668:}
------------------
slabs_free:
    79860:  664:void slabs_free(void *ptr, size_t size, unsigned int id) {
    79860:  665:    pthread_mutex_lock(&slabs_lock);
    79860:  666:    do_slabs_free(ptr, size, id);
    79860:  667:    pthread_mutex_unlock(&slabs_lock);
    79860:  668:}
------------------
        -:  669:
       78:  670:void slabs_stats(ADD_STAT add_stats, void *c) {
       78:  671:    pthread_mutex_lock(&slabs_lock);
       78:  672:    do_slabs_stats(add_stats, c);
       78:  673:    pthread_mutex_unlock(&slabs_lock);
       78:  674:}
------------------
slabs_stats:
       26:  670:void slabs_stats(ADD_STAT add_stats, void *c) {
       26:  671:    pthread_mutex_lock(&slabs_lock);
       26:  672:    do_slabs_stats(add_stats, c);
       26:  673:    pthread_mutex_unlock(&slabs_lock);
       26:  674:}
------------------
slabs_stats:
       26:  670:void slabs_stats(ADD_STAT add_stats, void *c) {
       26:  671:    pthread_mutex_lock(&slabs_lock);
       26:  672:    do_slabs_stats(add_stats, c);
       26:  673:    pthread_mutex_unlock(&slabs_lock);
       26:  674:}
------------------
slabs_stats:
       26:  670:void slabs_stats(ADD_STAT add_stats, void *c) {
       26:  671:    pthread_mutex_lock(&slabs_lock);
       26:  672:    do_slabs_stats(add_stats, c);
       26:  673:    pthread_mutex_unlock(&slabs_lock);
       26:  674:}
------------------
        -:  675:
        -:  676:static bool do_slabs_adjust_mem_limit(size_t new_mem_limit) {
        -:  677:    /* Cannot adjust memory limit at runtime if prealloc'ed */
        9:  678:    if (mem_base != NULL)
        -:  679:        return false;
        9:  680:    settings.maxbytes = new_mem_limit;
        9:  681:    mem_limit = new_mem_limit;
        9:  682:    mem_limit_reached = false; /* Will reset on next alloc */
        9:  683:    memory_release(); /* free what might already be in the global pool */
        9:  684:    return true;
        -:  685:}
        -:  686:
        9:  687:bool slabs_adjust_mem_limit(size_t new_mem_limit) {
        9:  688:    bool ret;
        9:  689:    pthread_mutex_lock(&slabs_lock);
        9:  690:    ret = do_slabs_adjust_mem_limit(new_mem_limit);
        9:  691:    pthread_mutex_unlock(&slabs_lock);
        9:  692:    return ret;
        -:  693:}
------------------
slabs_adjust_mem_limit:
        3:  687:bool slabs_adjust_mem_limit(size_t new_mem_limit) {
        3:  688:    bool ret;
        3:  689:    pthread_mutex_lock(&slabs_lock);
        3:  690:    ret = do_slabs_adjust_mem_limit(new_mem_limit);
        3:  691:    pthread_mutex_unlock(&slabs_lock);
        3:  692:    return ret;
        -:  693:}
------------------
slabs_adjust_mem_limit:
        3:  687:bool slabs_adjust_mem_limit(size_t new_mem_limit) {
        3:  688:    bool ret;
        3:  689:    pthread_mutex_lock(&slabs_lock);
        3:  690:    ret = do_slabs_adjust_mem_limit(new_mem_limit);
        3:  691:    pthread_mutex_unlock(&slabs_lock);
        3:  692:    return ret;
        -:  693:}
------------------
slabs_adjust_mem_limit:
        3:  687:bool slabs_adjust_mem_limit(size_t new_mem_limit) {
        3:  688:    bool ret;
        3:  689:    pthread_mutex_lock(&slabs_lock);
        3:  690:    ret = do_slabs_adjust_mem_limit(new_mem_limit);
        3:  691:    pthread_mutex_unlock(&slabs_lock);
        3:  692:    return ret;
        -:  693:}
------------------
        -:  694:
    #####:  695:void slabs_adjust_mem_requested(unsigned int id, size_t old, size_t ntotal)
        -:  696:{
    #####:  697:    pthread_mutex_lock(&slabs_lock);
    #####:  698:    slabclass_t *p;
    #####:  699:    if (id < POWER_SMALLEST || id > power_largest) {
    #####:  700:        fprintf(stderr, "Internal error! Invalid slab class\n");
    #####:  701:        abort();
        -:  702:    }
        -:  703:
    #####:  704:    p = &slabclass[id];
    #####:  705:    p->requested = p->requested - old + ntotal;
    #####:  706:    pthread_mutex_unlock(&slabs_lock);
    #####:  707:}
------------------
slabs_adjust_mem_requested:
    #####:  695:void slabs_adjust_mem_requested(unsigned int id, size_t old, size_t ntotal)
        -:  696:{
    #####:  697:    pthread_mutex_lock(&slabs_lock);
    #####:  698:    slabclass_t *p;
    #####:  699:    if (id < POWER_SMALLEST || id > power_largest) {
    #####:  700:        fprintf(stderr, "Internal error! Invalid slab class\n");
    #####:  701:        abort();
        -:  702:    }
        -:  703:
    #####:  704:    p = &slabclass[id];
    #####:  705:    p->requested = p->requested - old + ntotal;
    #####:  706:    pthread_mutex_unlock(&slabs_lock);
    #####:  707:}
------------------
slabs_adjust_mem_requested:
    #####:  695:void slabs_adjust_mem_requested(unsigned int id, size_t old, size_t ntotal)
        -:  696:{
    #####:  697:    pthread_mutex_lock(&slabs_lock);
    #####:  698:    slabclass_t *p;
    #####:  699:    if (id < POWER_SMALLEST || id > power_largest) {
    #####:  700:        fprintf(stderr, "Internal error! Invalid slab class\n");
    #####:  701:        abort();
        -:  702:    }
        -:  703:
    #####:  704:    p = &slabclass[id];
    #####:  705:    p->requested = p->requested - old + ntotal;
    #####:  706:    pthread_mutex_unlock(&slabs_lock);
    #####:  707:}
------------------
slabs_adjust_mem_requested:
    #####:  695:void slabs_adjust_mem_requested(unsigned int id, size_t old, size_t ntotal)
        -:  696:{
    #####:  697:    pthread_mutex_lock(&slabs_lock);
    #####:  698:    slabclass_t *p;
    #####:  699:    if (id < POWER_SMALLEST || id > power_largest) {
    #####:  700:        fprintf(stderr, "Internal error! Invalid slab class\n");
    #####:  701:        abort();
        -:  702:    }
        -:  703:
    #####:  704:    p = &slabclass[id];
    #####:  705:    p->requested = p->requested - old + ntotal;
    #####:  706:    pthread_mutex_unlock(&slabs_lock);
    #####:  707:}
------------------
        -:  708:
   671958:  709:unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,
        -:  710:        uint64_t *total_bytes, unsigned int *chunks_perslab) {
   671958:  711:    unsigned int ret;
   671958:  712:    slabclass_t *p;
        -:  713:
   671958:  714:    pthread_mutex_lock(&slabs_lock);
   671958:  715:    p = &slabclass[id];
   671958:  716:    ret = p->sl_curr;
   671958:  717:    if (mem_flag != NULL)
    #####:  718:        *mem_flag = mem_malloced >= mem_limit ? true : false;
   671958:  719:    if (total_bytes != NULL)
   671958:  720:        *total_bytes = p->requested;
   671958:  721:    if (chunks_perslab != NULL)
   671958:  722:        *chunks_perslab = p->perslab;
   671958:  723:    pthread_mutex_unlock(&slabs_lock);
   671958:  724:    return ret;
        -:  725:}
------------------
slabs_available_chunks:
   223986:  709:unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,
        -:  710:        uint64_t *total_bytes, unsigned int *chunks_perslab) {
   223986:  711:    unsigned int ret;
   223986:  712:    slabclass_t *p;
        -:  713:
   223986:  714:    pthread_mutex_lock(&slabs_lock);
   223986:  715:    p = &slabclass[id];
   223986:  716:    ret = p->sl_curr;
   223986:  717:    if (mem_flag != NULL)
    #####:  718:        *mem_flag = mem_malloced >= mem_limit ? true : false;
   223986:  719:    if (total_bytes != NULL)
   223986:  720:        *total_bytes = p->requested;
   223986:  721:    if (chunks_perslab != NULL)
   223986:  722:        *chunks_perslab = p->perslab;
   223986:  723:    pthread_mutex_unlock(&slabs_lock);
   223986:  724:    return ret;
        -:  725:}
------------------
slabs_available_chunks:
   223986:  709:unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,
        -:  710:        uint64_t *total_bytes, unsigned int *chunks_perslab) {
   223986:  711:    unsigned int ret;
   223986:  712:    slabclass_t *p;
        -:  713:
   223986:  714:    pthread_mutex_lock(&slabs_lock);
   223986:  715:    p = &slabclass[id];
   223986:  716:    ret = p->sl_curr;
   223986:  717:    if (mem_flag != NULL)
    #####:  718:        *mem_flag = mem_malloced >= mem_limit ? true : false;
   223986:  719:    if (total_bytes != NULL)
   223986:  720:        *total_bytes = p->requested;
   223986:  721:    if (chunks_perslab != NULL)
   223986:  722:        *chunks_perslab = p->perslab;
   223986:  723:    pthread_mutex_unlock(&slabs_lock);
   223986:  724:    return ret;
        -:  725:}
------------------
slabs_available_chunks:
   223986:  709:unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,
        -:  710:        uint64_t *total_bytes, unsigned int *chunks_perslab) {
   223986:  711:    unsigned int ret;
   223986:  712:    slabclass_t *p;
        -:  713:
   223986:  714:    pthread_mutex_lock(&slabs_lock);
   223986:  715:    p = &slabclass[id];
   223986:  716:    ret = p->sl_curr;
   223986:  717:    if (mem_flag != NULL)
    #####:  718:        *mem_flag = mem_malloced >= mem_limit ? true : false;
   223986:  719:    if (total_bytes != NULL)
   223986:  720:        *total_bytes = p->requested;
   223986:  721:    if (chunks_perslab != NULL)
   223986:  722:        *chunks_perslab = p->perslab;
   223986:  723:    pthread_mutex_unlock(&slabs_lock);
   223986:  724:    return ret;
        -:  725:}
------------------
        -:  726:
        -:  727:/* The slabber system could avoid needing to understand much, if anything,
        -:  728: * about items if callbacks were strategically used. Due to how the slab mover
        -:  729: * works, certain flag bits can only be adjusted while holding the slabs lock.
        -:  730: * Using these functions, isolate sections of code needing this and turn them
        -:  731: * into callbacks when an interface becomes more obvious.
        -:  732: */
   408513:  733:void slabs_mlock(void) {
   408513:  734:    pthread_mutex_lock(&slabs_lock);
   408513:  735:}
------------------
slabs_mlock:
   136171:  733:void slabs_mlock(void) {
   136171:  734:    pthread_mutex_lock(&slabs_lock);
   136171:  735:}
------------------
slabs_mlock:
   136171:  733:void slabs_mlock(void) {
   136171:  734:    pthread_mutex_lock(&slabs_lock);
   136171:  735:}
------------------
slabs_mlock:
   136171:  733:void slabs_mlock(void) {
   136171:  734:    pthread_mutex_lock(&slabs_lock);
   136171:  735:}
------------------
        -:  736:
   408513:  737:void slabs_munlock(void) {
   408513:  738:    pthread_mutex_unlock(&slabs_lock);
   408513:  739:}
------------------
slabs_munlock:
   136171:  737:void slabs_munlock(void) {
   136171:  738:    pthread_mutex_unlock(&slabs_lock);
   136171:  739:}
------------------
slabs_munlock:
   136171:  737:void slabs_munlock(void) {
   136171:  738:    pthread_mutex_unlock(&slabs_lock);
   136171:  739:}
------------------
slabs_munlock:
   136171:  737:void slabs_munlock(void) {
   136171:  738:    pthread_mutex_unlock(&slabs_lock);
   136171:  739:}
------------------
        -:  740:
        -:  741:static pthread_cond_t slab_rebalance_cond = PTHREAD_COND_INITIALIZER;
        -:  742:static volatile int do_run_slab_thread = 1;
        -:  743:static volatile int do_run_slab_rebalance_thread = 1;
        -:  744:
        -:  745:#define DEFAULT_SLAB_BULK_CHECK 1
        -:  746:int slab_bulk_check = DEFAULT_SLAB_BULK_CHECK;
        -:  747:
      291:  748:static int slab_rebalance_start(void) {
      291:  749:    slabclass_t *s_cls;
      291:  750:    int no_go = 0;
        -:  751:
      291:  752:    pthread_mutex_lock(&slabs_lock);
        -:  753:
      291:  754:    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
      291:  755:        slab_rebal.s_clsid > power_largest  ||
      291:  756:        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
      291:  757:        slab_rebal.d_clsid > power_largest  ||
        -:  758:        slab_rebal.s_clsid == slab_rebal.d_clsid)
    #####:  759:        no_go = -2;
        -:  760:
      291:  761:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  762:
      291:  763:    if (!grow_slab_list(slab_rebal.d_clsid)) {
    #####:  764:        no_go = -1;
        -:  765:    }
        -:  766:
      291:  767:    if (s_cls->slabs < 2)
        -:  768:        no_go = -3;
        -:  769:
      291:  770:    if (no_go != 0) {
    #####:  771:        pthread_mutex_unlock(&slabs_lock);
    #####:  772:        return no_go; /* Should use a wrapper function... */
        -:  773:    }
        -:  774:
        -:  775:    /* Always kill the first available slab page as it is most likely to
        -:  776:     * contain the oldest items
        -:  777:     */
      291:  778:    slab_rebal.slab_start = s_cls->slab_list[0];
      582:  779:    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
      291:  780:        (s_cls->size * s_cls->perslab);
      291:  781:    slab_rebal.slab_pos   = slab_rebal.slab_start;
      291:  782:    slab_rebal.done       = 0;
        -:  783:    // Don't need to do chunk move work if page is in global pool.
      291:  784:    if (slab_rebal.s_clsid == SLAB_GLOBAL_PAGE_POOL) {
    #####:  785:        slab_rebal.done = 1;
        -:  786:    }
        -:  787:
      291:  788:    slab_rebalance_signal = 2;
        -:  789:
      291:  790:    if (settings.verbose > 1) {
    #####:  791:        fprintf(stderr, "Started a slab rebalance\n");
        -:  792:    }
        -:  793:
      291:  794:    pthread_mutex_unlock(&slabs_lock);
        -:  795:
      291:  796:    STATS_LOCK();
      291:  797:    stats_state.slab_reassign_running = true;
      291:  798:    STATS_UNLOCK();
        -:  799:
      291:  800:    return 0;
        -:  801:}
------------------
slab_rebalance_start:
       97:  748:static int slab_rebalance_start(void) {
       97:  749:    slabclass_t *s_cls;
       97:  750:    int no_go = 0;
        -:  751:
       97:  752:    pthread_mutex_lock(&slabs_lock);
        -:  753:
       97:  754:    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
       97:  755:        slab_rebal.s_clsid > power_largest  ||
       97:  756:        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
       97:  757:        slab_rebal.d_clsid > power_largest  ||
        -:  758:        slab_rebal.s_clsid == slab_rebal.d_clsid)
    #####:  759:        no_go = -2;
        -:  760:
       97:  761:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  762:
       97:  763:    if (!grow_slab_list(slab_rebal.d_clsid)) {
    #####:  764:        no_go = -1;
        -:  765:    }
        -:  766:
       97:  767:    if (s_cls->slabs < 2)
        -:  768:        no_go = -3;
        -:  769:
       97:  770:    if (no_go != 0) {
    #####:  771:        pthread_mutex_unlock(&slabs_lock);
    #####:  772:        return no_go; /* Should use a wrapper function... */
        -:  773:    }
        -:  774:
        -:  775:    /* Always kill the first available slab page as it is most likely to
        -:  776:     * contain the oldest items
        -:  777:     */
       97:  778:    slab_rebal.slab_start = s_cls->slab_list[0];
      194:  779:    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
       97:  780:        (s_cls->size * s_cls->perslab);
       97:  781:    slab_rebal.slab_pos   = slab_rebal.slab_start;
       97:  782:    slab_rebal.done       = 0;
        -:  783:    // Don't need to do chunk move work if page is in global pool.
       97:  784:    if (slab_rebal.s_clsid == SLAB_GLOBAL_PAGE_POOL) {
    #####:  785:        slab_rebal.done = 1;
        -:  786:    }
        -:  787:
       97:  788:    slab_rebalance_signal = 2;
        -:  789:
       97:  790:    if (settings.verbose > 1) {
    #####:  791:        fprintf(stderr, "Started a slab rebalance\n");
        -:  792:    }
        -:  793:
       97:  794:    pthread_mutex_unlock(&slabs_lock);
        -:  795:
       97:  796:    STATS_LOCK();
       97:  797:    stats_state.slab_reassign_running = true;
       97:  798:    STATS_UNLOCK();
        -:  799:
       97:  800:    return 0;
        -:  801:}
------------------
slab_rebalance_start:
       97:  748:static int slab_rebalance_start(void) {
       97:  749:    slabclass_t *s_cls;
       97:  750:    int no_go = 0;
        -:  751:
       97:  752:    pthread_mutex_lock(&slabs_lock);
        -:  753:
       97:  754:    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
       97:  755:        slab_rebal.s_clsid > power_largest  ||
       97:  756:        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
       97:  757:        slab_rebal.d_clsid > power_largest  ||
        -:  758:        slab_rebal.s_clsid == slab_rebal.d_clsid)
    #####:  759:        no_go = -2;
        -:  760:
       97:  761:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  762:
       97:  763:    if (!grow_slab_list(slab_rebal.d_clsid)) {
    #####:  764:        no_go = -1;
        -:  765:    }
        -:  766:
       97:  767:    if (s_cls->slabs < 2)
        -:  768:        no_go = -3;
        -:  769:
       97:  770:    if (no_go != 0) {
    #####:  771:        pthread_mutex_unlock(&slabs_lock);
    #####:  772:        return no_go; /* Should use a wrapper function... */
        -:  773:    }
        -:  774:
        -:  775:    /* Always kill the first available slab page as it is most likely to
        -:  776:     * contain the oldest items
        -:  777:     */
       97:  778:    slab_rebal.slab_start = s_cls->slab_list[0];
      194:  779:    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
       97:  780:        (s_cls->size * s_cls->perslab);
       97:  781:    slab_rebal.slab_pos   = slab_rebal.slab_start;
       97:  782:    slab_rebal.done       = 0;
        -:  783:    // Don't need to do chunk move work if page is in global pool.
       97:  784:    if (slab_rebal.s_clsid == SLAB_GLOBAL_PAGE_POOL) {
    #####:  785:        slab_rebal.done = 1;
        -:  786:    }
        -:  787:
       97:  788:    slab_rebalance_signal = 2;
        -:  789:
       97:  790:    if (settings.verbose > 1) {
    #####:  791:        fprintf(stderr, "Started a slab rebalance\n");
        -:  792:    }
        -:  793:
       97:  794:    pthread_mutex_unlock(&slabs_lock);
        -:  795:
       97:  796:    STATS_LOCK();
       97:  797:    stats_state.slab_reassign_running = true;
       97:  798:    STATS_UNLOCK();
        -:  799:
       97:  800:    return 0;
        -:  801:}
------------------
slab_rebalance_start:
       97:  748:static int slab_rebalance_start(void) {
       97:  749:    slabclass_t *s_cls;
       97:  750:    int no_go = 0;
        -:  751:
       97:  752:    pthread_mutex_lock(&slabs_lock);
        -:  753:
       97:  754:    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
       97:  755:        slab_rebal.s_clsid > power_largest  ||
       97:  756:        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
       97:  757:        slab_rebal.d_clsid > power_largest  ||
        -:  758:        slab_rebal.s_clsid == slab_rebal.d_clsid)
    #####:  759:        no_go = -2;
        -:  760:
       97:  761:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  762:
       97:  763:    if (!grow_slab_list(slab_rebal.d_clsid)) {
    #####:  764:        no_go = -1;
        -:  765:    }
        -:  766:
       97:  767:    if (s_cls->slabs < 2)
        -:  768:        no_go = -3;
        -:  769:
       97:  770:    if (no_go != 0) {
    #####:  771:        pthread_mutex_unlock(&slabs_lock);
    #####:  772:        return no_go; /* Should use a wrapper function... */
        -:  773:    }
        -:  774:
        -:  775:    /* Always kill the first available slab page as it is most likely to
        -:  776:     * contain the oldest items
        -:  777:     */
       97:  778:    slab_rebal.slab_start = s_cls->slab_list[0];
      194:  779:    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
       97:  780:        (s_cls->size * s_cls->perslab);
       97:  781:    slab_rebal.slab_pos   = slab_rebal.slab_start;
       97:  782:    slab_rebal.done       = 0;
        -:  783:    // Don't need to do chunk move work if page is in global pool.
       97:  784:    if (slab_rebal.s_clsid == SLAB_GLOBAL_PAGE_POOL) {
    #####:  785:        slab_rebal.done = 1;
        -:  786:    }
        -:  787:
       97:  788:    slab_rebalance_signal = 2;
        -:  789:
       97:  790:    if (settings.verbose > 1) {
    #####:  791:        fprintf(stderr, "Started a slab rebalance\n");
        -:  792:    }
        -:  793:
       97:  794:    pthread_mutex_unlock(&slabs_lock);
        -:  795:
       97:  796:    STATS_LOCK();
       97:  797:    stats_state.slab_reassign_running = true;
       97:  798:    STATS_UNLOCK();
        -:  799:
       97:  800:    return 0;
        -:  801:}
------------------
        -:  802:
        -:  803:/* CALLED WITH slabs_lock HELD */
     5352:  804:static void *slab_rebalance_alloc(const size_t size, unsigned int id) {
     5352:  805:    slabclass_t *s_cls;
     5352:  806:    s_cls = &slabclass[slab_rebal.s_clsid];
     5352:  807:    int x;
     5352:  808:    item *new_it = NULL;
        -:  809:
     6597:  810:    for (x = 0; x < s_cls->perslab; x++) {
     6597:  811:        new_it = do_slabs_alloc(size, id, NULL, SLABS_ALLOC_NO_NEWPAGE);
        -:  812:        /* check that memory isn't within the range to clear */
     6597:  813:        if (new_it == NULL) {
        -:  814:            break;
        -:  815:        }
     5340:  816:        if ((void *)new_it >= slab_rebal.slab_start
     1245:  817:            && (void *)new_it < slab_rebal.slab_end) {
        -:  818:            /* Pulled something we intend to free. Mark it as freed since
        -:  819:             * we've already done the work of unlinking it from the freelist.
        -:  820:             */
     1245:  821:            s_cls->requested -= size;
     1245:  822:            new_it->refcount = 0;
     1245:  823:            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -:  824:#ifdef DEBUG_SLAB_MOVER
        -:  825:            memcpy(ITEM_key(new_it), "deadbeef", 8);
        -:  826:#endif
     1245:  827:            new_it = NULL;
     1245:  828:            slab_rebal.inline_reclaim++;
        -:  829:        } else {
        -:  830:            break;
        -:  831:        }
        -:  832:    }
     5352:  833:    return new_it;
        -:  834:}
------------------
slab_rebalance_alloc:
     1784:  804:static void *slab_rebalance_alloc(const size_t size, unsigned int id) {
     1784:  805:    slabclass_t *s_cls;
     1784:  806:    s_cls = &slabclass[slab_rebal.s_clsid];
     1784:  807:    int x;
     1784:  808:    item *new_it = NULL;
        -:  809:
     2199:  810:    for (x = 0; x < s_cls->perslab; x++) {
     2199:  811:        new_it = do_slabs_alloc(size, id, NULL, SLABS_ALLOC_NO_NEWPAGE);
        -:  812:        /* check that memory isn't within the range to clear */
     2199:  813:        if (new_it == NULL) {
        -:  814:            break;
        -:  815:        }
     1780:  816:        if ((void *)new_it >= slab_rebal.slab_start
      415:  817:            && (void *)new_it < slab_rebal.slab_end) {
        -:  818:            /* Pulled something we intend to free. Mark it as freed since
        -:  819:             * we've already done the work of unlinking it from the freelist.
        -:  820:             */
      415:  821:            s_cls->requested -= size;
      415:  822:            new_it->refcount = 0;
      415:  823:            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -:  824:#ifdef DEBUG_SLAB_MOVER
        -:  825:            memcpy(ITEM_key(new_it), "deadbeef", 8);
        -:  826:#endif
      415:  827:            new_it = NULL;
      415:  828:            slab_rebal.inline_reclaim++;
        -:  829:        } else {
        -:  830:            break;
        -:  831:        }
        -:  832:    }
     1784:  833:    return new_it;
        -:  834:}
------------------
slab_rebalance_alloc:
     1784:  804:static void *slab_rebalance_alloc(const size_t size, unsigned int id) {
     1784:  805:    slabclass_t *s_cls;
     1784:  806:    s_cls = &slabclass[slab_rebal.s_clsid];
     1784:  807:    int x;
     1784:  808:    item *new_it = NULL;
        -:  809:
     2199:  810:    for (x = 0; x < s_cls->perslab; x++) {
     2199:  811:        new_it = do_slabs_alloc(size, id, NULL, SLABS_ALLOC_NO_NEWPAGE);
        -:  812:        /* check that memory isn't within the range to clear */
     2199:  813:        if (new_it == NULL) {
        -:  814:            break;
        -:  815:        }
     1780:  816:        if ((void *)new_it >= slab_rebal.slab_start
      415:  817:            && (void *)new_it < slab_rebal.slab_end) {
        -:  818:            /* Pulled something we intend to free. Mark it as freed since
        -:  819:             * we've already done the work of unlinking it from the freelist.
        -:  820:             */
      415:  821:            s_cls->requested -= size;
      415:  822:            new_it->refcount = 0;
      415:  823:            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -:  824:#ifdef DEBUG_SLAB_MOVER
        -:  825:            memcpy(ITEM_key(new_it), "deadbeef", 8);
        -:  826:#endif
      415:  827:            new_it = NULL;
      415:  828:            slab_rebal.inline_reclaim++;
        -:  829:        } else {
        -:  830:            break;
        -:  831:        }
        -:  832:    }
     1784:  833:    return new_it;
        -:  834:}
------------------
slab_rebalance_alloc:
     1784:  804:static void *slab_rebalance_alloc(const size_t size, unsigned int id) {
     1784:  805:    slabclass_t *s_cls;
     1784:  806:    s_cls = &slabclass[slab_rebal.s_clsid];
     1784:  807:    int x;
     1784:  808:    item *new_it = NULL;
        -:  809:
     2199:  810:    for (x = 0; x < s_cls->perslab; x++) {
     2199:  811:        new_it = do_slabs_alloc(size, id, NULL, SLABS_ALLOC_NO_NEWPAGE);
        -:  812:        /* check that memory isn't within the range to clear */
     2199:  813:        if (new_it == NULL) {
        -:  814:            break;
        -:  815:        }
     1780:  816:        if ((void *)new_it >= slab_rebal.slab_start
      415:  817:            && (void *)new_it < slab_rebal.slab_end) {
        -:  818:            /* Pulled something we intend to free. Mark it as freed since
        -:  819:             * we've already done the work of unlinking it from the freelist.
        -:  820:             */
      415:  821:            s_cls->requested -= size;
      415:  822:            new_it->refcount = 0;
      415:  823:            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -:  824:#ifdef DEBUG_SLAB_MOVER
        -:  825:            memcpy(ITEM_key(new_it), "deadbeef", 8);
        -:  826:#endif
      415:  827:            new_it = NULL;
      415:  828:            slab_rebal.inline_reclaim++;
        -:  829:        } else {
        -:  830:            break;
        -:  831:        }
        -:  832:    }
     1784:  833:    return new_it;
        -:  834:}
------------------
        -:  835:
        -:  836:/* CALLED WITH slabs_lock HELD */
        -:  837:/* detaches item/chunk from freelist. */
    #####:  838:static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {
        -:  839:    /* Ensure this was on the freelist and nothing else. */
    #####:  840:    assert(it->it_flags == ITEM_SLABBED);
    #####:  841:    if (s_cls->slots == it) {
    #####:  842:        s_cls->slots = it->next;
        -:  843:    }
    #####:  844:    if (it->next) it->next->prev = it->prev;
    #####:  845:    if (it->prev) it->prev->next = it->next;
    #####:  846:    s_cls->sl_curr--;
    #####:  847:}
------------------
slab_rebalance_cut_free:
    #####:  838:static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {
        -:  839:    /* Ensure this was on the freelist and nothing else. */
    #####:  840:    assert(it->it_flags == ITEM_SLABBED);
    #####:  841:    if (s_cls->slots == it) {
    #####:  842:        s_cls->slots = it->next;
        -:  843:    }
    #####:  844:    if (it->next) it->next->prev = it->prev;
    #####:  845:    if (it->prev) it->prev->next = it->next;
    #####:  846:    s_cls->sl_curr--;
    #####:  847:}
------------------
slab_rebalance_cut_free:
    #####:  838:static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {
        -:  839:    /* Ensure this was on the freelist and nothing else. */
    #####:  840:    assert(it->it_flags == ITEM_SLABBED);
    #####:  841:    if (s_cls->slots == it) {
    #####:  842:        s_cls->slots = it->next;
        -:  843:    }
    #####:  844:    if (it->next) it->next->prev = it->prev;
    #####:  845:    if (it->prev) it->prev->next = it->next;
    #####:  846:    s_cls->sl_curr--;
    #####:  847:}
------------------
slab_rebalance_cut_free:
    #####:  838:static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {
        -:  839:    /* Ensure this was on the freelist and nothing else. */
    #####:  840:    assert(it->it_flags == ITEM_SLABBED);
    #####:  841:    if (s_cls->slots == it) {
    #####:  842:        s_cls->slots = it->next;
        -:  843:    }
    #####:  844:    if (it->next) it->next->prev = it->prev;
    #####:  845:    if (it->prev) it->prev->next = it->next;
    #####:  846:    s_cls->sl_curr--;
    #####:  847:}
------------------
        -:  848:
        -:  849:enum move_status {
        -:  850:    MOVE_PASS=0, MOVE_FROM_SLAB, MOVE_FROM_LRU, MOVE_BUSY, MOVE_LOCKED
        -:  851:};
        -:  852:
        -:  853:#define SLAB_MOVE_MAX_LOOPS 1000
        -:  854:
        -:  855:/* refcount == 0 is safe since nobody can incr while item_lock is held.
        -:  856: * refcount != 0 is impossible since flags/etc can be modified in other
        -:  857: * threads. instead, note we found a busy one and bail. logic in do_item_get
        -:  858: * will prevent busy items from continuing to be busy
        -:  859: * NOTE: This is checking it_flags outside of an item lock. I believe this
        -:  860: * works since it_flags is 8 bits, and we're only ever comparing a single bit
        -:  861: * regardless. ITEM_SLABBED bit will always be correct since we're holding the
        -:  862: * lock which modifies that bit. ITEM_LINKED won't exist if we're between an
        -:  863: * item having ITEM_SLABBED removed, and the key hasn't been added to the item
        -:  864: * yet. The memory barrier from the slabs lock should order the key write and the
        -:  865: * flags to the item?
        -:  866: * If ITEM_LINKED did exist and was just removed, but we still see it, that's
        -:  867: * still safe since it will have a valid key, which we then lock, and then
        -:  868: * recheck everything.
        -:  869: * This may not be safe on all platforms; If not, slabs_alloc() will need to
        -:  870: * seed the item key while holding slabs_lock.
        -:  871: */
    32982:  872:static int slab_rebalance_move(void) {
    32982:  873:    slabclass_t *s_cls;
    32982:  874:    int x;
    32982:  875:    int was_busy = 0;
    32982:  876:    int refcount = 0;
    32982:  877:    uint32_t hv;
    32982:  878:    void *hold_lock;
    32982:  879:    enum move_status status = MOVE_PASS;
        -:  880:
    32982:  881:    pthread_mutex_lock(&slabs_lock);
        -:  882:
    32982:  883:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  884:
    65661:  885:    for (x = 0; x < slab_bulk_check; x++) {
    32982:  886:        hv = 0;
    32982:  887:        hold_lock = NULL;
    32982:  888:        item *it = slab_rebal.slab_pos;
    32982:  889:        item_chunk *ch = NULL;
    32982:  890:        status = MOVE_PASS;
    32982:  891:        if (it->it_flags & ITEM_CHUNK) {
        -:  892:            /* This chunk is a chained part of a larger item. */
     1335:  893:            ch = (item_chunk *) it;
        -:  894:            /* Instead, we use the head chunk to find the item and effectively
        -:  895:             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
        -:  896:             * head cannot be slabbed, so the normal routine is safe. */
     1335:  897:            it = ch->head;
    1335*:  898:            assert(it->it_flags & ITEM_CHUNKED);
        -:  899:        }
        -:  900:
        -:  901:        /* ITEM_FETCHED when ITEM_SLABBED is overloaded to mean we've cleared
        -:  902:         * the chunk for move. Only these two flags should exist.
        -:  903:         */
    32982:  904:        if (it->it_flags != (ITEM_SLABBED|ITEM_FETCHED)) {
        -:  905:            /* ITEM_SLABBED can only be added/removed under the slabs_lock */
    30207:  906:            if (it->it_flags & ITEM_SLABBED) {
   24855*:  907:                assert(ch == NULL);
    24855:  908:                slab_rebalance_cut_free(s_cls, it);
    24855:  909:                status = MOVE_FROM_SLAB;
     5352:  910:            } else if ((it->it_flags & ITEM_LINKED) != 0) {
        -:  911:                /* If it doesn't have ITEM_SLABBED, the item could be in any
        -:  912:                 * state on its way to being freed or written to. If no
        -:  913:                 * ITEM_SLABBED, but it's had ITEM_LINKED, it must be active
        -:  914:                 * and have the key written to it already.
        -:  915:                 */
     5352:  916:                hv = hash(ITEM_key(it), it->nkey);
     5352:  917:                if ((hold_lock = item_trylock(hv)) == NULL) {
        -:  918:                    status = MOVE_LOCKED;
        -:  919:                } else {
     5352:  920:                    bool is_linked = (it->it_flags & ITEM_LINKED);
     5352:  921:                    refcount = refcount_incr(it);
     5352:  922:                    if (refcount == 2) { /* item is linked but not busy */
        -:  923:                        /* Double check ITEM_LINKED flag here, since we're
        -:  924:                         * past a memory barrier from the mutex. */
     5352:  925:                        if (is_linked) {
        -:  926:                            status = MOVE_FROM_LRU;
        -:  927:                        } else {
        -:  928:                            /* refcount == 1 + !ITEM_LINKED means the item is being
        -:  929:                             * uploaded to, or was just unlinked but hasn't been freed
        -:  930:                             * yet. Let it bleed off on its own and try again later */
        -:  931:                            status = MOVE_BUSY;
        -:  932:                        }
    #####:  933:                    } else if (refcount > 2 && is_linked) {
        -:  934:                        // TODO: Mark items for delete/rescue and process
        -:  935:                        // outside of the main loop.
    #####:  936:                        if (slab_rebal.busy_loops > SLAB_MOVE_MAX_LOOPS) {
    #####:  937:                            slab_rebal.busy_deletes++;
        -:  938:                            // Only safe to hold slabs lock because refcount
        -:  939:                            // can't drop to 0 until we release item lock.
    #####:  940:                            STORAGE_delete(storage, it);
    #####:  941:                            pthread_mutex_unlock(&slabs_lock);
    #####:  942:                            do_item_unlink(it, hv);
    #####:  943:                            pthread_mutex_lock(&slabs_lock);
        -:  944:                        }
        -:  945:                        status = MOVE_BUSY;
        -:  946:                    } else {
    #####:  947:                        if (settings.verbose > 2) {
    #####:  948:                            fprintf(stderr, "Slab reassign hit a busy item: refcount: %d (%d -> %d)\n",
        -:  949:                                it->refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);
        -:  950:                        }
        -:  951:                        status = MOVE_BUSY;
        -:  952:                    }
        -:  953:                    /* Item lock must be held while modifying refcount */
        -:  954:                    if (status == MOVE_BUSY) {
    #####:  955:                        refcount_decr(it);
    #####:  956:                        item_trylock_unlock(hold_lock);
        -:  957:                    }
        -:  958:                }
        -:  959:            } else {
        -:  960:                /* See above comment. No ITEM_SLABBED or ITEM_LINKED. Mark
        -:  961:                 * busy and wait for item to complete its upload. */
        -:  962:                status = MOVE_BUSY;
        -:  963:            }
        -:  964:        }
        -:  965:
    32982:  966:        int save_item = 0;
    32982:  967:        item *new_it = NULL;
    32982:  968:        size_t ntotal = 0;
    32982:  969:        switch (status) {
     5352:  970:            case MOVE_FROM_LRU:
        -:  971:                /* Lock order is LRU locks -> slabs_lock. unlink uses LRU lock.
        -:  972:                 * We only need to hold the slabs_lock while initially looking
        -:  973:                 * at an item, and at this point we have an exclusive refcount
        -:  974:                 * (2) + the item is locked. Drop slabs lock, drop item to
        -:  975:                 * refcount 1 (just our own, then fall through and wipe it
        -:  976:                 */
        -:  977:                /* Check if expired or flushed */
     5352:  978:                ntotal = ITEM_ntotal(it);
        -:  979:#ifdef EXTSTORE
        -:  980:                if (it->it_flags & ITEM_HDR) {
        -:  981:                    ntotal = (ntotal - it->nbytes) + sizeof(item_hdr);
        -:  982:                }
        -:  983:#endif
        -:  984:                /* REQUIRES slabs_lock: CHECK FOR cls->sl_curr > 0 */
     5352:  985:                if (ch == NULL && (it->it_flags & ITEM_CHUNKED)) {
        -:  986:                    /* Chunked should be identical to non-chunked, except we need
        -:  987:                     * to swap out ntotal for the head-chunk-total. */
    #####:  988:                    ntotal = s_cls->size;
        -:  989:                }
    5352*:  990:                if ((it->exptime != 0 && it->exptime < current_time)
     5352:  991:                    || item_is_flushed(it)) {
        -:  992:                    /* Expired, don't save. */
        -:  993:                    save_item = 0;
     5352:  994:                } else if (ch == NULL &&
     4017:  995:                        (new_it = slab_rebalance_alloc(ntotal, slab_rebal.s_clsid)) == NULL) {
        -:  996:                    /* Not a chunk of an item, and nomem. */
      489:  997:                    save_item = 0;
      489:  998:                    slab_rebal.evictions_nomem++;
     4863:  999:                } else if (ch != NULL &&
     1335: 1000:                        (new_it = slab_rebalance_alloc(s_cls->size, slab_rebal.s_clsid)) == NULL) {
        -: 1001:                    /* Is a chunk of an item, and nomem. */
      768: 1002:                    save_item = 0;
      768: 1003:                    slab_rebal.evictions_nomem++;
        -: 1004:                } else {
        -: 1005:                    /* Was whatever it was, and we have memory for it. */
        -: 1006:                    save_item = 1;
        -: 1007:                }
     5352: 1008:                pthread_mutex_unlock(&slabs_lock);
     5352: 1009:                unsigned int requested_adjust = 0;
     5352: 1010:                if (save_item) {
     4095: 1011:                    if (ch == NULL) {
    3528*: 1012:                        assert((new_it->it_flags & ITEM_CHUNKED) == 0);
        -: 1013:                        /* if free memory, memcpy. clear prev/next/h_bucket */
     3528: 1014:                        memcpy(new_it, it, ntotal);
     3528: 1015:                        new_it->prev = 0;
     3528: 1016:                        new_it->next = 0;
     3528: 1017:                        new_it->h_next = 0;
        -: 1018:                        /* These are definitely required. else fails assert */
     3528: 1019:                        new_it->it_flags &= ~ITEM_LINKED;
     3528: 1020:                        new_it->refcount = 0;
     3528: 1021:                        do_item_replace(it, new_it, hv);
        -: 1022:                        /* Need to walk the chunks and repoint head  */
     3528: 1023:                        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 1024:                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);
    #####: 1025:                            fch->next->prev = fch;
    #####: 1026:                            while (fch) {
    #####: 1027:                                fch->head = new_it;
    #####: 1028:                                fch = fch->next;
        -: 1029:                            }
        -: 1030:                        }
     3528: 1031:                        it->refcount = 0;
     3528: 1032:                        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1033:#ifdef DEBUG_SLAB_MOVER
        -: 1034:                        memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1035:#endif
     3528: 1036:                        slab_rebal.rescues++;
     3528: 1037:                        requested_adjust = ntotal;
        -: 1038:                    } else {
      567: 1039:                        item_chunk *nch = (item_chunk *) new_it;
        -: 1040:                        /* Chunks always have head chunk (the main it) */
      567: 1041:                        ch->prev->next = nch;
      567: 1042:                        if (ch->next)
       57: 1043:                            ch->next->prev = nch;
      567: 1044:                        memcpy(nch, ch, ch->used + sizeof(item_chunk));
      567: 1045:                        ch->refcount = 0;
      567: 1046:                        ch->it_flags = ITEM_SLABBED|ITEM_FETCHED;
      567: 1047:                        slab_rebal.chunk_rescues++;
        -: 1048:#ifdef DEBUG_SLAB_MOVER
        -: 1049:                        memcpy(ITEM_key((item *)ch), "deadbeef", 8);
        -: 1050:#endif
      567: 1051:                        refcount_decr(it);
      567: 1052:                        requested_adjust = s_cls->size;
        -: 1053:                    }
        -: 1054:                } else {
        -: 1055:                    /* restore ntotal in case we tried saving a head chunk. */
     1257: 1056:                    ntotal = ITEM_ntotal(it);
     1257: 1057:                    STORAGE_delete(storage, it);
     1257: 1058:                    do_item_unlink(it, hv);
     1257: 1059:                    slabs_free(it, ntotal, slab_rebal.s_clsid);
        -: 1060:                    /* Swing around again later to remove it from the freelist. */
     1257: 1061:                    slab_rebal.busy_items++;
     1257: 1062:                    was_busy++;
        -: 1063:                }
     5352: 1064:                item_trylock_unlock(hold_lock);
     5352: 1065:                pthread_mutex_lock(&slabs_lock);
        -: 1066:                /* Always remove the ntotal, as we added it in during
        -: 1067:                 * do_slabs_alloc() when copying the item.
        -: 1068:                 */
     5352: 1069:                s_cls->requested -= requested_adjust;
     5352: 1070:                break;
    24855: 1071:            case MOVE_FROM_SLAB:
    24855: 1072:                it->refcount = 0;
    24855: 1073:                it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1074:#ifdef DEBUG_SLAB_MOVER
        -: 1075:                memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1076:#endif
    24855: 1077:                break;
    #####: 1078:            case MOVE_BUSY:
        -: 1079:            case MOVE_LOCKED:
    #####: 1080:                slab_rebal.busy_items++;
    #####: 1081:                was_busy++;
    #####: 1082:                break;
        -: 1083:            case MOVE_PASS:
        -: 1084:                break;
        -: 1085:        }
        -: 1086:
    32982: 1087:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
    32982: 1088:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1089:            break;
        -: 1090:    }
        -: 1091:
    32982: 1092:    if (slab_rebal.slab_pos >= slab_rebal.slab_end) {
        -: 1093:        /* Some items were busy, start again from the top */
      303: 1094:        if (slab_rebal.busy_items) {
       15: 1095:            slab_rebal.slab_pos = slab_rebal.slab_start;
       15: 1096:            STATS_LOCK();
       15: 1097:            stats.slab_reassign_busy_items += slab_rebal.busy_items;
       15: 1098:            STATS_UNLOCK();
       15: 1099:            slab_rebal.busy_items = 0;
       15: 1100:            slab_rebal.busy_loops++;
        -: 1101:        } else {
      288: 1102:            slab_rebal.done++;
        -: 1103:        }
        -: 1104:    }
        -: 1105:
    32982: 1106:    pthread_mutex_unlock(&slabs_lock);
        -: 1107:
    32982: 1108:    return was_busy;
        -: 1109:}
------------------
slab_rebalance_move:
    10994:  872:static int slab_rebalance_move(void) {
    10994:  873:    slabclass_t *s_cls;
    10994:  874:    int x;
    10994:  875:    int was_busy = 0;
    10994:  876:    int refcount = 0;
    10994:  877:    uint32_t hv;
    10994:  878:    void *hold_lock;
    10994:  879:    enum move_status status = MOVE_PASS;
        -:  880:
    10994:  881:    pthread_mutex_lock(&slabs_lock);
        -:  882:
    10994:  883:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  884:
    21887:  885:    for (x = 0; x < slab_bulk_check; x++) {
    10994:  886:        hv = 0;
    10994:  887:        hold_lock = NULL;
    10994:  888:        item *it = slab_rebal.slab_pos;
    10994:  889:        item_chunk *ch = NULL;
    10994:  890:        status = MOVE_PASS;
    10994:  891:        if (it->it_flags & ITEM_CHUNK) {
        -:  892:            /* This chunk is a chained part of a larger item. */
      445:  893:            ch = (item_chunk *) it;
        -:  894:            /* Instead, we use the head chunk to find the item and effectively
        -:  895:             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
        -:  896:             * head cannot be slabbed, so the normal routine is safe. */
      445:  897:            it = ch->head;
     445*:  898:            assert(it->it_flags & ITEM_CHUNKED);
        -:  899:        }
        -:  900:
        -:  901:        /* ITEM_FETCHED when ITEM_SLABBED is overloaded to mean we've cleared
        -:  902:         * the chunk for move. Only these two flags should exist.
        -:  903:         */
    10994:  904:        if (it->it_flags != (ITEM_SLABBED|ITEM_FETCHED)) {
        -:  905:            /* ITEM_SLABBED can only be added/removed under the slabs_lock */
    10069:  906:            if (it->it_flags & ITEM_SLABBED) {
    8285*:  907:                assert(ch == NULL);
     8285:  908:                slab_rebalance_cut_free(s_cls, it);
     8285:  909:                status = MOVE_FROM_SLAB;
     1784:  910:            } else if ((it->it_flags & ITEM_LINKED) != 0) {
        -:  911:                /* If it doesn't have ITEM_SLABBED, the item could be in any
        -:  912:                 * state on its way to being freed or written to. If no
        -:  913:                 * ITEM_SLABBED, but it's had ITEM_LINKED, it must be active
        -:  914:                 * and have the key written to it already.
        -:  915:                 */
     1784:  916:                hv = hash(ITEM_key(it), it->nkey);
     1784:  917:                if ((hold_lock = item_trylock(hv)) == NULL) {
        -:  918:                    status = MOVE_LOCKED;
        -:  919:                } else {
     1784:  920:                    bool is_linked = (it->it_flags & ITEM_LINKED);
     1784:  921:                    refcount = refcount_incr(it);
     1784:  922:                    if (refcount == 2) { /* item is linked but not busy */
        -:  923:                        /* Double check ITEM_LINKED flag here, since we're
        -:  924:                         * past a memory barrier from the mutex. */
     1784:  925:                        if (is_linked) {
        -:  926:                            status = MOVE_FROM_LRU;
        -:  927:                        } else {
        -:  928:                            /* refcount == 1 + !ITEM_LINKED means the item is being
        -:  929:                             * uploaded to, or was just unlinked but hasn't been freed
        -:  930:                             * yet. Let it bleed off on its own and try again later */
        -:  931:                            status = MOVE_BUSY;
        -:  932:                        }
    #####:  933:                    } else if (refcount > 2 && is_linked) {
        -:  934:                        // TODO: Mark items for delete/rescue and process
        -:  935:                        // outside of the main loop.
    #####:  936:                        if (slab_rebal.busy_loops > SLAB_MOVE_MAX_LOOPS) {
    #####:  937:                            slab_rebal.busy_deletes++;
        -:  938:                            // Only safe to hold slabs lock because refcount
        -:  939:                            // can't drop to 0 until we release item lock.
    #####:  940:                            STORAGE_delete(storage, it);
    #####:  941:                            pthread_mutex_unlock(&slabs_lock);
    #####:  942:                            do_item_unlink(it, hv);
    #####:  943:                            pthread_mutex_lock(&slabs_lock);
        -:  944:                        }
        -:  945:                        status = MOVE_BUSY;
        -:  946:                    } else {
    #####:  947:                        if (settings.verbose > 2) {
    #####:  948:                            fprintf(stderr, "Slab reassign hit a busy item: refcount: %d (%d -> %d)\n",
        -:  949:                                it->refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);
        -:  950:                        }
        -:  951:                        status = MOVE_BUSY;
        -:  952:                    }
        -:  953:                    /* Item lock must be held while modifying refcount */
        -:  954:                    if (status == MOVE_BUSY) {
    #####:  955:                        refcount_decr(it);
    #####:  956:                        item_trylock_unlock(hold_lock);
        -:  957:                    }
        -:  958:                }
        -:  959:            } else {
        -:  960:                /* See above comment. No ITEM_SLABBED or ITEM_LINKED. Mark
        -:  961:                 * busy and wait for item to complete its upload. */
        -:  962:                status = MOVE_BUSY;
        -:  963:            }
        -:  964:        }
        -:  965:
    10994:  966:        int save_item = 0;
    10994:  967:        item *new_it = NULL;
    10994:  968:        size_t ntotal = 0;
    10994:  969:        switch (status) {
     1784:  970:            case MOVE_FROM_LRU:
        -:  971:                /* Lock order is LRU locks -> slabs_lock. unlink uses LRU lock.
        -:  972:                 * We only need to hold the slabs_lock while initially looking
        -:  973:                 * at an item, and at this point we have an exclusive refcount
        -:  974:                 * (2) + the item is locked. Drop slabs lock, drop item to
        -:  975:                 * refcount 1 (just our own, then fall through and wipe it
        -:  976:                 */
        -:  977:                /* Check if expired or flushed */
     1784:  978:                ntotal = ITEM_ntotal(it);
        -:  979:#ifdef EXTSTORE
        -:  980:                if (it->it_flags & ITEM_HDR) {
        -:  981:                    ntotal = (ntotal - it->nbytes) + sizeof(item_hdr);
        -:  982:                }
        -:  983:#endif
        -:  984:                /* REQUIRES slabs_lock: CHECK FOR cls->sl_curr > 0 */
     1784:  985:                if (ch == NULL && (it->it_flags & ITEM_CHUNKED)) {
        -:  986:                    /* Chunked should be identical to non-chunked, except we need
        -:  987:                     * to swap out ntotal for the head-chunk-total. */
    #####:  988:                    ntotal = s_cls->size;
        -:  989:                }
    1784*:  990:                if ((it->exptime != 0 && it->exptime < current_time)
     1784:  991:                    || item_is_flushed(it)) {
        -:  992:                    /* Expired, don't save. */
        -:  993:                    save_item = 0;
     1784:  994:                } else if (ch == NULL &&
     1339:  995:                        (new_it = slab_rebalance_alloc(ntotal, slab_rebal.s_clsid)) == NULL) {
        -:  996:                    /* Not a chunk of an item, and nomem. */
      163:  997:                    save_item = 0;
      163:  998:                    slab_rebal.evictions_nomem++;
     1621:  999:                } else if (ch != NULL &&
      445: 1000:                        (new_it = slab_rebalance_alloc(s_cls->size, slab_rebal.s_clsid)) == NULL) {
        -: 1001:                    /* Is a chunk of an item, and nomem. */
      256: 1002:                    save_item = 0;
      256: 1003:                    slab_rebal.evictions_nomem++;
        -: 1004:                } else {
        -: 1005:                    /* Was whatever it was, and we have memory for it. */
        -: 1006:                    save_item = 1;
        -: 1007:                }
     1784: 1008:                pthread_mutex_unlock(&slabs_lock);
     1784: 1009:                unsigned int requested_adjust = 0;
     1784: 1010:                if (save_item) {
     1365: 1011:                    if (ch == NULL) {
    1176*: 1012:                        assert((new_it->it_flags & ITEM_CHUNKED) == 0);
        -: 1013:                        /* if free memory, memcpy. clear prev/next/h_bucket */
     1176: 1014:                        memcpy(new_it, it, ntotal);
     1176: 1015:                        new_it->prev = 0;
     1176: 1016:                        new_it->next = 0;
     1176: 1017:                        new_it->h_next = 0;
        -: 1018:                        /* These are definitely required. else fails assert */
     1176: 1019:                        new_it->it_flags &= ~ITEM_LINKED;
     1176: 1020:                        new_it->refcount = 0;
     1176: 1021:                        do_item_replace(it, new_it, hv);
        -: 1022:                        /* Need to walk the chunks and repoint head  */
     1176: 1023:                        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 1024:                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);
    #####: 1025:                            fch->next->prev = fch;
    #####: 1026:                            while (fch) {
    #####: 1027:                                fch->head = new_it;
    #####: 1028:                                fch = fch->next;
        -: 1029:                            }
        -: 1030:                        }
     1176: 1031:                        it->refcount = 0;
     1176: 1032:                        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1033:#ifdef DEBUG_SLAB_MOVER
        -: 1034:                        memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1035:#endif
     1176: 1036:                        slab_rebal.rescues++;
     1176: 1037:                        requested_adjust = ntotal;
        -: 1038:                    } else {
      189: 1039:                        item_chunk *nch = (item_chunk *) new_it;
        -: 1040:                        /* Chunks always have head chunk (the main it) */
      189: 1041:                        ch->prev->next = nch;
      189: 1042:                        if (ch->next)
       19: 1043:                            ch->next->prev = nch;
      189: 1044:                        memcpy(nch, ch, ch->used + sizeof(item_chunk));
      189: 1045:                        ch->refcount = 0;
      189: 1046:                        ch->it_flags = ITEM_SLABBED|ITEM_FETCHED;
      189: 1047:                        slab_rebal.chunk_rescues++;
        -: 1048:#ifdef DEBUG_SLAB_MOVER
        -: 1049:                        memcpy(ITEM_key((item *)ch), "deadbeef", 8);
        -: 1050:#endif
      189: 1051:                        refcount_decr(it);
      189: 1052:                        requested_adjust = s_cls->size;
        -: 1053:                    }
        -: 1054:                } else {
        -: 1055:                    /* restore ntotal in case we tried saving a head chunk. */
      419: 1056:                    ntotal = ITEM_ntotal(it);
      419: 1057:                    STORAGE_delete(storage, it);
      419: 1058:                    do_item_unlink(it, hv);
      419: 1059:                    slabs_free(it, ntotal, slab_rebal.s_clsid);
        -: 1060:                    /* Swing around again later to remove it from the freelist. */
      419: 1061:                    slab_rebal.busy_items++;
      419: 1062:                    was_busy++;
        -: 1063:                }
     1784: 1064:                item_trylock_unlock(hold_lock);
     1784: 1065:                pthread_mutex_lock(&slabs_lock);
        -: 1066:                /* Always remove the ntotal, as we added it in during
        -: 1067:                 * do_slabs_alloc() when copying the item.
        -: 1068:                 */
     1784: 1069:                s_cls->requested -= requested_adjust;
     1784: 1070:                break;
     8285: 1071:            case MOVE_FROM_SLAB:
     8285: 1072:                it->refcount = 0;
     8285: 1073:                it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1074:#ifdef DEBUG_SLAB_MOVER
        -: 1075:                memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1076:#endif
     8285: 1077:                break;
    #####: 1078:            case MOVE_BUSY:
        -: 1079:            case MOVE_LOCKED:
    #####: 1080:                slab_rebal.busy_items++;
    #####: 1081:                was_busy++;
    #####: 1082:                break;
        -: 1083:            case MOVE_PASS:
        -: 1084:                break;
        -: 1085:        }
        -: 1086:
    10994: 1087:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
    10994: 1088:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1089:            break;
        -: 1090:    }
        -: 1091:
    10994: 1092:    if (slab_rebal.slab_pos >= slab_rebal.slab_end) {
        -: 1093:        /* Some items were busy, start again from the top */
      101: 1094:        if (slab_rebal.busy_items) {
        5: 1095:            slab_rebal.slab_pos = slab_rebal.slab_start;
        5: 1096:            STATS_LOCK();
        5: 1097:            stats.slab_reassign_busy_items += slab_rebal.busy_items;
        5: 1098:            STATS_UNLOCK();
        5: 1099:            slab_rebal.busy_items = 0;
        5: 1100:            slab_rebal.busy_loops++;
        -: 1101:        } else {
       96: 1102:            slab_rebal.done++;
        -: 1103:        }
        -: 1104:    }
        -: 1105:
    10994: 1106:    pthread_mutex_unlock(&slabs_lock);
        -: 1107:
    10994: 1108:    return was_busy;
        -: 1109:}
------------------
slab_rebalance_move:
    10994:  872:static int slab_rebalance_move(void) {
    10994:  873:    slabclass_t *s_cls;
    10994:  874:    int x;
    10994:  875:    int was_busy = 0;
    10994:  876:    int refcount = 0;
    10994:  877:    uint32_t hv;
    10994:  878:    void *hold_lock;
    10994:  879:    enum move_status status = MOVE_PASS;
        -:  880:
    10994:  881:    pthread_mutex_lock(&slabs_lock);
        -:  882:
    10994:  883:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  884:
    21887:  885:    for (x = 0; x < slab_bulk_check; x++) {
    10994:  886:        hv = 0;
    10994:  887:        hold_lock = NULL;
    10994:  888:        item *it = slab_rebal.slab_pos;
    10994:  889:        item_chunk *ch = NULL;
    10994:  890:        status = MOVE_PASS;
    10994:  891:        if (it->it_flags & ITEM_CHUNK) {
        -:  892:            /* This chunk is a chained part of a larger item. */
      445:  893:            ch = (item_chunk *) it;
        -:  894:            /* Instead, we use the head chunk to find the item and effectively
        -:  895:             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
        -:  896:             * head cannot be slabbed, so the normal routine is safe. */
      445:  897:            it = ch->head;
     445*:  898:            assert(it->it_flags & ITEM_CHUNKED);
        -:  899:        }
        -:  900:
        -:  901:        /* ITEM_FETCHED when ITEM_SLABBED is overloaded to mean we've cleared
        -:  902:         * the chunk for move. Only these two flags should exist.
        -:  903:         */
    10994:  904:        if (it->it_flags != (ITEM_SLABBED|ITEM_FETCHED)) {
        -:  905:            /* ITEM_SLABBED can only be added/removed under the slabs_lock */
    10069:  906:            if (it->it_flags & ITEM_SLABBED) {
    8285*:  907:                assert(ch == NULL);
     8285:  908:                slab_rebalance_cut_free(s_cls, it);
     8285:  909:                status = MOVE_FROM_SLAB;
     1784:  910:            } else if ((it->it_flags & ITEM_LINKED) != 0) {
        -:  911:                /* If it doesn't have ITEM_SLABBED, the item could be in any
        -:  912:                 * state on its way to being freed or written to. If no
        -:  913:                 * ITEM_SLABBED, but it's had ITEM_LINKED, it must be active
        -:  914:                 * and have the key written to it already.
        -:  915:                 */
     1784:  916:                hv = hash(ITEM_key(it), it->nkey);
     1784:  917:                if ((hold_lock = item_trylock(hv)) == NULL) {
        -:  918:                    status = MOVE_LOCKED;
        -:  919:                } else {
     1784:  920:                    bool is_linked = (it->it_flags & ITEM_LINKED);
     1784:  921:                    refcount = refcount_incr(it);
     1784:  922:                    if (refcount == 2) { /* item is linked but not busy */
        -:  923:                        /* Double check ITEM_LINKED flag here, since we're
        -:  924:                         * past a memory barrier from the mutex. */
     1784:  925:                        if (is_linked) {
        -:  926:                            status = MOVE_FROM_LRU;
        -:  927:                        } else {
        -:  928:                            /* refcount == 1 + !ITEM_LINKED means the item is being
        -:  929:                             * uploaded to, or was just unlinked but hasn't been freed
        -:  930:                             * yet. Let it bleed off on its own and try again later */
        -:  931:                            status = MOVE_BUSY;
        -:  932:                        }
    #####:  933:                    } else if (refcount > 2 && is_linked) {
        -:  934:                        // TODO: Mark items for delete/rescue and process
        -:  935:                        // outside of the main loop.
    #####:  936:                        if (slab_rebal.busy_loops > SLAB_MOVE_MAX_LOOPS) {
    #####:  937:                            slab_rebal.busy_deletes++;
        -:  938:                            // Only safe to hold slabs lock because refcount
        -:  939:                            // can't drop to 0 until we release item lock.
    #####:  940:                            STORAGE_delete(storage, it);
    #####:  941:                            pthread_mutex_unlock(&slabs_lock);
    #####:  942:                            do_item_unlink(it, hv);
    #####:  943:                            pthread_mutex_lock(&slabs_lock);
        -:  944:                        }
        -:  945:                        status = MOVE_BUSY;
        -:  946:                    } else {
    #####:  947:                        if (settings.verbose > 2) {
    #####:  948:                            fprintf(stderr, "Slab reassign hit a busy item: refcount: %d (%d -> %d)\n",
        -:  949:                                it->refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);
        -:  950:                        }
        -:  951:                        status = MOVE_BUSY;
        -:  952:                    }
        -:  953:                    /* Item lock must be held while modifying refcount */
        -:  954:                    if (status == MOVE_BUSY) {
    #####:  955:                        refcount_decr(it);
    #####:  956:                        item_trylock_unlock(hold_lock);
        -:  957:                    }
        -:  958:                }
        -:  959:            } else {
        -:  960:                /* See above comment. No ITEM_SLABBED or ITEM_LINKED. Mark
        -:  961:                 * busy and wait for item to complete its upload. */
        -:  962:                status = MOVE_BUSY;
        -:  963:            }
        -:  964:        }
        -:  965:
    10994:  966:        int save_item = 0;
    10994:  967:        item *new_it = NULL;
    10994:  968:        size_t ntotal = 0;
    10994:  969:        switch (status) {
     1784:  970:            case MOVE_FROM_LRU:
        -:  971:                /* Lock order is LRU locks -> slabs_lock. unlink uses LRU lock.
        -:  972:                 * We only need to hold the slabs_lock while initially looking
        -:  973:                 * at an item, and at this point we have an exclusive refcount
        -:  974:                 * (2) + the item is locked. Drop slabs lock, drop item to
        -:  975:                 * refcount 1 (just our own, then fall through and wipe it
        -:  976:                 */
        -:  977:                /* Check if expired or flushed */
     1784:  978:                ntotal = ITEM_ntotal(it);
        -:  979:#ifdef EXTSTORE
        -:  980:                if (it->it_flags & ITEM_HDR) {
        -:  981:                    ntotal = (ntotal - it->nbytes) + sizeof(item_hdr);
        -:  982:                }
        -:  983:#endif
        -:  984:                /* REQUIRES slabs_lock: CHECK FOR cls->sl_curr > 0 */
     1784:  985:                if (ch == NULL && (it->it_flags & ITEM_CHUNKED)) {
        -:  986:                    /* Chunked should be identical to non-chunked, except we need
        -:  987:                     * to swap out ntotal for the head-chunk-total. */
    #####:  988:                    ntotal = s_cls->size;
        -:  989:                }
    1784*:  990:                if ((it->exptime != 0 && it->exptime < current_time)
     1784:  991:                    || item_is_flushed(it)) {
        -:  992:                    /* Expired, don't save. */
        -:  993:                    save_item = 0;
     1784:  994:                } else if (ch == NULL &&
     1339:  995:                        (new_it = slab_rebalance_alloc(ntotal, slab_rebal.s_clsid)) == NULL) {
        -:  996:                    /* Not a chunk of an item, and nomem. */
      163:  997:                    save_item = 0;
      163:  998:                    slab_rebal.evictions_nomem++;
     1621:  999:                } else if (ch != NULL &&
      445: 1000:                        (new_it = slab_rebalance_alloc(s_cls->size, slab_rebal.s_clsid)) == NULL) {
        -: 1001:                    /* Is a chunk of an item, and nomem. */
      256: 1002:                    save_item = 0;
      256: 1003:                    slab_rebal.evictions_nomem++;
        -: 1004:                } else {
        -: 1005:                    /* Was whatever it was, and we have memory for it. */
        -: 1006:                    save_item = 1;
        -: 1007:                }
     1784: 1008:                pthread_mutex_unlock(&slabs_lock);
     1784: 1009:                unsigned int requested_adjust = 0;
     1784: 1010:                if (save_item) {
     1365: 1011:                    if (ch == NULL) {
    1176*: 1012:                        assert((new_it->it_flags & ITEM_CHUNKED) == 0);
        -: 1013:                        /* if free memory, memcpy. clear prev/next/h_bucket */
     1176: 1014:                        memcpy(new_it, it, ntotal);
     1176: 1015:                        new_it->prev = 0;
     1176: 1016:                        new_it->next = 0;
     1176: 1017:                        new_it->h_next = 0;
        -: 1018:                        /* These are definitely required. else fails assert */
     1176: 1019:                        new_it->it_flags &= ~ITEM_LINKED;
     1176: 1020:                        new_it->refcount = 0;
     1176: 1021:                        do_item_replace(it, new_it, hv);
        -: 1022:                        /* Need to walk the chunks and repoint head  */
     1176: 1023:                        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 1024:                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);
    #####: 1025:                            fch->next->prev = fch;
    #####: 1026:                            while (fch) {
    #####: 1027:                                fch->head = new_it;
    #####: 1028:                                fch = fch->next;
        -: 1029:                            }
        -: 1030:                        }
     1176: 1031:                        it->refcount = 0;
     1176: 1032:                        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1033:#ifdef DEBUG_SLAB_MOVER
        -: 1034:                        memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1035:#endif
     1176: 1036:                        slab_rebal.rescues++;
     1176: 1037:                        requested_adjust = ntotal;
        -: 1038:                    } else {
      189: 1039:                        item_chunk *nch = (item_chunk *) new_it;
        -: 1040:                        /* Chunks always have head chunk (the main it) */
      189: 1041:                        ch->prev->next = nch;
      189: 1042:                        if (ch->next)
       19: 1043:                            ch->next->prev = nch;
      189: 1044:                        memcpy(nch, ch, ch->used + sizeof(item_chunk));
      189: 1045:                        ch->refcount = 0;
      189: 1046:                        ch->it_flags = ITEM_SLABBED|ITEM_FETCHED;
      189: 1047:                        slab_rebal.chunk_rescues++;
        -: 1048:#ifdef DEBUG_SLAB_MOVER
        -: 1049:                        memcpy(ITEM_key((item *)ch), "deadbeef", 8);
        -: 1050:#endif
      189: 1051:                        refcount_decr(it);
      189: 1052:                        requested_adjust = s_cls->size;
        -: 1053:                    }
        -: 1054:                } else {
        -: 1055:                    /* restore ntotal in case we tried saving a head chunk. */
      419: 1056:                    ntotal = ITEM_ntotal(it);
      419: 1057:                    STORAGE_delete(storage, it);
      419: 1058:                    do_item_unlink(it, hv);
      419: 1059:                    slabs_free(it, ntotal, slab_rebal.s_clsid);
        -: 1060:                    /* Swing around again later to remove it from the freelist. */
      419: 1061:                    slab_rebal.busy_items++;
      419: 1062:                    was_busy++;
        -: 1063:                }
     1784: 1064:                item_trylock_unlock(hold_lock);
     1784: 1065:                pthread_mutex_lock(&slabs_lock);
        -: 1066:                /* Always remove the ntotal, as we added it in during
        -: 1067:                 * do_slabs_alloc() when copying the item.
        -: 1068:                 */
     1784: 1069:                s_cls->requested -= requested_adjust;
     1784: 1070:                break;
     8285: 1071:            case MOVE_FROM_SLAB:
     8285: 1072:                it->refcount = 0;
     8285: 1073:                it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1074:#ifdef DEBUG_SLAB_MOVER
        -: 1075:                memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1076:#endif
     8285: 1077:                break;
    #####: 1078:            case MOVE_BUSY:
        -: 1079:            case MOVE_LOCKED:
    #####: 1080:                slab_rebal.busy_items++;
    #####: 1081:                was_busy++;
    #####: 1082:                break;
        -: 1083:            case MOVE_PASS:
        -: 1084:                break;
        -: 1085:        }
        -: 1086:
    10994: 1087:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
    10994: 1088:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1089:            break;
        -: 1090:    }
        -: 1091:
    10994: 1092:    if (slab_rebal.slab_pos >= slab_rebal.slab_end) {
        -: 1093:        /* Some items were busy, start again from the top */
      101: 1094:        if (slab_rebal.busy_items) {
        5: 1095:            slab_rebal.slab_pos = slab_rebal.slab_start;
        5: 1096:            STATS_LOCK();
        5: 1097:            stats.slab_reassign_busy_items += slab_rebal.busy_items;
        5: 1098:            STATS_UNLOCK();
        5: 1099:            slab_rebal.busy_items = 0;
        5: 1100:            slab_rebal.busy_loops++;
        -: 1101:        } else {
       96: 1102:            slab_rebal.done++;
        -: 1103:        }
        -: 1104:    }
        -: 1105:
    10994: 1106:    pthread_mutex_unlock(&slabs_lock);
        -: 1107:
    10994: 1108:    return was_busy;
        -: 1109:}
------------------
slab_rebalance_move:
    10994:  872:static int slab_rebalance_move(void) {
    10994:  873:    slabclass_t *s_cls;
    10994:  874:    int x;
    10994:  875:    int was_busy = 0;
    10994:  876:    int refcount = 0;
    10994:  877:    uint32_t hv;
    10994:  878:    void *hold_lock;
    10994:  879:    enum move_status status = MOVE_PASS;
        -:  880:
    10994:  881:    pthread_mutex_lock(&slabs_lock);
        -:  882:
    10994:  883:    s_cls = &slabclass[slab_rebal.s_clsid];
        -:  884:
    21887:  885:    for (x = 0; x < slab_bulk_check; x++) {
    10994:  886:        hv = 0;
    10994:  887:        hold_lock = NULL;
    10994:  888:        item *it = slab_rebal.slab_pos;
    10994:  889:        item_chunk *ch = NULL;
    10994:  890:        status = MOVE_PASS;
    10994:  891:        if (it->it_flags & ITEM_CHUNK) {
        -:  892:            /* This chunk is a chained part of a larger item. */
      445:  893:            ch = (item_chunk *) it;
        -:  894:            /* Instead, we use the head chunk to find the item and effectively
        -:  895:             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
        -:  896:             * head cannot be slabbed, so the normal routine is safe. */
      445:  897:            it = ch->head;
     445*:  898:            assert(it->it_flags & ITEM_CHUNKED);
        -:  899:        }
        -:  900:
        -:  901:        /* ITEM_FETCHED when ITEM_SLABBED is overloaded to mean we've cleared
        -:  902:         * the chunk for move. Only these two flags should exist.
        -:  903:         */
    10994:  904:        if (it->it_flags != (ITEM_SLABBED|ITEM_FETCHED)) {
        -:  905:            /* ITEM_SLABBED can only be added/removed under the slabs_lock */
    10069:  906:            if (it->it_flags & ITEM_SLABBED) {
    8285*:  907:                assert(ch == NULL);
     8285:  908:                slab_rebalance_cut_free(s_cls, it);
     8285:  909:                status = MOVE_FROM_SLAB;
     1784:  910:            } else if ((it->it_flags & ITEM_LINKED) != 0) {
        -:  911:                /* If it doesn't have ITEM_SLABBED, the item could be in any
        -:  912:                 * state on its way to being freed or written to. If no
        -:  913:                 * ITEM_SLABBED, but it's had ITEM_LINKED, it must be active
        -:  914:                 * and have the key written to it already.
        -:  915:                 */
     1784:  916:                hv = hash(ITEM_key(it), it->nkey);
     1784:  917:                if ((hold_lock = item_trylock(hv)) == NULL) {
        -:  918:                    status = MOVE_LOCKED;
        -:  919:                } else {
     1784:  920:                    bool is_linked = (it->it_flags & ITEM_LINKED);
     1784:  921:                    refcount = refcount_incr(it);
     1784:  922:                    if (refcount == 2) { /* item is linked but not busy */
        -:  923:                        /* Double check ITEM_LINKED flag here, since we're
        -:  924:                         * past a memory barrier from the mutex. */
     1784:  925:                        if (is_linked) {
        -:  926:                            status = MOVE_FROM_LRU;
        -:  927:                        } else {
        -:  928:                            /* refcount == 1 + !ITEM_LINKED means the item is being
        -:  929:                             * uploaded to, or was just unlinked but hasn't been freed
        -:  930:                             * yet. Let it bleed off on its own and try again later */
        -:  931:                            status = MOVE_BUSY;
        -:  932:                        }
    #####:  933:                    } else if (refcount > 2 && is_linked) {
        -:  934:                        // TODO: Mark items for delete/rescue and process
        -:  935:                        // outside of the main loop.
    #####:  936:                        if (slab_rebal.busy_loops > SLAB_MOVE_MAX_LOOPS) {
    #####:  937:                            slab_rebal.busy_deletes++;
        -:  938:                            // Only safe to hold slabs lock because refcount
        -:  939:                            // can't drop to 0 until we release item lock.
    #####:  940:                            STORAGE_delete(storage, it);
    #####:  941:                            pthread_mutex_unlock(&slabs_lock);
    #####:  942:                            do_item_unlink(it, hv);
    #####:  943:                            pthread_mutex_lock(&slabs_lock);
        -:  944:                        }
        -:  945:                        status = MOVE_BUSY;
        -:  946:                    } else {
    #####:  947:                        if (settings.verbose > 2) {
    #####:  948:                            fprintf(stderr, "Slab reassign hit a busy item: refcount: %d (%d -> %d)\n",
        -:  949:                                it->refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);
        -:  950:                        }
        -:  951:                        status = MOVE_BUSY;
        -:  952:                    }
        -:  953:                    /* Item lock must be held while modifying refcount */
        -:  954:                    if (status == MOVE_BUSY) {
    #####:  955:                        refcount_decr(it);
    #####:  956:                        item_trylock_unlock(hold_lock);
        -:  957:                    }
        -:  958:                }
        -:  959:            } else {
        -:  960:                /* See above comment. No ITEM_SLABBED or ITEM_LINKED. Mark
        -:  961:                 * busy and wait for item to complete its upload. */
        -:  962:                status = MOVE_BUSY;
        -:  963:            }
        -:  964:        }
        -:  965:
    10994:  966:        int save_item = 0;
    10994:  967:        item *new_it = NULL;
    10994:  968:        size_t ntotal = 0;
    10994:  969:        switch (status) {
     1784:  970:            case MOVE_FROM_LRU:
        -:  971:                /* Lock order is LRU locks -> slabs_lock. unlink uses LRU lock.
        -:  972:                 * We only need to hold the slabs_lock while initially looking
        -:  973:                 * at an item, and at this point we have an exclusive refcount
        -:  974:                 * (2) + the item is locked. Drop slabs lock, drop item to
        -:  975:                 * refcount 1 (just our own, then fall through and wipe it
        -:  976:                 */
        -:  977:                /* Check if expired or flushed */
     1784:  978:                ntotal = ITEM_ntotal(it);
        -:  979:#ifdef EXTSTORE
        -:  980:                if (it->it_flags & ITEM_HDR) {
        -:  981:                    ntotal = (ntotal - it->nbytes) + sizeof(item_hdr);
        -:  982:                }
        -:  983:#endif
        -:  984:                /* REQUIRES slabs_lock: CHECK FOR cls->sl_curr > 0 */
     1784:  985:                if (ch == NULL && (it->it_flags & ITEM_CHUNKED)) {
        -:  986:                    /* Chunked should be identical to non-chunked, except we need
        -:  987:                     * to swap out ntotal for the head-chunk-total. */
    #####:  988:                    ntotal = s_cls->size;
        -:  989:                }
    1784*:  990:                if ((it->exptime != 0 && it->exptime < current_time)
     1784:  991:                    || item_is_flushed(it)) {
        -:  992:                    /* Expired, don't save. */
        -:  993:                    save_item = 0;
     1784:  994:                } else if (ch == NULL &&
     1339:  995:                        (new_it = slab_rebalance_alloc(ntotal, slab_rebal.s_clsid)) == NULL) {
        -:  996:                    /* Not a chunk of an item, and nomem. */
      163:  997:                    save_item = 0;
      163:  998:                    slab_rebal.evictions_nomem++;
     1621:  999:                } else if (ch != NULL &&
      445: 1000:                        (new_it = slab_rebalance_alloc(s_cls->size, slab_rebal.s_clsid)) == NULL) {
        -: 1001:                    /* Is a chunk of an item, and nomem. */
      256: 1002:                    save_item = 0;
      256: 1003:                    slab_rebal.evictions_nomem++;
        -: 1004:                } else {
        -: 1005:                    /* Was whatever it was, and we have memory for it. */
        -: 1006:                    save_item = 1;
        -: 1007:                }
     1784: 1008:                pthread_mutex_unlock(&slabs_lock);
     1784: 1009:                unsigned int requested_adjust = 0;
     1784: 1010:                if (save_item) {
     1365: 1011:                    if (ch == NULL) {
    1176*: 1012:                        assert((new_it->it_flags & ITEM_CHUNKED) == 0);
        -: 1013:                        /* if free memory, memcpy. clear prev/next/h_bucket */
     1176: 1014:                        memcpy(new_it, it, ntotal);
     1176: 1015:                        new_it->prev = 0;
     1176: 1016:                        new_it->next = 0;
     1176: 1017:                        new_it->h_next = 0;
        -: 1018:                        /* These are definitely required. else fails assert */
     1176: 1019:                        new_it->it_flags &= ~ITEM_LINKED;
     1176: 1020:                        new_it->refcount = 0;
     1176: 1021:                        do_item_replace(it, new_it, hv);
        -: 1022:                        /* Need to walk the chunks and repoint head  */
     1176: 1023:                        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 1024:                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);
    #####: 1025:                            fch->next->prev = fch;
    #####: 1026:                            while (fch) {
    #####: 1027:                                fch->head = new_it;
    #####: 1028:                                fch = fch->next;
        -: 1029:                            }
        -: 1030:                        }
     1176: 1031:                        it->refcount = 0;
     1176: 1032:                        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1033:#ifdef DEBUG_SLAB_MOVER
        -: 1034:                        memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1035:#endif
     1176: 1036:                        slab_rebal.rescues++;
     1176: 1037:                        requested_adjust = ntotal;
        -: 1038:                    } else {
      189: 1039:                        item_chunk *nch = (item_chunk *) new_it;
        -: 1040:                        /* Chunks always have head chunk (the main it) */
      189: 1041:                        ch->prev->next = nch;
      189: 1042:                        if (ch->next)
       19: 1043:                            ch->next->prev = nch;
      189: 1044:                        memcpy(nch, ch, ch->used + sizeof(item_chunk));
      189: 1045:                        ch->refcount = 0;
      189: 1046:                        ch->it_flags = ITEM_SLABBED|ITEM_FETCHED;
      189: 1047:                        slab_rebal.chunk_rescues++;
        -: 1048:#ifdef DEBUG_SLAB_MOVER
        -: 1049:                        memcpy(ITEM_key((item *)ch), "deadbeef", 8);
        -: 1050:#endif
      189: 1051:                        refcount_decr(it);
      189: 1052:                        requested_adjust = s_cls->size;
        -: 1053:                    }
        -: 1054:                } else {
        -: 1055:                    /* restore ntotal in case we tried saving a head chunk. */
      419: 1056:                    ntotal = ITEM_ntotal(it);
      419: 1057:                    STORAGE_delete(storage, it);
      419: 1058:                    do_item_unlink(it, hv);
      419: 1059:                    slabs_free(it, ntotal, slab_rebal.s_clsid);
        -: 1060:                    /* Swing around again later to remove it from the freelist. */
      419: 1061:                    slab_rebal.busy_items++;
      419: 1062:                    was_busy++;
        -: 1063:                }
     1784: 1064:                item_trylock_unlock(hold_lock);
     1784: 1065:                pthread_mutex_lock(&slabs_lock);
        -: 1066:                /* Always remove the ntotal, as we added it in during
        -: 1067:                 * do_slabs_alloc() when copying the item.
        -: 1068:                 */
     1784: 1069:                s_cls->requested -= requested_adjust;
     1784: 1070:                break;
     8285: 1071:            case MOVE_FROM_SLAB:
     8285: 1072:                it->refcount = 0;
     8285: 1073:                it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1074:#ifdef DEBUG_SLAB_MOVER
        -: 1075:                memcpy(ITEM_key(it), "deadbeef", 8);
        -: 1076:#endif
     8285: 1077:                break;
    #####: 1078:            case MOVE_BUSY:
        -: 1079:            case MOVE_LOCKED:
    #####: 1080:                slab_rebal.busy_items++;
    #####: 1081:                was_busy++;
    #####: 1082:                break;
        -: 1083:            case MOVE_PASS:
        -: 1084:                break;
        -: 1085:        }
        -: 1086:
    10994: 1087:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
    10994: 1088:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1089:            break;
        -: 1090:    }
        -: 1091:
    10994: 1092:    if (slab_rebal.slab_pos >= slab_rebal.slab_end) {
        -: 1093:        /* Some items were busy, start again from the top */
      101: 1094:        if (slab_rebal.busy_items) {
        5: 1095:            slab_rebal.slab_pos = slab_rebal.slab_start;
        5: 1096:            STATS_LOCK();
        5: 1097:            stats.slab_reassign_busy_items += slab_rebal.busy_items;
        5: 1098:            STATS_UNLOCK();
        5: 1099:            slab_rebal.busy_items = 0;
        5: 1100:            slab_rebal.busy_loops++;
        -: 1101:        } else {
       96: 1102:            slab_rebal.done++;
        -: 1103:        }
        -: 1104:    }
        -: 1105:
    10994: 1106:    pthread_mutex_unlock(&slabs_lock);
        -: 1107:
    10994: 1108:    return was_busy;
        -: 1109:}
------------------
        -: 1110:
      288: 1111:static void slab_rebalance_finish(void) {
      288: 1112:    slabclass_t *s_cls;
      288: 1113:    slabclass_t *d_cls;
      288: 1114:    int x;
      288: 1115:    uint32_t rescues;
      288: 1116:    uint32_t evictions_nomem;
      288: 1117:    uint32_t inline_reclaim;
      288: 1118:    uint32_t chunk_rescues;
      288: 1119:    uint32_t busy_deletes;
        -: 1120:
      288: 1121:    pthread_mutex_lock(&slabs_lock);
        -: 1122:
      288: 1123:    s_cls = &slabclass[slab_rebal.s_clsid];
      288: 1124:    d_cls = &slabclass[slab_rebal.d_clsid];
        -: 1125:
        -: 1126:#ifdef DEBUG_SLAB_MOVER
        -: 1127:    /* If the algorithm is broken, live items can sneak in. */
        -: 1128:    slab_rebal.slab_pos = slab_rebal.slab_start;
        -: 1129:    while (1) {
        -: 1130:        item *it = slab_rebal.slab_pos;
        -: 1131:        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        -: 1132:        assert(memcmp(ITEM_key(it), "deadbeef", 8) == 0);
        -: 1133:        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1134:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        -: 1135:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1136:            break;
        -: 1137:    }
        -: 1138:#endif
        -: 1139:
        -: 1140:    /* At this point the stolen slab is completely clear.
        -: 1141:     * We always kill the "first"/"oldest" slab page in the slab_list, so
        -: 1142:     * shuffle the page list backwards and decrement.
        -: 1143:     */
      288: 1144:    s_cls->slabs--;
     6723: 1145:    for (x = 0; x < s_cls->slabs; x++) {
     6435: 1146:        s_cls->slab_list[x] = s_cls->slab_list[x+1];
        -: 1147:    }
        -: 1148:
      288: 1149:    d_cls->slab_list[d_cls->slabs++] = slab_rebal.slab_start;
        -: 1150:    /* Don't need to split the page into chunks if we're just storing it */
      288: 1151:    if (slab_rebal.d_clsid > SLAB_GLOBAL_PAGE_POOL) {
        6: 1152:        memset(slab_rebal.slab_start, 0, (size_t)settings.slab_page_size);
       12: 1153:        split_slab_page_into_freelist(slab_rebal.slab_start,
        6: 1154:            slab_rebal.d_clsid);
      282: 1155:    } else if (slab_rebal.d_clsid == SLAB_GLOBAL_PAGE_POOL) {
        -: 1156:        /* mem_malloc'ed might be higher than mem_limit. */
      282: 1157:        mem_limit_reached = false;
      282: 1158:        memory_release();
        -: 1159:    }
        -: 1160:
      288: 1161:    slab_rebal.busy_loops = 0;
      288: 1162:    slab_rebal.done       = 0;
      288: 1163:    slab_rebal.s_clsid    = 0;
      288: 1164:    slab_rebal.d_clsid    = 0;
      288: 1165:    slab_rebal.slab_start = NULL;
      288: 1166:    slab_rebal.slab_end   = NULL;
      288: 1167:    slab_rebal.slab_pos   = NULL;
      288: 1168:    evictions_nomem    = slab_rebal.evictions_nomem;
      288: 1169:    inline_reclaim = slab_rebal.inline_reclaim;
      288: 1170:    rescues   = slab_rebal.rescues;
      288: 1171:    chunk_rescues = slab_rebal.chunk_rescues;
      288: 1172:    busy_deletes = slab_rebal.busy_deletes;
      288: 1173:    slab_rebal.evictions_nomem    = 0;
      288: 1174:    slab_rebal.inline_reclaim = 0;
      288: 1175:    slab_rebal.rescues  = 0;
      288: 1176:    slab_rebal.chunk_rescues = 0;
      288: 1177:    slab_rebal.busy_deletes = 0;
        -: 1178:
      288: 1179:    slab_rebalance_signal = 0;
        -: 1180:
      288: 1181:    pthread_mutex_unlock(&slabs_lock);
        -: 1182:
      288: 1183:    STATS_LOCK();
      288: 1184:    stats.slabs_moved++;
      288: 1185:    stats.slab_reassign_rescues += rescues;
      288: 1186:    stats.slab_reassign_evictions_nomem += evictions_nomem;
      288: 1187:    stats.slab_reassign_inline_reclaim += inline_reclaim;
      288: 1188:    stats.slab_reassign_chunk_rescues += chunk_rescues;
      288: 1189:    stats.slab_reassign_busy_deletes += busy_deletes;
      288: 1190:    stats_state.slab_reassign_running = false;
      288: 1191:    STATS_UNLOCK();
        -: 1192:
      288: 1193:    if (settings.verbose > 1) {
    #####: 1194:        fprintf(stderr, "finished a slab move\n");
        -: 1195:    }
      288: 1196:}
------------------
slab_rebalance_finish:
       96: 1111:static void slab_rebalance_finish(void) {
       96: 1112:    slabclass_t *s_cls;
       96: 1113:    slabclass_t *d_cls;
       96: 1114:    int x;
       96: 1115:    uint32_t rescues;
       96: 1116:    uint32_t evictions_nomem;
       96: 1117:    uint32_t inline_reclaim;
       96: 1118:    uint32_t chunk_rescues;
       96: 1119:    uint32_t busy_deletes;
        -: 1120:
       96: 1121:    pthread_mutex_lock(&slabs_lock);
        -: 1122:
       96: 1123:    s_cls = &slabclass[slab_rebal.s_clsid];
       96: 1124:    d_cls = &slabclass[slab_rebal.d_clsid];
        -: 1125:
        -: 1126:#ifdef DEBUG_SLAB_MOVER
        -: 1127:    /* If the algorithm is broken, live items can sneak in. */
        -: 1128:    slab_rebal.slab_pos = slab_rebal.slab_start;
        -: 1129:    while (1) {
        -: 1130:        item *it = slab_rebal.slab_pos;
        -: 1131:        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        -: 1132:        assert(memcmp(ITEM_key(it), "deadbeef", 8) == 0);
        -: 1133:        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1134:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        -: 1135:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1136:            break;
        -: 1137:    }
        -: 1138:#endif
        -: 1139:
        -: 1140:    /* At this point the stolen slab is completely clear.
        -: 1141:     * We always kill the "first"/"oldest" slab page in the slab_list, so
        -: 1142:     * shuffle the page list backwards and decrement.
        -: 1143:     */
       96: 1144:    s_cls->slabs--;
     2241: 1145:    for (x = 0; x < s_cls->slabs; x++) {
     2145: 1146:        s_cls->slab_list[x] = s_cls->slab_list[x+1];
        -: 1147:    }
        -: 1148:
       96: 1149:    d_cls->slab_list[d_cls->slabs++] = slab_rebal.slab_start;
        -: 1150:    /* Don't need to split the page into chunks if we're just storing it */
       96: 1151:    if (slab_rebal.d_clsid > SLAB_GLOBAL_PAGE_POOL) {
        2: 1152:        memset(slab_rebal.slab_start, 0, (size_t)settings.slab_page_size);
        4: 1153:        split_slab_page_into_freelist(slab_rebal.slab_start,
        2: 1154:            slab_rebal.d_clsid);
       94: 1155:    } else if (slab_rebal.d_clsid == SLAB_GLOBAL_PAGE_POOL) {
        -: 1156:        /* mem_malloc'ed might be higher than mem_limit. */
       94: 1157:        mem_limit_reached = false;
       94: 1158:        memory_release();
        -: 1159:    }
        -: 1160:
       96: 1161:    slab_rebal.busy_loops = 0;
       96: 1162:    slab_rebal.done       = 0;
       96: 1163:    slab_rebal.s_clsid    = 0;
       96: 1164:    slab_rebal.d_clsid    = 0;
       96: 1165:    slab_rebal.slab_start = NULL;
       96: 1166:    slab_rebal.slab_end   = NULL;
       96: 1167:    slab_rebal.slab_pos   = NULL;
       96: 1168:    evictions_nomem    = slab_rebal.evictions_nomem;
       96: 1169:    inline_reclaim = slab_rebal.inline_reclaim;
       96: 1170:    rescues   = slab_rebal.rescues;
       96: 1171:    chunk_rescues = slab_rebal.chunk_rescues;
       96: 1172:    busy_deletes = slab_rebal.busy_deletes;
       96: 1173:    slab_rebal.evictions_nomem    = 0;
       96: 1174:    slab_rebal.inline_reclaim = 0;
       96: 1175:    slab_rebal.rescues  = 0;
       96: 1176:    slab_rebal.chunk_rescues = 0;
       96: 1177:    slab_rebal.busy_deletes = 0;
        -: 1178:
       96: 1179:    slab_rebalance_signal = 0;
        -: 1180:
       96: 1181:    pthread_mutex_unlock(&slabs_lock);
        -: 1182:
       96: 1183:    STATS_LOCK();
       96: 1184:    stats.slabs_moved++;
       96: 1185:    stats.slab_reassign_rescues += rescues;
       96: 1186:    stats.slab_reassign_evictions_nomem += evictions_nomem;
       96: 1187:    stats.slab_reassign_inline_reclaim += inline_reclaim;
       96: 1188:    stats.slab_reassign_chunk_rescues += chunk_rescues;
       96: 1189:    stats.slab_reassign_busy_deletes += busy_deletes;
       96: 1190:    stats_state.slab_reassign_running = false;
       96: 1191:    STATS_UNLOCK();
        -: 1192:
       96: 1193:    if (settings.verbose > 1) {
    #####: 1194:        fprintf(stderr, "finished a slab move\n");
        -: 1195:    }
       96: 1196:}
------------------
slab_rebalance_finish:
       96: 1111:static void slab_rebalance_finish(void) {
       96: 1112:    slabclass_t *s_cls;
       96: 1113:    slabclass_t *d_cls;
       96: 1114:    int x;
       96: 1115:    uint32_t rescues;
       96: 1116:    uint32_t evictions_nomem;
       96: 1117:    uint32_t inline_reclaim;
       96: 1118:    uint32_t chunk_rescues;
       96: 1119:    uint32_t busy_deletes;
        -: 1120:
       96: 1121:    pthread_mutex_lock(&slabs_lock);
        -: 1122:
       96: 1123:    s_cls = &slabclass[slab_rebal.s_clsid];
       96: 1124:    d_cls = &slabclass[slab_rebal.d_clsid];
        -: 1125:
        -: 1126:#ifdef DEBUG_SLAB_MOVER
        -: 1127:    /* If the algorithm is broken, live items can sneak in. */
        -: 1128:    slab_rebal.slab_pos = slab_rebal.slab_start;
        -: 1129:    while (1) {
        -: 1130:        item *it = slab_rebal.slab_pos;
        -: 1131:        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        -: 1132:        assert(memcmp(ITEM_key(it), "deadbeef", 8) == 0);
        -: 1133:        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1134:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        -: 1135:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1136:            break;
        -: 1137:    }
        -: 1138:#endif
        -: 1139:
        -: 1140:    /* At this point the stolen slab is completely clear.
        -: 1141:     * We always kill the "first"/"oldest" slab page in the slab_list, so
        -: 1142:     * shuffle the page list backwards and decrement.
        -: 1143:     */
       96: 1144:    s_cls->slabs--;
     2241: 1145:    for (x = 0; x < s_cls->slabs; x++) {
     2145: 1146:        s_cls->slab_list[x] = s_cls->slab_list[x+1];
        -: 1147:    }
        -: 1148:
       96: 1149:    d_cls->slab_list[d_cls->slabs++] = slab_rebal.slab_start;
        -: 1150:    /* Don't need to split the page into chunks if we're just storing it */
       96: 1151:    if (slab_rebal.d_clsid > SLAB_GLOBAL_PAGE_POOL) {
        2: 1152:        memset(slab_rebal.slab_start, 0, (size_t)settings.slab_page_size);
        4: 1153:        split_slab_page_into_freelist(slab_rebal.slab_start,
        2: 1154:            slab_rebal.d_clsid);
       94: 1155:    } else if (slab_rebal.d_clsid == SLAB_GLOBAL_PAGE_POOL) {
        -: 1156:        /* mem_malloc'ed might be higher than mem_limit. */
       94: 1157:        mem_limit_reached = false;
       94: 1158:        memory_release();
        -: 1159:    }
        -: 1160:
       96: 1161:    slab_rebal.busy_loops = 0;
       96: 1162:    slab_rebal.done       = 0;
       96: 1163:    slab_rebal.s_clsid    = 0;
       96: 1164:    slab_rebal.d_clsid    = 0;
       96: 1165:    slab_rebal.slab_start = NULL;
       96: 1166:    slab_rebal.slab_end   = NULL;
       96: 1167:    slab_rebal.slab_pos   = NULL;
       96: 1168:    evictions_nomem    = slab_rebal.evictions_nomem;
       96: 1169:    inline_reclaim = slab_rebal.inline_reclaim;
       96: 1170:    rescues   = slab_rebal.rescues;
       96: 1171:    chunk_rescues = slab_rebal.chunk_rescues;
       96: 1172:    busy_deletes = slab_rebal.busy_deletes;
       96: 1173:    slab_rebal.evictions_nomem    = 0;
       96: 1174:    slab_rebal.inline_reclaim = 0;
       96: 1175:    slab_rebal.rescues  = 0;
       96: 1176:    slab_rebal.chunk_rescues = 0;
       96: 1177:    slab_rebal.busy_deletes = 0;
        -: 1178:
       96: 1179:    slab_rebalance_signal = 0;
        -: 1180:
       96: 1181:    pthread_mutex_unlock(&slabs_lock);
        -: 1182:
       96: 1183:    STATS_LOCK();
       96: 1184:    stats.slabs_moved++;
       96: 1185:    stats.slab_reassign_rescues += rescues;
       96: 1186:    stats.slab_reassign_evictions_nomem += evictions_nomem;
       96: 1187:    stats.slab_reassign_inline_reclaim += inline_reclaim;
       96: 1188:    stats.slab_reassign_chunk_rescues += chunk_rescues;
       96: 1189:    stats.slab_reassign_busy_deletes += busy_deletes;
       96: 1190:    stats_state.slab_reassign_running = false;
       96: 1191:    STATS_UNLOCK();
        -: 1192:
       96: 1193:    if (settings.verbose > 1) {
    #####: 1194:        fprintf(stderr, "finished a slab move\n");
        -: 1195:    }
       96: 1196:}
------------------
slab_rebalance_finish:
       96: 1111:static void slab_rebalance_finish(void) {
       96: 1112:    slabclass_t *s_cls;
       96: 1113:    slabclass_t *d_cls;
       96: 1114:    int x;
       96: 1115:    uint32_t rescues;
       96: 1116:    uint32_t evictions_nomem;
       96: 1117:    uint32_t inline_reclaim;
       96: 1118:    uint32_t chunk_rescues;
       96: 1119:    uint32_t busy_deletes;
        -: 1120:
       96: 1121:    pthread_mutex_lock(&slabs_lock);
        -: 1122:
       96: 1123:    s_cls = &slabclass[slab_rebal.s_clsid];
       96: 1124:    d_cls = &slabclass[slab_rebal.d_clsid];
        -: 1125:
        -: 1126:#ifdef DEBUG_SLAB_MOVER
        -: 1127:    /* If the algorithm is broken, live items can sneak in. */
        -: 1128:    slab_rebal.slab_pos = slab_rebal.slab_start;
        -: 1129:    while (1) {
        -: 1130:        item *it = slab_rebal.slab_pos;
        -: 1131:        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        -: 1132:        assert(memcmp(ITEM_key(it), "deadbeef", 8) == 0);
        -: 1133:        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        -: 1134:        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        -: 1135:        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
        -: 1136:            break;
        -: 1137:    }
        -: 1138:#endif
        -: 1139:
        -: 1140:    /* At this point the stolen slab is completely clear.
        -: 1141:     * We always kill the "first"/"oldest" slab page in the slab_list, so
        -: 1142:     * shuffle the page list backwards and decrement.
        -: 1143:     */
       96: 1144:    s_cls->slabs--;
     2241: 1145:    for (x = 0; x < s_cls->slabs; x++) {
     2145: 1146:        s_cls->slab_list[x] = s_cls->slab_list[x+1];
        -: 1147:    }
        -: 1148:
       96: 1149:    d_cls->slab_list[d_cls->slabs++] = slab_rebal.slab_start;
        -: 1150:    /* Don't need to split the page into chunks if we're just storing it */
       96: 1151:    if (slab_rebal.d_clsid > SLAB_GLOBAL_PAGE_POOL) {
        2: 1152:        memset(slab_rebal.slab_start, 0, (size_t)settings.slab_page_size);
        4: 1153:        split_slab_page_into_freelist(slab_rebal.slab_start,
        2: 1154:            slab_rebal.d_clsid);
       94: 1155:    } else if (slab_rebal.d_clsid == SLAB_GLOBAL_PAGE_POOL) {
        -: 1156:        /* mem_malloc'ed might be higher than mem_limit. */
       94: 1157:        mem_limit_reached = false;
       94: 1158:        memory_release();
        -: 1159:    }
        -: 1160:
       96: 1161:    slab_rebal.busy_loops = 0;
       96: 1162:    slab_rebal.done       = 0;
       96: 1163:    slab_rebal.s_clsid    = 0;
       96: 1164:    slab_rebal.d_clsid    = 0;
       96: 1165:    slab_rebal.slab_start = NULL;
       96: 1166:    slab_rebal.slab_end   = NULL;
       96: 1167:    slab_rebal.slab_pos   = NULL;
       96: 1168:    evictions_nomem    = slab_rebal.evictions_nomem;
       96: 1169:    inline_reclaim = slab_rebal.inline_reclaim;
       96: 1170:    rescues   = slab_rebal.rescues;
       96: 1171:    chunk_rescues = slab_rebal.chunk_rescues;
       96: 1172:    busy_deletes = slab_rebal.busy_deletes;
       96: 1173:    slab_rebal.evictions_nomem    = 0;
       96: 1174:    slab_rebal.inline_reclaim = 0;
       96: 1175:    slab_rebal.rescues  = 0;
       96: 1176:    slab_rebal.chunk_rescues = 0;
       96: 1177:    slab_rebal.busy_deletes = 0;
        -: 1178:
       96: 1179:    slab_rebalance_signal = 0;
        -: 1180:
       96: 1181:    pthread_mutex_unlock(&slabs_lock);
        -: 1182:
       96: 1183:    STATS_LOCK();
       96: 1184:    stats.slabs_moved++;
       96: 1185:    stats.slab_reassign_rescues += rescues;
       96: 1186:    stats.slab_reassign_evictions_nomem += evictions_nomem;
       96: 1187:    stats.slab_reassign_inline_reclaim += inline_reclaim;
       96: 1188:    stats.slab_reassign_chunk_rescues += chunk_rescues;
       96: 1189:    stats.slab_reassign_busy_deletes += busy_deletes;
       96: 1190:    stats_state.slab_reassign_running = false;
       96: 1191:    STATS_UNLOCK();
        -: 1192:
       96: 1193:    if (settings.verbose > 1) {
    #####: 1194:        fprintf(stderr, "finished a slab move\n");
        -: 1195:    }
       96: 1196:}
------------------
        -: 1197:
        -: 1198:/* Slab mover thread.
        -: 1199: * Sits waiting for a condition to jump off and shovel some memory about
        -: 1200: */
      264: 1201:static void *slab_rebalance_thread(void *arg) {
      264: 1202:    int was_busy = 0;
        -: 1203:    /* So we first pass into cond_wait with the mutex held */
      264: 1204:    mutex_lock(&slabs_rebalance_lock);
        -: 1205:
    33537: 1206:    while (do_run_slab_rebalance_thread) {
    33537: 1207:        if (slab_rebalance_signal == 1) {
      291: 1208:            if (slab_rebalance_start() < 0) {
        -: 1209:                /* Handle errors with more specificity as required. */
    #####: 1210:                slab_rebalance_signal = 0;
        -: 1211:            }
        -: 1212:
        -: 1213:            was_busy = 0;
    33246: 1214:        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
    32982: 1215:            was_busy = slab_rebalance_move();
        -: 1216:        }
        -: 1217:
    33537: 1218:        if (slab_rebal.done) {
      288: 1219:            slab_rebalance_finish();
    33249: 1220:        } else if (was_busy) {
        -: 1221:            /* Stuck waiting for some items to unlock, so slow down a bit
        -: 1222:             * to give them a chance to free up */
     1257: 1223:            usleep(1000);
        -: 1224:        }
        -: 1225:
    33534: 1226:        if (slab_rebalance_signal == 0) {
        -: 1227:            /* always hold this lock while we're running */
      552: 1228:            pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock);
        -: 1229:        }
        -: 1230:    }
    #####: 1231:    return NULL;
        -: 1232:}
------------------
slab_rebalance_thread:
       88: 1201:static void *slab_rebalance_thread(void *arg) {
       88: 1202:    int was_busy = 0;
        -: 1203:    /* So we first pass into cond_wait with the mutex held */
       88: 1204:    mutex_lock(&slabs_rebalance_lock);
        -: 1205:
    11179: 1206:    while (do_run_slab_rebalance_thread) {
    11179: 1207:        if (slab_rebalance_signal == 1) {
       97: 1208:            if (slab_rebalance_start() < 0) {
        -: 1209:                /* Handle errors with more specificity as required. */
    #####: 1210:                slab_rebalance_signal = 0;
        -: 1211:            }
        -: 1212:
        -: 1213:            was_busy = 0;
    11082: 1214:        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
    10994: 1215:            was_busy = slab_rebalance_move();
        -: 1216:        }
        -: 1217:
    11179: 1218:        if (slab_rebal.done) {
       96: 1219:            slab_rebalance_finish();
    11083: 1220:        } else if (was_busy) {
        -: 1221:            /* Stuck waiting for some items to unlock, so slow down a bit
        -: 1222:             * to give them a chance to free up */
      419: 1223:            usleep(1000);
        -: 1224:        }
        -: 1225:
    11178: 1226:        if (slab_rebalance_signal == 0) {
        -: 1227:            /* always hold this lock while we're running */
      184: 1228:            pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock);
        -: 1229:        }
        -: 1230:    }
    #####: 1231:    return NULL;
        -: 1232:}
------------------
slab_rebalance_thread:
       88: 1201:static void *slab_rebalance_thread(void *arg) {
       88: 1202:    int was_busy = 0;
        -: 1203:    /* So we first pass into cond_wait with the mutex held */
       88: 1204:    mutex_lock(&slabs_rebalance_lock);
        -: 1205:
    11179: 1206:    while (do_run_slab_rebalance_thread) {
    11179: 1207:        if (slab_rebalance_signal == 1) {
       97: 1208:            if (slab_rebalance_start() < 0) {
        -: 1209:                /* Handle errors with more specificity as required. */
    #####: 1210:                slab_rebalance_signal = 0;
        -: 1211:            }
        -: 1212:
        -: 1213:            was_busy = 0;
    11082: 1214:        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
    10994: 1215:            was_busy = slab_rebalance_move();
        -: 1216:        }
        -: 1217:
    11179: 1218:        if (slab_rebal.done) {
       96: 1219:            slab_rebalance_finish();
    11083: 1220:        } else if (was_busy) {
        -: 1221:            /* Stuck waiting for some items to unlock, so slow down a bit
        -: 1222:             * to give them a chance to free up */
      419: 1223:            usleep(1000);
        -: 1224:        }
        -: 1225:
    11178: 1226:        if (slab_rebalance_signal == 0) {
        -: 1227:            /* always hold this lock while we're running */
      184: 1228:            pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock);
        -: 1229:        }
        -: 1230:    }
    #####: 1231:    return NULL;
        -: 1232:}
------------------
slab_rebalance_thread:
       88: 1201:static void *slab_rebalance_thread(void *arg) {
       88: 1202:    int was_busy = 0;
        -: 1203:    /* So we first pass into cond_wait with the mutex held */
       88: 1204:    mutex_lock(&slabs_rebalance_lock);
        -: 1205:
    11179: 1206:    while (do_run_slab_rebalance_thread) {
    11179: 1207:        if (slab_rebalance_signal == 1) {
       97: 1208:            if (slab_rebalance_start() < 0) {
        -: 1209:                /* Handle errors with more specificity as required. */
    #####: 1210:                slab_rebalance_signal = 0;
        -: 1211:            }
        -: 1212:
        -: 1213:            was_busy = 0;
    11082: 1214:        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
    10994: 1215:            was_busy = slab_rebalance_move();
        -: 1216:        }
        -: 1217:
    11179: 1218:        if (slab_rebal.done) {
       96: 1219:            slab_rebalance_finish();
    11083: 1220:        } else if (was_busy) {
        -: 1221:            /* Stuck waiting for some items to unlock, so slow down a bit
        -: 1222:             * to give them a chance to free up */
      419: 1223:            usleep(1000);
        -: 1224:        }
        -: 1225:
    11178: 1226:        if (slab_rebalance_signal == 0) {
        -: 1227:            /* always hold this lock while we're running */
      184: 1228:            pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock);
        -: 1229:        }
        -: 1230:    }
    #####: 1231:    return NULL;
        -: 1232:}
------------------
        -: 1233:
        -: 1234:/* Iterate at most once through the slab classes and pick a "random" source.
        -: 1235: * I like this better than calling rand() since rand() is slow enough that we
        -: 1236: * can just check all of the classes once instead.
        -: 1237: */
        -: 1238:static int slabs_reassign_pick_any(int dst) {
    #####: 1239:    static int cur = POWER_SMALLEST - 1;
    #####: 1240:    int tries = power_largest - POWER_SMALLEST + 1;
    #####: 1241:    for (; tries > 0; tries--) {
    #####: 1242:        cur++;
    #####: 1243:        if (cur > power_largest)
    #####: 1244:            cur = POWER_SMALLEST;
    #####: 1245:        if (cur == dst)
        -: 1246:            continue;
    #####: 1247:        if (slabclass[cur].slabs > 1) {
        -: 1248:            return cur;
        -: 1249:        }
        -: 1250:    }
        -: 1251:    return -1;
        -: 1252:}
        -: 1253:
      291: 1254:static enum reassign_result_type do_slabs_reassign(int src, int dst) {
      291: 1255:    bool nospare = false;
      291: 1256:    if (slab_rebalance_signal != 0)
        -: 1257:        return REASSIGN_RUNNING;
        -: 1258:
      291: 1259:    if (src == dst)
        -: 1260:        return REASSIGN_SRC_DST_SAME;
        -: 1261:
        -: 1262:    /* Special indicator to choose ourselves. */
      291: 1263:    if (src == -1) {
    #####: 1264:        src = slabs_reassign_pick_any(dst);
        -: 1265:        /* TODO: If we end up back at -1, return a new error type */
        -: 1266:    }
        -: 1267:
      291: 1268:    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
      291: 1269:        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        -: 1270:        return REASSIGN_BADCLASS;
        -: 1271:
      291: 1272:    pthread_mutex_lock(&slabs_lock);
      291: 1273:    if (slabclass[src].slabs < 2)
    #####: 1274:        nospare = true;
      291: 1275:    pthread_mutex_unlock(&slabs_lock);
      291: 1276:    if (nospare)
        -: 1277:        return REASSIGN_NOSPARE;
        -: 1278:
      291: 1279:    slab_rebal.s_clsid = src;
      291: 1280:    slab_rebal.d_clsid = dst;
        -: 1281:
      291: 1282:    slab_rebalance_signal = 1;
      291: 1283:    pthread_cond_signal(&slab_rebalance_cond);
        -: 1284:
      291: 1285:    return REASSIGN_OK;
        -: 1286:}
------------------
do_slabs_reassign:
       97: 1254:static enum reassign_result_type do_slabs_reassign(int src, int dst) {
       97: 1255:    bool nospare = false;
       97: 1256:    if (slab_rebalance_signal != 0)
        -: 1257:        return REASSIGN_RUNNING;
        -: 1258:
       97: 1259:    if (src == dst)
        -: 1260:        return REASSIGN_SRC_DST_SAME;
        -: 1261:
        -: 1262:    /* Special indicator to choose ourselves. */
       97: 1263:    if (src == -1) {
    #####: 1264:        src = slabs_reassign_pick_any(dst);
        -: 1265:        /* TODO: If we end up back at -1, return a new error type */
        -: 1266:    }
        -: 1267:
       97: 1268:    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
       97: 1269:        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        -: 1270:        return REASSIGN_BADCLASS;
        -: 1271:
       97: 1272:    pthread_mutex_lock(&slabs_lock);
       97: 1273:    if (slabclass[src].slabs < 2)
    #####: 1274:        nospare = true;
       97: 1275:    pthread_mutex_unlock(&slabs_lock);
       97: 1276:    if (nospare)
        -: 1277:        return REASSIGN_NOSPARE;
        -: 1278:
       97: 1279:    slab_rebal.s_clsid = src;
       97: 1280:    slab_rebal.d_clsid = dst;
        -: 1281:
       97: 1282:    slab_rebalance_signal = 1;
       97: 1283:    pthread_cond_signal(&slab_rebalance_cond);
        -: 1284:
       97: 1285:    return REASSIGN_OK;
        -: 1286:}
------------------
do_slabs_reassign:
       97: 1254:static enum reassign_result_type do_slabs_reassign(int src, int dst) {
       97: 1255:    bool nospare = false;
       97: 1256:    if (slab_rebalance_signal != 0)
        -: 1257:        return REASSIGN_RUNNING;
        -: 1258:
       97: 1259:    if (src == dst)
        -: 1260:        return REASSIGN_SRC_DST_SAME;
        -: 1261:
        -: 1262:    /* Special indicator to choose ourselves. */
       97: 1263:    if (src == -1) {
    #####: 1264:        src = slabs_reassign_pick_any(dst);
        -: 1265:        /* TODO: If we end up back at -1, return a new error type */
        -: 1266:    }
        -: 1267:
       97: 1268:    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
       97: 1269:        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        -: 1270:        return REASSIGN_BADCLASS;
        -: 1271:
       97: 1272:    pthread_mutex_lock(&slabs_lock);
       97: 1273:    if (slabclass[src].slabs < 2)
    #####: 1274:        nospare = true;
       97: 1275:    pthread_mutex_unlock(&slabs_lock);
       97: 1276:    if (nospare)
        -: 1277:        return REASSIGN_NOSPARE;
        -: 1278:
       97: 1279:    slab_rebal.s_clsid = src;
       97: 1280:    slab_rebal.d_clsid = dst;
        -: 1281:
       97: 1282:    slab_rebalance_signal = 1;
       97: 1283:    pthread_cond_signal(&slab_rebalance_cond);
        -: 1284:
       97: 1285:    return REASSIGN_OK;
        -: 1286:}
------------------
do_slabs_reassign:
       97: 1254:static enum reassign_result_type do_slabs_reassign(int src, int dst) {
       97: 1255:    bool nospare = false;
       97: 1256:    if (slab_rebalance_signal != 0)
        -: 1257:        return REASSIGN_RUNNING;
        -: 1258:
       97: 1259:    if (src == dst)
        -: 1260:        return REASSIGN_SRC_DST_SAME;
        -: 1261:
        -: 1262:    /* Special indicator to choose ourselves. */
       97: 1263:    if (src == -1) {
    #####: 1264:        src = slabs_reassign_pick_any(dst);
        -: 1265:        /* TODO: If we end up back at -1, return a new error type */
        -: 1266:    }
        -: 1267:
       97: 1268:    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
       97: 1269:        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        -: 1270:        return REASSIGN_BADCLASS;
        -: 1271:
       97: 1272:    pthread_mutex_lock(&slabs_lock);
       97: 1273:    if (slabclass[src].slabs < 2)
    #####: 1274:        nospare = true;
       97: 1275:    pthread_mutex_unlock(&slabs_lock);
       97: 1276:    if (nospare)
        -: 1277:        return REASSIGN_NOSPARE;
        -: 1278:
       97: 1279:    slab_rebal.s_clsid = src;
       97: 1280:    slab_rebal.d_clsid = dst;
        -: 1281:
       97: 1282:    slab_rebalance_signal = 1;
       97: 1283:    pthread_cond_signal(&slab_rebalance_cond);
        -: 1284:
       97: 1285:    return REASSIGN_OK;
        -: 1286:}
------------------
        -: 1287:
      291: 1288:enum reassign_result_type slabs_reassign(int src, int dst) {
      291: 1289:    enum reassign_result_type ret;
      291: 1290:    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        -: 1291:        return REASSIGN_RUNNING;
        -: 1292:    }
      291: 1293:    ret = do_slabs_reassign(src, dst);
      291: 1294:    pthread_mutex_unlock(&slabs_rebalance_lock);
      291: 1295:    return ret;
        -: 1296:}
------------------
slabs_reassign:
       97: 1288:enum reassign_result_type slabs_reassign(int src, int dst) {
       97: 1289:    enum reassign_result_type ret;
       97: 1290:    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        -: 1291:        return REASSIGN_RUNNING;
        -: 1292:    }
       97: 1293:    ret = do_slabs_reassign(src, dst);
       97: 1294:    pthread_mutex_unlock(&slabs_rebalance_lock);
       97: 1295:    return ret;
        -: 1296:}
------------------
slabs_reassign:
       97: 1288:enum reassign_result_type slabs_reassign(int src, int dst) {
       97: 1289:    enum reassign_result_type ret;
       97: 1290:    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        -: 1291:        return REASSIGN_RUNNING;
        -: 1292:    }
       97: 1293:    ret = do_slabs_reassign(src, dst);
       97: 1294:    pthread_mutex_unlock(&slabs_rebalance_lock);
       97: 1295:    return ret;
        -: 1296:}
------------------
slabs_reassign:
       97: 1288:enum reassign_result_type slabs_reassign(int src, int dst) {
       97: 1289:    enum reassign_result_type ret;
       97: 1290:    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        -: 1291:        return REASSIGN_RUNNING;
        -: 1292:    }
       97: 1293:    ret = do_slabs_reassign(src, dst);
       97: 1294:    pthread_mutex_unlock(&slabs_rebalance_lock);
       97: 1295:    return ret;
        -: 1296:}
------------------
        -: 1297:
        -: 1298:/* If we hold this lock, rebalancer can't wake up or move */
    #####: 1299:void slabs_rebalancer_pause(void) {
    #####: 1300:    pthread_mutex_lock(&slabs_rebalance_lock);
    #####: 1301:}
------------------
slabs_rebalancer_pause:
    #####: 1299:void slabs_rebalancer_pause(void) {
    #####: 1300:    pthread_mutex_lock(&slabs_rebalance_lock);
    #####: 1301:}
------------------
slabs_rebalancer_pause:
    #####: 1299:void slabs_rebalancer_pause(void) {
    #####: 1300:    pthread_mutex_lock(&slabs_rebalance_lock);
    #####: 1301:}
------------------
slabs_rebalancer_pause:
    #####: 1299:void slabs_rebalancer_pause(void) {
    #####: 1300:    pthread_mutex_lock(&slabs_rebalance_lock);
    #####: 1301:}
------------------
        -: 1302:
    #####: 1303:void slabs_rebalancer_resume(void) {
    #####: 1304:    pthread_mutex_unlock(&slabs_rebalance_lock);
    #####: 1305:}
------------------
slabs_rebalancer_resume:
    #####: 1303:void slabs_rebalancer_resume(void) {
    #####: 1304:    pthread_mutex_unlock(&slabs_rebalance_lock);
    #####: 1305:}
------------------
slabs_rebalancer_resume:
    #####: 1303:void slabs_rebalancer_resume(void) {
    #####: 1304:    pthread_mutex_unlock(&slabs_rebalance_lock);
    #####: 1305:}
------------------
slabs_rebalancer_resume:
    #####: 1303:void slabs_rebalancer_resume(void) {
    #####: 1304:    pthread_mutex_unlock(&slabs_rebalance_lock);
    #####: 1305:}
------------------
        -: 1306:
        -: 1307:static pthread_t rebalance_tid;
        -: 1308:
      264: 1309:int start_slab_maintenance_thread(void) {
      264: 1310:    int ret;
      264: 1311:    slab_rebalance_signal = 0;
      264: 1312:    slab_rebal.slab_start = NULL;
      264: 1313:    char *env = getenv("MEMCACHED_SLAB_BULK_CHECK");
      264: 1314:    if (env != NULL) {
    #####: 1315:        slab_bulk_check = atoi(env);
    #####: 1316:        if (slab_bulk_check == 0) {
    #####: 1317:            slab_bulk_check = DEFAULT_SLAB_BULK_CHECK;
        -: 1318:        }
        -: 1319:    }
        -: 1320:
      264: 1321:    if (pthread_cond_init(&slab_rebalance_cond, NULL) != 0) {
    #####: 1322:        fprintf(stderr, "Can't initialize rebalance condition\n");
    #####: 1323:        return -1;
        -: 1324:    }
      264: 1325:    pthread_mutex_init(&slabs_rebalance_lock, NULL);
        -: 1326:
      264: 1327:    if ((ret = pthread_create(&rebalance_tid, NULL,
        -: 1328:                              slab_rebalance_thread, NULL)) != 0) {
    #####: 1329:        fprintf(stderr, "Can't create rebal thread: %s\n", strerror(ret));
    #####: 1330:        return -1;
        -: 1331:    }
        -: 1332:    return 0;
        -: 1333:}
------------------
start_slab_maintenance_thread:
       88: 1309:int start_slab_maintenance_thread(void) {
       88: 1310:    int ret;
       88: 1311:    slab_rebalance_signal = 0;
       88: 1312:    slab_rebal.slab_start = NULL;
       88: 1313:    char *env = getenv("MEMCACHED_SLAB_BULK_CHECK");
       88: 1314:    if (env != NULL) {
    #####: 1315:        slab_bulk_check = atoi(env);
    #####: 1316:        if (slab_bulk_check == 0) {
    #####: 1317:            slab_bulk_check = DEFAULT_SLAB_BULK_CHECK;
        -: 1318:        }
        -: 1319:    }
        -: 1320:
       88: 1321:    if (pthread_cond_init(&slab_rebalance_cond, NULL) != 0) {
    #####: 1322:        fprintf(stderr, "Can't initialize rebalance condition\n");
    #####: 1323:        return -1;
        -: 1324:    }
       88: 1325:    pthread_mutex_init(&slabs_rebalance_lock, NULL);
        -: 1326:
       88: 1327:    if ((ret = pthread_create(&rebalance_tid, NULL,
        -: 1328:                              slab_rebalance_thread, NULL)) != 0) {
    #####: 1329:        fprintf(stderr, "Can't create rebal thread: %s\n", strerror(ret));
    #####: 1330:        return -1;
        -: 1331:    }
        -: 1332:    return 0;
        -: 1333:}
------------------
start_slab_maintenance_thread:
       88: 1309:int start_slab_maintenance_thread(void) {
       88: 1310:    int ret;
       88: 1311:    slab_rebalance_signal = 0;
       88: 1312:    slab_rebal.slab_start = NULL;
       88: 1313:    char *env = getenv("MEMCACHED_SLAB_BULK_CHECK");
       88: 1314:    if (env != NULL) {
    #####: 1315:        slab_bulk_check = atoi(env);
    #####: 1316:        if (slab_bulk_check == 0) {
    #####: 1317:            slab_bulk_check = DEFAULT_SLAB_BULK_CHECK;
        -: 1318:        }
        -: 1319:    }
        -: 1320:
       88: 1321:    if (pthread_cond_init(&slab_rebalance_cond, NULL) != 0) {
    #####: 1322:        fprintf(stderr, "Can't initialize rebalance condition\n");
    #####: 1323:        return -1;
        -: 1324:    }
       88: 1325:    pthread_mutex_init(&slabs_rebalance_lock, NULL);
        -: 1326:
       88: 1327:    if ((ret = pthread_create(&rebalance_tid, NULL,
        -: 1328:                              slab_rebalance_thread, NULL)) != 0) {
    #####: 1329:        fprintf(stderr, "Can't create rebal thread: %s\n", strerror(ret));
    #####: 1330:        return -1;
        -: 1331:    }
        -: 1332:    return 0;
        -: 1333:}
------------------
start_slab_maintenance_thread:
       88: 1309:int start_slab_maintenance_thread(void) {
       88: 1310:    int ret;
       88: 1311:    slab_rebalance_signal = 0;
       88: 1312:    slab_rebal.slab_start = NULL;
       88: 1313:    char *env = getenv("MEMCACHED_SLAB_BULK_CHECK");
       88: 1314:    if (env != NULL) {
    #####: 1315:        slab_bulk_check = atoi(env);
    #####: 1316:        if (slab_bulk_check == 0) {
    #####: 1317:            slab_bulk_check = DEFAULT_SLAB_BULK_CHECK;
        -: 1318:        }
        -: 1319:    }
        -: 1320:
       88: 1321:    if (pthread_cond_init(&slab_rebalance_cond, NULL) != 0) {
    #####: 1322:        fprintf(stderr, "Can't initialize rebalance condition\n");
    #####: 1323:        return -1;
        -: 1324:    }
       88: 1325:    pthread_mutex_init(&slabs_rebalance_lock, NULL);
        -: 1326:
       88: 1327:    if ((ret = pthread_create(&rebalance_tid, NULL,
        -: 1328:                              slab_rebalance_thread, NULL)) != 0) {
    #####: 1329:        fprintf(stderr, "Can't create rebal thread: %s\n", strerror(ret));
    #####: 1330:        return -1;
        -: 1331:    }
        -: 1332:    return 0;
        -: 1333:}
------------------
        -: 1334:
        -: 1335:/* The maintenance thread is on a sleep/loop cycle, so it should join after a
        -: 1336: * short wait */
    #####: 1337:void stop_slab_maintenance_thread(void) {
    #####: 1338:    mutex_lock(&slabs_rebalance_lock);
    #####: 1339:    do_run_slab_thread = 0;
    #####: 1340:    do_run_slab_rebalance_thread = 0;
    #####: 1341:    pthread_cond_signal(&slab_rebalance_cond);
    #####: 1342:    pthread_mutex_unlock(&slabs_rebalance_lock);
        -: 1343:
        -: 1344:    /* Wait for the maintenance thread to stop */
    #####: 1345:    pthread_join(rebalance_tid, NULL);
    #####: 1346:}
------------------
stop_slab_maintenance_thread:
    #####: 1337:void stop_slab_maintenance_thread(void) {
    #####: 1338:    mutex_lock(&slabs_rebalance_lock);
    #####: 1339:    do_run_slab_thread = 0;
    #####: 1340:    do_run_slab_rebalance_thread = 0;
    #####: 1341:    pthread_cond_signal(&slab_rebalance_cond);
    #####: 1342:    pthread_mutex_unlock(&slabs_rebalance_lock);
        -: 1343:
        -: 1344:    /* Wait for the maintenance thread to stop */
    #####: 1345:    pthread_join(rebalance_tid, NULL);
    #####: 1346:}
------------------
stop_slab_maintenance_thread:
    #####: 1337:void stop_slab_maintenance_thread(void) {
    #####: 1338:    mutex_lock(&slabs_rebalance_lock);
    #####: 1339:    do_run_slab_thread = 0;
    #####: 1340:    do_run_slab_rebalance_thread = 0;
    #####: 1341:    pthread_cond_signal(&slab_rebalance_cond);
    #####: 1342:    pthread_mutex_unlock(&slabs_rebalance_lock);
        -: 1343:
        -: 1344:    /* Wait for the maintenance thread to stop */
    #####: 1345:    pthread_join(rebalance_tid, NULL);
    #####: 1346:}
------------------
stop_slab_maintenance_thread:
    #####: 1337:void stop_slab_maintenance_thread(void) {
    #####: 1338:    mutex_lock(&slabs_rebalance_lock);
    #####: 1339:    do_run_slab_thread = 0;
    #####: 1340:    do_run_slab_rebalance_thread = 0;
    #####: 1341:    pthread_cond_signal(&slab_rebalance_cond);
    #####: 1342:    pthread_mutex_unlock(&slabs_rebalance_lock);
        -: 1343:
        -: 1344:    /* Wait for the maintenance thread to stop */
    #####: 1345:    pthread_join(rebalance_tid, NULL);
    #####: 1346:}
------------------
