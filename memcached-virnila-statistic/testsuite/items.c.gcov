        -:    0:Source:items.c
        -:    0:Programs:72
        -:    0:Source is newer than graph
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:#include "memcached.h"
        -:    3:#include "bipbuffer.h"
        -:    4:#include "slab_automove.h"
        -:    5:#ifdef EXTSTORE
        -:    6:#include "storage.h"
        -:    7:#include "slab_automove_extstore.h"
        -:    8:#endif
        -:    9:#include <sys/stat.h>
        -:   10:#include <sys/socket.h>
        -:   11:#include <sys/resource.h>
        -:   12:#include <fcntl.h>
        -:   13:#include <netinet/in.h>
        -:   14:#include <errno.h>
        -:   15:#include <stdlib.h>
        -:   16:#include <stdio.h>
        -:   17:#include <signal.h>
        -:   18:#include <string.h>
        -:   19:#include <time.h>
        -:   20:#include <assert.h>
        -:   21:#include <unistd.h>
        -:   22:#include <poll.h>
        -:   23:
        -:   24:/* Forward Declarations */
        -:   25:static void item_link_q(item *it);
        -:   26:static void item_unlink_q(item *it);
        -:   27:
        -:   28:static unsigned int lru_type_map[4] = {HOT_LRU, WARM_LRU, COLD_LRU, TEMP_LRU};
        -:   29:
        -:   30:#define LARGEST_ID POWER_LARGEST
        -:   31:typedef struct {
        -:   32:    uint64_t evicted;
        -:   33:    uint64_t evicted_nonzero;
        -:   34:    uint64_t reclaimed;
        -:   35:    uint64_t outofmemory;
        -:   36:    uint64_t tailrepairs;
        -:   37:    uint64_t expired_unfetched; /* items reclaimed but never touched */
        -:   38:    uint64_t evicted_unfetched; /* items evicted but never touched */
        -:   39:    uint64_t evicted_active; /* items evicted that should have been shuffled */
        -:   40:    uint64_t crawler_reclaimed;
        -:   41:    uint64_t crawler_items_checked;
        -:   42:    uint64_t lrutail_reflocked;
        -:   43:    uint64_t moves_to_cold;
        -:   44:    uint64_t moves_to_warm;
        -:   45:    uint64_t moves_within_lru;
        -:   46:    uint64_t direct_reclaims;
        -:   47:    uint64_t hits_to_hot;
        -:   48:    uint64_t hits_to_warm;
        -:   49:    uint64_t hits_to_cold;
        -:   50:    uint64_t hits_to_temp;
        -:   51:    rel_time_t evicted_time;
        -:   52:} itemstats_t;
        -:   53:
        -:   54:static item *heads[LARGEST_ID];
        -:   55:static item *tails[LARGEST_ID];
        -:   56:static itemstats_t itemstats[LARGEST_ID];
        -:   57:static unsigned int sizes[LARGEST_ID];
        -:   58:static uint64_t sizes_bytes[LARGEST_ID];
        -:   59:static unsigned int *stats_sizes_hist = NULL;
        -:   60:static uint64_t stats_sizes_cas_min = 0;
        -:   61:static int stats_sizes_buckets = 0;
        -:   62:
        -:   63:static volatile int do_run_lru_maintainer_thread = 0;
        -:   64:static int lru_maintainer_initialized = 0;
        -:   65:static pthread_mutex_t lru_maintainer_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   66:static pthread_mutex_t cas_id_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   67:static pthread_mutex_t stats_sizes_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   68:
       12:   69:void item_stats_reset(void) {
       12:   70:    int i;
     3084:   71:    for (i = 0; i < LARGEST_ID; i++) {
     3072:   72:        pthread_mutex_lock(&lru_locks[i]);
     3072:   73:        memset(&itemstats[i], 0, sizeof(itemstats_t));
     3072:   74:        pthread_mutex_unlock(&lru_locks[i]);
        -:   75:    }
       12:   76:}
------------------
item_stats_reset:
        3:   69:void item_stats_reset(void) {
        3:   70:    int i;
      771:   71:    for (i = 0; i < LARGEST_ID; i++) {
      768:   72:        pthread_mutex_lock(&lru_locks[i]);
      768:   73:        memset(&itemstats[i], 0, sizeof(itemstats_t));
      768:   74:        pthread_mutex_unlock(&lru_locks[i]);
        -:   75:    }
        3:   76:}
------------------
item_stats_reset:
        3:   69:void item_stats_reset(void) {
        3:   70:    int i;
      771:   71:    for (i = 0; i < LARGEST_ID; i++) {
      768:   72:        pthread_mutex_lock(&lru_locks[i]);
      768:   73:        memset(&itemstats[i], 0, sizeof(itemstats_t));
      768:   74:        pthread_mutex_unlock(&lru_locks[i]);
        -:   75:    }
        3:   76:}
------------------
item_stats_reset:
        3:   69:void item_stats_reset(void) {
        3:   70:    int i;
      771:   71:    for (i = 0; i < LARGEST_ID; i++) {
      768:   72:        pthread_mutex_lock(&lru_locks[i]);
      768:   73:        memset(&itemstats[i], 0, sizeof(itemstats_t));
      768:   74:        pthread_mutex_unlock(&lru_locks[i]);
        -:   75:    }
        3:   76:}
------------------
item_stats_reset:
        3:   69:void item_stats_reset(void) {
        3:   70:    int i;
      771:   71:    for (i = 0; i < LARGEST_ID; i++) {
      768:   72:        pthread_mutex_lock(&lru_locks[i]);
      768:   73:        memset(&itemstats[i], 0, sizeof(itemstats_t));
      768:   74:        pthread_mutex_unlock(&lru_locks[i]);
        -:   75:    }
        3:   76:}
------------------
        -:   77:
        -:   78:/* called with class lru lock held */
    90812:   79:void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        -:   80:        const uint64_t unfetched, const uint64_t checked) {
    90812:   81:    itemstats[i].crawler_reclaimed += reclaimed;
    90812:   82:    itemstats[i].expired_unfetched += unfetched;
    90812:   83:    itemstats[i].crawler_items_checked += checked;
    90812:   84:}
------------------
do_item_stats_add_crawl:
    22703:   79:void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        -:   80:        const uint64_t unfetched, const uint64_t checked) {
    22703:   81:    itemstats[i].crawler_reclaimed += reclaimed;
    22703:   82:    itemstats[i].expired_unfetched += unfetched;
    22703:   83:    itemstats[i].crawler_items_checked += checked;
    22703:   84:}
------------------
do_item_stats_add_crawl:
    22703:   79:void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        -:   80:        const uint64_t unfetched, const uint64_t checked) {
    22703:   81:    itemstats[i].crawler_reclaimed += reclaimed;
    22703:   82:    itemstats[i].expired_unfetched += unfetched;
    22703:   83:    itemstats[i].crawler_items_checked += checked;
    22703:   84:}
------------------
do_item_stats_add_crawl:
    22703:   79:void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        -:   80:        const uint64_t unfetched, const uint64_t checked) {
    22703:   81:    itemstats[i].crawler_reclaimed += reclaimed;
    22703:   82:    itemstats[i].expired_unfetched += unfetched;
    22703:   83:    itemstats[i].crawler_items_checked += checked;
    22703:   84:}
------------------
do_item_stats_add_crawl:
    22703:   79:void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        -:   80:        const uint64_t unfetched, const uint64_t checked) {
    22703:   81:    itemstats[i].crawler_reclaimed += reclaimed;
    22703:   82:    itemstats[i].expired_unfetched += unfetched;
    22703:   83:    itemstats[i].crawler_items_checked += checked;
    22703:   84:}
------------------
        -:   85:
        -:   86:typedef struct _lru_bump_buf {
        -:   87:    struct _lru_bump_buf *prev;
        -:   88:    struct _lru_bump_buf *next;
        -:   89:    pthread_mutex_t mutex;
        -:   90:    bipbuf_t *buf;
        -:   91:    uint64_t dropped;
        -:   92:} lru_bump_buf;
        -:   93:
        -:   94:typedef struct {
        -:   95:    item *it;
        -:   96:    uint32_t hv;
        -:   97:} lru_bump_entry;
        -:   98:
        -:   99:static lru_bump_buf *bump_buf_head = NULL;
        -:  100:static lru_bump_buf *bump_buf_tail = NULL;
        -:  101:static pthread_mutex_t bump_buf_lock = PTHREAD_MUTEX_INITIALIZER;
        -:  102:/* TODO: tunable? Need bench results */
        -:  103:#define LRU_BUMP_BUF_SIZE 8192
        -:  104:
        -:  105:static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv);
        -:  106:static uint64_t lru_total_bumps_dropped(void);
        -:  107:
        -:  108:/* Get the next CAS id for a new item. */
        -:  109:/* TODO: refactor some atomics for this. */
   417380:  110:uint64_t get_cas_id(void) {
   417380:  111:    static uint64_t cas_id = 0;
   417380:  112:    pthread_mutex_lock(&cas_id_lock);
   417380:  113:    uint64_t next_id = ++cas_id;
   417380:  114:    pthread_mutex_unlock(&cas_id_lock);
   417380:  115:    return next_id;
        -:  116:}
------------------
get_cas_id:
   104345:  110:uint64_t get_cas_id(void) {
   104345:  111:    static uint64_t cas_id = 0;
   104345:  112:    pthread_mutex_lock(&cas_id_lock);
   104345:  113:    uint64_t next_id = ++cas_id;
   104345:  114:    pthread_mutex_unlock(&cas_id_lock);
   104345:  115:    return next_id;
        -:  116:}
------------------
get_cas_id:
   104345:  110:uint64_t get_cas_id(void) {
   104345:  111:    static uint64_t cas_id = 0;
   104345:  112:    pthread_mutex_lock(&cas_id_lock);
   104345:  113:    uint64_t next_id = ++cas_id;
   104345:  114:    pthread_mutex_unlock(&cas_id_lock);
   104345:  115:    return next_id;
        -:  116:}
------------------
get_cas_id:
   104345:  110:uint64_t get_cas_id(void) {
   104345:  111:    static uint64_t cas_id = 0;
   104345:  112:    pthread_mutex_lock(&cas_id_lock);
   104345:  113:    uint64_t next_id = ++cas_id;
   104345:  114:    pthread_mutex_unlock(&cas_id_lock);
   104345:  115:    return next_id;
        -:  116:}
------------------
get_cas_id:
   104345:  110:uint64_t get_cas_id(void) {
   104345:  111:    static uint64_t cas_id = 0;
   104345:  112:    pthread_mutex_lock(&cas_id_lock);
   104345:  113:    uint64_t next_id = ++cas_id;
   104345:  114:    pthread_mutex_unlock(&cas_id_lock);
   104345:  115:    return next_id;
        -:  116:}
------------------
        -:  117:
   762028:  118:int item_is_flushed(item *it) {
   762028:  119:    rel_time_t oldest_live = settings.oldest_live;
   762028:  120:    uint64_t cas = ITEM_get_cas(it);
   762028:  121:    uint64_t oldest_cas = settings.oldest_cas;
   762028:  122:    if (oldest_live == 0 || oldest_live > current_time)
        -:  123:        return 0;
   247084:  124:    if ((it->time <= oldest_live)
   219352:  125:            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
    28064:  126:        return 1;
        -:  127:    }
        -:  128:    return 0;
        -:  129:}
------------------
item_is_flushed:
   190507:  118:int item_is_flushed(item *it) {
   190507:  119:    rel_time_t oldest_live = settings.oldest_live;
   190507:  120:    uint64_t cas = ITEM_get_cas(it);
   190507:  121:    uint64_t oldest_cas = settings.oldest_cas;
   190507:  122:    if (oldest_live == 0 || oldest_live > current_time)
        -:  123:        return 0;
    61771:  124:    if ((it->time <= oldest_live)
    54838:  125:            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
     7016:  126:        return 1;
        -:  127:    }
        -:  128:    return 0;
        -:  129:}
------------------
item_is_flushed:
   190507:  118:int item_is_flushed(item *it) {
   190507:  119:    rel_time_t oldest_live = settings.oldest_live;
   190507:  120:    uint64_t cas = ITEM_get_cas(it);
   190507:  121:    uint64_t oldest_cas = settings.oldest_cas;
   190507:  122:    if (oldest_live == 0 || oldest_live > current_time)
        -:  123:        return 0;
    61771:  124:    if ((it->time <= oldest_live)
    54838:  125:            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
     7016:  126:        return 1;
        -:  127:    }
        -:  128:    return 0;
        -:  129:}
------------------
item_is_flushed:
   190507:  118:int item_is_flushed(item *it) {
   190507:  119:    rel_time_t oldest_live = settings.oldest_live;
   190507:  120:    uint64_t cas = ITEM_get_cas(it);
   190507:  121:    uint64_t oldest_cas = settings.oldest_cas;
   190507:  122:    if (oldest_live == 0 || oldest_live > current_time)
        -:  123:        return 0;
    61771:  124:    if ((it->time <= oldest_live)
    54838:  125:            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
     7016:  126:        return 1;
        -:  127:    }
        -:  128:    return 0;
        -:  129:}
------------------
item_is_flushed:
   190507:  118:int item_is_flushed(item *it) {
   190507:  119:    rel_time_t oldest_live = settings.oldest_live;
   190507:  120:    uint64_t cas = ITEM_get_cas(it);
   190507:  121:    uint64_t oldest_cas = settings.oldest_cas;
   190507:  122:    if (oldest_live == 0 || oldest_live > current_time)
        -:  123:        return 0;
    61771:  124:    if ((it->time <= oldest_live)
    54838:  125:            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
     7016:  126:        return 1;
        -:  127:    }
        -:  128:    return 0;
        -:  129:}
------------------
        -:  130:
        -:  131:static unsigned int temp_lru_size(int slabs_clsid) {
    11604:  132:    int id = CLEAR_LRU(slabs_clsid);
    11604:  133:    id |= TEMP_LRU;
    11604:  134:    unsigned int ret;
    11604:  135:    pthread_mutex_lock(&lru_locks[id]);
    11604:  136:    ret = sizes_bytes[id];
    11604:  137:    pthread_mutex_unlock(&lru_locks[id]);
    11604:  138:    return ret;
        -:  139:}
        -:  140:
        -:  141:/* must be locked before call */
     1020:  142:unsigned int do_get_lru_size(uint32_t id) {
     1020:  143:    return sizes[id];
        -:  144:}
------------------
do_get_lru_size:
      255:  142:unsigned int do_get_lru_size(uint32_t id) {
      255:  143:    return sizes[id];
        -:  144:}
------------------
do_get_lru_size:
      255:  142:unsigned int do_get_lru_size(uint32_t id) {
      255:  143:    return sizes[id];
        -:  144:}
------------------
do_get_lru_size:
      255:  142:unsigned int do_get_lru_size(uint32_t id) {
      255:  143:    return sizes[id];
        -:  144:}
------------------
do_get_lru_size:
      255:  142:unsigned int do_get_lru_size(uint32_t id) {
      255:  143:    return sizes[id];
        -:  144:}
------------------
        -:  145:
        -:  146:/* Enable this for reference-count debugging. */
        -:  147:#if 0
        -:  148:# define DEBUG_REFCNT(it,op) \
        -:  149:                fprintf(stderr, "item %x refcnt(%c) %d %c%c%c\n", \
        -:  150:                        it, op, it->refcount, \
        -:  151:                        (it->it_flags & ITEM_LINKED) ? 'L' : ' ', \
        -:  152:                        (it->it_flags & ITEM_SLABBED) ? 'S' : ' ')
        -:  153:#else
        -:  154:# define DEBUG_REFCNT(it,op) while(0)
        -:  155:#endif
        -:  156:
        -:  157:/**
        -:  158: * Generates the variable-sized part of the header for an object.
        -:  159: *
        -:  160: * key     - The key
        -:  161: * nkey    - The length of the key
        -:  162: * flags   - key flags
        -:  163: * nbytes  - Number of bytes to hold value and addition CRLF terminator
        -:  164: * suffix  - Buffer for the "VALUE" line suffix (flags, size).
        -:  165: * nsuffix - The length of the suffix is stored here.
        -:  166: *
        -:  167: * Returns the total size of the header.
        -:  168: */
        -:  169:static size_t item_make_header(const uint8_t nkey, const unsigned int flags, const int nbytes,
        -:  170:                     char *suffix, uint8_t *nsuffix) {
   476760:  171:    if (flags == 0) {
        -:  172:        *nsuffix = 0;
        -:  173:    } else {
    79564:  174:        *nsuffix = sizeof(flags);
        -:  175:    }
   476760:  176:    return sizeof(item) + nkey + *nsuffix + nbytes;
        -:  177:}
        -:  178:
  1021392:  179:item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
  1021392:  180:    item *it = NULL;
  1021392:  181:    int i;
        -:  182:    /* If no memory is available, attempt a direct LRU juggle/eviction */
        -:  183:    /* This is a race in order to simplify lru_pull_tail; in cases where
        -:  184:     * locked items are on the tail, you want them to fall out and cause
        -:  185:     * occasional OOM's, rather than internally work around them.
        -:  186:     * This also gives one fewer code path for slab alloc/free
        -:  187:     */
  1134504:  188:    for (i = 0; i < 10; i++) {
  1134484:  189:        uint64_t total_bytes;
        -:  190:        /* Try to reclaim memory first */
  1134484:  191:        if (!settings.lru_segmented) {
    83572:  192:            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        -:  193:        }
  1134484:  194:        it = slabs_alloc(ntotal, id, &total_bytes, 0);
        -:  195:
  1134484:  196:        if (settings.temp_lru)
     2040:  197:            total_bytes -= temp_lru_size(id);
        -:  198:
  1134484:  199:        if (it == NULL) {
   113112:  200:            if (lru_pull_tail(id, COLD_LRU, total_bytes, LRU_PULL_EVICT, 0, NULL) <= 0) {
    42920:  201:                if (settings.lru_segmented) {
    42920:  202:                    lru_pull_tail(id, HOT_LRU, total_bytes, 0, 0, NULL);
        -:  203:                } else {
        -:  204:                    break;
        -:  205:                }
        -:  206:            }
        -:  207:        } else {
        -:  208:            break;
        -:  209:        }
        -:  210:    }
        -:  211:
  1021392:  212:    if (i > 0) {
    70212:  213:        pthread_mutex_lock(&lru_locks[id]);
    70212:  214:        itemstats[id].direct_reclaims += i;
    70212:  215:        pthread_mutex_unlock(&lru_locks[id]);
        -:  216:    }
        -:  217:
  1021392:  218:    return it;
        -:  219:}
------------------
do_item_alloc_pull:
   255348:  179:item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
   255348:  180:    item *it = NULL;
   255348:  181:    int i;
        -:  182:    /* If no memory is available, attempt a direct LRU juggle/eviction */
        -:  183:    /* This is a race in order to simplify lru_pull_tail; in cases where
        -:  184:     * locked items are on the tail, you want them to fall out and cause
        -:  185:     * occasional OOM's, rather than internally work around them.
        -:  186:     * This also gives one fewer code path for slab alloc/free
        -:  187:     */
   283626:  188:    for (i = 0; i < 10; i++) {
   283621:  189:        uint64_t total_bytes;
        -:  190:        /* Try to reclaim memory first */
   283621:  191:        if (!settings.lru_segmented) {
    20893:  192:            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        -:  193:        }
   283621:  194:        it = slabs_alloc(ntotal, id, &total_bytes, 0);
        -:  195:
   283621:  196:        if (settings.temp_lru)
      510:  197:            total_bytes -= temp_lru_size(id);
        -:  198:
   283621:  199:        if (it == NULL) {
    28278:  200:            if (lru_pull_tail(id, COLD_LRU, total_bytes, LRU_PULL_EVICT, 0, NULL) <= 0) {
    10730:  201:                if (settings.lru_segmented) {
    10730:  202:                    lru_pull_tail(id, HOT_LRU, total_bytes, 0, 0, NULL);
        -:  203:                } else {
        -:  204:                    break;
        -:  205:                }
        -:  206:            }
        -:  207:        } else {
        -:  208:            break;
        -:  209:        }
        -:  210:    }
        -:  211:
   255348:  212:    if (i > 0) {
    17553:  213:        pthread_mutex_lock(&lru_locks[id]);
    17553:  214:        itemstats[id].direct_reclaims += i;
    17553:  215:        pthread_mutex_unlock(&lru_locks[id]);
        -:  216:    }
        -:  217:
   255348:  218:    return it;
        -:  219:}
------------------
do_item_alloc_pull:
   255348:  179:item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
   255348:  180:    item *it = NULL;
   255348:  181:    int i;
        -:  182:    /* If no memory is available, attempt a direct LRU juggle/eviction */
        -:  183:    /* This is a race in order to simplify lru_pull_tail; in cases where
        -:  184:     * locked items are on the tail, you want them to fall out and cause
        -:  185:     * occasional OOM's, rather than internally work around them.
        -:  186:     * This also gives one fewer code path for slab alloc/free
        -:  187:     */
   283626:  188:    for (i = 0; i < 10; i++) {
   283621:  189:        uint64_t total_bytes;
        -:  190:        /* Try to reclaim memory first */
   283621:  191:        if (!settings.lru_segmented) {
    20893:  192:            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        -:  193:        }
   283621:  194:        it = slabs_alloc(ntotal, id, &total_bytes, 0);
        -:  195:
   283621:  196:        if (settings.temp_lru)
      510:  197:            total_bytes -= temp_lru_size(id);
        -:  198:
   283621:  199:        if (it == NULL) {
    28278:  200:            if (lru_pull_tail(id, COLD_LRU, total_bytes, LRU_PULL_EVICT, 0, NULL) <= 0) {
    10730:  201:                if (settings.lru_segmented) {
    10730:  202:                    lru_pull_tail(id, HOT_LRU, total_bytes, 0, 0, NULL);
        -:  203:                } else {
        -:  204:                    break;
        -:  205:                }
        -:  206:            }
        -:  207:        } else {
        -:  208:            break;
        -:  209:        }
        -:  210:    }
        -:  211:
   255348:  212:    if (i > 0) {
    17553:  213:        pthread_mutex_lock(&lru_locks[id]);
    17553:  214:        itemstats[id].direct_reclaims += i;
    17553:  215:        pthread_mutex_unlock(&lru_locks[id]);
        -:  216:    }
        -:  217:
   255348:  218:    return it;
        -:  219:}
------------------
do_item_alloc_pull:
   255348:  179:item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
   255348:  180:    item *it = NULL;
   255348:  181:    int i;
        -:  182:    /* If no memory is available, attempt a direct LRU juggle/eviction */
        -:  183:    /* This is a race in order to simplify lru_pull_tail; in cases where
        -:  184:     * locked items are on the tail, you want them to fall out and cause
        -:  185:     * occasional OOM's, rather than internally work around them.
        -:  186:     * This also gives one fewer code path for slab alloc/free
        -:  187:     */
   283626:  188:    for (i = 0; i < 10; i++) {
   283621:  189:        uint64_t total_bytes;
        -:  190:        /* Try to reclaim memory first */
   283621:  191:        if (!settings.lru_segmented) {
    20893:  192:            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        -:  193:        }
   283621:  194:        it = slabs_alloc(ntotal, id, &total_bytes, 0);
        -:  195:
   283621:  196:        if (settings.temp_lru)
      510:  197:            total_bytes -= temp_lru_size(id);
        -:  198:
   283621:  199:        if (it == NULL) {
    28278:  200:            if (lru_pull_tail(id, COLD_LRU, total_bytes, LRU_PULL_EVICT, 0, NULL) <= 0) {
    10730:  201:                if (settings.lru_segmented) {
    10730:  202:                    lru_pull_tail(id, HOT_LRU, total_bytes, 0, 0, NULL);
        -:  203:                } else {
        -:  204:                    break;
        -:  205:                }
        -:  206:            }
        -:  207:        } else {
        -:  208:            break;
        -:  209:        }
        -:  210:    }
        -:  211:
   255348:  212:    if (i > 0) {
    17553:  213:        pthread_mutex_lock(&lru_locks[id]);
    17553:  214:        itemstats[id].direct_reclaims += i;
    17553:  215:        pthread_mutex_unlock(&lru_locks[id]);
        -:  216:    }
        -:  217:
   255348:  218:    return it;
        -:  219:}
------------------
do_item_alloc_pull:
   255348:  179:item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
   255348:  180:    item *it = NULL;
   255348:  181:    int i;
        -:  182:    /* If no memory is available, attempt a direct LRU juggle/eviction */
        -:  183:    /* This is a race in order to simplify lru_pull_tail; in cases where
        -:  184:     * locked items are on the tail, you want them to fall out and cause
        -:  185:     * occasional OOM's, rather than internally work around them.
        -:  186:     * This also gives one fewer code path for slab alloc/free
        -:  187:     */
   283626:  188:    for (i = 0; i < 10; i++) {
   283621:  189:        uint64_t total_bytes;
        -:  190:        /* Try to reclaim memory first */
   283621:  191:        if (!settings.lru_segmented) {
    20893:  192:            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        -:  193:        }
   283621:  194:        it = slabs_alloc(ntotal, id, &total_bytes, 0);
        -:  195:
   283621:  196:        if (settings.temp_lru)
      510:  197:            total_bytes -= temp_lru_size(id);
        -:  198:
   283621:  199:        if (it == NULL) {
    28278:  200:            if (lru_pull_tail(id, COLD_LRU, total_bytes, LRU_PULL_EVICT, 0, NULL) <= 0) {
    10730:  201:                if (settings.lru_segmented) {
    10730:  202:                    lru_pull_tail(id, HOT_LRU, total_bytes, 0, 0, NULL);
        -:  203:                } else {
        -:  204:                    break;
        -:  205:                }
        -:  206:            }
        -:  207:        } else {
        -:  208:            break;
        -:  209:        }
        -:  210:    }
        -:  211:
   255348:  212:    if (i > 0) {
    17553:  213:        pthread_mutex_lock(&lru_locks[id]);
    17553:  214:        itemstats[id].direct_reclaims += i;
    17553:  215:        pthread_mutex_unlock(&lru_locks[id]);
        -:  216:    }
        -:  217:
   255348:  218:    return it;
        -:  219:}
------------------
        -:  220:
        -:  221:/* Chain another chunk onto this chunk. */
        -:  222:/* slab mover: if it finds a chunk without ITEM_CHUNK flag, and no ITEM_LINKED
        -:  223: * flag, it counts as busy and skips.
        -:  224: * I think it might still not be safe to do linking outside of the slab lock
        -:  225: */
   544684:  226:item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
        -:  227:    // TODO: Should be a cleaner way of finding real size with slabber calls
   544684:  228:    size_t size = bytes_remain + sizeof(item_chunk);
   544684:  229:    if (size > settings.slab_chunk_size_max)
   303960:  230:        size = settings.slab_chunk_size_max;
   544684:  231:    unsigned int id = slabs_clsid(size);
        -:  232:
   544684:  233:    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
   544684:  234:    if (nch == NULL)
        -:  235:        return NULL;
        -:  236:
        -:  237:    // link in.
        -:  238:    // ITEM_CHUNK[ED] bits need to be protected by the slabs lock.
   544684:  239:    slabs_mlock();
   544684:  240:    nch->head = ch->head;
   544684:  241:    ch->next = nch;
   544684:  242:    nch->prev = ch;
   544684:  243:    nch->next = 0;
   544684:  244:    nch->used = 0;
   544684:  245:    nch->slabs_clsid = id;
   544684:  246:    nch->size = size - sizeof(item_chunk);
   544684:  247:    nch->it_flags |= ITEM_CHUNK;
   544684:  248:    slabs_munlock();
   544684:  249:    return nch;
        -:  250:}
------------------
do_item_alloc_chunk:
   136171:  226:item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
        -:  227:    // TODO: Should be a cleaner way of finding real size with slabber calls
   136171:  228:    size_t size = bytes_remain + sizeof(item_chunk);
   136171:  229:    if (size > settings.slab_chunk_size_max)
    75990:  230:        size = settings.slab_chunk_size_max;
   136171:  231:    unsigned int id = slabs_clsid(size);
        -:  232:
   136171:  233:    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
   136171:  234:    if (nch == NULL)
        -:  235:        return NULL;
        -:  236:
        -:  237:    // link in.
        -:  238:    // ITEM_CHUNK[ED] bits need to be protected by the slabs lock.
   136171:  239:    slabs_mlock();
   136171:  240:    nch->head = ch->head;
   136171:  241:    ch->next = nch;
   136171:  242:    nch->prev = ch;
   136171:  243:    nch->next = 0;
   136171:  244:    nch->used = 0;
   136171:  245:    nch->slabs_clsid = id;
   136171:  246:    nch->size = size - sizeof(item_chunk);
   136171:  247:    nch->it_flags |= ITEM_CHUNK;
   136171:  248:    slabs_munlock();
   136171:  249:    return nch;
        -:  250:}
------------------
do_item_alloc_chunk:
   136171:  226:item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
        -:  227:    // TODO: Should be a cleaner way of finding real size with slabber calls
   136171:  228:    size_t size = bytes_remain + sizeof(item_chunk);
   136171:  229:    if (size > settings.slab_chunk_size_max)
    75990:  230:        size = settings.slab_chunk_size_max;
   136171:  231:    unsigned int id = slabs_clsid(size);
        -:  232:
   136171:  233:    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
   136171:  234:    if (nch == NULL)
        -:  235:        return NULL;
        -:  236:
        -:  237:    // link in.
        -:  238:    // ITEM_CHUNK[ED] bits need to be protected by the slabs lock.
   136171:  239:    slabs_mlock();
   136171:  240:    nch->head = ch->head;
   136171:  241:    ch->next = nch;
   136171:  242:    nch->prev = ch;
   136171:  243:    nch->next = 0;
   136171:  244:    nch->used = 0;
   136171:  245:    nch->slabs_clsid = id;
   136171:  246:    nch->size = size - sizeof(item_chunk);
   136171:  247:    nch->it_flags |= ITEM_CHUNK;
   136171:  248:    slabs_munlock();
   136171:  249:    return nch;
        -:  250:}
------------------
do_item_alloc_chunk:
   136171:  226:item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
        -:  227:    // TODO: Should be a cleaner way of finding real size with slabber calls
   136171:  228:    size_t size = bytes_remain + sizeof(item_chunk);
   136171:  229:    if (size > settings.slab_chunk_size_max)
    75990:  230:        size = settings.slab_chunk_size_max;
   136171:  231:    unsigned int id = slabs_clsid(size);
        -:  232:
   136171:  233:    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
   136171:  234:    if (nch == NULL)
        -:  235:        return NULL;
        -:  236:
        -:  237:    // link in.
        -:  238:    // ITEM_CHUNK[ED] bits need to be protected by the slabs lock.
   136171:  239:    slabs_mlock();
   136171:  240:    nch->head = ch->head;
   136171:  241:    ch->next = nch;
   136171:  242:    nch->prev = ch;
   136171:  243:    nch->next = 0;
   136171:  244:    nch->used = 0;
   136171:  245:    nch->slabs_clsid = id;
   136171:  246:    nch->size = size - sizeof(item_chunk);
   136171:  247:    nch->it_flags |= ITEM_CHUNK;
   136171:  248:    slabs_munlock();
   136171:  249:    return nch;
        -:  250:}
------------------
do_item_alloc_chunk:
   136171:  226:item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
        -:  227:    // TODO: Should be a cleaner way of finding real size with slabber calls
   136171:  228:    size_t size = bytes_remain + sizeof(item_chunk);
   136171:  229:    if (size > settings.slab_chunk_size_max)
    75990:  230:        size = settings.slab_chunk_size_max;
   136171:  231:    unsigned int id = slabs_clsid(size);
        -:  232:
   136171:  233:    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
   136171:  234:    if (nch == NULL)
        -:  235:        return NULL;
        -:  236:
        -:  237:    // link in.
        -:  238:    // ITEM_CHUNK[ED] bits need to be protected by the slabs lock.
   136171:  239:    slabs_mlock();
   136171:  240:    nch->head = ch->head;
   136171:  241:    ch->next = nch;
   136171:  242:    nch->prev = ch;
   136171:  243:    nch->next = 0;
   136171:  244:    nch->used = 0;
   136171:  245:    nch->slabs_clsid = id;
   136171:  246:    nch->size = size - sizeof(item_chunk);
   136171:  247:    nch->it_flags |= ITEM_CHUNK;
   136171:  248:    slabs_munlock();
   136171:  249:    return nch;
        -:  250:}
------------------
        -:  251:
   476728:  252:item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
        -:  253:                    const rel_time_t exptime, const int nbytes) {
   476728:  254:    uint8_t nsuffix;
   476728:  255:    item *it = NULL;
   476728:  256:    char suffix[40];
        -:  257:    // Avoid potential underflows.
   476728:  258:    if (nbytes < 2)
        -:  259:        return 0;
        -:  260:
   476724:  261:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
   476724:  262:    if (settings.use_cas) {
   476720:  263:        ntotal += sizeof(uint64_t);
        -:  264:    }
        -:  265:
   476724:  266:    unsigned int id = slabs_clsid(ntotal);
   476724:  267:    unsigned int hdr_id = 0;
   476724:  268:    if (id == 0)
        -:  269:        return 0;
        -:  270:
        -:  271:    /* This is a large item. Allocate a header object now, lazily allocate
        -:  272:     *  chunks while reading the upload.
        -:  273:     */
   476708:  274:    if (ntotal > settings.slab_chunk_size_max) {
        -:  275:        /* We still link this item into the LRU for the larger slab class, but
        -:  276:         * we're pulling a header from an entirely different slab class. The
        -:  277:         * free routines handle large items specifically.
        -:  278:         */
    78532:  279:        int htotal = nkey + 1 + nsuffix + sizeof(item) + sizeof(item_chunk);
    78532:  280:        if (settings.use_cas) {
    78532:  281:            htotal += sizeof(uint64_t);
        -:  282:        }
        -:  283:#ifdef NEED_ALIGN
        -:  284:        // header chunk needs to be padded on some systems
        -:  285:        int remain = htotal % 8;
        -:  286:        if (remain != 0) {
        -:  287:            htotal += 8 - remain;
        -:  288:        }
        -:  289:#endif
    78532:  290:        hdr_id = slabs_clsid(htotal);
    78532:  291:        it = do_item_alloc_pull(htotal, hdr_id);
        -:  292:        /* setting ITEM_CHUNKED is fine here because we aren't LINKED yet. */
    78532:  293:        if (it != NULL)
    78532:  294:            it->it_flags |= ITEM_CHUNKED;
        -:  295:    } else {
   398176:  296:        it = do_item_alloc_pull(ntotal, id);
        -:  297:    }
        -:  298:
   476708:  299:    if (it == NULL) {
       20:  300:        pthread_mutex_lock(&lru_locks[id]);
       20:  301:        itemstats[id].outofmemory++;
       20:  302:        pthread_mutex_unlock(&lru_locks[id]);
       20:  303:        return NULL;
        -:  304:    }
        -:  305:
  476688*:  306:    assert(it->slabs_clsid == 0);
        -:  307:    //assert(it != heads[id]);
        -:  308:
        -:  309:    /* Refcount is seeded to 1 by slabs_alloc() */
   476688:  310:    it->next = it->prev = 0;
        -:  311:
        -:  312:    /* Items are initially loaded into the HOT_LRU. This is '0' but I want at
        -:  313:     * least a note here. Compiler (hopefully?) optimizes this out.
        -:  314:     */
   476688:  315:    if (settings.temp_lru &&
      404:  316:            exptime - current_time <= settings.temporary_ttl) {
        4:  317:        id |= TEMP_LRU;
   476684:  318:    } else if (settings.lru_segmented) {
        -:  319:        id |= HOT_LRU;
        -:  320:    } else {
        -:  321:        /* There is only COLD in compat-mode */
    81780:  322:        id |= COLD_LRU;
        -:  323:    }
   476688:  324:    it->slabs_clsid = id;
        -:  325:
   476688:  326:    DEBUG_REFCNT(it, '*');
   476688:  327:    it->it_flags |= settings.use_cas ? ITEM_CAS : 0;
   476688:  328:    it->it_flags |= nsuffix != 0 ? ITEM_CFLAGS : 0;
   476688:  329:    it->nkey = nkey;
   476688:  330:    it->nbytes = nbytes;
   476688:  331:    memcpy(ITEM_key(it), key, nkey);
   476688:  332:    it->exptime = exptime;
   476688:  333:    if (nsuffix > 0) {
    79556:  334:        memcpy(ITEM_suffix(it), &flags, sizeof(flags));
        -:  335:    }
        -:  336:
        -:  337:    /* Initialize internal chunk. */
   476688:  338:    if (it->it_flags & ITEM_CHUNKED) {
    78532:  339:        item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
        -:  340:
    78532:  341:        chunk->next = 0;
    78532:  342:        chunk->prev = 0;
    78532:  343:        chunk->used = 0;
    78532:  344:        chunk->size = 0;
    78532:  345:        chunk->head = it;
    78532:  346:        chunk->orig_clsid = hdr_id;
        -:  347:    }
   476688:  348:    it->h_next = 0;
        -:  349:
   476688:  350:    return it;
        -:  351:}
------------------
do_item_alloc:
   119182:  252:item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
        -:  253:                    const rel_time_t exptime, const int nbytes) {
   119182:  254:    uint8_t nsuffix;
   119182:  255:    item *it = NULL;
   119182:  256:    char suffix[40];
        -:  257:    // Avoid potential underflows.
   119182:  258:    if (nbytes < 2)
        -:  259:        return 0;
        -:  260:
   119181:  261:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
   119181:  262:    if (settings.use_cas) {
   119180:  263:        ntotal += sizeof(uint64_t);
        -:  264:    }
        -:  265:
   119181:  266:    unsigned int id = slabs_clsid(ntotal);
   119181:  267:    unsigned int hdr_id = 0;
   119181:  268:    if (id == 0)
        -:  269:        return 0;
        -:  270:
        -:  271:    /* This is a large item. Allocate a header object now, lazily allocate
        -:  272:     *  chunks while reading the upload.
        -:  273:     */
   119177:  274:    if (ntotal > settings.slab_chunk_size_max) {
        -:  275:        /* We still link this item into the LRU for the larger slab class, but
        -:  276:         * we're pulling a header from an entirely different slab class. The
        -:  277:         * free routines handle large items specifically.
        -:  278:         */
    19633:  279:        int htotal = nkey + 1 + nsuffix + sizeof(item) + sizeof(item_chunk);
    19633:  280:        if (settings.use_cas) {
    19633:  281:            htotal += sizeof(uint64_t);
        -:  282:        }
        -:  283:#ifdef NEED_ALIGN
        -:  284:        // header chunk needs to be padded on some systems
        -:  285:        int remain = htotal % 8;
        -:  286:        if (remain != 0) {
        -:  287:            htotal += 8 - remain;
        -:  288:        }
        -:  289:#endif
    19633:  290:        hdr_id = slabs_clsid(htotal);
    19633:  291:        it = do_item_alloc_pull(htotal, hdr_id);
        -:  292:        /* setting ITEM_CHUNKED is fine here because we aren't LINKED yet. */
    19633:  293:        if (it != NULL)
    19633:  294:            it->it_flags |= ITEM_CHUNKED;
        -:  295:    } else {
    99544:  296:        it = do_item_alloc_pull(ntotal, id);
        -:  297:    }
        -:  298:
   119177:  299:    if (it == NULL) {
        5:  300:        pthread_mutex_lock(&lru_locks[id]);
        5:  301:        itemstats[id].outofmemory++;
        5:  302:        pthread_mutex_unlock(&lru_locks[id]);
        5:  303:        return NULL;
        -:  304:    }
        -:  305:
  119172*:  306:    assert(it->slabs_clsid == 0);
        -:  307:    //assert(it != heads[id]);
        -:  308:
        -:  309:    /* Refcount is seeded to 1 by slabs_alloc() */
   119172:  310:    it->next = it->prev = 0;
        -:  311:
        -:  312:    /* Items are initially loaded into the HOT_LRU. This is '0' but I want at
        -:  313:     * least a note here. Compiler (hopefully?) optimizes this out.
        -:  314:     */
   119172:  315:    if (settings.temp_lru &&
      101:  316:            exptime - current_time <= settings.temporary_ttl) {
        1:  317:        id |= TEMP_LRU;
   119171:  318:    } else if (settings.lru_segmented) {
        -:  319:        id |= HOT_LRU;
        -:  320:    } else {
        -:  321:        /* There is only COLD in compat-mode */
    20445:  322:        id |= COLD_LRU;
        -:  323:    }
   119172:  324:    it->slabs_clsid = id;
        -:  325:
   119172:  326:    DEBUG_REFCNT(it, '*');
   119172:  327:    it->it_flags |= settings.use_cas ? ITEM_CAS : 0;
   119172:  328:    it->it_flags |= nsuffix != 0 ? ITEM_CFLAGS : 0;
   119172:  329:    it->nkey = nkey;
   119172:  330:    it->nbytes = nbytes;
   119172:  331:    memcpy(ITEM_key(it), key, nkey);
   119172:  332:    it->exptime = exptime;
   119172:  333:    if (nsuffix > 0) {
    19889:  334:        memcpy(ITEM_suffix(it), &flags, sizeof(flags));
        -:  335:    }
        -:  336:
        -:  337:    /* Initialize internal chunk. */
   119172:  338:    if (it->it_flags & ITEM_CHUNKED) {
    19633:  339:        item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
        -:  340:
    19633:  341:        chunk->next = 0;
    19633:  342:        chunk->prev = 0;
    19633:  343:        chunk->used = 0;
    19633:  344:        chunk->size = 0;
    19633:  345:        chunk->head = it;
    19633:  346:        chunk->orig_clsid = hdr_id;
        -:  347:    }
   119172:  348:    it->h_next = 0;
        -:  349:
   119172:  350:    return it;
        -:  351:}
------------------
do_item_alloc:
   119182:  252:item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
        -:  253:                    const rel_time_t exptime, const int nbytes) {
   119182:  254:    uint8_t nsuffix;
   119182:  255:    item *it = NULL;
   119182:  256:    char suffix[40];
        -:  257:    // Avoid potential underflows.
   119182:  258:    if (nbytes < 2)
        -:  259:        return 0;
        -:  260:
   119181:  261:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
   119181:  262:    if (settings.use_cas) {
   119180:  263:        ntotal += sizeof(uint64_t);
        -:  264:    }
        -:  265:
   119181:  266:    unsigned int id = slabs_clsid(ntotal);
   119181:  267:    unsigned int hdr_id = 0;
   119181:  268:    if (id == 0)
        -:  269:        return 0;
        -:  270:
        -:  271:    /* This is a large item. Allocate a header object now, lazily allocate
        -:  272:     *  chunks while reading the upload.
        -:  273:     */
   119177:  274:    if (ntotal > settings.slab_chunk_size_max) {
        -:  275:        /* We still link this item into the LRU for the larger slab class, but
        -:  276:         * we're pulling a header from an entirely different slab class. The
        -:  277:         * free routines handle large items specifically.
        -:  278:         */
    19633:  279:        int htotal = nkey + 1 + nsuffix + sizeof(item) + sizeof(item_chunk);
    19633:  280:        if (settings.use_cas) {
    19633:  281:            htotal += sizeof(uint64_t);
        -:  282:        }
        -:  283:#ifdef NEED_ALIGN
        -:  284:        // header chunk needs to be padded on some systems
        -:  285:        int remain = htotal % 8;
        -:  286:        if (remain != 0) {
        -:  287:            htotal += 8 - remain;
        -:  288:        }
        -:  289:#endif
    19633:  290:        hdr_id = slabs_clsid(htotal);
    19633:  291:        it = do_item_alloc_pull(htotal, hdr_id);
        -:  292:        /* setting ITEM_CHUNKED is fine here because we aren't LINKED yet. */
    19633:  293:        if (it != NULL)
    19633:  294:            it->it_flags |= ITEM_CHUNKED;
        -:  295:    } else {
    99544:  296:        it = do_item_alloc_pull(ntotal, id);
        -:  297:    }
        -:  298:
   119177:  299:    if (it == NULL) {
        5:  300:        pthread_mutex_lock(&lru_locks[id]);
        5:  301:        itemstats[id].outofmemory++;
        5:  302:        pthread_mutex_unlock(&lru_locks[id]);
        5:  303:        return NULL;
        -:  304:    }
        -:  305:
  119172*:  306:    assert(it->slabs_clsid == 0);
        -:  307:    //assert(it != heads[id]);
        -:  308:
        -:  309:    /* Refcount is seeded to 1 by slabs_alloc() */
   119172:  310:    it->next = it->prev = 0;
        -:  311:
        -:  312:    /* Items are initially loaded into the HOT_LRU. This is '0' but I want at
        -:  313:     * least a note here. Compiler (hopefully?) optimizes this out.
        -:  314:     */
   119172:  315:    if (settings.temp_lru &&
      101:  316:            exptime - current_time <= settings.temporary_ttl) {
        1:  317:        id |= TEMP_LRU;
   119171:  318:    } else if (settings.lru_segmented) {
        -:  319:        id |= HOT_LRU;
        -:  320:    } else {
        -:  321:        /* There is only COLD in compat-mode */
    20445:  322:        id |= COLD_LRU;
        -:  323:    }
   119172:  324:    it->slabs_clsid = id;
        -:  325:
   119172:  326:    DEBUG_REFCNT(it, '*');
   119172:  327:    it->it_flags |= settings.use_cas ? ITEM_CAS : 0;
   119172:  328:    it->it_flags |= nsuffix != 0 ? ITEM_CFLAGS : 0;
   119172:  329:    it->nkey = nkey;
   119172:  330:    it->nbytes = nbytes;
   119172:  331:    memcpy(ITEM_key(it), key, nkey);
   119172:  332:    it->exptime = exptime;
   119172:  333:    if (nsuffix > 0) {
    19889:  334:        memcpy(ITEM_suffix(it), &flags, sizeof(flags));
        -:  335:    }
        -:  336:
        -:  337:    /* Initialize internal chunk. */
   119172:  338:    if (it->it_flags & ITEM_CHUNKED) {
    19633:  339:        item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
        -:  340:
    19633:  341:        chunk->next = 0;
    19633:  342:        chunk->prev = 0;
    19633:  343:        chunk->used = 0;
    19633:  344:        chunk->size = 0;
    19633:  345:        chunk->head = it;
    19633:  346:        chunk->orig_clsid = hdr_id;
        -:  347:    }
   119172:  348:    it->h_next = 0;
        -:  349:
   119172:  350:    return it;
        -:  351:}
------------------
do_item_alloc:
   119182:  252:item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
        -:  253:                    const rel_time_t exptime, const int nbytes) {
   119182:  254:    uint8_t nsuffix;
   119182:  255:    item *it = NULL;
   119182:  256:    char suffix[40];
        -:  257:    // Avoid potential underflows.
   119182:  258:    if (nbytes < 2)
        -:  259:        return 0;
        -:  260:
   119181:  261:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
   119181:  262:    if (settings.use_cas) {
   119180:  263:        ntotal += sizeof(uint64_t);
        -:  264:    }
        -:  265:
   119181:  266:    unsigned int id = slabs_clsid(ntotal);
   119181:  267:    unsigned int hdr_id = 0;
   119181:  268:    if (id == 0)
        -:  269:        return 0;
        -:  270:
        -:  271:    /* This is a large item. Allocate a header object now, lazily allocate
        -:  272:     *  chunks while reading the upload.
        -:  273:     */
   119177:  274:    if (ntotal > settings.slab_chunk_size_max) {
        -:  275:        /* We still link this item into the LRU for the larger slab class, but
        -:  276:         * we're pulling a header from an entirely different slab class. The
        -:  277:         * free routines handle large items specifically.
        -:  278:         */
    19633:  279:        int htotal = nkey + 1 + nsuffix + sizeof(item) + sizeof(item_chunk);
    19633:  280:        if (settings.use_cas) {
    19633:  281:            htotal += sizeof(uint64_t);
        -:  282:        }
        -:  283:#ifdef NEED_ALIGN
        -:  284:        // header chunk needs to be padded on some systems
        -:  285:        int remain = htotal % 8;
        -:  286:        if (remain != 0) {
        -:  287:            htotal += 8 - remain;
        -:  288:        }
        -:  289:#endif
    19633:  290:        hdr_id = slabs_clsid(htotal);
    19633:  291:        it = do_item_alloc_pull(htotal, hdr_id);
        -:  292:        /* setting ITEM_CHUNKED is fine here because we aren't LINKED yet. */
    19633:  293:        if (it != NULL)
    19633:  294:            it->it_flags |= ITEM_CHUNKED;
        -:  295:    } else {
    99544:  296:        it = do_item_alloc_pull(ntotal, id);
        -:  297:    }
        -:  298:
   119177:  299:    if (it == NULL) {
        5:  300:        pthread_mutex_lock(&lru_locks[id]);
        5:  301:        itemstats[id].outofmemory++;
        5:  302:        pthread_mutex_unlock(&lru_locks[id]);
        5:  303:        return NULL;
        -:  304:    }
        -:  305:
  119172*:  306:    assert(it->slabs_clsid == 0);
        -:  307:    //assert(it != heads[id]);
        -:  308:
        -:  309:    /* Refcount is seeded to 1 by slabs_alloc() */
   119172:  310:    it->next = it->prev = 0;
        -:  311:
        -:  312:    /* Items are initially loaded into the HOT_LRU. This is '0' but I want at
        -:  313:     * least a note here. Compiler (hopefully?) optimizes this out.
        -:  314:     */
   119172:  315:    if (settings.temp_lru &&
      101:  316:            exptime - current_time <= settings.temporary_ttl) {
        1:  317:        id |= TEMP_LRU;
   119171:  318:    } else if (settings.lru_segmented) {
        -:  319:        id |= HOT_LRU;
        -:  320:    } else {
        -:  321:        /* There is only COLD in compat-mode */
    20445:  322:        id |= COLD_LRU;
        -:  323:    }
   119172:  324:    it->slabs_clsid = id;
        -:  325:
   119172:  326:    DEBUG_REFCNT(it, '*');
   119172:  327:    it->it_flags |= settings.use_cas ? ITEM_CAS : 0;
   119172:  328:    it->it_flags |= nsuffix != 0 ? ITEM_CFLAGS : 0;
   119172:  329:    it->nkey = nkey;
   119172:  330:    it->nbytes = nbytes;
   119172:  331:    memcpy(ITEM_key(it), key, nkey);
   119172:  332:    it->exptime = exptime;
   119172:  333:    if (nsuffix > 0) {
    19889:  334:        memcpy(ITEM_suffix(it), &flags, sizeof(flags));
        -:  335:    }
        -:  336:
        -:  337:    /* Initialize internal chunk. */
   119172:  338:    if (it->it_flags & ITEM_CHUNKED) {
    19633:  339:        item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
        -:  340:
    19633:  341:        chunk->next = 0;
    19633:  342:        chunk->prev = 0;
    19633:  343:        chunk->used = 0;
    19633:  344:        chunk->size = 0;
    19633:  345:        chunk->head = it;
    19633:  346:        chunk->orig_clsid = hdr_id;
        -:  347:    }
   119172:  348:    it->h_next = 0;
        -:  349:
   119172:  350:    return it;
        -:  351:}
------------------
do_item_alloc:
   119182:  252:item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
        -:  253:                    const rel_time_t exptime, const int nbytes) {
   119182:  254:    uint8_t nsuffix;
   119182:  255:    item *it = NULL;
   119182:  256:    char suffix[40];
        -:  257:    // Avoid potential underflows.
   119182:  258:    if (nbytes < 2)
        -:  259:        return 0;
        -:  260:
   119181:  261:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
   119181:  262:    if (settings.use_cas) {
   119180:  263:        ntotal += sizeof(uint64_t);
        -:  264:    }
        -:  265:
   119181:  266:    unsigned int id = slabs_clsid(ntotal);
   119181:  267:    unsigned int hdr_id = 0;
   119181:  268:    if (id == 0)
        -:  269:        return 0;
        -:  270:
        -:  271:    /* This is a large item. Allocate a header object now, lazily allocate
        -:  272:     *  chunks while reading the upload.
        -:  273:     */
   119177:  274:    if (ntotal > settings.slab_chunk_size_max) {
        -:  275:        /* We still link this item into the LRU for the larger slab class, but
        -:  276:         * we're pulling a header from an entirely different slab class. The
        -:  277:         * free routines handle large items specifically.
        -:  278:         */
    19633:  279:        int htotal = nkey + 1 + nsuffix + sizeof(item) + sizeof(item_chunk);
    19633:  280:        if (settings.use_cas) {
    19633:  281:            htotal += sizeof(uint64_t);
        -:  282:        }
        -:  283:#ifdef NEED_ALIGN
        -:  284:        // header chunk needs to be padded on some systems
        -:  285:        int remain = htotal % 8;
        -:  286:        if (remain != 0) {
        -:  287:            htotal += 8 - remain;
        -:  288:        }
        -:  289:#endif
    19633:  290:        hdr_id = slabs_clsid(htotal);
    19633:  291:        it = do_item_alloc_pull(htotal, hdr_id);
        -:  292:        /* setting ITEM_CHUNKED is fine here because we aren't LINKED yet. */
    19633:  293:        if (it != NULL)
    19633:  294:            it->it_flags |= ITEM_CHUNKED;
        -:  295:    } else {
    99544:  296:        it = do_item_alloc_pull(ntotal, id);
        -:  297:    }
        -:  298:
   119177:  299:    if (it == NULL) {
        5:  300:        pthread_mutex_lock(&lru_locks[id]);
        5:  301:        itemstats[id].outofmemory++;
        5:  302:        pthread_mutex_unlock(&lru_locks[id]);
        5:  303:        return NULL;
        -:  304:    }
        -:  305:
  119172*:  306:    assert(it->slabs_clsid == 0);
        -:  307:    //assert(it != heads[id]);
        -:  308:
        -:  309:    /* Refcount is seeded to 1 by slabs_alloc() */
   119172:  310:    it->next = it->prev = 0;
        -:  311:
        -:  312:    /* Items are initially loaded into the HOT_LRU. This is '0' but I want at
        -:  313:     * least a note here. Compiler (hopefully?) optimizes this out.
        -:  314:     */
   119172:  315:    if (settings.temp_lru &&
      101:  316:            exptime - current_time <= settings.temporary_ttl) {
        1:  317:        id |= TEMP_LRU;
   119171:  318:    } else if (settings.lru_segmented) {
        -:  319:        id |= HOT_LRU;
        -:  320:    } else {
        -:  321:        /* There is only COLD in compat-mode */
    20445:  322:        id |= COLD_LRU;
        -:  323:    }
   119172:  324:    it->slabs_clsid = id;
        -:  325:
   119172:  326:    DEBUG_REFCNT(it, '*');
   119172:  327:    it->it_flags |= settings.use_cas ? ITEM_CAS : 0;
   119172:  328:    it->it_flags |= nsuffix != 0 ? ITEM_CFLAGS : 0;
   119172:  329:    it->nkey = nkey;
   119172:  330:    it->nbytes = nbytes;
   119172:  331:    memcpy(ITEM_key(it), key, nkey);
   119172:  332:    it->exptime = exptime;
   119172:  333:    if (nsuffix > 0) {
    19889:  334:        memcpy(ITEM_suffix(it), &flags, sizeof(flags));
        -:  335:    }
        -:  336:
        -:  337:    /* Initialize internal chunk. */
   119172:  338:    if (it->it_flags & ITEM_CHUNKED) {
    19633:  339:        item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
        -:  340:
    19633:  341:        chunk->next = 0;
    19633:  342:        chunk->prev = 0;
    19633:  343:        chunk->used = 0;
    19633:  344:        chunk->size = 0;
    19633:  345:        chunk->head = it;
    19633:  346:        chunk->orig_clsid = hdr_id;
        -:  347:    }
   119172:  348:    it->h_next = 0;
        -:  349:
   119172:  350:    return it;
        -:  351:}
------------------
        -:  352:
   317712:  353:void item_free(item *it) {
   317712:  354:    size_t ntotal = ITEM_ntotal(it);
   317712:  355:    unsigned int clsid;
  317712*:  356:    assert((it->it_flags & ITEM_LINKED) == 0);
  317712*:  357:    assert(it != heads[it->slabs_clsid]);
  317712*:  358:    assert(it != tails[it->slabs_clsid]);
  317712*:  359:    assert(it->refcount == 0);
        -:  360:
        -:  361:    /* so slab size changer can tell later if item is already free or not */
   317712:  362:    clsid = ITEM_clsid(it);
   317712:  363:    DEBUG_REFCNT(it, 'F');
   317712:  364:    slabs_free(it, ntotal, clsid);
   317712:  365:}
------------------
item_free:
    79428:  353:void item_free(item *it) {
    79428:  354:    size_t ntotal = ITEM_ntotal(it);
    79428:  355:    unsigned int clsid;
   79428*:  356:    assert((it->it_flags & ITEM_LINKED) == 0);
   79428*:  357:    assert(it != heads[it->slabs_clsid]);
   79428*:  358:    assert(it != tails[it->slabs_clsid]);
   79428*:  359:    assert(it->refcount == 0);
        -:  360:
        -:  361:    /* so slab size changer can tell later if item is already free or not */
    79428:  362:    clsid = ITEM_clsid(it);
    79428:  363:    DEBUG_REFCNT(it, 'F');
    79428:  364:    slabs_free(it, ntotal, clsid);
    79428:  365:}
------------------
item_free:
    79428:  353:void item_free(item *it) {
    79428:  354:    size_t ntotal = ITEM_ntotal(it);
    79428:  355:    unsigned int clsid;
   79428*:  356:    assert((it->it_flags & ITEM_LINKED) == 0);
   79428*:  357:    assert(it != heads[it->slabs_clsid]);
   79428*:  358:    assert(it != tails[it->slabs_clsid]);
   79428*:  359:    assert(it->refcount == 0);
        -:  360:
        -:  361:    /* so slab size changer can tell later if item is already free or not */
    79428:  362:    clsid = ITEM_clsid(it);
    79428:  363:    DEBUG_REFCNT(it, 'F');
    79428:  364:    slabs_free(it, ntotal, clsid);
    79428:  365:}
------------------
item_free:
    79428:  353:void item_free(item *it) {
    79428:  354:    size_t ntotal = ITEM_ntotal(it);
    79428:  355:    unsigned int clsid;
   79428*:  356:    assert((it->it_flags & ITEM_LINKED) == 0);
   79428*:  357:    assert(it != heads[it->slabs_clsid]);
   79428*:  358:    assert(it != tails[it->slabs_clsid]);
   79428*:  359:    assert(it->refcount == 0);
        -:  360:
        -:  361:    /* so slab size changer can tell later if item is already free or not */
    79428:  362:    clsid = ITEM_clsid(it);
    79428:  363:    DEBUG_REFCNT(it, 'F');
    79428:  364:    slabs_free(it, ntotal, clsid);
    79428:  365:}
------------------
item_free:
    79428:  353:void item_free(item *it) {
    79428:  354:    size_t ntotal = ITEM_ntotal(it);
    79428:  355:    unsigned int clsid;
   79428*:  356:    assert((it->it_flags & ITEM_LINKED) == 0);
   79428*:  357:    assert(it != heads[it->slabs_clsid]);
   79428*:  358:    assert(it != tails[it->slabs_clsid]);
   79428*:  359:    assert(it->refcount == 0);
        -:  360:
        -:  361:    /* so slab size changer can tell later if item is already free or not */
    79428:  362:    clsid = ITEM_clsid(it);
    79428:  363:    DEBUG_REFCNT(it, 'F');
    79428:  364:    slabs_free(it, ntotal, clsid);
    79428:  365:}
------------------
        -:  366:
        -:  367:/**
        -:  368: * Returns true if an item will fit in the cache (its size does not exceed
        -:  369: * the maximum for a cache entry.)
        -:  370: */
       40:  371:bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
       40:  372:    char prefix[40];
       40:  373:    uint8_t nsuffix;
       40:  374:    if (nbytes < 2)
        -:  375:        return false;
        -:  376:
       36:  377:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
        -:  378:                                     prefix, &nsuffix);
       36:  379:    if (settings.use_cas) {
       36:  380:        ntotal += sizeof(uint64_t);
        -:  381:    }
        -:  382:
       36:  383:    return slabs_clsid(ntotal) != 0;
        -:  384:}
------------------
item_size_ok:
       10:  371:bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
       10:  372:    char prefix[40];
       10:  373:    uint8_t nsuffix;
       10:  374:    if (nbytes < 2)
        -:  375:        return false;
        -:  376:
        9:  377:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
        -:  378:                                     prefix, &nsuffix);
        9:  379:    if (settings.use_cas) {
        9:  380:        ntotal += sizeof(uint64_t);
        -:  381:    }
        -:  382:
        9:  383:    return slabs_clsid(ntotal) != 0;
        -:  384:}
------------------
item_size_ok:
       10:  371:bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
       10:  372:    char prefix[40];
       10:  373:    uint8_t nsuffix;
       10:  374:    if (nbytes < 2)
        -:  375:        return false;
        -:  376:
        9:  377:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
        -:  378:                                     prefix, &nsuffix);
        9:  379:    if (settings.use_cas) {
        9:  380:        ntotal += sizeof(uint64_t);
        -:  381:    }
        -:  382:
        9:  383:    return slabs_clsid(ntotal) != 0;
        -:  384:}
------------------
item_size_ok:
       10:  371:bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
       10:  372:    char prefix[40];
       10:  373:    uint8_t nsuffix;
       10:  374:    if (nbytes < 2)
        -:  375:        return false;
        -:  376:
        9:  377:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
        -:  378:                                     prefix, &nsuffix);
        9:  379:    if (settings.use_cas) {
        9:  380:        ntotal += sizeof(uint64_t);
        -:  381:    }
        -:  382:
        9:  383:    return slabs_clsid(ntotal) != 0;
        -:  384:}
------------------
item_size_ok:
       10:  371:bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
       10:  372:    char prefix[40];
       10:  373:    uint8_t nsuffix;
       10:  374:    if (nbytes < 2)
        -:  375:        return false;
        -:  376:
        9:  377:    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
        -:  378:                                     prefix, &nsuffix);
        9:  379:    if (settings.use_cas) {
        9:  380:        ntotal += sizeof(uint64_t);
        -:  381:    }
        -:  382:
        9:  383:    return slabs_clsid(ntotal) != 0;
        -:  384:}
------------------
        -:  385:
   572280:  386:static void do_item_link_q(item *it) { /* item is the new head */
   572280:  387:    item **head, **tail;
  572280*:  388:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  389:
   572280:  390:    head = &heads[it->slabs_clsid];
   572280:  391:    tail = &tails[it->slabs_clsid];
  572280*:  392:    assert(it != *head);
  572280*:  393:    assert((*head && *tail) || (*head == 0 && *tail == 0));
   572280:  394:    it->prev = 0;
   572280:  395:    it->next = *head;
   572280:  396:    if (it->next) it->next->prev = it;
   572280:  397:    *head = it;
   572280:  398:    if (*tail == 0) *tail = it;
   572280:  399:    sizes[it->slabs_clsid]++;
        -:  400:#ifdef EXTSTORE
        -:  401:    if (it->it_flags & ITEM_HDR) {
        -:  402:        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  403:    } else {
        -:  404:        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  405:    }
        -:  406:#else
   572280:  407:    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  408:#endif
        -:  409:
   572280:  410:    return;
        -:  411:}
------------------
do_item_link_q:
   143070:  386:static void do_item_link_q(item *it) { /* item is the new head */
   143070:  387:    item **head, **tail;
  143070*:  388:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  389:
   143070:  390:    head = &heads[it->slabs_clsid];
   143070:  391:    tail = &tails[it->slabs_clsid];
  143070*:  392:    assert(it != *head);
  143070*:  393:    assert((*head && *tail) || (*head == 0 && *tail == 0));
   143070:  394:    it->prev = 0;
   143070:  395:    it->next = *head;
   143070:  396:    if (it->next) it->next->prev = it;
   143070:  397:    *head = it;
   143070:  398:    if (*tail == 0) *tail = it;
   143070:  399:    sizes[it->slabs_clsid]++;
        -:  400:#ifdef EXTSTORE
        -:  401:    if (it->it_flags & ITEM_HDR) {
        -:  402:        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  403:    } else {
        -:  404:        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  405:    }
        -:  406:#else
   143070:  407:    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  408:#endif
        -:  409:
   143070:  410:    return;
        -:  411:}
------------------
do_item_link_q:
   143070:  386:static void do_item_link_q(item *it) { /* item is the new head */
   143070:  387:    item **head, **tail;
  143070*:  388:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  389:
   143070:  390:    head = &heads[it->slabs_clsid];
   143070:  391:    tail = &tails[it->slabs_clsid];
  143070*:  392:    assert(it != *head);
  143070*:  393:    assert((*head && *tail) || (*head == 0 && *tail == 0));
   143070:  394:    it->prev = 0;
   143070:  395:    it->next = *head;
   143070:  396:    if (it->next) it->next->prev = it;
   143070:  397:    *head = it;
   143070:  398:    if (*tail == 0) *tail = it;
   143070:  399:    sizes[it->slabs_clsid]++;
        -:  400:#ifdef EXTSTORE
        -:  401:    if (it->it_flags & ITEM_HDR) {
        -:  402:        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  403:    } else {
        -:  404:        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  405:    }
        -:  406:#else
   143070:  407:    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  408:#endif
        -:  409:
   143070:  410:    return;
        -:  411:}
------------------
do_item_link_q:
   143070:  386:static void do_item_link_q(item *it) { /* item is the new head */
   143070:  387:    item **head, **tail;
  143070*:  388:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  389:
   143070:  390:    head = &heads[it->slabs_clsid];
   143070:  391:    tail = &tails[it->slabs_clsid];
  143070*:  392:    assert(it != *head);
  143070*:  393:    assert((*head && *tail) || (*head == 0 && *tail == 0));
   143070:  394:    it->prev = 0;
   143070:  395:    it->next = *head;
   143070:  396:    if (it->next) it->next->prev = it;
   143070:  397:    *head = it;
   143070:  398:    if (*tail == 0) *tail = it;
   143070:  399:    sizes[it->slabs_clsid]++;
        -:  400:#ifdef EXTSTORE
        -:  401:    if (it->it_flags & ITEM_HDR) {
        -:  402:        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  403:    } else {
        -:  404:        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  405:    }
        -:  406:#else
   143070:  407:    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  408:#endif
        -:  409:
   143070:  410:    return;
        -:  411:}
------------------
do_item_link_q:
   143070:  386:static void do_item_link_q(item *it) { /* item is the new head */
   143070:  387:    item **head, **tail;
  143070*:  388:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  389:
   143070:  390:    head = &heads[it->slabs_clsid];
   143070:  391:    tail = &tails[it->slabs_clsid];
  143070*:  392:    assert(it != *head);
  143070*:  393:    assert((*head && *tail) || (*head == 0 && *tail == 0));
   143070:  394:    it->prev = 0;
   143070:  395:    it->next = *head;
   143070:  396:    if (it->next) it->next->prev = it;
   143070:  397:    *head = it;
   143070:  398:    if (*tail == 0) *tail = it;
   143070:  399:    sizes[it->slabs_clsid]++;
        -:  400:#ifdef EXTSTORE
        -:  401:    if (it->it_flags & ITEM_HDR) {
        -:  402:        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  403:    } else {
        -:  404:        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  405:    }
        -:  406:#else
   143070:  407:    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
        -:  408:#endif
        -:  409:
   143070:  410:    return;
        -:  411:}
------------------
        -:  412:
   572276:  413:static void item_link_q(item *it) {
   572276:  414:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
   572276:  415:    do_item_link_q(it);
   572276:  416:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
   572276:  417:}
------------------
item_link_q:
   143069:  413:static void item_link_q(item *it) {
   143069:  414:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
   143069:  415:    do_item_link_q(it);
   143069:  416:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
   143069:  417:}
------------------
item_link_q:
   143069:  413:static void item_link_q(item *it) {
   143069:  414:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
   143069:  415:    do_item_link_q(it);
   143069:  416:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
   143069:  417:}
------------------
item_link_q:
   143069:  413:static void item_link_q(item *it) {
   143069:  414:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
   143069:  415:    do_item_link_q(it);
   143069:  416:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
   143069:  417:}
------------------
item_link_q:
   143069:  413:static void item_link_q(item *it) {
   143069:  414:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
   143069:  415:    do_item_link_q(it);
   143069:  416:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
   143069:  417:}
------------------
        -:  418:
        4:  419:static void item_link_q_warm(item *it) {
        4:  420:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
        4:  421:    do_item_link_q(it);
        4:  422:    itemstats[it->slabs_clsid].moves_to_warm++;
        4:  423:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
        4:  424:}
------------------
item_link_q_warm:
        1:  419:static void item_link_q_warm(item *it) {
        1:  420:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
        1:  421:    do_item_link_q(it);
        1:  422:    itemstats[it->slabs_clsid].moves_to_warm++;
        1:  423:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
        1:  424:}
------------------
item_link_q_warm:
        1:  419:static void item_link_q_warm(item *it) {
        1:  420:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
        1:  421:    do_item_link_q(it);
        1:  422:    itemstats[it->slabs_clsid].moves_to_warm++;
        1:  423:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
        1:  424:}
------------------
item_link_q_warm:
        1:  419:static void item_link_q_warm(item *it) {
        1:  420:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
        1:  421:    do_item_link_q(it);
        1:  422:    itemstats[it->slabs_clsid].moves_to_warm++;
        1:  423:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
        1:  424:}
------------------
item_link_q_warm:
        1:  419:static void item_link_q_warm(item *it) {
        1:  420:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
        1:  421:    do_item_link_q(it);
        1:  422:    itemstats[it->slabs_clsid].moves_to_warm++;
        1:  423:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
        1:  424:}
------------------
        -:  425:
   414992:  426:static void do_item_unlink_q(item *it) {
   414992:  427:    item **head, **tail;
   414992:  428:    head = &heads[it->slabs_clsid];
   414992:  429:    tail = &tails[it->slabs_clsid];
        -:  430:
   414992:  431:    if (*head == it) {
  188680*:  432:        assert(it->prev == 0);
   188680:  433:        *head = it->next;
        -:  434:    }
   414992:  435:    if (*tail == it) {
  304544*:  436:        assert(it->next == 0);
   304544:  437:        *tail = it->prev;
        -:  438:    }
  414992*:  439:    assert(it->next != it);
  414992*:  440:    assert(it->prev != it);
        -:  441:
   414992:  442:    if (it->next) it->next->prev = it->prev;
   414992:  443:    if (it->prev) it->prev->next = it->next;
   414992:  444:    sizes[it->slabs_clsid]--;
        -:  445:#ifdef EXTSTORE
        -:  446:    if (it->it_flags & ITEM_HDR) {
        -:  447:        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  448:    } else {
        -:  449:        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  450:    }
        -:  451:#else
   414992:  452:    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  453:#endif
        -:  454:
   414992:  455:    return;
        -:  456:}
------------------
do_item_unlink_q:
   103748:  426:static void do_item_unlink_q(item *it) {
   103748:  427:    item **head, **tail;
   103748:  428:    head = &heads[it->slabs_clsid];
   103748:  429:    tail = &tails[it->slabs_clsid];
        -:  430:
   103748:  431:    if (*head == it) {
   47170*:  432:        assert(it->prev == 0);
    47170:  433:        *head = it->next;
        -:  434:    }
   103748:  435:    if (*tail == it) {
   76136*:  436:        assert(it->next == 0);
    76136:  437:        *tail = it->prev;
        -:  438:    }
  103748*:  439:    assert(it->next != it);
  103748*:  440:    assert(it->prev != it);
        -:  441:
   103748:  442:    if (it->next) it->next->prev = it->prev;
   103748:  443:    if (it->prev) it->prev->next = it->next;
   103748:  444:    sizes[it->slabs_clsid]--;
        -:  445:#ifdef EXTSTORE
        -:  446:    if (it->it_flags & ITEM_HDR) {
        -:  447:        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  448:    } else {
        -:  449:        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  450:    }
        -:  451:#else
   103748:  452:    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  453:#endif
        -:  454:
   103748:  455:    return;
        -:  456:}
------------------
do_item_unlink_q:
   103748:  426:static void do_item_unlink_q(item *it) {
   103748:  427:    item **head, **tail;
   103748:  428:    head = &heads[it->slabs_clsid];
   103748:  429:    tail = &tails[it->slabs_clsid];
        -:  430:
   103748:  431:    if (*head == it) {
   47170*:  432:        assert(it->prev == 0);
    47170:  433:        *head = it->next;
        -:  434:    }
   103748:  435:    if (*tail == it) {
   76136*:  436:        assert(it->next == 0);
    76136:  437:        *tail = it->prev;
        -:  438:    }
  103748*:  439:    assert(it->next != it);
  103748*:  440:    assert(it->prev != it);
        -:  441:
   103748:  442:    if (it->next) it->next->prev = it->prev;
   103748:  443:    if (it->prev) it->prev->next = it->next;
   103748:  444:    sizes[it->slabs_clsid]--;
        -:  445:#ifdef EXTSTORE
        -:  446:    if (it->it_flags & ITEM_HDR) {
        -:  447:        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  448:    } else {
        -:  449:        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  450:    }
        -:  451:#else
   103748:  452:    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  453:#endif
        -:  454:
   103748:  455:    return;
        -:  456:}
------------------
do_item_unlink_q:
   103748:  426:static void do_item_unlink_q(item *it) {
   103748:  427:    item **head, **tail;
   103748:  428:    head = &heads[it->slabs_clsid];
   103748:  429:    tail = &tails[it->slabs_clsid];
        -:  430:
   103748:  431:    if (*head == it) {
   47170*:  432:        assert(it->prev == 0);
    47170:  433:        *head = it->next;
        -:  434:    }
   103748:  435:    if (*tail == it) {
   76136*:  436:        assert(it->next == 0);
    76136:  437:        *tail = it->prev;
        -:  438:    }
  103748*:  439:    assert(it->next != it);
  103748*:  440:    assert(it->prev != it);
        -:  441:
   103748:  442:    if (it->next) it->next->prev = it->prev;
   103748:  443:    if (it->prev) it->prev->next = it->next;
   103748:  444:    sizes[it->slabs_clsid]--;
        -:  445:#ifdef EXTSTORE
        -:  446:    if (it->it_flags & ITEM_HDR) {
        -:  447:        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  448:    } else {
        -:  449:        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  450:    }
        -:  451:#else
   103748:  452:    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  453:#endif
        -:  454:
   103748:  455:    return;
        -:  456:}
------------------
do_item_unlink_q:
   103748:  426:static void do_item_unlink_q(item *it) {
   103748:  427:    item **head, **tail;
   103748:  428:    head = &heads[it->slabs_clsid];
   103748:  429:    tail = &tails[it->slabs_clsid];
        -:  430:
   103748:  431:    if (*head == it) {
   47170*:  432:        assert(it->prev == 0);
    47170:  433:        *head = it->next;
        -:  434:    }
   103748:  435:    if (*tail == it) {
   76136*:  436:        assert(it->next == 0);
    76136:  437:        *tail = it->prev;
        -:  438:    }
  103748*:  439:    assert(it->next != it);
  103748*:  440:    assert(it->prev != it);
        -:  441:
   103748:  442:    if (it->next) it->next->prev = it->prev;
   103748:  443:    if (it->prev) it->prev->next = it->next;
   103748:  444:    sizes[it->slabs_clsid]--;
        -:  445:#ifdef EXTSTORE
        -:  446:    if (it->it_flags & ITEM_HDR) {
        -:  447:        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
        -:  448:    } else {
        -:  449:        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  450:    }
        -:  451:#else
   103748:  452:    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
        -:  453:#endif
        -:  454:
   103748:  455:    return;
        -:  456:}
------------------
        -:  457:
   161308:  458:static void item_unlink_q(item *it) {
   161308:  459:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
   161308:  460:    do_item_unlink_q(it);
   161308:  461:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
   161308:  462:}
------------------
item_unlink_q:
    40327:  458:static void item_unlink_q(item *it) {
    40327:  459:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    40327:  460:    do_item_unlink_q(it);
    40327:  461:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
    40327:  462:}
------------------
item_unlink_q:
    40327:  458:static void item_unlink_q(item *it) {
    40327:  459:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    40327:  460:    do_item_unlink_q(it);
    40327:  461:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
    40327:  462:}
------------------
item_unlink_q:
    40327:  458:static void item_unlink_q(item *it) {
    40327:  459:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    40327:  460:    do_item_unlink_q(it);
    40327:  461:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
    40327:  462:}
------------------
item_unlink_q:
    40327:  458:static void item_unlink_q(item *it) {
    40327:  459:    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    40327:  460:    do_item_unlink_q(it);
    40327:  461:    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
    40327:  462:}
------------------
        -:  463:
   416916:  464:int do_item_link(item *it, const uint32_t hv) {
   416916:  465:    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
  416916*:  466:    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
   416916:  467:    it->it_flags |= ITEM_LINKED;
   416916:  468:    it->time = current_time;
        -:  469:
   416916:  470:    STATS_LOCK();
   416916:  471:    stats_state.curr_bytes += ITEM_ntotal(it);
   416916:  472:    stats_state.curr_items += 1;
   416916:  473:    stats.total_items += 1;
   416916:  474:    STATS_UNLOCK();
        -:  475:
        -:  476:    /* Allocate a new CAS ID on link. */
   416916:  477:    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
   416916:  478:    assoc_insert(it, hv);
   416916:  479:    item_link_q(it);
   416916:  480:    refcount_incr(it);
   416916:  481:    item_stats_sizes_add(it);
        -:  482:
   416916:  483:    return 1;
        -:  484:}
------------------
do_item_link:
   104229:  464:int do_item_link(item *it, const uint32_t hv) {
   104229:  465:    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
  104229*:  466:    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
   104229:  467:    it->it_flags |= ITEM_LINKED;
   104229:  468:    it->time = current_time;
        -:  469:
   104229:  470:    STATS_LOCK();
   104229:  471:    stats_state.curr_bytes += ITEM_ntotal(it);
   104229:  472:    stats_state.curr_items += 1;
   104229:  473:    stats.total_items += 1;
   104229:  474:    STATS_UNLOCK();
        -:  475:
        -:  476:    /* Allocate a new CAS ID on link. */
   104229:  477:    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
   104229:  478:    assoc_insert(it, hv);
   104229:  479:    item_link_q(it);
   104229:  480:    refcount_incr(it);
   104229:  481:    item_stats_sizes_add(it);
        -:  482:
   104229:  483:    return 1;
        -:  484:}
------------------
do_item_link:
   104229:  464:int do_item_link(item *it, const uint32_t hv) {
   104229:  465:    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
  104229*:  466:    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
   104229:  467:    it->it_flags |= ITEM_LINKED;
   104229:  468:    it->time = current_time;
        -:  469:
   104229:  470:    STATS_LOCK();
   104229:  471:    stats_state.curr_bytes += ITEM_ntotal(it);
   104229:  472:    stats_state.curr_items += 1;
   104229:  473:    stats.total_items += 1;
   104229:  474:    STATS_UNLOCK();
        -:  475:
        -:  476:    /* Allocate a new CAS ID on link. */
   104229:  477:    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
   104229:  478:    assoc_insert(it, hv);
   104229:  479:    item_link_q(it);
   104229:  480:    refcount_incr(it);
   104229:  481:    item_stats_sizes_add(it);
        -:  482:
   104229:  483:    return 1;
        -:  484:}
------------------
do_item_link:
   104229:  464:int do_item_link(item *it, const uint32_t hv) {
   104229:  465:    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
  104229*:  466:    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
   104229:  467:    it->it_flags |= ITEM_LINKED;
   104229:  468:    it->time = current_time;
        -:  469:
   104229:  470:    STATS_LOCK();
   104229:  471:    stats_state.curr_bytes += ITEM_ntotal(it);
   104229:  472:    stats_state.curr_items += 1;
   104229:  473:    stats.total_items += 1;
   104229:  474:    STATS_UNLOCK();
        -:  475:
        -:  476:    /* Allocate a new CAS ID on link. */
   104229:  477:    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
   104229:  478:    assoc_insert(it, hv);
   104229:  479:    item_link_q(it);
   104229:  480:    refcount_incr(it);
   104229:  481:    item_stats_sizes_add(it);
        -:  482:
   104229:  483:    return 1;
        -:  484:}
------------------
do_item_link:
   104229:  464:int do_item_link(item *it, const uint32_t hv) {
   104229:  465:    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
  104229*:  466:    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
   104229:  467:    it->it_flags |= ITEM_LINKED;
   104229:  468:    it->time = current_time;
        -:  469:
   104229:  470:    STATS_LOCK();
   104229:  471:    stats_state.curr_bytes += ITEM_ntotal(it);
   104229:  472:    stats_state.curr_items += 1;
   104229:  473:    stats.total_items += 1;
   104229:  474:    STATS_UNLOCK();
        -:  475:
        -:  476:    /* Allocate a new CAS ID on link. */
   104229:  477:    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
   104229:  478:    assoc_insert(it, hv);
   104229:  479:    item_link_q(it);
   104229:  480:    refcount_incr(it);
   104229:  481:    item_stats_sizes_add(it);
        -:  482:
   104229:  483:    return 1;
        -:  484:}
------------------
        -:  485:
   161304:  486:void do_item_unlink(item *it, const uint32_t hv) {
   161304:  487:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
   161304:  488:    if ((it->it_flags & ITEM_LINKED) != 0) {
   161304:  489:        it->it_flags &= ~ITEM_LINKED;
   161304:  490:        STATS_LOCK();
   161304:  491:        stats_state.curr_bytes -= ITEM_ntotal(it);
   161304:  492:        stats_state.curr_items -= 1;
   161304:  493:        STATS_UNLOCK();
   161304:  494:        item_stats_sizes_remove(it);
   161304:  495:        assoc_delete(ITEM_key(it), it->nkey, hv);
   161304:  496:        item_unlink_q(it);
   161304:  497:        do_item_remove(it);
        -:  498:    }
   161304:  499:}
------------------
do_item_unlink:
    40326:  486:void do_item_unlink(item *it, const uint32_t hv) {
    40326:  487:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    40326:  488:    if ((it->it_flags & ITEM_LINKED) != 0) {
    40326:  489:        it->it_flags &= ~ITEM_LINKED;
    40326:  490:        STATS_LOCK();
    40326:  491:        stats_state.curr_bytes -= ITEM_ntotal(it);
    40326:  492:        stats_state.curr_items -= 1;
    40326:  493:        STATS_UNLOCK();
    40326:  494:        item_stats_sizes_remove(it);
    40326:  495:        assoc_delete(ITEM_key(it), it->nkey, hv);
    40326:  496:        item_unlink_q(it);
    40326:  497:        do_item_remove(it);
        -:  498:    }
    40326:  499:}
------------------
do_item_unlink:
    40326:  486:void do_item_unlink(item *it, const uint32_t hv) {
    40326:  487:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    40326:  488:    if ((it->it_flags & ITEM_LINKED) != 0) {
    40326:  489:        it->it_flags &= ~ITEM_LINKED;
    40326:  490:        STATS_LOCK();
    40326:  491:        stats_state.curr_bytes -= ITEM_ntotal(it);
    40326:  492:        stats_state.curr_items -= 1;
    40326:  493:        STATS_UNLOCK();
    40326:  494:        item_stats_sizes_remove(it);
    40326:  495:        assoc_delete(ITEM_key(it), it->nkey, hv);
    40326:  496:        item_unlink_q(it);
    40326:  497:        do_item_remove(it);
        -:  498:    }
    40326:  499:}
------------------
do_item_unlink:
    40326:  486:void do_item_unlink(item *it, const uint32_t hv) {
    40326:  487:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    40326:  488:    if ((it->it_flags & ITEM_LINKED) != 0) {
    40326:  489:        it->it_flags &= ~ITEM_LINKED;
    40326:  490:        STATS_LOCK();
    40326:  491:        stats_state.curr_bytes -= ITEM_ntotal(it);
    40326:  492:        stats_state.curr_items -= 1;
    40326:  493:        STATS_UNLOCK();
    40326:  494:        item_stats_sizes_remove(it);
    40326:  495:        assoc_delete(ITEM_key(it), it->nkey, hv);
    40326:  496:        item_unlink_q(it);
    40326:  497:        do_item_remove(it);
        -:  498:    }
    40326:  499:}
------------------
do_item_unlink:
    40326:  486:void do_item_unlink(item *it, const uint32_t hv) {
    40326:  487:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    40326:  488:    if ((it->it_flags & ITEM_LINKED) != 0) {
    40326:  489:        it->it_flags &= ~ITEM_LINKED;
    40326:  490:        STATS_LOCK();
    40326:  491:        stats_state.curr_bytes -= ITEM_ntotal(it);
    40326:  492:        stats_state.curr_items -= 1;
    40326:  493:        STATS_UNLOCK();
    40326:  494:        item_stats_sizes_remove(it);
    40326:  495:        assoc_delete(ITEM_key(it), it->nkey, hv);
    40326:  496:        item_unlink_q(it);
    40326:  497:        do_item_remove(it);
        -:  498:    }
    40326:  499:}
------------------
        -:  500:
        -:  501:/* FIXME: Is it necessary to keep this copy/pasted code? */
    98324:  502:void do_item_unlink_nolock(item *it, const uint32_t hv) {
    98324:  503:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    98324:  504:    if ((it->it_flags & ITEM_LINKED) != 0) {
    98324:  505:        it->it_flags &= ~ITEM_LINKED;
    98324:  506:        STATS_LOCK();
    98324:  507:        stats_state.curr_bytes -= ITEM_ntotal(it);
    98324:  508:        stats_state.curr_items -= 1;
    98324:  509:        STATS_UNLOCK();
    98324:  510:        item_stats_sizes_remove(it);
    98324:  511:        assoc_delete(ITEM_key(it), it->nkey, hv);
    98324:  512:        do_item_unlink_q(it);
    98324:  513:        do_item_remove(it);
        -:  514:    }
    98324:  515:}
------------------
do_item_unlink_nolock:
    24581:  502:void do_item_unlink_nolock(item *it, const uint32_t hv) {
    24581:  503:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    24581:  504:    if ((it->it_flags & ITEM_LINKED) != 0) {
    24581:  505:        it->it_flags &= ~ITEM_LINKED;
    24581:  506:        STATS_LOCK();
    24581:  507:        stats_state.curr_bytes -= ITEM_ntotal(it);
    24581:  508:        stats_state.curr_items -= 1;
    24581:  509:        STATS_UNLOCK();
    24581:  510:        item_stats_sizes_remove(it);
    24581:  511:        assoc_delete(ITEM_key(it), it->nkey, hv);
    24581:  512:        do_item_unlink_q(it);
    24581:  513:        do_item_remove(it);
        -:  514:    }
    24581:  515:}
------------------
do_item_unlink_nolock:
    24581:  502:void do_item_unlink_nolock(item *it, const uint32_t hv) {
    24581:  503:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    24581:  504:    if ((it->it_flags & ITEM_LINKED) != 0) {
    24581:  505:        it->it_flags &= ~ITEM_LINKED;
    24581:  506:        STATS_LOCK();
    24581:  507:        stats_state.curr_bytes -= ITEM_ntotal(it);
    24581:  508:        stats_state.curr_items -= 1;
    24581:  509:        STATS_UNLOCK();
    24581:  510:        item_stats_sizes_remove(it);
    24581:  511:        assoc_delete(ITEM_key(it), it->nkey, hv);
    24581:  512:        do_item_unlink_q(it);
    24581:  513:        do_item_remove(it);
        -:  514:    }
    24581:  515:}
------------------
do_item_unlink_nolock:
    24581:  502:void do_item_unlink_nolock(item *it, const uint32_t hv) {
    24581:  503:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    24581:  504:    if ((it->it_flags & ITEM_LINKED) != 0) {
    24581:  505:        it->it_flags &= ~ITEM_LINKED;
    24581:  506:        STATS_LOCK();
    24581:  507:        stats_state.curr_bytes -= ITEM_ntotal(it);
    24581:  508:        stats_state.curr_items -= 1;
    24581:  509:        STATS_UNLOCK();
    24581:  510:        item_stats_sizes_remove(it);
    24581:  511:        assoc_delete(ITEM_key(it), it->nkey, hv);
    24581:  512:        do_item_unlink_q(it);
    24581:  513:        do_item_remove(it);
        -:  514:    }
    24581:  515:}
------------------
do_item_unlink_nolock:
    24581:  502:void do_item_unlink_nolock(item *it, const uint32_t hv) {
    24581:  503:    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    24581:  504:    if ((it->it_flags & ITEM_LINKED) != 0) {
    24581:  505:        it->it_flags &= ~ITEM_LINKED;
    24581:  506:        STATS_LOCK();
    24581:  507:        stats_state.curr_bytes -= ITEM_ntotal(it);
    24581:  508:        stats_state.curr_items -= 1;
    24581:  509:        STATS_UNLOCK();
    24581:  510:        item_stats_sizes_remove(it);
    24581:  511:        assoc_delete(ITEM_key(it), it->nkey, hv);
    24581:  512:        do_item_unlink_q(it);
    24581:  513:        do_item_remove(it);
        -:  514:    }
    24581:  515:}
------------------
        -:  516:
  1490844:  517:void do_item_remove(item *it) {
  1490844:  518:    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
 1490844*:  519:    assert((it->it_flags & ITEM_SLABBED) == 0);
 1490844*:  520:    assert(it->refcount > 0);
        -:  521:
  1490844:  522:    if (refcount_decr(it) == 0) {
   317712:  523:        item_free(it);
        -:  524:    }
  1490844:  525:}
------------------
do_item_remove:
   372711:  517:void do_item_remove(item *it) {
   372711:  518:    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
  372711*:  519:    assert((it->it_flags & ITEM_SLABBED) == 0);
  372711*:  520:    assert(it->refcount > 0);
        -:  521:
   372711:  522:    if (refcount_decr(it) == 0) {
    79428:  523:        item_free(it);
        -:  524:    }
   372711:  525:}
------------------
do_item_remove:
   372711:  517:void do_item_remove(item *it) {
   372711:  518:    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
  372711*:  519:    assert((it->it_flags & ITEM_SLABBED) == 0);
  372711*:  520:    assert(it->refcount > 0);
        -:  521:
   372711:  522:    if (refcount_decr(it) == 0) {
    79428:  523:        item_free(it);
        -:  524:    }
   372711:  525:}
------------------
do_item_remove:
   372711:  517:void do_item_remove(item *it) {
   372711:  518:    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
  372711*:  519:    assert((it->it_flags & ITEM_SLABBED) == 0);
  372711*:  520:    assert(it->refcount > 0);
        -:  521:
   372711:  522:    if (refcount_decr(it) == 0) {
    79428:  523:        item_free(it);
        -:  524:    }
   372711:  525:}
------------------
do_item_remove:
   372711:  517:void do_item_remove(item *it) {
   372711:  518:    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
  372711*:  519:    assert((it->it_flags & ITEM_SLABBED) == 0);
  372711*:  520:    assert(it->refcount > 0);
        -:  521:
   372711:  522:    if (refcount_decr(it) == 0) {
    79428:  523:        item_free(it);
        -:  524:    }
   372711:  525:}
------------------
        -:  526:
        -:  527:/* Copy/paste to avoid adding two extra branches for all common calls, since
        -:  528: * _nolock is only used in an uncommon case where we want to relink. */
    #####:  529:void do_item_update_nolock(item *it) {
    #####:  530:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
    #####:  531:    if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  532:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  533:
    #####:  534:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  535:            do_item_unlink_q(it);
    #####:  536:            it->time = current_time;
    #####:  537:            do_item_link_q(it);
        -:  538:        }
        -:  539:    }
    #####:  540:}
------------------
do_item_update_nolock:
    #####:  529:void do_item_update_nolock(item *it) {
    #####:  530:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
    #####:  531:    if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  532:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  533:
    #####:  534:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  535:            do_item_unlink_q(it);
    #####:  536:            it->time = current_time;
    #####:  537:            do_item_link_q(it);
        -:  538:        }
        -:  539:    }
    #####:  540:}
------------------
do_item_update_nolock:
    #####:  529:void do_item_update_nolock(item *it) {
    #####:  530:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
    #####:  531:    if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  532:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  533:
    #####:  534:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  535:            do_item_unlink_q(it);
    #####:  536:            it->time = current_time;
    #####:  537:            do_item_link_q(it);
        -:  538:        }
        -:  539:    }
    #####:  540:}
------------------
do_item_update_nolock:
    #####:  529:void do_item_update_nolock(item *it) {
    #####:  530:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
    #####:  531:    if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  532:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  533:
    #####:  534:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  535:            do_item_unlink_q(it);
    #####:  536:            it->time = current_time;
    #####:  537:            do_item_link_q(it);
        -:  538:        }
        -:  539:    }
    #####:  540:}
------------------
do_item_update_nolock:
    #####:  529:void do_item_update_nolock(item *it) {
    #####:  530:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
    #####:  531:    if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  532:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  533:
    #####:  534:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  535:            do_item_unlink_q(it);
    #####:  536:            it->time = current_time;
    #####:  537:            do_item_link_q(it);
        -:  538:        }
        -:  539:    }
    #####:  540:}
------------------
        -:  541:
        -:  542:/* Bump the last accessed time, or relink if we're in compat mode */
     3676:  543:void do_item_update(item *it) {
     3676:  544:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
        -:  545:
        -:  546:    /* Hits to COLD_LRU immediately move to WARM. */
     3676:  547:    if (settings.lru_segmented) {
     384*:  548:        assert((it->it_flags & ITEM_SLABBED) == 0);
      384:  549:        if ((it->it_flags & ITEM_LINKED) != 0) {
      380:  550:            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
        4:  551:                it->time = current_time;
        4:  552:                item_unlink_q(it);
        4:  553:                it->slabs_clsid = ITEM_clsid(it);
        4:  554:                it->slabs_clsid |= WARM_LRU;
        4:  555:                it->it_flags &= ~ITEM_ACTIVE;
        4:  556:                item_link_q_warm(it);
      376:  557:            } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  558:                it->time = current_time;
        -:  559:            }
        -:  560:        }
     3292:  561:    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  562:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  563:
    #####:  564:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  565:            it->time = current_time;
    #####:  566:            item_unlink_q(it);
    #####:  567:            item_link_q(it);
        -:  568:        }
        -:  569:    }
     3676:  570:}
------------------
do_item_update:
      919:  543:void do_item_update(item *it) {
      919:  544:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
        -:  545:
        -:  546:    /* Hits to COLD_LRU immediately move to WARM. */
      919:  547:    if (settings.lru_segmented) {
      96*:  548:        assert((it->it_flags & ITEM_SLABBED) == 0);
       96:  549:        if ((it->it_flags & ITEM_LINKED) != 0) {
       95:  550:            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
        1:  551:                it->time = current_time;
        1:  552:                item_unlink_q(it);
        1:  553:                it->slabs_clsid = ITEM_clsid(it);
        1:  554:                it->slabs_clsid |= WARM_LRU;
        1:  555:                it->it_flags &= ~ITEM_ACTIVE;
        1:  556:                item_link_q_warm(it);
       94:  557:            } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  558:                it->time = current_time;
        -:  559:            }
        -:  560:        }
      823:  561:    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  562:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  563:
    #####:  564:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  565:            it->time = current_time;
    #####:  566:            item_unlink_q(it);
    #####:  567:            item_link_q(it);
        -:  568:        }
        -:  569:    }
      919:  570:}
------------------
do_item_update:
      919:  543:void do_item_update(item *it) {
      919:  544:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
        -:  545:
        -:  546:    /* Hits to COLD_LRU immediately move to WARM. */
      919:  547:    if (settings.lru_segmented) {
      96*:  548:        assert((it->it_flags & ITEM_SLABBED) == 0);
       96:  549:        if ((it->it_flags & ITEM_LINKED) != 0) {
       95:  550:            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
        1:  551:                it->time = current_time;
        1:  552:                item_unlink_q(it);
        1:  553:                it->slabs_clsid = ITEM_clsid(it);
        1:  554:                it->slabs_clsid |= WARM_LRU;
        1:  555:                it->it_flags &= ~ITEM_ACTIVE;
        1:  556:                item_link_q_warm(it);
       94:  557:            } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  558:                it->time = current_time;
        -:  559:            }
        -:  560:        }
      823:  561:    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  562:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  563:
    #####:  564:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  565:            it->time = current_time;
    #####:  566:            item_unlink_q(it);
    #####:  567:            item_link_q(it);
        -:  568:        }
        -:  569:    }
      919:  570:}
------------------
do_item_update:
      919:  543:void do_item_update(item *it) {
      919:  544:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
        -:  545:
        -:  546:    /* Hits to COLD_LRU immediately move to WARM. */
      919:  547:    if (settings.lru_segmented) {
      96*:  548:        assert((it->it_flags & ITEM_SLABBED) == 0);
       96:  549:        if ((it->it_flags & ITEM_LINKED) != 0) {
       95:  550:            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
        1:  551:                it->time = current_time;
        1:  552:                item_unlink_q(it);
        1:  553:                it->slabs_clsid = ITEM_clsid(it);
        1:  554:                it->slabs_clsid |= WARM_LRU;
        1:  555:                it->it_flags &= ~ITEM_ACTIVE;
        1:  556:                item_link_q_warm(it);
       94:  557:            } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  558:                it->time = current_time;
        -:  559:            }
        -:  560:        }
      823:  561:    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  562:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  563:
    #####:  564:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  565:            it->time = current_time;
    #####:  566:            item_unlink_q(it);
    #####:  567:            item_link_q(it);
        -:  568:        }
        -:  569:    }
      919:  570:}
------------------
do_item_update:
      919:  543:void do_item_update(item *it) {
      919:  544:    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);
        -:  545:
        -:  546:    /* Hits to COLD_LRU immediately move to WARM. */
      919:  547:    if (settings.lru_segmented) {
      96*:  548:        assert((it->it_flags & ITEM_SLABBED) == 0);
       96:  549:        if ((it->it_flags & ITEM_LINKED) != 0) {
       95:  550:            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
        1:  551:                it->time = current_time;
        1:  552:                item_unlink_q(it);
        1:  553:                it->slabs_clsid = ITEM_clsid(it);
        1:  554:                it->slabs_clsid |= WARM_LRU;
        1:  555:                it->it_flags &= ~ITEM_ACTIVE;
        1:  556:                item_link_q_warm(it);
       94:  557:            } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  558:                it->time = current_time;
        -:  559:            }
        -:  560:        }
      823:  561:    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
    #####:  562:        assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  563:
    #####:  564:        if ((it->it_flags & ITEM_LINKED) != 0) {
    #####:  565:            it->time = current_time;
    #####:  566:            item_unlink_q(it);
    #####:  567:            item_link_q(it);
        -:  568:        }
        -:  569:    }
      919:  570:}
------------------
        -:  571:
   148644:  572:int do_item_replace(item *it, item *new_it, const uint32_t hv) {
        -:  573:    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
   148644:  574:                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
  148644*:  575:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  576:
   148644:  577:    do_item_unlink(it, hv);
   148644:  578:    return do_item_link(new_it, hv);
        -:  579:}
------------------
do_item_replace:
    37161:  572:int do_item_replace(item *it, item *new_it, const uint32_t hv) {
        -:  573:    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
    37161:  574:                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
   37161*:  575:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  576:
    37161:  577:    do_item_unlink(it, hv);
    37161:  578:    return do_item_link(new_it, hv);
        -:  579:}
------------------
do_item_replace:
    37161:  572:int do_item_replace(item *it, item *new_it, const uint32_t hv) {
        -:  573:    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
    37161:  574:                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
   37161*:  575:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  576:
    37161:  577:    do_item_unlink(it, hv);
    37161:  578:    return do_item_link(new_it, hv);
        -:  579:}
------------------
do_item_replace:
    37161:  572:int do_item_replace(item *it, item *new_it, const uint32_t hv) {
        -:  573:    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
    37161:  574:                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
   37161*:  575:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  576:
    37161:  577:    do_item_unlink(it, hv);
    37161:  578:    return do_item_link(new_it, hv);
        -:  579:}
------------------
do_item_replace:
    37161:  572:int do_item_replace(item *it, item *new_it, const uint32_t hv) {
        -:  573:    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
    37161:  574:                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
   37161*:  575:    assert((it->it_flags & ITEM_SLABBED) == 0);
        -:  576:
    37161:  577:    do_item_unlink(it, hv);
    37161:  578:    return do_item_link(new_it, hv);
        -:  579:}
------------------
        -:  580:
        -:  581:/*@null@*/
        -:  582:/* This is walking the line of violating lock order, but I think it's safe.
        -:  583: * If the LRU lock is held, an item in the LRU cannot be wiped and freed.
        -:  584: * The data could possibly be overwritten, but this is only accessing the
        -:  585: * headers.
        -:  586: * It may not be the best idea to leave it like this, but for now it's safe.
        -:  587: */
        8:  588:char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
        8:  589:    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
        8:  590:    char *buffer;
        8:  591:    unsigned int bufcurr;
        8:  592:    item *it;
        8:  593:    unsigned int len;
        8:  594:    unsigned int shown = 0;
        8:  595:    char key_temp[KEY_MAX_LENGTH + 1];
        8:  596:    char temp[512];
        8:  597:    unsigned int id = slabs_clsid;
        8:  598:    id |= COLD_LRU;
        -:  599:
        8:  600:    pthread_mutex_lock(&lru_locks[id]);
        8:  601:    it = heads[id];
        -:  602:
        8:  603:    buffer = malloc((size_t)memlimit);
        8:  604:    if (buffer == 0) {
        -:  605:        return NULL;
        -:  606:    }
        -:  607:    bufcurr = 0;
        -:  608:
       12:  609:    while (it != NULL && (limit == 0 || shown < limit)) {
       4*:  610:        assert(it->nkey <= KEY_MAX_LENGTH);
       4*:  611:        if (it->nbytes == 0 && it->nkey == 0) {
    #####:  612:            it = it->next;
    #####:  613:            continue;
        -:  614:        }
        -:  615:        /* Copy the key since it may not be null-terminated in the struct */
        4:  616:        strncpy(key_temp, ITEM_key(it), it->nkey);
        4:  617:        key_temp[it->nkey] = 0x00; /* terminate */
      16*:  618:        len = snprintf(temp, sizeof(temp), "ITEM %s [%d b; %llu s]\r\n",
        4:  619:                       key_temp, it->nbytes - 2,
        4:  620:                       it->exptime == 0 ? 0 :
    #####:  621:                       (unsigned long long)it->exptime + process_started);
        4:  622:        if (bufcurr + len + 6 > memlimit)  /* 6 is END\r\n\0 */
        -:  623:            break;
        4:  624:        memcpy(buffer + bufcurr, temp, len);
        4:  625:        bufcurr += len;
        4:  626:        shown++;
        4:  627:        it = it->next;
        -:  628:    }
        -:  629:
        8:  630:    memcpy(buffer + bufcurr, "END\r\n", 6);
        8:  631:    bufcurr += 5;
        -:  632:
        8:  633:    *bytes = bufcurr;
        8:  634:    pthread_mutex_unlock(&lru_locks[id]);
        8:  635:    return buffer;
        -:  636:}
------------------
item_cachedump:
        2:  588:char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
        2:  589:    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
        2:  590:    char *buffer;
        2:  591:    unsigned int bufcurr;
        2:  592:    item *it;
        2:  593:    unsigned int len;
        2:  594:    unsigned int shown = 0;
        2:  595:    char key_temp[KEY_MAX_LENGTH + 1];
        2:  596:    char temp[512];
        2:  597:    unsigned int id = slabs_clsid;
        2:  598:    id |= COLD_LRU;
        -:  599:
        2:  600:    pthread_mutex_lock(&lru_locks[id]);
        2:  601:    it = heads[id];
        -:  602:
        2:  603:    buffer = malloc((size_t)memlimit);
        2:  604:    if (buffer == 0) {
        -:  605:        return NULL;
        -:  606:    }
        -:  607:    bufcurr = 0;
        -:  608:
        3:  609:    while (it != NULL && (limit == 0 || shown < limit)) {
       1*:  610:        assert(it->nkey <= KEY_MAX_LENGTH);
       1*:  611:        if (it->nbytes == 0 && it->nkey == 0) {
    #####:  612:            it = it->next;
    #####:  613:            continue;
        -:  614:        }
        -:  615:        /* Copy the key since it may not be null-terminated in the struct */
        1:  616:        strncpy(key_temp, ITEM_key(it), it->nkey);
        1:  617:        key_temp[it->nkey] = 0x00; /* terminate */
       4*:  618:        len = snprintf(temp, sizeof(temp), "ITEM %s [%d b; %llu s]\r\n",
        1:  619:                       key_temp, it->nbytes - 2,
        1:  620:                       it->exptime == 0 ? 0 :
    #####:  621:                       (unsigned long long)it->exptime + process_started);
        1:  622:        if (bufcurr + len + 6 > memlimit)  /* 6 is END\r\n\0 */
        -:  623:            break;
        1:  624:        memcpy(buffer + bufcurr, temp, len);
        1:  625:        bufcurr += len;
        1:  626:        shown++;
        1:  627:        it = it->next;
        -:  628:    }
        -:  629:
        2:  630:    memcpy(buffer + bufcurr, "END\r\n", 6);
        2:  631:    bufcurr += 5;
        -:  632:
        2:  633:    *bytes = bufcurr;
        2:  634:    pthread_mutex_unlock(&lru_locks[id]);
        2:  635:    return buffer;
        -:  636:}
------------------
item_cachedump:
        2:  588:char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
        2:  589:    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
        2:  590:    char *buffer;
        2:  591:    unsigned int bufcurr;
        2:  592:    item *it;
        2:  593:    unsigned int len;
        2:  594:    unsigned int shown = 0;
        2:  595:    char key_temp[KEY_MAX_LENGTH + 1];
        2:  596:    char temp[512];
        2:  597:    unsigned int id = slabs_clsid;
        2:  598:    id |= COLD_LRU;
        -:  599:
        2:  600:    pthread_mutex_lock(&lru_locks[id]);
        2:  601:    it = heads[id];
        -:  602:
        2:  603:    buffer = malloc((size_t)memlimit);
        2:  604:    if (buffer == 0) {
        -:  605:        return NULL;
        -:  606:    }
        -:  607:    bufcurr = 0;
        -:  608:
        3:  609:    while (it != NULL && (limit == 0 || shown < limit)) {
       1*:  610:        assert(it->nkey <= KEY_MAX_LENGTH);
       1*:  611:        if (it->nbytes == 0 && it->nkey == 0) {
    #####:  612:            it = it->next;
    #####:  613:            continue;
        -:  614:        }
        -:  615:        /* Copy the key since it may not be null-terminated in the struct */
        1:  616:        strncpy(key_temp, ITEM_key(it), it->nkey);
        1:  617:        key_temp[it->nkey] = 0x00; /* terminate */
       4*:  618:        len = snprintf(temp, sizeof(temp), "ITEM %s [%d b; %llu s]\r\n",
        1:  619:                       key_temp, it->nbytes - 2,
        1:  620:                       it->exptime == 0 ? 0 :
    #####:  621:                       (unsigned long long)it->exptime + process_started);
        1:  622:        if (bufcurr + len + 6 > memlimit)  /* 6 is END\r\n\0 */
        -:  623:            break;
        1:  624:        memcpy(buffer + bufcurr, temp, len);
        1:  625:        bufcurr += len;
        1:  626:        shown++;
        1:  627:        it = it->next;
        -:  628:    }
        -:  629:
        2:  630:    memcpy(buffer + bufcurr, "END\r\n", 6);
        2:  631:    bufcurr += 5;
        -:  632:
        2:  633:    *bytes = bufcurr;
        2:  634:    pthread_mutex_unlock(&lru_locks[id]);
        2:  635:    return buffer;
        -:  636:}
------------------
item_cachedump:
        2:  588:char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
        2:  589:    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
        2:  590:    char *buffer;
        2:  591:    unsigned int bufcurr;
        2:  592:    item *it;
        2:  593:    unsigned int len;
        2:  594:    unsigned int shown = 0;
        2:  595:    char key_temp[KEY_MAX_LENGTH + 1];
        2:  596:    char temp[512];
        2:  597:    unsigned int id = slabs_clsid;
        2:  598:    id |= COLD_LRU;
        -:  599:
        2:  600:    pthread_mutex_lock(&lru_locks[id]);
        2:  601:    it = heads[id];
        -:  602:
        2:  603:    buffer = malloc((size_t)memlimit);
        2:  604:    if (buffer == 0) {
        -:  605:        return NULL;
        -:  606:    }
        -:  607:    bufcurr = 0;
        -:  608:
        3:  609:    while (it != NULL && (limit == 0 || shown < limit)) {
       1*:  610:        assert(it->nkey <= KEY_MAX_LENGTH);
       1*:  611:        if (it->nbytes == 0 && it->nkey == 0) {
    #####:  612:            it = it->next;
    #####:  613:            continue;
        -:  614:        }
        -:  615:        /* Copy the key since it may not be null-terminated in the struct */
        1:  616:        strncpy(key_temp, ITEM_key(it), it->nkey);
        1:  617:        key_temp[it->nkey] = 0x00; /* terminate */
       4*:  618:        len = snprintf(temp, sizeof(temp), "ITEM %s [%d b; %llu s]\r\n",
        1:  619:                       key_temp, it->nbytes - 2,
        1:  620:                       it->exptime == 0 ? 0 :
    #####:  621:                       (unsigned long long)it->exptime + process_started);
        1:  622:        if (bufcurr + len + 6 > memlimit)  /* 6 is END\r\n\0 */
        -:  623:            break;
        1:  624:        memcpy(buffer + bufcurr, temp, len);
        1:  625:        bufcurr += len;
        1:  626:        shown++;
        1:  627:        it = it->next;
        -:  628:    }
        -:  629:
        2:  630:    memcpy(buffer + bufcurr, "END\r\n", 6);
        2:  631:    bufcurr += 5;
        -:  632:
        2:  633:    *bytes = bufcurr;
        2:  634:    pthread_mutex_unlock(&lru_locks[id]);
        2:  635:    return buffer;
        -:  636:}
------------------
item_cachedump:
        2:  588:char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
        2:  589:    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
        2:  590:    char *buffer;
        2:  591:    unsigned int bufcurr;
        2:  592:    item *it;
        2:  593:    unsigned int len;
        2:  594:    unsigned int shown = 0;
        2:  595:    char key_temp[KEY_MAX_LENGTH + 1];
        2:  596:    char temp[512];
        2:  597:    unsigned int id = slabs_clsid;
        2:  598:    id |= COLD_LRU;
        -:  599:
        2:  600:    pthread_mutex_lock(&lru_locks[id]);
        2:  601:    it = heads[id];
        -:  602:
        2:  603:    buffer = malloc((size_t)memlimit);
        2:  604:    if (buffer == 0) {
        -:  605:        return NULL;
        -:  606:    }
        -:  607:    bufcurr = 0;
        -:  608:
        3:  609:    while (it != NULL && (limit == 0 || shown < limit)) {
       1*:  610:        assert(it->nkey <= KEY_MAX_LENGTH);
       1*:  611:        if (it->nbytes == 0 && it->nkey == 0) {
    #####:  612:            it = it->next;
    #####:  613:            continue;
        -:  614:        }
        -:  615:        /* Copy the key since it may not be null-terminated in the struct */
        1:  616:        strncpy(key_temp, ITEM_key(it), it->nkey);
        1:  617:        key_temp[it->nkey] = 0x00; /* terminate */
       4*:  618:        len = snprintf(temp, sizeof(temp), "ITEM %s [%d b; %llu s]\r\n",
        1:  619:                       key_temp, it->nbytes - 2,
        1:  620:                       it->exptime == 0 ? 0 :
    #####:  621:                       (unsigned long long)it->exptime + process_started);
        1:  622:        if (bufcurr + len + 6 > memlimit)  /* 6 is END\r\n\0 */
        -:  623:            break;
        1:  624:        memcpy(buffer + bufcurr, temp, len);
        1:  625:        bufcurr += len;
        1:  626:        shown++;
        1:  627:        it = it->next;
        -:  628:    }
        -:  629:
        2:  630:    memcpy(buffer + bufcurr, "END\r\n", 6);
        2:  631:    bufcurr += 5;
        -:  632:
        2:  633:    *bytes = bufcurr;
        2:  634:    pthread_mutex_unlock(&lru_locks[id]);
        2:  635:    return buffer;
        -:  636:}
------------------
        -:  637:
        -:  638:/* With refactoring of the various stats code the automover won't need a
        -:  639: * custom function here.
        -:  640: */
     1448:  641:void fill_item_stats_automove(item_stats_automove *am) {
     1448:  642:    int n;
    94120:  643:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    92672:  644:        item_stats_automove *cur = &am[n];
        -:  645:
        -:  646:        // outofmemory records into HOT
    92672:  647:        int i = n | HOT_LRU;
    92672:  648:        pthread_mutex_lock(&lru_locks[i]);
    92672:  649:        cur->outofmemory = itemstats[i].outofmemory;
    92672:  650:        pthread_mutex_unlock(&lru_locks[i]);
        -:  651:
        -:  652:        // evictions and tail age are from COLD
    92672:  653:        i = n | COLD_LRU;
    92672:  654:        pthread_mutex_lock(&lru_locks[i]);
    92672:  655:        cur->evicted = itemstats[i].evicted;
    92672:  656:        if (tails[i]) {
    22016:  657:            cur->age = current_time - tails[i]->time;
        -:  658:        } else {
    70656:  659:            cur->age = 0;
        -:  660:        }
    92672:  661:        pthread_mutex_unlock(&lru_locks[i]);
        -:  662:     }
     1448:  663:}
------------------
fill_item_stats_automove:
      362:  641:void fill_item_stats_automove(item_stats_automove *am) {
      362:  642:    int n;
    23530:  643:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    23168:  644:        item_stats_automove *cur = &am[n];
        -:  645:
        -:  646:        // outofmemory records into HOT
    23168:  647:        int i = n | HOT_LRU;
    23168:  648:        pthread_mutex_lock(&lru_locks[i]);
    23168:  649:        cur->outofmemory = itemstats[i].outofmemory;
    23168:  650:        pthread_mutex_unlock(&lru_locks[i]);
        -:  651:
        -:  652:        // evictions and tail age are from COLD
    23168:  653:        i = n | COLD_LRU;
    23168:  654:        pthread_mutex_lock(&lru_locks[i]);
    23168:  655:        cur->evicted = itemstats[i].evicted;
    23168:  656:        if (tails[i]) {
     5504:  657:            cur->age = current_time - tails[i]->time;
        -:  658:        } else {
    17664:  659:            cur->age = 0;
        -:  660:        }
    23168:  661:        pthread_mutex_unlock(&lru_locks[i]);
        -:  662:     }
      362:  663:}
------------------
fill_item_stats_automove:
      362:  641:void fill_item_stats_automove(item_stats_automove *am) {
      362:  642:    int n;
    23530:  643:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    23168:  644:        item_stats_automove *cur = &am[n];
        -:  645:
        -:  646:        // outofmemory records into HOT
    23168:  647:        int i = n | HOT_LRU;
    23168:  648:        pthread_mutex_lock(&lru_locks[i]);
    23168:  649:        cur->outofmemory = itemstats[i].outofmemory;
    23168:  650:        pthread_mutex_unlock(&lru_locks[i]);
        -:  651:
        -:  652:        // evictions and tail age are from COLD
    23168:  653:        i = n | COLD_LRU;
    23168:  654:        pthread_mutex_lock(&lru_locks[i]);
    23168:  655:        cur->evicted = itemstats[i].evicted;
    23168:  656:        if (tails[i]) {
     5504:  657:            cur->age = current_time - tails[i]->time;
        -:  658:        } else {
    17664:  659:            cur->age = 0;
        -:  660:        }
    23168:  661:        pthread_mutex_unlock(&lru_locks[i]);
        -:  662:     }
      362:  663:}
------------------
fill_item_stats_automove:
      362:  641:void fill_item_stats_automove(item_stats_automove *am) {
      362:  642:    int n;
    23530:  643:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    23168:  644:        item_stats_automove *cur = &am[n];
        -:  645:
        -:  646:        // outofmemory records into HOT
    23168:  647:        int i = n | HOT_LRU;
    23168:  648:        pthread_mutex_lock(&lru_locks[i]);
    23168:  649:        cur->outofmemory = itemstats[i].outofmemory;
    23168:  650:        pthread_mutex_unlock(&lru_locks[i]);
        -:  651:
        -:  652:        // evictions and tail age are from COLD
    23168:  653:        i = n | COLD_LRU;
    23168:  654:        pthread_mutex_lock(&lru_locks[i]);
    23168:  655:        cur->evicted = itemstats[i].evicted;
    23168:  656:        if (tails[i]) {
     5504:  657:            cur->age = current_time - tails[i]->time;
        -:  658:        } else {
    17664:  659:            cur->age = 0;
        -:  660:        }
    23168:  661:        pthread_mutex_unlock(&lru_locks[i]);
        -:  662:     }
      362:  663:}
------------------
fill_item_stats_automove:
      362:  641:void fill_item_stats_automove(item_stats_automove *am) {
      362:  642:    int n;
    23530:  643:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    23168:  644:        item_stats_automove *cur = &am[n];
        -:  645:
        -:  646:        // outofmemory records into HOT
    23168:  647:        int i = n | HOT_LRU;
    23168:  648:        pthread_mutex_lock(&lru_locks[i]);
    23168:  649:        cur->outofmemory = itemstats[i].outofmemory;
    23168:  650:        pthread_mutex_unlock(&lru_locks[i]);
        -:  651:
        -:  652:        // evictions and tail age are from COLD
    23168:  653:        i = n | COLD_LRU;
    23168:  654:        pthread_mutex_lock(&lru_locks[i]);
    23168:  655:        cur->evicted = itemstats[i].evicted;
    23168:  656:        if (tails[i]) {
     5504:  657:            cur->age = current_time - tails[i]->time;
        -:  658:        } else {
    17664:  659:            cur->age = 0;
        -:  660:        }
    23168:  661:        pthread_mutex_unlock(&lru_locks[i]);
        -:  662:     }
      362:  663:}
------------------
        -:  664:
    10640:  665:void item_stats_totals(ADD_STAT add_stats, void *c) {
    10640:  666:    itemstats_t totals;
    10640:  667:    memset(&totals, 0, sizeof(itemstats_t));
    10640:  668:    int n;
   691600:  669:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        -:  670:        int x;
        -:  671:        int i;
  3404800:  672:        for (x = 0; x < 4; x++) {
  2723840:  673:            i = n | lru_type_map[x];
  2723840:  674:            pthread_mutex_lock(&lru_locks[i]);
  2723840:  675:            totals.expired_unfetched += itemstats[i].expired_unfetched;
  2723840:  676:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
  2723840:  677:            totals.evicted_active += itemstats[i].evicted_active;
  2723840:  678:            totals.evicted += itemstats[i].evicted;
  2723840:  679:            totals.reclaimed += itemstats[i].reclaimed;
  2723840:  680:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
  2723840:  681:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
  2723840:  682:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
  2723840:  683:            totals.moves_to_cold += itemstats[i].moves_to_cold;
  2723840:  684:            totals.moves_to_warm += itemstats[i].moves_to_warm;
  2723840:  685:            totals.moves_within_lru += itemstats[i].moves_within_lru;
  2723840:  686:            totals.direct_reclaims += itemstats[i].direct_reclaims;
  2723840:  687:            pthread_mutex_unlock(&lru_locks[i]);
        -:  688:        }
        -:  689:    }
    10640:  690:    APPEND_STAT("expired_unfetched", "%llu",
    10640:  691:                (unsigned long long)totals.expired_unfetched);
    10640:  692:    APPEND_STAT("evicted_unfetched", "%llu",
    10640:  693:                (unsigned long long)totals.evicted_unfetched);
    10640:  694:    if (settings.lru_maintainer_thread) {
    10536:  695:        APPEND_STAT("evicted_active", "%llu",
    10640:  696:                    (unsigned long long)totals.evicted_active);
        -:  697:    }
    10640:  698:    APPEND_STAT("evictions", "%llu",
    10640:  699:                (unsigned long long)totals.evicted);
    10640:  700:    APPEND_STAT("reclaimed", "%llu",
    10640:  701:                (unsigned long long)totals.reclaimed);
    10640:  702:    APPEND_STAT("crawler_reclaimed", "%llu",
    10640:  703:                (unsigned long long)totals.crawler_reclaimed);
    10640:  704:    APPEND_STAT("crawler_items_checked", "%llu",
    10640:  705:                (unsigned long long)totals.crawler_items_checked);
    10640:  706:    APPEND_STAT("lrutail_reflocked", "%llu",
    10640:  707:                (unsigned long long)totals.lrutail_reflocked);
    10640:  708:    if (settings.lru_maintainer_thread) {
    10536:  709:        APPEND_STAT("moves_to_cold", "%llu",
    10536:  710:                    (unsigned long long)totals.moves_to_cold);
    10536:  711:        APPEND_STAT("moves_to_warm", "%llu",
    10536:  712:                    (unsigned long long)totals.moves_to_warm);
    10536:  713:        APPEND_STAT("moves_within_lru", "%llu",
    10536:  714:                    (unsigned long long)totals.moves_within_lru);
    10536:  715:        APPEND_STAT("direct_reclaims", "%llu",
    10536:  716:                    (unsigned long long)totals.direct_reclaims);
    10536:  717:        APPEND_STAT("lru_bumps_dropped", "%llu",
    10640:  718:                    (unsigned long long)lru_total_bumps_dropped());
        -:  719:    }
    10640:  720:}
------------------
item_stats_totals:
     2660:  665:void item_stats_totals(ADD_STAT add_stats, void *c) {
     2660:  666:    itemstats_t totals;
     2660:  667:    memset(&totals, 0, sizeof(itemstats_t));
     2660:  668:    int n;
   172900:  669:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        -:  670:        int x;
        -:  671:        int i;
   851200:  672:        for (x = 0; x < 4; x++) {
   680960:  673:            i = n | lru_type_map[x];
   680960:  674:            pthread_mutex_lock(&lru_locks[i]);
   680960:  675:            totals.expired_unfetched += itemstats[i].expired_unfetched;
   680960:  676:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
   680960:  677:            totals.evicted_active += itemstats[i].evicted_active;
   680960:  678:            totals.evicted += itemstats[i].evicted;
   680960:  679:            totals.reclaimed += itemstats[i].reclaimed;
   680960:  680:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
   680960:  681:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
   680960:  682:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
   680960:  683:            totals.moves_to_cold += itemstats[i].moves_to_cold;
   680960:  684:            totals.moves_to_warm += itemstats[i].moves_to_warm;
   680960:  685:            totals.moves_within_lru += itemstats[i].moves_within_lru;
   680960:  686:            totals.direct_reclaims += itemstats[i].direct_reclaims;
   680960:  687:            pthread_mutex_unlock(&lru_locks[i]);
        -:  688:        }
        -:  689:    }
     2660:  690:    APPEND_STAT("expired_unfetched", "%llu",
     2660:  691:                (unsigned long long)totals.expired_unfetched);
     2660:  692:    APPEND_STAT("evicted_unfetched", "%llu",
     2660:  693:                (unsigned long long)totals.evicted_unfetched);
     2660:  694:    if (settings.lru_maintainer_thread) {
     2634:  695:        APPEND_STAT("evicted_active", "%llu",
     2660:  696:                    (unsigned long long)totals.evicted_active);
        -:  697:    }
     2660:  698:    APPEND_STAT("evictions", "%llu",
     2660:  699:                (unsigned long long)totals.evicted);
     2660:  700:    APPEND_STAT("reclaimed", "%llu",
     2660:  701:                (unsigned long long)totals.reclaimed);
     2660:  702:    APPEND_STAT("crawler_reclaimed", "%llu",
     2660:  703:                (unsigned long long)totals.crawler_reclaimed);
     2660:  704:    APPEND_STAT("crawler_items_checked", "%llu",
     2660:  705:                (unsigned long long)totals.crawler_items_checked);
     2660:  706:    APPEND_STAT("lrutail_reflocked", "%llu",
     2660:  707:                (unsigned long long)totals.lrutail_reflocked);
     2660:  708:    if (settings.lru_maintainer_thread) {
     2634:  709:        APPEND_STAT("moves_to_cold", "%llu",
     2634:  710:                    (unsigned long long)totals.moves_to_cold);
     2634:  711:        APPEND_STAT("moves_to_warm", "%llu",
     2634:  712:                    (unsigned long long)totals.moves_to_warm);
     2634:  713:        APPEND_STAT("moves_within_lru", "%llu",
     2634:  714:                    (unsigned long long)totals.moves_within_lru);
     2634:  715:        APPEND_STAT("direct_reclaims", "%llu",
     2634:  716:                    (unsigned long long)totals.direct_reclaims);
     2634:  717:        APPEND_STAT("lru_bumps_dropped", "%llu",
     2660:  718:                    (unsigned long long)lru_total_bumps_dropped());
        -:  719:    }
     2660:  720:}
------------------
item_stats_totals:
     2660:  665:void item_stats_totals(ADD_STAT add_stats, void *c) {
     2660:  666:    itemstats_t totals;
     2660:  667:    memset(&totals, 0, sizeof(itemstats_t));
     2660:  668:    int n;
   172900:  669:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        -:  670:        int x;
        -:  671:        int i;
   851200:  672:        for (x = 0; x < 4; x++) {
   680960:  673:            i = n | lru_type_map[x];
   680960:  674:            pthread_mutex_lock(&lru_locks[i]);
   680960:  675:            totals.expired_unfetched += itemstats[i].expired_unfetched;
   680960:  676:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
   680960:  677:            totals.evicted_active += itemstats[i].evicted_active;
   680960:  678:            totals.evicted += itemstats[i].evicted;
   680960:  679:            totals.reclaimed += itemstats[i].reclaimed;
   680960:  680:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
   680960:  681:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
   680960:  682:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
   680960:  683:            totals.moves_to_cold += itemstats[i].moves_to_cold;
   680960:  684:            totals.moves_to_warm += itemstats[i].moves_to_warm;
   680960:  685:            totals.moves_within_lru += itemstats[i].moves_within_lru;
   680960:  686:            totals.direct_reclaims += itemstats[i].direct_reclaims;
   680960:  687:            pthread_mutex_unlock(&lru_locks[i]);
        -:  688:        }
        -:  689:    }
     2660:  690:    APPEND_STAT("expired_unfetched", "%llu",
     2660:  691:                (unsigned long long)totals.expired_unfetched);
     2660:  692:    APPEND_STAT("evicted_unfetched", "%llu",
     2660:  693:                (unsigned long long)totals.evicted_unfetched);
     2660:  694:    if (settings.lru_maintainer_thread) {
     2634:  695:        APPEND_STAT("evicted_active", "%llu",
     2660:  696:                    (unsigned long long)totals.evicted_active);
        -:  697:    }
     2660:  698:    APPEND_STAT("evictions", "%llu",
     2660:  699:                (unsigned long long)totals.evicted);
     2660:  700:    APPEND_STAT("reclaimed", "%llu",
     2660:  701:                (unsigned long long)totals.reclaimed);
     2660:  702:    APPEND_STAT("crawler_reclaimed", "%llu",
     2660:  703:                (unsigned long long)totals.crawler_reclaimed);
     2660:  704:    APPEND_STAT("crawler_items_checked", "%llu",
     2660:  705:                (unsigned long long)totals.crawler_items_checked);
     2660:  706:    APPEND_STAT("lrutail_reflocked", "%llu",
     2660:  707:                (unsigned long long)totals.lrutail_reflocked);
     2660:  708:    if (settings.lru_maintainer_thread) {
     2634:  709:        APPEND_STAT("moves_to_cold", "%llu",
     2634:  710:                    (unsigned long long)totals.moves_to_cold);
     2634:  711:        APPEND_STAT("moves_to_warm", "%llu",
     2634:  712:                    (unsigned long long)totals.moves_to_warm);
     2634:  713:        APPEND_STAT("moves_within_lru", "%llu",
     2634:  714:                    (unsigned long long)totals.moves_within_lru);
     2634:  715:        APPEND_STAT("direct_reclaims", "%llu",
     2634:  716:                    (unsigned long long)totals.direct_reclaims);
     2634:  717:        APPEND_STAT("lru_bumps_dropped", "%llu",
     2660:  718:                    (unsigned long long)lru_total_bumps_dropped());
        -:  719:    }
     2660:  720:}
------------------
item_stats_totals:
     2660:  665:void item_stats_totals(ADD_STAT add_stats, void *c) {
     2660:  666:    itemstats_t totals;
     2660:  667:    memset(&totals, 0, sizeof(itemstats_t));
     2660:  668:    int n;
   172900:  669:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        -:  670:        int x;
        -:  671:        int i;
   851200:  672:        for (x = 0; x < 4; x++) {
   680960:  673:            i = n | lru_type_map[x];
   680960:  674:            pthread_mutex_lock(&lru_locks[i]);
   680960:  675:            totals.expired_unfetched += itemstats[i].expired_unfetched;
   680960:  676:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
   680960:  677:            totals.evicted_active += itemstats[i].evicted_active;
   680960:  678:            totals.evicted += itemstats[i].evicted;
   680960:  679:            totals.reclaimed += itemstats[i].reclaimed;
   680960:  680:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
   680960:  681:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
   680960:  682:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
   680960:  683:            totals.moves_to_cold += itemstats[i].moves_to_cold;
   680960:  684:            totals.moves_to_warm += itemstats[i].moves_to_warm;
   680960:  685:            totals.moves_within_lru += itemstats[i].moves_within_lru;
   680960:  686:            totals.direct_reclaims += itemstats[i].direct_reclaims;
   680960:  687:            pthread_mutex_unlock(&lru_locks[i]);
        -:  688:        }
        -:  689:    }
     2660:  690:    APPEND_STAT("expired_unfetched", "%llu",
     2660:  691:                (unsigned long long)totals.expired_unfetched);
     2660:  692:    APPEND_STAT("evicted_unfetched", "%llu",
     2660:  693:                (unsigned long long)totals.evicted_unfetched);
     2660:  694:    if (settings.lru_maintainer_thread) {
     2634:  695:        APPEND_STAT("evicted_active", "%llu",
     2660:  696:                    (unsigned long long)totals.evicted_active);
        -:  697:    }
     2660:  698:    APPEND_STAT("evictions", "%llu",
     2660:  699:                (unsigned long long)totals.evicted);
     2660:  700:    APPEND_STAT("reclaimed", "%llu",
     2660:  701:                (unsigned long long)totals.reclaimed);
     2660:  702:    APPEND_STAT("crawler_reclaimed", "%llu",
     2660:  703:                (unsigned long long)totals.crawler_reclaimed);
     2660:  704:    APPEND_STAT("crawler_items_checked", "%llu",
     2660:  705:                (unsigned long long)totals.crawler_items_checked);
     2660:  706:    APPEND_STAT("lrutail_reflocked", "%llu",
     2660:  707:                (unsigned long long)totals.lrutail_reflocked);
     2660:  708:    if (settings.lru_maintainer_thread) {
     2634:  709:        APPEND_STAT("moves_to_cold", "%llu",
     2634:  710:                    (unsigned long long)totals.moves_to_cold);
     2634:  711:        APPEND_STAT("moves_to_warm", "%llu",
     2634:  712:                    (unsigned long long)totals.moves_to_warm);
     2634:  713:        APPEND_STAT("moves_within_lru", "%llu",
     2634:  714:                    (unsigned long long)totals.moves_within_lru);
     2634:  715:        APPEND_STAT("direct_reclaims", "%llu",
     2634:  716:                    (unsigned long long)totals.direct_reclaims);
     2634:  717:        APPEND_STAT("lru_bumps_dropped", "%llu",
     2660:  718:                    (unsigned long long)lru_total_bumps_dropped());
        -:  719:    }
     2660:  720:}
------------------
item_stats_totals:
     2660:  665:void item_stats_totals(ADD_STAT add_stats, void *c) {
     2660:  666:    itemstats_t totals;
     2660:  667:    memset(&totals, 0, sizeof(itemstats_t));
     2660:  668:    int n;
   172900:  669:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        -:  670:        int x;
        -:  671:        int i;
   851200:  672:        for (x = 0; x < 4; x++) {
   680960:  673:            i = n | lru_type_map[x];
   680960:  674:            pthread_mutex_lock(&lru_locks[i]);
   680960:  675:            totals.expired_unfetched += itemstats[i].expired_unfetched;
   680960:  676:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
   680960:  677:            totals.evicted_active += itemstats[i].evicted_active;
   680960:  678:            totals.evicted += itemstats[i].evicted;
   680960:  679:            totals.reclaimed += itemstats[i].reclaimed;
   680960:  680:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
   680960:  681:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
   680960:  682:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
   680960:  683:            totals.moves_to_cold += itemstats[i].moves_to_cold;
   680960:  684:            totals.moves_to_warm += itemstats[i].moves_to_warm;
   680960:  685:            totals.moves_within_lru += itemstats[i].moves_within_lru;
   680960:  686:            totals.direct_reclaims += itemstats[i].direct_reclaims;
   680960:  687:            pthread_mutex_unlock(&lru_locks[i]);
        -:  688:        }
        -:  689:    }
     2660:  690:    APPEND_STAT("expired_unfetched", "%llu",
     2660:  691:                (unsigned long long)totals.expired_unfetched);
     2660:  692:    APPEND_STAT("evicted_unfetched", "%llu",
     2660:  693:                (unsigned long long)totals.evicted_unfetched);
     2660:  694:    if (settings.lru_maintainer_thread) {
     2634:  695:        APPEND_STAT("evicted_active", "%llu",
     2660:  696:                    (unsigned long long)totals.evicted_active);
        -:  697:    }
     2660:  698:    APPEND_STAT("evictions", "%llu",
     2660:  699:                (unsigned long long)totals.evicted);
     2660:  700:    APPEND_STAT("reclaimed", "%llu",
     2660:  701:                (unsigned long long)totals.reclaimed);
     2660:  702:    APPEND_STAT("crawler_reclaimed", "%llu",
     2660:  703:                (unsigned long long)totals.crawler_reclaimed);
     2660:  704:    APPEND_STAT("crawler_items_checked", "%llu",
     2660:  705:                (unsigned long long)totals.crawler_items_checked);
     2660:  706:    APPEND_STAT("lrutail_reflocked", "%llu",
     2660:  707:                (unsigned long long)totals.lrutail_reflocked);
     2660:  708:    if (settings.lru_maintainer_thread) {
     2634:  709:        APPEND_STAT("moves_to_cold", "%llu",
     2634:  710:                    (unsigned long long)totals.moves_to_cold);
     2634:  711:        APPEND_STAT("moves_to_warm", "%llu",
     2634:  712:                    (unsigned long long)totals.moves_to_warm);
     2634:  713:        APPEND_STAT("moves_within_lru", "%llu",
     2634:  714:                    (unsigned long long)totals.moves_within_lru);
     2634:  715:        APPEND_STAT("direct_reclaims", "%llu",
     2634:  716:                    (unsigned long long)totals.direct_reclaims);
     2634:  717:        APPEND_STAT("lru_bumps_dropped", "%llu",
     2660:  718:                    (unsigned long long)lru_total_bumps_dropped());
        -:  719:    }
     2660:  720:}
------------------
        -:  721:
       44:  722:void item_stats(ADD_STAT add_stats, void *c) {
       44:  723:    struct thread_stats thread_stats;
       44:  724:    threadlocal_stats_aggregate(&thread_stats);
       44:  725:    itemstats_t totals;
       44:  726:    int n;
     2860:  727:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
     2816:  728:        memset(&totals, 0, sizeof(itemstats_t));
     2816:  729:        int x;
     2816:  730:        int i;
     2816:  731:        unsigned int size = 0;
     2816:  732:        unsigned int age  = 0;
     2816:  733:        unsigned int age_hot = 0;
     2816:  734:        unsigned int age_warm = 0;
     2816:  735:        unsigned int lru_size_map[4];
     2816:  736:        const char *fmt = "items:%d:%s";
     2816:  737:        char key_str[STAT_KEY_LEN];
     2816:  738:        char val_str[STAT_VAL_LEN];
     2816:  739:        int klen = 0, vlen = 0;
    14080:  740:        for (x = 0; x < 4; x++) {
    11264:  741:            i = n | lru_type_map[x];
    11264:  742:            pthread_mutex_lock(&lru_locks[i]);
    11264:  743:            totals.evicted += itemstats[i].evicted;
    11264:  744:            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
    11264:  745:            totals.outofmemory += itemstats[i].outofmemory;
    11264:  746:            totals.tailrepairs += itemstats[i].tailrepairs;
    11264:  747:            totals.reclaimed += itemstats[i].reclaimed;
    11264:  748:            totals.expired_unfetched += itemstats[i].expired_unfetched;
    11264:  749:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
    11264:  750:            totals.evicted_active += itemstats[i].evicted_active;
    11264:  751:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
    11264:  752:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
    11264:  753:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
    11264:  754:            totals.moves_to_cold += itemstats[i].moves_to_cold;
    11264:  755:            totals.moves_to_warm += itemstats[i].moves_to_warm;
    11264:  756:            totals.moves_within_lru += itemstats[i].moves_within_lru;
    11264:  757:            totals.direct_reclaims += itemstats[i].direct_reclaims;
    11264:  758:            size += sizes[i];
    11264:  759:            lru_size_map[x] = sizes[i];
    11264:  760:            if (lru_type_map[x] == COLD_LRU && tails[i] != NULL) {
       12:  761:                age = current_time - tails[i]->time;
    11252:  762:            } else if (lru_type_map[x] == HOT_LRU && tails[i] != NULL) {
       36:  763:                age_hot = current_time - tails[i]->time;
    11216:  764:            } else if (lru_type_map[x] == WARM_LRU && tails[i] != NULL) {
        4:  765:                age_warm = current_time - tails[i]->time;
        -:  766:            }
    11264:  767:            if (lru_type_map[x] == COLD_LRU)
     2816:  768:                totals.evicted_time = itemstats[i].evicted_time;
    11264:  769:            switch (lru_type_map[x]) {
     2816:  770:                case HOT_LRU:
     2816:  771:                    totals.hits_to_hot = thread_stats.lru_hits[i];
     2816:  772:                    break;
     2816:  773:                case WARM_LRU:
     2816:  774:                    totals.hits_to_warm = thread_stats.lru_hits[i];
     2816:  775:                    break;
     2816:  776:                case COLD_LRU:
     2816:  777:                    totals.hits_to_cold = thread_stats.lru_hits[i];
     2816:  778:                    break;
     2816:  779:                case TEMP_LRU:
     2816:  780:                    totals.hits_to_temp = thread_stats.lru_hits[i];
     2816:  781:                    break;
        -:  782:            }
    11264:  783:            pthread_mutex_unlock(&lru_locks[i]);
        -:  784:        }
     2816:  785:        if (size == 0)
     2768:  786:            continue;
      144:  787:        APPEND_NUM_FMT_STAT(fmt, n, "number", "%u", size);
       48:  788:        if (settings.lru_maintainer_thread) {
      132:  789:            APPEND_NUM_FMT_STAT(fmt, n, "number_hot", "%u", lru_size_map[0]);
      132:  790:            APPEND_NUM_FMT_STAT(fmt, n, "number_warm", "%u", lru_size_map[1]);
      132:  791:            APPEND_NUM_FMT_STAT(fmt, n, "number_cold", "%u", lru_size_map[2]);
       44:  792:            if (settings.temp_lru) {
       24:  793:                APPEND_NUM_FMT_STAT(fmt, n, "number_temp", "%u", lru_size_map[3]);
        -:  794:            }
      132:  795:            APPEND_NUM_FMT_STAT(fmt, n, "age_hot", "%u", age_hot);
      132:  796:            APPEND_NUM_FMT_STAT(fmt, n, "age_warm", "%u", age_warm);
        -:  797:        }
      144:  798:        APPEND_NUM_FMT_STAT(fmt, n, "age", "%u", age);
      144:  799:        APPEND_NUM_FMT_STAT(fmt, n, "evicted",
       48:  800:                            "%llu", (unsigned long long)totals.evicted);
      144:  801:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_nonzero",
       48:  802:                            "%llu", (unsigned long long)totals.evicted_nonzero);
      144:  803:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_time",
       48:  804:                            "%u", totals.evicted_time);
      144:  805:        APPEND_NUM_FMT_STAT(fmt, n, "outofmemory",
       48:  806:                            "%llu", (unsigned long long)totals.outofmemory);
      144:  807:        APPEND_NUM_FMT_STAT(fmt, n, "tailrepairs",
       48:  808:                            "%llu", (unsigned long long)totals.tailrepairs);
      144:  809:        APPEND_NUM_FMT_STAT(fmt, n, "reclaimed",
       48:  810:                            "%llu", (unsigned long long)totals.reclaimed);
      144:  811:        APPEND_NUM_FMT_STAT(fmt, n, "expired_unfetched",
       48:  812:                            "%llu", (unsigned long long)totals.expired_unfetched);
      144:  813:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_unfetched",
       48:  814:                            "%llu", (unsigned long long)totals.evicted_unfetched);
       48:  815:        if (settings.lru_maintainer_thread) {
      132:  816:            APPEND_NUM_FMT_STAT(fmt, n, "evicted_active",
       48:  817:                                "%llu", (unsigned long long)totals.evicted_active);
        -:  818:        }
      144:  819:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_reclaimed",
       48:  820:                            "%llu", (unsigned long long)totals.crawler_reclaimed);
      144:  821:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_items_checked",
       48:  822:                            "%llu", (unsigned long long)totals.crawler_items_checked);
      144:  823:        APPEND_NUM_FMT_STAT(fmt, n, "lrutail_reflocked",
       48:  824:                            "%llu", (unsigned long long)totals.lrutail_reflocked);
       48:  825:        if (settings.lru_maintainer_thread) {
      132:  826:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_cold",
       44:  827:                                "%llu", (unsigned long long)totals.moves_to_cold);
      132:  828:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_warm",
       44:  829:                                "%llu", (unsigned long long)totals.moves_to_warm);
      132:  830:            APPEND_NUM_FMT_STAT(fmt, n, "moves_within_lru",
       44:  831:                                "%llu", (unsigned long long)totals.moves_within_lru);
      132:  832:            APPEND_NUM_FMT_STAT(fmt, n, "direct_reclaims",
       44:  833:                                "%llu", (unsigned long long)totals.direct_reclaims);
      132:  834:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_hot",
       44:  835:                                "%llu", (unsigned long long)totals.hits_to_hot);
        -:  836:
      132:  837:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_warm",
       44:  838:                                "%llu", (unsigned long long)totals.hits_to_warm);
        -:  839:
      132:  840:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_cold",
       44:  841:                                "%llu", (unsigned long long)totals.hits_to_cold);
        -:  842:
      132:  843:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_temp",
       48:  844:                                "%llu", (unsigned long long)totals.hits_to_temp);
        -:  845:
        -:  846:        }
        -:  847:    }
        -:  848:
        -:  849:    /* getting here means both ascii and binary terminators fit */
       44:  850:    add_stats(NULL, 0, NULL, 0, c);
       44:  851:}
------------------
item_stats:
       11:  722:void item_stats(ADD_STAT add_stats, void *c) {
       11:  723:    struct thread_stats thread_stats;
       11:  724:    threadlocal_stats_aggregate(&thread_stats);
       11:  725:    itemstats_t totals;
       11:  726:    int n;
      715:  727:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
      704:  728:        memset(&totals, 0, sizeof(itemstats_t));
      704:  729:        int x;
      704:  730:        int i;
      704:  731:        unsigned int size = 0;
      704:  732:        unsigned int age  = 0;
      704:  733:        unsigned int age_hot = 0;
      704:  734:        unsigned int age_warm = 0;
      704:  735:        unsigned int lru_size_map[4];
      704:  736:        const char *fmt = "items:%d:%s";
      704:  737:        char key_str[STAT_KEY_LEN];
      704:  738:        char val_str[STAT_VAL_LEN];
      704:  739:        int klen = 0, vlen = 0;
     3520:  740:        for (x = 0; x < 4; x++) {
     2816:  741:            i = n | lru_type_map[x];
     2816:  742:            pthread_mutex_lock(&lru_locks[i]);
     2816:  743:            totals.evicted += itemstats[i].evicted;
     2816:  744:            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
     2816:  745:            totals.outofmemory += itemstats[i].outofmemory;
     2816:  746:            totals.tailrepairs += itemstats[i].tailrepairs;
     2816:  747:            totals.reclaimed += itemstats[i].reclaimed;
     2816:  748:            totals.expired_unfetched += itemstats[i].expired_unfetched;
     2816:  749:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
     2816:  750:            totals.evicted_active += itemstats[i].evicted_active;
     2816:  751:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
     2816:  752:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
     2816:  753:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
     2816:  754:            totals.moves_to_cold += itemstats[i].moves_to_cold;
     2816:  755:            totals.moves_to_warm += itemstats[i].moves_to_warm;
     2816:  756:            totals.moves_within_lru += itemstats[i].moves_within_lru;
     2816:  757:            totals.direct_reclaims += itemstats[i].direct_reclaims;
     2816:  758:            size += sizes[i];
     2816:  759:            lru_size_map[x] = sizes[i];
     2816:  760:            if (lru_type_map[x] == COLD_LRU && tails[i] != NULL) {
        3:  761:                age = current_time - tails[i]->time;
     2813:  762:            } else if (lru_type_map[x] == HOT_LRU && tails[i] != NULL) {
        9:  763:                age_hot = current_time - tails[i]->time;
     2804:  764:            } else if (lru_type_map[x] == WARM_LRU && tails[i] != NULL) {
        1:  765:                age_warm = current_time - tails[i]->time;
        -:  766:            }
     2816:  767:            if (lru_type_map[x] == COLD_LRU)
      704:  768:                totals.evicted_time = itemstats[i].evicted_time;
     2816:  769:            switch (lru_type_map[x]) {
      704:  770:                case HOT_LRU:
      704:  771:                    totals.hits_to_hot = thread_stats.lru_hits[i];
      704:  772:                    break;
      704:  773:                case WARM_LRU:
      704:  774:                    totals.hits_to_warm = thread_stats.lru_hits[i];
      704:  775:                    break;
      704:  776:                case COLD_LRU:
      704:  777:                    totals.hits_to_cold = thread_stats.lru_hits[i];
      704:  778:                    break;
      704:  779:                case TEMP_LRU:
      704:  780:                    totals.hits_to_temp = thread_stats.lru_hits[i];
      704:  781:                    break;
        -:  782:            }
     2816:  783:            pthread_mutex_unlock(&lru_locks[i]);
        -:  784:        }
      704:  785:        if (size == 0)
      692:  786:            continue;
       36:  787:        APPEND_NUM_FMT_STAT(fmt, n, "number", "%u", size);
       12:  788:        if (settings.lru_maintainer_thread) {
       33:  789:            APPEND_NUM_FMT_STAT(fmt, n, "number_hot", "%u", lru_size_map[0]);
       33:  790:            APPEND_NUM_FMT_STAT(fmt, n, "number_warm", "%u", lru_size_map[1]);
       33:  791:            APPEND_NUM_FMT_STAT(fmt, n, "number_cold", "%u", lru_size_map[2]);
       11:  792:            if (settings.temp_lru) {
        6:  793:                APPEND_NUM_FMT_STAT(fmt, n, "number_temp", "%u", lru_size_map[3]);
        -:  794:            }
       33:  795:            APPEND_NUM_FMT_STAT(fmt, n, "age_hot", "%u", age_hot);
       33:  796:            APPEND_NUM_FMT_STAT(fmt, n, "age_warm", "%u", age_warm);
        -:  797:        }
       36:  798:        APPEND_NUM_FMT_STAT(fmt, n, "age", "%u", age);
       36:  799:        APPEND_NUM_FMT_STAT(fmt, n, "evicted",
       12:  800:                            "%llu", (unsigned long long)totals.evicted);
       36:  801:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_nonzero",
       12:  802:                            "%llu", (unsigned long long)totals.evicted_nonzero);
       36:  803:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_time",
       12:  804:                            "%u", totals.evicted_time);
       36:  805:        APPEND_NUM_FMT_STAT(fmt, n, "outofmemory",
       12:  806:                            "%llu", (unsigned long long)totals.outofmemory);
       36:  807:        APPEND_NUM_FMT_STAT(fmt, n, "tailrepairs",
       12:  808:                            "%llu", (unsigned long long)totals.tailrepairs);
       36:  809:        APPEND_NUM_FMT_STAT(fmt, n, "reclaimed",
       12:  810:                            "%llu", (unsigned long long)totals.reclaimed);
       36:  811:        APPEND_NUM_FMT_STAT(fmt, n, "expired_unfetched",
       12:  812:                            "%llu", (unsigned long long)totals.expired_unfetched);
       36:  813:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_unfetched",
       12:  814:                            "%llu", (unsigned long long)totals.evicted_unfetched);
       12:  815:        if (settings.lru_maintainer_thread) {
       33:  816:            APPEND_NUM_FMT_STAT(fmt, n, "evicted_active",
       12:  817:                                "%llu", (unsigned long long)totals.evicted_active);
        -:  818:        }
       36:  819:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_reclaimed",
       12:  820:                            "%llu", (unsigned long long)totals.crawler_reclaimed);
       36:  821:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_items_checked",
       12:  822:                            "%llu", (unsigned long long)totals.crawler_items_checked);
       36:  823:        APPEND_NUM_FMT_STAT(fmt, n, "lrutail_reflocked",
       12:  824:                            "%llu", (unsigned long long)totals.lrutail_reflocked);
       12:  825:        if (settings.lru_maintainer_thread) {
       33:  826:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_cold",
       11:  827:                                "%llu", (unsigned long long)totals.moves_to_cold);
       33:  828:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_warm",
       11:  829:                                "%llu", (unsigned long long)totals.moves_to_warm);
       33:  830:            APPEND_NUM_FMT_STAT(fmt, n, "moves_within_lru",
       11:  831:                                "%llu", (unsigned long long)totals.moves_within_lru);
       33:  832:            APPEND_NUM_FMT_STAT(fmt, n, "direct_reclaims",
       11:  833:                                "%llu", (unsigned long long)totals.direct_reclaims);
       33:  834:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_hot",
       11:  835:                                "%llu", (unsigned long long)totals.hits_to_hot);
        -:  836:
       33:  837:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_warm",
       11:  838:                                "%llu", (unsigned long long)totals.hits_to_warm);
        -:  839:
       33:  840:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_cold",
       11:  841:                                "%llu", (unsigned long long)totals.hits_to_cold);
        -:  842:
       33:  843:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_temp",
       12:  844:                                "%llu", (unsigned long long)totals.hits_to_temp);
        -:  845:
        -:  846:        }
        -:  847:    }
        -:  848:
        -:  849:    /* getting here means both ascii and binary terminators fit */
       11:  850:    add_stats(NULL, 0, NULL, 0, c);
       11:  851:}
------------------
item_stats:
       11:  722:void item_stats(ADD_STAT add_stats, void *c) {
       11:  723:    struct thread_stats thread_stats;
       11:  724:    threadlocal_stats_aggregate(&thread_stats);
       11:  725:    itemstats_t totals;
       11:  726:    int n;
      715:  727:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
      704:  728:        memset(&totals, 0, sizeof(itemstats_t));
      704:  729:        int x;
      704:  730:        int i;
      704:  731:        unsigned int size = 0;
      704:  732:        unsigned int age  = 0;
      704:  733:        unsigned int age_hot = 0;
      704:  734:        unsigned int age_warm = 0;
      704:  735:        unsigned int lru_size_map[4];
      704:  736:        const char *fmt = "items:%d:%s";
      704:  737:        char key_str[STAT_KEY_LEN];
      704:  738:        char val_str[STAT_VAL_LEN];
      704:  739:        int klen = 0, vlen = 0;
     3520:  740:        for (x = 0; x < 4; x++) {
     2816:  741:            i = n | lru_type_map[x];
     2816:  742:            pthread_mutex_lock(&lru_locks[i]);
     2816:  743:            totals.evicted += itemstats[i].evicted;
     2816:  744:            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
     2816:  745:            totals.outofmemory += itemstats[i].outofmemory;
     2816:  746:            totals.tailrepairs += itemstats[i].tailrepairs;
     2816:  747:            totals.reclaimed += itemstats[i].reclaimed;
     2816:  748:            totals.expired_unfetched += itemstats[i].expired_unfetched;
     2816:  749:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
     2816:  750:            totals.evicted_active += itemstats[i].evicted_active;
     2816:  751:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
     2816:  752:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
     2816:  753:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
     2816:  754:            totals.moves_to_cold += itemstats[i].moves_to_cold;
     2816:  755:            totals.moves_to_warm += itemstats[i].moves_to_warm;
     2816:  756:            totals.moves_within_lru += itemstats[i].moves_within_lru;
     2816:  757:            totals.direct_reclaims += itemstats[i].direct_reclaims;
     2816:  758:            size += sizes[i];
     2816:  759:            lru_size_map[x] = sizes[i];
     2816:  760:            if (lru_type_map[x] == COLD_LRU && tails[i] != NULL) {
        3:  761:                age = current_time - tails[i]->time;
     2813:  762:            } else if (lru_type_map[x] == HOT_LRU && tails[i] != NULL) {
        9:  763:                age_hot = current_time - tails[i]->time;
     2804:  764:            } else if (lru_type_map[x] == WARM_LRU && tails[i] != NULL) {
        1:  765:                age_warm = current_time - tails[i]->time;
        -:  766:            }
     2816:  767:            if (lru_type_map[x] == COLD_LRU)
      704:  768:                totals.evicted_time = itemstats[i].evicted_time;
     2816:  769:            switch (lru_type_map[x]) {
      704:  770:                case HOT_LRU:
      704:  771:                    totals.hits_to_hot = thread_stats.lru_hits[i];
      704:  772:                    break;
      704:  773:                case WARM_LRU:
      704:  774:                    totals.hits_to_warm = thread_stats.lru_hits[i];
      704:  775:                    break;
      704:  776:                case COLD_LRU:
      704:  777:                    totals.hits_to_cold = thread_stats.lru_hits[i];
      704:  778:                    break;
      704:  779:                case TEMP_LRU:
      704:  780:                    totals.hits_to_temp = thread_stats.lru_hits[i];
      704:  781:                    break;
        -:  782:            }
     2816:  783:            pthread_mutex_unlock(&lru_locks[i]);
        -:  784:        }
      704:  785:        if (size == 0)
      692:  786:            continue;
       36:  787:        APPEND_NUM_FMT_STAT(fmt, n, "number", "%u", size);
       12:  788:        if (settings.lru_maintainer_thread) {
       33:  789:            APPEND_NUM_FMT_STAT(fmt, n, "number_hot", "%u", lru_size_map[0]);
       33:  790:            APPEND_NUM_FMT_STAT(fmt, n, "number_warm", "%u", lru_size_map[1]);
       33:  791:            APPEND_NUM_FMT_STAT(fmt, n, "number_cold", "%u", lru_size_map[2]);
       11:  792:            if (settings.temp_lru) {
        6:  793:                APPEND_NUM_FMT_STAT(fmt, n, "number_temp", "%u", lru_size_map[3]);
        -:  794:            }
       33:  795:            APPEND_NUM_FMT_STAT(fmt, n, "age_hot", "%u", age_hot);
       33:  796:            APPEND_NUM_FMT_STAT(fmt, n, "age_warm", "%u", age_warm);
        -:  797:        }
       36:  798:        APPEND_NUM_FMT_STAT(fmt, n, "age", "%u", age);
       36:  799:        APPEND_NUM_FMT_STAT(fmt, n, "evicted",
       12:  800:                            "%llu", (unsigned long long)totals.evicted);
       36:  801:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_nonzero",
       12:  802:                            "%llu", (unsigned long long)totals.evicted_nonzero);
       36:  803:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_time",
       12:  804:                            "%u", totals.evicted_time);
       36:  805:        APPEND_NUM_FMT_STAT(fmt, n, "outofmemory",
       12:  806:                            "%llu", (unsigned long long)totals.outofmemory);
       36:  807:        APPEND_NUM_FMT_STAT(fmt, n, "tailrepairs",
       12:  808:                            "%llu", (unsigned long long)totals.tailrepairs);
       36:  809:        APPEND_NUM_FMT_STAT(fmt, n, "reclaimed",
       12:  810:                            "%llu", (unsigned long long)totals.reclaimed);
       36:  811:        APPEND_NUM_FMT_STAT(fmt, n, "expired_unfetched",
       12:  812:                            "%llu", (unsigned long long)totals.expired_unfetched);
       36:  813:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_unfetched",
       12:  814:                            "%llu", (unsigned long long)totals.evicted_unfetched);
       12:  815:        if (settings.lru_maintainer_thread) {
       33:  816:            APPEND_NUM_FMT_STAT(fmt, n, "evicted_active",
       12:  817:                                "%llu", (unsigned long long)totals.evicted_active);
        -:  818:        }
       36:  819:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_reclaimed",
       12:  820:                            "%llu", (unsigned long long)totals.crawler_reclaimed);
       36:  821:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_items_checked",
       12:  822:                            "%llu", (unsigned long long)totals.crawler_items_checked);
       36:  823:        APPEND_NUM_FMT_STAT(fmt, n, "lrutail_reflocked",
       12:  824:                            "%llu", (unsigned long long)totals.lrutail_reflocked);
       12:  825:        if (settings.lru_maintainer_thread) {
       33:  826:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_cold",
       11:  827:                                "%llu", (unsigned long long)totals.moves_to_cold);
       33:  828:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_warm",
       11:  829:                                "%llu", (unsigned long long)totals.moves_to_warm);
       33:  830:            APPEND_NUM_FMT_STAT(fmt, n, "moves_within_lru",
       11:  831:                                "%llu", (unsigned long long)totals.moves_within_lru);
       33:  832:            APPEND_NUM_FMT_STAT(fmt, n, "direct_reclaims",
       11:  833:                                "%llu", (unsigned long long)totals.direct_reclaims);
       33:  834:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_hot",
       11:  835:                                "%llu", (unsigned long long)totals.hits_to_hot);
        -:  836:
       33:  837:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_warm",
       11:  838:                                "%llu", (unsigned long long)totals.hits_to_warm);
        -:  839:
       33:  840:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_cold",
       11:  841:                                "%llu", (unsigned long long)totals.hits_to_cold);
        -:  842:
       33:  843:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_temp",
       12:  844:                                "%llu", (unsigned long long)totals.hits_to_temp);
        -:  845:
        -:  846:        }
        -:  847:    }
        -:  848:
        -:  849:    /* getting here means both ascii and binary terminators fit */
       11:  850:    add_stats(NULL, 0, NULL, 0, c);
       11:  851:}
------------------
item_stats:
       11:  722:void item_stats(ADD_STAT add_stats, void *c) {
       11:  723:    struct thread_stats thread_stats;
       11:  724:    threadlocal_stats_aggregate(&thread_stats);
       11:  725:    itemstats_t totals;
       11:  726:    int n;
      715:  727:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
      704:  728:        memset(&totals, 0, sizeof(itemstats_t));
      704:  729:        int x;
      704:  730:        int i;
      704:  731:        unsigned int size = 0;
      704:  732:        unsigned int age  = 0;
      704:  733:        unsigned int age_hot = 0;
      704:  734:        unsigned int age_warm = 0;
      704:  735:        unsigned int lru_size_map[4];
      704:  736:        const char *fmt = "items:%d:%s";
      704:  737:        char key_str[STAT_KEY_LEN];
      704:  738:        char val_str[STAT_VAL_LEN];
      704:  739:        int klen = 0, vlen = 0;
     3520:  740:        for (x = 0; x < 4; x++) {
     2816:  741:            i = n | lru_type_map[x];
     2816:  742:            pthread_mutex_lock(&lru_locks[i]);
     2816:  743:            totals.evicted += itemstats[i].evicted;
     2816:  744:            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
     2816:  745:            totals.outofmemory += itemstats[i].outofmemory;
     2816:  746:            totals.tailrepairs += itemstats[i].tailrepairs;
     2816:  747:            totals.reclaimed += itemstats[i].reclaimed;
     2816:  748:            totals.expired_unfetched += itemstats[i].expired_unfetched;
     2816:  749:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
     2816:  750:            totals.evicted_active += itemstats[i].evicted_active;
     2816:  751:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
     2816:  752:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
     2816:  753:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
     2816:  754:            totals.moves_to_cold += itemstats[i].moves_to_cold;
     2816:  755:            totals.moves_to_warm += itemstats[i].moves_to_warm;
     2816:  756:            totals.moves_within_lru += itemstats[i].moves_within_lru;
     2816:  757:            totals.direct_reclaims += itemstats[i].direct_reclaims;
     2816:  758:            size += sizes[i];
     2816:  759:            lru_size_map[x] = sizes[i];
     2816:  760:            if (lru_type_map[x] == COLD_LRU && tails[i] != NULL) {
        3:  761:                age = current_time - tails[i]->time;
     2813:  762:            } else if (lru_type_map[x] == HOT_LRU && tails[i] != NULL) {
        9:  763:                age_hot = current_time - tails[i]->time;
     2804:  764:            } else if (lru_type_map[x] == WARM_LRU && tails[i] != NULL) {
        1:  765:                age_warm = current_time - tails[i]->time;
        -:  766:            }
     2816:  767:            if (lru_type_map[x] == COLD_LRU)
      704:  768:                totals.evicted_time = itemstats[i].evicted_time;
     2816:  769:            switch (lru_type_map[x]) {
      704:  770:                case HOT_LRU:
      704:  771:                    totals.hits_to_hot = thread_stats.lru_hits[i];
      704:  772:                    break;
      704:  773:                case WARM_LRU:
      704:  774:                    totals.hits_to_warm = thread_stats.lru_hits[i];
      704:  775:                    break;
      704:  776:                case COLD_LRU:
      704:  777:                    totals.hits_to_cold = thread_stats.lru_hits[i];
      704:  778:                    break;
      704:  779:                case TEMP_LRU:
      704:  780:                    totals.hits_to_temp = thread_stats.lru_hits[i];
      704:  781:                    break;
        -:  782:            }
     2816:  783:            pthread_mutex_unlock(&lru_locks[i]);
        -:  784:        }
      704:  785:        if (size == 0)
      692:  786:            continue;
       36:  787:        APPEND_NUM_FMT_STAT(fmt, n, "number", "%u", size);
       12:  788:        if (settings.lru_maintainer_thread) {
       33:  789:            APPEND_NUM_FMT_STAT(fmt, n, "number_hot", "%u", lru_size_map[0]);
       33:  790:            APPEND_NUM_FMT_STAT(fmt, n, "number_warm", "%u", lru_size_map[1]);
       33:  791:            APPEND_NUM_FMT_STAT(fmt, n, "number_cold", "%u", lru_size_map[2]);
       11:  792:            if (settings.temp_lru) {
        6:  793:                APPEND_NUM_FMT_STAT(fmt, n, "number_temp", "%u", lru_size_map[3]);
        -:  794:            }
       33:  795:            APPEND_NUM_FMT_STAT(fmt, n, "age_hot", "%u", age_hot);
       33:  796:            APPEND_NUM_FMT_STAT(fmt, n, "age_warm", "%u", age_warm);
        -:  797:        }
       36:  798:        APPEND_NUM_FMT_STAT(fmt, n, "age", "%u", age);
       36:  799:        APPEND_NUM_FMT_STAT(fmt, n, "evicted",
       12:  800:                            "%llu", (unsigned long long)totals.evicted);
       36:  801:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_nonzero",
       12:  802:                            "%llu", (unsigned long long)totals.evicted_nonzero);
       36:  803:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_time",
       12:  804:                            "%u", totals.evicted_time);
       36:  805:        APPEND_NUM_FMT_STAT(fmt, n, "outofmemory",
       12:  806:                            "%llu", (unsigned long long)totals.outofmemory);
       36:  807:        APPEND_NUM_FMT_STAT(fmt, n, "tailrepairs",
       12:  808:                            "%llu", (unsigned long long)totals.tailrepairs);
       36:  809:        APPEND_NUM_FMT_STAT(fmt, n, "reclaimed",
       12:  810:                            "%llu", (unsigned long long)totals.reclaimed);
       36:  811:        APPEND_NUM_FMT_STAT(fmt, n, "expired_unfetched",
       12:  812:                            "%llu", (unsigned long long)totals.expired_unfetched);
       36:  813:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_unfetched",
       12:  814:                            "%llu", (unsigned long long)totals.evicted_unfetched);
       12:  815:        if (settings.lru_maintainer_thread) {
       33:  816:            APPEND_NUM_FMT_STAT(fmt, n, "evicted_active",
       12:  817:                                "%llu", (unsigned long long)totals.evicted_active);
        -:  818:        }
       36:  819:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_reclaimed",
       12:  820:                            "%llu", (unsigned long long)totals.crawler_reclaimed);
       36:  821:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_items_checked",
       12:  822:                            "%llu", (unsigned long long)totals.crawler_items_checked);
       36:  823:        APPEND_NUM_FMT_STAT(fmt, n, "lrutail_reflocked",
       12:  824:                            "%llu", (unsigned long long)totals.lrutail_reflocked);
       12:  825:        if (settings.lru_maintainer_thread) {
       33:  826:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_cold",
       11:  827:                                "%llu", (unsigned long long)totals.moves_to_cold);
       33:  828:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_warm",
       11:  829:                                "%llu", (unsigned long long)totals.moves_to_warm);
       33:  830:            APPEND_NUM_FMT_STAT(fmt, n, "moves_within_lru",
       11:  831:                                "%llu", (unsigned long long)totals.moves_within_lru);
       33:  832:            APPEND_NUM_FMT_STAT(fmt, n, "direct_reclaims",
       11:  833:                                "%llu", (unsigned long long)totals.direct_reclaims);
       33:  834:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_hot",
       11:  835:                                "%llu", (unsigned long long)totals.hits_to_hot);
        -:  836:
       33:  837:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_warm",
       11:  838:                                "%llu", (unsigned long long)totals.hits_to_warm);
        -:  839:
       33:  840:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_cold",
       11:  841:                                "%llu", (unsigned long long)totals.hits_to_cold);
        -:  842:
       33:  843:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_temp",
       12:  844:                                "%llu", (unsigned long long)totals.hits_to_temp);
        -:  845:
        -:  846:        }
        -:  847:    }
        -:  848:
        -:  849:    /* getting here means both ascii and binary terminators fit */
       11:  850:    add_stats(NULL, 0, NULL, 0, c);
       11:  851:}
------------------
item_stats:
       11:  722:void item_stats(ADD_STAT add_stats, void *c) {
       11:  723:    struct thread_stats thread_stats;
       11:  724:    threadlocal_stats_aggregate(&thread_stats);
       11:  725:    itemstats_t totals;
       11:  726:    int n;
      715:  727:    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
      704:  728:        memset(&totals, 0, sizeof(itemstats_t));
      704:  729:        int x;
      704:  730:        int i;
      704:  731:        unsigned int size = 0;
      704:  732:        unsigned int age  = 0;
      704:  733:        unsigned int age_hot = 0;
      704:  734:        unsigned int age_warm = 0;
      704:  735:        unsigned int lru_size_map[4];
      704:  736:        const char *fmt = "items:%d:%s";
      704:  737:        char key_str[STAT_KEY_LEN];
      704:  738:        char val_str[STAT_VAL_LEN];
      704:  739:        int klen = 0, vlen = 0;
     3520:  740:        for (x = 0; x < 4; x++) {
     2816:  741:            i = n | lru_type_map[x];
     2816:  742:            pthread_mutex_lock(&lru_locks[i]);
     2816:  743:            totals.evicted += itemstats[i].evicted;
     2816:  744:            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
     2816:  745:            totals.outofmemory += itemstats[i].outofmemory;
     2816:  746:            totals.tailrepairs += itemstats[i].tailrepairs;
     2816:  747:            totals.reclaimed += itemstats[i].reclaimed;
     2816:  748:            totals.expired_unfetched += itemstats[i].expired_unfetched;
     2816:  749:            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
     2816:  750:            totals.evicted_active += itemstats[i].evicted_active;
     2816:  751:            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
     2816:  752:            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
     2816:  753:            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
     2816:  754:            totals.moves_to_cold += itemstats[i].moves_to_cold;
     2816:  755:            totals.moves_to_warm += itemstats[i].moves_to_warm;
     2816:  756:            totals.moves_within_lru += itemstats[i].moves_within_lru;
     2816:  757:            totals.direct_reclaims += itemstats[i].direct_reclaims;
     2816:  758:            size += sizes[i];
     2816:  759:            lru_size_map[x] = sizes[i];
     2816:  760:            if (lru_type_map[x] == COLD_LRU && tails[i] != NULL) {
        3:  761:                age = current_time - tails[i]->time;
     2813:  762:            } else if (lru_type_map[x] == HOT_LRU && tails[i] != NULL) {
        9:  763:                age_hot = current_time - tails[i]->time;
     2804:  764:            } else if (lru_type_map[x] == WARM_LRU && tails[i] != NULL) {
        1:  765:                age_warm = current_time - tails[i]->time;
        -:  766:            }
     2816:  767:            if (lru_type_map[x] == COLD_LRU)
      704:  768:                totals.evicted_time = itemstats[i].evicted_time;
     2816:  769:            switch (lru_type_map[x]) {
      704:  770:                case HOT_LRU:
      704:  771:                    totals.hits_to_hot = thread_stats.lru_hits[i];
      704:  772:                    break;
      704:  773:                case WARM_LRU:
      704:  774:                    totals.hits_to_warm = thread_stats.lru_hits[i];
      704:  775:                    break;
      704:  776:                case COLD_LRU:
      704:  777:                    totals.hits_to_cold = thread_stats.lru_hits[i];
      704:  778:                    break;
      704:  779:                case TEMP_LRU:
      704:  780:                    totals.hits_to_temp = thread_stats.lru_hits[i];
      704:  781:                    break;
        -:  782:            }
     2816:  783:            pthread_mutex_unlock(&lru_locks[i]);
        -:  784:        }
      704:  785:        if (size == 0)
      692:  786:            continue;
       36:  787:        APPEND_NUM_FMT_STAT(fmt, n, "number", "%u", size);
       12:  788:        if (settings.lru_maintainer_thread) {
       33:  789:            APPEND_NUM_FMT_STAT(fmt, n, "number_hot", "%u", lru_size_map[0]);
       33:  790:            APPEND_NUM_FMT_STAT(fmt, n, "number_warm", "%u", lru_size_map[1]);
       33:  791:            APPEND_NUM_FMT_STAT(fmt, n, "number_cold", "%u", lru_size_map[2]);
       11:  792:            if (settings.temp_lru) {
        6:  793:                APPEND_NUM_FMT_STAT(fmt, n, "number_temp", "%u", lru_size_map[3]);
        -:  794:            }
       33:  795:            APPEND_NUM_FMT_STAT(fmt, n, "age_hot", "%u", age_hot);
       33:  796:            APPEND_NUM_FMT_STAT(fmt, n, "age_warm", "%u", age_warm);
        -:  797:        }
       36:  798:        APPEND_NUM_FMT_STAT(fmt, n, "age", "%u", age);
       36:  799:        APPEND_NUM_FMT_STAT(fmt, n, "evicted",
       12:  800:                            "%llu", (unsigned long long)totals.evicted);
       36:  801:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_nonzero",
       12:  802:                            "%llu", (unsigned long long)totals.evicted_nonzero);
       36:  803:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_time",
       12:  804:                            "%u", totals.evicted_time);
       36:  805:        APPEND_NUM_FMT_STAT(fmt, n, "outofmemory",
       12:  806:                            "%llu", (unsigned long long)totals.outofmemory);
       36:  807:        APPEND_NUM_FMT_STAT(fmt, n, "tailrepairs",
       12:  808:                            "%llu", (unsigned long long)totals.tailrepairs);
       36:  809:        APPEND_NUM_FMT_STAT(fmt, n, "reclaimed",
       12:  810:                            "%llu", (unsigned long long)totals.reclaimed);
       36:  811:        APPEND_NUM_FMT_STAT(fmt, n, "expired_unfetched",
       12:  812:                            "%llu", (unsigned long long)totals.expired_unfetched);
       36:  813:        APPEND_NUM_FMT_STAT(fmt, n, "evicted_unfetched",
       12:  814:                            "%llu", (unsigned long long)totals.evicted_unfetched);
       12:  815:        if (settings.lru_maintainer_thread) {
       33:  816:            APPEND_NUM_FMT_STAT(fmt, n, "evicted_active",
       12:  817:                                "%llu", (unsigned long long)totals.evicted_active);
        -:  818:        }
       36:  819:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_reclaimed",
       12:  820:                            "%llu", (unsigned long long)totals.crawler_reclaimed);
       36:  821:        APPEND_NUM_FMT_STAT(fmt, n, "crawler_items_checked",
       12:  822:                            "%llu", (unsigned long long)totals.crawler_items_checked);
       36:  823:        APPEND_NUM_FMT_STAT(fmt, n, "lrutail_reflocked",
       12:  824:                            "%llu", (unsigned long long)totals.lrutail_reflocked);
       12:  825:        if (settings.lru_maintainer_thread) {
       33:  826:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_cold",
       11:  827:                                "%llu", (unsigned long long)totals.moves_to_cold);
       33:  828:            APPEND_NUM_FMT_STAT(fmt, n, "moves_to_warm",
       11:  829:                                "%llu", (unsigned long long)totals.moves_to_warm);
       33:  830:            APPEND_NUM_FMT_STAT(fmt, n, "moves_within_lru",
       11:  831:                                "%llu", (unsigned long long)totals.moves_within_lru);
       33:  832:            APPEND_NUM_FMT_STAT(fmt, n, "direct_reclaims",
       11:  833:                                "%llu", (unsigned long long)totals.direct_reclaims);
       33:  834:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_hot",
       11:  835:                                "%llu", (unsigned long long)totals.hits_to_hot);
        -:  836:
       33:  837:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_warm",
       11:  838:                                "%llu", (unsigned long long)totals.hits_to_warm);
        -:  839:
       33:  840:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_cold",
       11:  841:                                "%llu", (unsigned long long)totals.hits_to_cold);
        -:  842:
       33:  843:            APPEND_NUM_FMT_STAT(fmt, n, "hits_to_temp",
       12:  844:                                "%llu", (unsigned long long)totals.hits_to_temp);
        -:  845:
        -:  846:        }
        -:  847:    }
        -:  848:
        -:  849:    /* getting here means both ascii and binary terminators fit */
       11:  850:    add_stats(NULL, 0, NULL, 0, c);
       11:  851:}
------------------
        -:  852:
       72:  853:bool item_stats_sizes_status(void) {
       72:  854:    bool ret = false;
       72:  855:    mutex_lock(&stats_sizes_lock);
       72:  856:    if (stats_sizes_hist != NULL)
    #####:  857:        ret = true;
       72:  858:    mutex_unlock(&stats_sizes_lock);
       72:  859:    return ret;
        -:  860:}
------------------
item_stats_sizes_status:
       18:  853:bool item_stats_sizes_status(void) {
       18:  854:    bool ret = false;
       18:  855:    mutex_lock(&stats_sizes_lock);
       18:  856:    if (stats_sizes_hist != NULL)
    #####:  857:        ret = true;
       18:  858:    mutex_unlock(&stats_sizes_lock);
       18:  859:    return ret;
        -:  860:}
------------------
item_stats_sizes_status:
       18:  853:bool item_stats_sizes_status(void) {
       18:  854:    bool ret = false;
       18:  855:    mutex_lock(&stats_sizes_lock);
       18:  856:    if (stats_sizes_hist != NULL)
    #####:  857:        ret = true;
       18:  858:    mutex_unlock(&stats_sizes_lock);
       18:  859:    return ret;
        -:  860:}
------------------
item_stats_sizes_status:
       18:  853:bool item_stats_sizes_status(void) {
       18:  854:    bool ret = false;
       18:  855:    mutex_lock(&stats_sizes_lock);
       18:  856:    if (stats_sizes_hist != NULL)
    #####:  857:        ret = true;
       18:  858:    mutex_unlock(&stats_sizes_lock);
       18:  859:    return ret;
        -:  860:}
------------------
item_stats_sizes_status:
       18:  853:bool item_stats_sizes_status(void) {
       18:  854:    bool ret = false;
       18:  855:    mutex_lock(&stats_sizes_lock);
       18:  856:    if (stats_sizes_hist != NULL)
    #####:  857:        ret = true;
       18:  858:    mutex_unlock(&stats_sizes_lock);
       18:  859:    return ret;
        -:  860:}
------------------
        -:  861:
    #####:  862:void item_stats_sizes_init(void) {
    #####:  863:    if (stats_sizes_hist != NULL)
        -:  864:        return;
    #####:  865:    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    #####:  866:    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    #####:  867:    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
        -:  868:}
------------------
item_stats_sizes_init:
    #####:  862:void item_stats_sizes_init(void) {
    #####:  863:    if (stats_sizes_hist != NULL)
        -:  864:        return;
    #####:  865:    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    #####:  866:    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    #####:  867:    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
        -:  868:}
------------------
item_stats_sizes_init:
    #####:  862:void item_stats_sizes_init(void) {
    #####:  863:    if (stats_sizes_hist != NULL)
        -:  864:        return;
    #####:  865:    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    #####:  866:    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    #####:  867:    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
        -:  868:}
------------------
item_stats_sizes_init:
    #####:  862:void item_stats_sizes_init(void) {
    #####:  863:    if (stats_sizes_hist != NULL)
        -:  864:        return;
    #####:  865:    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    #####:  866:    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    #####:  867:    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
        -:  868:}
------------------
item_stats_sizes_init:
    #####:  862:void item_stats_sizes_init(void) {
    #####:  863:    if (stats_sizes_hist != NULL)
        -:  864:        return;
    #####:  865:    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    #####:  866:    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    #####:  867:    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
        -:  868:}
------------------
        -:  869:
    #####:  870:void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    #####:  871:    mutex_lock(&stats_sizes_lock);
    #####:  872:    if (!settings.use_cas) {
    #####:  873:        APPEND_STAT("sizes_status", "error", "");
    #####:  874:        APPEND_STAT("sizes_error", "cas_support_disabled", "");
    #####:  875:    } else if (stats_sizes_hist == NULL) {
    #####:  876:        item_stats_sizes_init();
    #####:  877:        if (stats_sizes_hist != NULL) {
    #####:  878:            APPEND_STAT("sizes_status", "enabled", "");
        -:  879:        } else {
    #####:  880:            APPEND_STAT("sizes_status", "error", "");
    #####:  881:            APPEND_STAT("sizes_error", "no_memory", "");
        -:  882:        }
        -:  883:    } else {
    #####:  884:        APPEND_STAT("sizes_status", "enabled", "");
        -:  885:    }
    #####:  886:    mutex_unlock(&stats_sizes_lock);
    #####:  887:}
------------------
item_stats_sizes_enable:
    #####:  870:void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    #####:  871:    mutex_lock(&stats_sizes_lock);
    #####:  872:    if (!settings.use_cas) {
    #####:  873:        APPEND_STAT("sizes_status", "error", "");
    #####:  874:        APPEND_STAT("sizes_error", "cas_support_disabled", "");
    #####:  875:    } else if (stats_sizes_hist == NULL) {
    #####:  876:        item_stats_sizes_init();
    #####:  877:        if (stats_sizes_hist != NULL) {
    #####:  878:            APPEND_STAT("sizes_status", "enabled", "");
        -:  879:        } else {
    #####:  880:            APPEND_STAT("sizes_status", "error", "");
    #####:  881:            APPEND_STAT("sizes_error", "no_memory", "");
        -:  882:        }
        -:  883:    } else {
    #####:  884:        APPEND_STAT("sizes_status", "enabled", "");
        -:  885:    }
    #####:  886:    mutex_unlock(&stats_sizes_lock);
    #####:  887:}
------------------
item_stats_sizes_enable:
    #####:  870:void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    #####:  871:    mutex_lock(&stats_sizes_lock);
    #####:  872:    if (!settings.use_cas) {
    #####:  873:        APPEND_STAT("sizes_status", "error", "");
    #####:  874:        APPEND_STAT("sizes_error", "cas_support_disabled", "");
    #####:  875:    } else if (stats_sizes_hist == NULL) {
    #####:  876:        item_stats_sizes_init();
    #####:  877:        if (stats_sizes_hist != NULL) {
    #####:  878:            APPEND_STAT("sizes_status", "enabled", "");
        -:  879:        } else {
    #####:  880:            APPEND_STAT("sizes_status", "error", "");
    #####:  881:            APPEND_STAT("sizes_error", "no_memory", "");
        -:  882:        }
        -:  883:    } else {
    #####:  884:        APPEND_STAT("sizes_status", "enabled", "");
        -:  885:    }
    #####:  886:    mutex_unlock(&stats_sizes_lock);
    #####:  887:}
------------------
item_stats_sizes_enable:
    #####:  870:void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    #####:  871:    mutex_lock(&stats_sizes_lock);
    #####:  872:    if (!settings.use_cas) {
    #####:  873:        APPEND_STAT("sizes_status", "error", "");
    #####:  874:        APPEND_STAT("sizes_error", "cas_support_disabled", "");
    #####:  875:    } else if (stats_sizes_hist == NULL) {
    #####:  876:        item_stats_sizes_init();
    #####:  877:        if (stats_sizes_hist != NULL) {
    #####:  878:            APPEND_STAT("sizes_status", "enabled", "");
        -:  879:        } else {
    #####:  880:            APPEND_STAT("sizes_status", "error", "");
    #####:  881:            APPEND_STAT("sizes_error", "no_memory", "");
        -:  882:        }
        -:  883:    } else {
    #####:  884:        APPEND_STAT("sizes_status", "enabled", "");
        -:  885:    }
    #####:  886:    mutex_unlock(&stats_sizes_lock);
    #####:  887:}
------------------
item_stats_sizes_enable:
    #####:  870:void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    #####:  871:    mutex_lock(&stats_sizes_lock);
    #####:  872:    if (!settings.use_cas) {
    #####:  873:        APPEND_STAT("sizes_status", "error", "");
    #####:  874:        APPEND_STAT("sizes_error", "cas_support_disabled", "");
    #####:  875:    } else if (stats_sizes_hist == NULL) {
    #####:  876:        item_stats_sizes_init();
    #####:  877:        if (stats_sizes_hist != NULL) {
    #####:  878:            APPEND_STAT("sizes_status", "enabled", "");
        -:  879:        } else {
    #####:  880:            APPEND_STAT("sizes_status", "error", "");
    #####:  881:            APPEND_STAT("sizes_error", "no_memory", "");
        -:  882:        }
        -:  883:    } else {
    #####:  884:        APPEND_STAT("sizes_status", "enabled", "");
        -:  885:    }
    #####:  886:    mutex_unlock(&stats_sizes_lock);
    #####:  887:}
------------------
        -:  888:
    #####:  889:void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    #####:  890:    mutex_lock(&stats_sizes_lock);
    #####:  891:    if (stats_sizes_hist != NULL) {
    #####:  892:        free(stats_sizes_hist);
    #####:  893:        stats_sizes_hist = NULL;
        -:  894:    }
    #####:  895:    APPEND_STAT("sizes_status", "disabled", "");
    #####:  896:    mutex_unlock(&stats_sizes_lock);
    #####:  897:}
------------------
item_stats_sizes_disable:
    #####:  889:void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    #####:  890:    mutex_lock(&stats_sizes_lock);
    #####:  891:    if (stats_sizes_hist != NULL) {
    #####:  892:        free(stats_sizes_hist);
    #####:  893:        stats_sizes_hist = NULL;
        -:  894:    }
    #####:  895:    APPEND_STAT("sizes_status", "disabled", "");
    #####:  896:    mutex_unlock(&stats_sizes_lock);
    #####:  897:}
------------------
item_stats_sizes_disable:
    #####:  889:void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    #####:  890:    mutex_lock(&stats_sizes_lock);
    #####:  891:    if (stats_sizes_hist != NULL) {
    #####:  892:        free(stats_sizes_hist);
    #####:  893:        stats_sizes_hist = NULL;
        -:  894:    }
    #####:  895:    APPEND_STAT("sizes_status", "disabled", "");
    #####:  896:    mutex_unlock(&stats_sizes_lock);
    #####:  897:}
------------------
item_stats_sizes_disable:
    #####:  889:void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    #####:  890:    mutex_lock(&stats_sizes_lock);
    #####:  891:    if (stats_sizes_hist != NULL) {
    #####:  892:        free(stats_sizes_hist);
    #####:  893:        stats_sizes_hist = NULL;
        -:  894:    }
    #####:  895:    APPEND_STAT("sizes_status", "disabled", "");
    #####:  896:    mutex_unlock(&stats_sizes_lock);
    #####:  897:}
------------------
item_stats_sizes_disable:
    #####:  889:void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    #####:  890:    mutex_lock(&stats_sizes_lock);
    #####:  891:    if (stats_sizes_hist != NULL) {
    #####:  892:        free(stats_sizes_hist);
    #####:  893:        stats_sizes_hist = NULL;
        -:  894:    }
    #####:  895:    APPEND_STAT("sizes_status", "disabled", "");
    #####:  896:    mutex_unlock(&stats_sizes_lock);
    #####:  897:}
------------------
        -:  898:
   417192:  899:void item_stats_sizes_add(item *it) {
  417192*:  900:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  901:        return;
    #####:  902:    int ntotal = ITEM_ntotal(it);
    #####:  903:    int bucket = ntotal / 32;
    #####:  904:    if ((ntotal % 32) != 0) bucket++;
    #####:  905:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
        -:  906:}
------------------
item_stats_sizes_add:
   104298:  899:void item_stats_sizes_add(item *it) {
  104298*:  900:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  901:        return;
    #####:  902:    int ntotal = ITEM_ntotal(it);
    #####:  903:    int bucket = ntotal / 32;
    #####:  904:    if ((ntotal % 32) != 0) bucket++;
    #####:  905:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
        -:  906:}
------------------
item_stats_sizes_add:
   104298:  899:void item_stats_sizes_add(item *it) {
  104298*:  900:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  901:        return;
    #####:  902:    int ntotal = ITEM_ntotal(it);
    #####:  903:    int bucket = ntotal / 32;
    #####:  904:    if ((ntotal % 32) != 0) bucket++;
    #####:  905:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
        -:  906:}
------------------
item_stats_sizes_add:
   104298:  899:void item_stats_sizes_add(item *it) {
  104298*:  900:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  901:        return;
    #####:  902:    int ntotal = ITEM_ntotal(it);
    #####:  903:    int bucket = ntotal / 32;
    #####:  904:    if ((ntotal % 32) != 0) bucket++;
    #####:  905:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
        -:  906:}
------------------
item_stats_sizes_add:
   104298:  899:void item_stats_sizes_add(item *it) {
  104298*:  900:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  901:        return;
    #####:  902:    int ntotal = ITEM_ntotal(it);
    #####:  903:    int bucket = ntotal / 32;
    #####:  904:    if ((ntotal % 32) != 0) bucket++;
    #####:  905:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
        -:  906:}
------------------
        -:  907:
        -:  908:/* I think there's no way for this to be accurate without using the CAS value.
        -:  909: * Since items getting their time value bumped will pass this validation.
        -:  910: */
   259904:  911:void item_stats_sizes_remove(item *it) {
  259904*:  912:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  913:        return;
    #####:  914:    int ntotal = ITEM_ntotal(it);
    #####:  915:    int bucket = ntotal / 32;
    #####:  916:    if ((ntotal % 32) != 0) bucket++;
    #####:  917:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
        -:  918:}
------------------
item_stats_sizes_remove:
    64976:  911:void item_stats_sizes_remove(item *it) {
   64976*:  912:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  913:        return;
    #####:  914:    int ntotal = ITEM_ntotal(it);
    #####:  915:    int bucket = ntotal / 32;
    #####:  916:    if ((ntotal % 32) != 0) bucket++;
    #####:  917:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
        -:  918:}
------------------
item_stats_sizes_remove:
    64976:  911:void item_stats_sizes_remove(item *it) {
   64976*:  912:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  913:        return;
    #####:  914:    int ntotal = ITEM_ntotal(it);
    #####:  915:    int bucket = ntotal / 32;
    #####:  916:    if ((ntotal % 32) != 0) bucket++;
    #####:  917:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
        -:  918:}
------------------
item_stats_sizes_remove:
    64976:  911:void item_stats_sizes_remove(item *it) {
   64976*:  912:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  913:        return;
    #####:  914:    int ntotal = ITEM_ntotal(it);
    #####:  915:    int bucket = ntotal / 32;
    #####:  916:    if ((ntotal % 32) != 0) bucket++;
    #####:  917:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
        -:  918:}
------------------
item_stats_sizes_remove:
    64976:  911:void item_stats_sizes_remove(item *it) {
   64976*:  912:    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        -:  913:        return;
    #####:  914:    int ntotal = ITEM_ntotal(it);
    #####:  915:    int bucket = ntotal / 32;
    #####:  916:    if ((ntotal % 32) != 0) bucket++;
    #####:  917:    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
        -:  918:}
------------------
        -:  919:
        -:  920:/** dumps out a list of objects of each size, with granularity of 32 bytes */
        -:  921:/*@null@*/
        -:  922:/* Locks are correct based on a technicality. Holds LRU lock while doing the
        -:  923: * work, so items can't go invalid, and it's only looking at header sizes
        -:  924: * which don't change.
        -:  925: */
    #####:  926:void item_stats_sizes(ADD_STAT add_stats, void *c) {
    #####:  927:    mutex_lock(&stats_sizes_lock);
        -:  928:
    #####:  929:    if (stats_sizes_hist != NULL) {
        -:  930:        int i;
    #####:  931:        for (i = 0; i < stats_sizes_buckets; i++) {
    #####:  932:            if (stats_sizes_hist[i] != 0) {
    #####:  933:                char key[12];
    #####:  934:                snprintf(key, sizeof(key), "%d", i * 32);
    #####:  935:                APPEND_STAT(key, "%u", stats_sizes_hist[i]);
        -:  936:            }
        -:  937:        }
        -:  938:    } else {
    #####:  939:        APPEND_STAT("sizes_status", "disabled", "");
        -:  940:    }
        -:  941:
    #####:  942:    add_stats(NULL, 0, NULL, 0, c);
    #####:  943:    mutex_unlock(&stats_sizes_lock);
    #####:  944:}
------------------
item_stats_sizes:
    #####:  926:void item_stats_sizes(ADD_STAT add_stats, void *c) {
    #####:  927:    mutex_lock(&stats_sizes_lock);
        -:  928:
    #####:  929:    if (stats_sizes_hist != NULL) {
        -:  930:        int i;
    #####:  931:        for (i = 0; i < stats_sizes_buckets; i++) {
    #####:  932:            if (stats_sizes_hist[i] != 0) {
    #####:  933:                char key[12];
    #####:  934:                snprintf(key, sizeof(key), "%d", i * 32);
    #####:  935:                APPEND_STAT(key, "%u", stats_sizes_hist[i]);
        -:  936:            }
        -:  937:        }
        -:  938:    } else {
    #####:  939:        APPEND_STAT("sizes_status", "disabled", "");
        -:  940:    }
        -:  941:
    #####:  942:    add_stats(NULL, 0, NULL, 0, c);
    #####:  943:    mutex_unlock(&stats_sizes_lock);
    #####:  944:}
------------------
item_stats_sizes:
    #####:  926:void item_stats_sizes(ADD_STAT add_stats, void *c) {
    #####:  927:    mutex_lock(&stats_sizes_lock);
        -:  928:
    #####:  929:    if (stats_sizes_hist != NULL) {
        -:  930:        int i;
    #####:  931:        for (i = 0; i < stats_sizes_buckets; i++) {
    #####:  932:            if (stats_sizes_hist[i] != 0) {
    #####:  933:                char key[12];
    #####:  934:                snprintf(key, sizeof(key), "%d", i * 32);
    #####:  935:                APPEND_STAT(key, "%u", stats_sizes_hist[i]);
        -:  936:            }
        -:  937:        }
        -:  938:    } else {
    #####:  939:        APPEND_STAT("sizes_status", "disabled", "");
        -:  940:    }
        -:  941:
    #####:  942:    add_stats(NULL, 0, NULL, 0, c);
    #####:  943:    mutex_unlock(&stats_sizes_lock);
    #####:  944:}
------------------
item_stats_sizes:
    #####:  926:void item_stats_sizes(ADD_STAT add_stats, void *c) {
    #####:  927:    mutex_lock(&stats_sizes_lock);
        -:  928:
    #####:  929:    if (stats_sizes_hist != NULL) {
        -:  930:        int i;
    #####:  931:        for (i = 0; i < stats_sizes_buckets; i++) {
    #####:  932:            if (stats_sizes_hist[i] != 0) {
    #####:  933:                char key[12];
    #####:  934:                snprintf(key, sizeof(key), "%d", i * 32);
    #####:  935:                APPEND_STAT(key, "%u", stats_sizes_hist[i]);
        -:  936:            }
        -:  937:        }
        -:  938:    } else {
    #####:  939:        APPEND_STAT("sizes_status", "disabled", "");
        -:  940:    }
        -:  941:
    #####:  942:    add_stats(NULL, 0, NULL, 0, c);
    #####:  943:    mutex_unlock(&stats_sizes_lock);
    #####:  944:}
------------------
item_stats_sizes:
    #####:  926:void item_stats_sizes(ADD_STAT add_stats, void *c) {
    #####:  927:    mutex_lock(&stats_sizes_lock);
        -:  928:
    #####:  929:    if (stats_sizes_hist != NULL) {
        -:  930:        int i;
    #####:  931:        for (i = 0; i < stats_sizes_buckets; i++) {
    #####:  932:            if (stats_sizes_hist[i] != 0) {
    #####:  933:                char key[12];
    #####:  934:                snprintf(key, sizeof(key), "%d", i * 32);
    #####:  935:                APPEND_STAT(key, "%u", stats_sizes_hist[i]);
        -:  936:            }
        -:  937:        }
        -:  938:    } else {
    #####:  939:        APPEND_STAT("sizes_status", "disabled", "");
        -:  940:    }
        -:  941:
    #####:  942:    add_stats(NULL, 0, NULL, 0, c);
    #####:  943:    mutex_unlock(&stats_sizes_lock);
    #####:  944:}
------------------
        -:  945:
        -:  946:/** wrapper around assoc_find which does the lazy expiration logic */
   879900:  947:item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
   879900:  948:    item *it = assoc_find(key, nkey, hv);
   879900:  949:    if (it != NULL) {
   284176:  950:        refcount_incr(it);
        -:  951:        /* Optimization for slab reassignment. prevents popular items from
        -:  952:         * jamming in busy wait. Can only do this here to satisfy lock order
        -:  953:         * of item_lock, slabs_lock. */
        -:  954:        /* This was made unsafe by removal of the cache_lock:
        -:  955:         * slab_rebalance_signal and slab_rebal.* are modified in a separate
        -:  956:         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
        -:  957:         * NULL (0), but slab_end is still equal to some value, this would end
        -:  958:         * up unlinking every item fetched.
        -:  959:         * This is either an acceptable loss, or if slab_rebalance_signal is
        -:  960:         * true, slab_start/slab_end should be put behind the slabs_lock.
        -:  961:         * Which would cause a huge potential slowdown.
        -:  962:         * Could also use a specific lock for slab_rebal.* and
        -:  963:         * slab_rebalance_signal (shorter lock?)
        -:  964:         */
        -:  965:        /*if (slab_rebalance_signal &&
        -:  966:            ((void *)it >= slab_rebal.slab_start && (void *)it < slab_rebal.slab_end)) {
        -:  967:            do_item_unlink(it, hv);
        -:  968:            do_item_remove(it);
        -:  969:            it = NULL;
        -:  970:        }*/
        -:  971:    }
   879900:  972:    int was_found = 0;
        -:  973:
   879900:  974:    if (settings.verbose > 2) {
    #####:  975:        int ii;
    #####:  976:        if (it == NULL) {
    #####:  977:            fprintf(stderr, "> NOT FOUND ");
        -:  978:        } else {
    #####:  979:            fprintf(stderr, "> FOUND KEY ");
        -:  980:        }
    #####:  981:        for (ii = 0; ii < nkey; ++ii) {
    #####:  982:            fprintf(stderr, "%c", key[ii]);
        -:  983:        }
        -:  984:    }
        -:  985:
   879900:  986:    if (it != NULL) {
   284176:  987:        was_found = 1;
   284176:  988:        if (item_is_flushed(it)) {
      272:  989:            do_item_unlink(it, hv);
      272:  990:            STORAGE_delete(c->thread->storage, it);
      272:  991:            do_item_remove(it);
      272:  992:            it = NULL;
      272:  993:            pthread_mutex_lock(&c->thread->stats.mutex);
      272:  994:            c->thread->stats.get_flushed++;
      272:  995:            pthread_mutex_unlock(&c->thread->stats.mutex);
      272:  996:            if (settings.verbose > 2) {
    #####:  997:                fprintf(stderr, " -nuked by flush");
        -:  998:            }
        -:  999:            was_found = 2;
   283904: 1000:        } else if (it->exptime != 0 && it->exptime <= current_time) {
       28: 1001:            do_item_unlink(it, hv);
       28: 1002:            STORAGE_delete(c->thread->storage, it);
       28: 1003:            do_item_remove(it);
       28: 1004:            it = NULL;
       28: 1005:            pthread_mutex_lock(&c->thread->stats.mutex);
       28: 1006:            c->thread->stats.get_expired++;
       28: 1007:            pthread_mutex_unlock(&c->thread->stats.mutex);
       28: 1008:            if (settings.verbose > 2) {
    #####: 1009:                fprintf(stderr, " -nuked by expire");
        -: 1010:            }
        -: 1011:            was_found = 3;
        -: 1012:        } else {
   283876: 1013:            if (do_update) {
        -: 1014:                /* We update the hit markers only during fetches.
        -: 1015:                 * An item needs to be hit twice overall to be considered
        -: 1016:                 * ACTIVE, but only needs a single hit to maintain activity
        -: 1017:                 * afterward.
        -: 1018:                 * FETCHED tells if an item has ever been active.
        -: 1019:                 */
   128852: 1020:                if (settings.lru_segmented) {
   125624: 1021:                    if ((it->it_flags & ITEM_ACTIVE) == 0) {
   125460: 1022:                        if ((it->it_flags & ITEM_FETCHED) == 0) {
   125356: 1023:                            it->it_flags |= ITEM_FETCHED;
        -: 1024:                        } else {
      104: 1025:                            it->it_flags |= ITEM_ACTIVE;
      104: 1026:                            if (ITEM_lruid(it) != COLD_LRU) {
       60: 1027:                                do_item_update(it); // bump LA time
       44: 1028:                            } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
        -: 1029:                                // add flag before async bump to avoid race.
    #####: 1030:                                it->it_flags &= ~ITEM_ACTIVE;
        -: 1031:                            }
        -: 1032:                        }
        -: 1033:                    }
        -: 1034:                } else {
     3228: 1035:                    it->it_flags |= ITEM_FETCHED;
     3228: 1036:                    do_item_update(it);
        -: 1037:                }
        -: 1038:            }
   879900: 1039:            DEBUG_REFCNT(it, '+');
        -: 1040:        }
        -: 1041:    }
        -: 1042:
   879900: 1043:    if (settings.verbose > 2)
    #####: 1044:        fprintf(stderr, "\n");
        -: 1045:    /* For now this is in addition to the above verbose logging. */
  879900*: 1046:    LOGGER_LOG(c->thread->l, LOG_FETCHERS, LOGGER_ITEM_GET, NULL, was_found, key, nkey,
        -: 1047:               (it) ? ITEM_clsid(it) : 0);
        -: 1048:
   879900: 1049:    return it;
        -: 1050:}
------------------
do_item_get:
   219975:  947:item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
   219975:  948:    item *it = assoc_find(key, nkey, hv);
   219975:  949:    if (it != NULL) {
    71044:  950:        refcount_incr(it);
        -:  951:        /* Optimization for slab reassignment. prevents popular items from
        -:  952:         * jamming in busy wait. Can only do this here to satisfy lock order
        -:  953:         * of item_lock, slabs_lock. */
        -:  954:        /* This was made unsafe by removal of the cache_lock:
        -:  955:         * slab_rebalance_signal and slab_rebal.* are modified in a separate
        -:  956:         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
        -:  957:         * NULL (0), but slab_end is still equal to some value, this would end
        -:  958:         * up unlinking every item fetched.
        -:  959:         * This is either an acceptable loss, or if slab_rebalance_signal is
        -:  960:         * true, slab_start/slab_end should be put behind the slabs_lock.
        -:  961:         * Which would cause a huge potential slowdown.
        -:  962:         * Could also use a specific lock for slab_rebal.* and
        -:  963:         * slab_rebalance_signal (shorter lock?)
        -:  964:         */
        -:  965:        /*if (slab_rebalance_signal &&
        -:  966:            ((void *)it >= slab_rebal.slab_start && (void *)it < slab_rebal.slab_end)) {
        -:  967:            do_item_unlink(it, hv);
        -:  968:            do_item_remove(it);
        -:  969:            it = NULL;
        -:  970:        }*/
        -:  971:    }
   219975:  972:    int was_found = 0;
        -:  973:
   219975:  974:    if (settings.verbose > 2) {
    #####:  975:        int ii;
    #####:  976:        if (it == NULL) {
    #####:  977:            fprintf(stderr, "> NOT FOUND ");
        -:  978:        } else {
    #####:  979:            fprintf(stderr, "> FOUND KEY ");
        -:  980:        }
    #####:  981:        for (ii = 0; ii < nkey; ++ii) {
    #####:  982:            fprintf(stderr, "%c", key[ii]);
        -:  983:        }
        -:  984:    }
        -:  985:
   219975:  986:    if (it != NULL) {
    71044:  987:        was_found = 1;
    71044:  988:        if (item_is_flushed(it)) {
       68:  989:            do_item_unlink(it, hv);
       68:  990:            STORAGE_delete(c->thread->storage, it);
       68:  991:            do_item_remove(it);
       68:  992:            it = NULL;
       68:  993:            pthread_mutex_lock(&c->thread->stats.mutex);
       68:  994:            c->thread->stats.get_flushed++;
       68:  995:            pthread_mutex_unlock(&c->thread->stats.mutex);
       68:  996:            if (settings.verbose > 2) {
    #####:  997:                fprintf(stderr, " -nuked by flush");
        -:  998:            }
        -:  999:            was_found = 2;
    70976: 1000:        } else if (it->exptime != 0 && it->exptime <= current_time) {
        7: 1001:            do_item_unlink(it, hv);
        7: 1002:            STORAGE_delete(c->thread->storage, it);
        7: 1003:            do_item_remove(it);
        7: 1004:            it = NULL;
        7: 1005:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 1006:            c->thread->stats.get_expired++;
        7: 1007:            pthread_mutex_unlock(&c->thread->stats.mutex);
        7: 1008:            if (settings.verbose > 2) {
    #####: 1009:                fprintf(stderr, " -nuked by expire");
        -: 1010:            }
        -: 1011:            was_found = 3;
        -: 1012:        } else {
    70969: 1013:            if (do_update) {
        -: 1014:                /* We update the hit markers only during fetches.
        -: 1015:                 * An item needs to be hit twice overall to be considered
        -: 1016:                 * ACTIVE, but only needs a single hit to maintain activity
        -: 1017:                 * afterward.
        -: 1018:                 * FETCHED tells if an item has ever been active.
        -: 1019:                 */
    32213: 1020:                if (settings.lru_segmented) {
    31406: 1021:                    if ((it->it_flags & ITEM_ACTIVE) == 0) {
    31365: 1022:                        if ((it->it_flags & ITEM_FETCHED) == 0) {
    31339: 1023:                            it->it_flags |= ITEM_FETCHED;
        -: 1024:                        } else {
       26: 1025:                            it->it_flags |= ITEM_ACTIVE;
       26: 1026:                            if (ITEM_lruid(it) != COLD_LRU) {
       15: 1027:                                do_item_update(it); // bump LA time
       11: 1028:                            } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
        -: 1029:                                // add flag before async bump to avoid race.
    #####: 1030:                                it->it_flags &= ~ITEM_ACTIVE;
        -: 1031:                            }
        -: 1032:                        }
        -: 1033:                    }
        -: 1034:                } else {
      807: 1035:                    it->it_flags |= ITEM_FETCHED;
      807: 1036:                    do_item_update(it);
        -: 1037:                }
        -: 1038:            }
   219975: 1039:            DEBUG_REFCNT(it, '+');
        -: 1040:        }
        -: 1041:    }
        -: 1042:
   219975: 1043:    if (settings.verbose > 2)
    #####: 1044:        fprintf(stderr, "\n");
        -: 1045:    /* For now this is in addition to the above verbose logging. */
  219975*: 1046:    LOGGER_LOG(c->thread->l, LOG_FETCHERS, LOGGER_ITEM_GET, NULL, was_found, key, nkey,
        -: 1047:               (it) ? ITEM_clsid(it) : 0);
        -: 1048:
   219975: 1049:    return it;
        -: 1050:}
------------------
do_item_get:
   219975:  947:item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
   219975:  948:    item *it = assoc_find(key, nkey, hv);
   219975:  949:    if (it != NULL) {
    71044:  950:        refcount_incr(it);
        -:  951:        /* Optimization for slab reassignment. prevents popular items from
        -:  952:         * jamming in busy wait. Can only do this here to satisfy lock order
        -:  953:         * of item_lock, slabs_lock. */
        -:  954:        /* This was made unsafe by removal of the cache_lock:
        -:  955:         * slab_rebalance_signal and slab_rebal.* are modified in a separate
        -:  956:         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
        -:  957:         * NULL (0), but slab_end is still equal to some value, this would end
        -:  958:         * up unlinking every item fetched.
        -:  959:         * This is either an acceptable loss, or if slab_rebalance_signal is
        -:  960:         * true, slab_start/slab_end should be put behind the slabs_lock.
        -:  961:         * Which would cause a huge potential slowdown.
        -:  962:         * Could also use a specific lock for slab_rebal.* and
        -:  963:         * slab_rebalance_signal (shorter lock?)
        -:  964:         */
        -:  965:        /*if (slab_rebalance_signal &&
        -:  966:            ((void *)it >= slab_rebal.slab_start && (void *)it < slab_rebal.slab_end)) {
        -:  967:            do_item_unlink(it, hv);
        -:  968:            do_item_remove(it);
        -:  969:            it = NULL;
        -:  970:        }*/
        -:  971:    }
   219975:  972:    int was_found = 0;
        -:  973:
   219975:  974:    if (settings.verbose > 2) {
    #####:  975:        int ii;
    #####:  976:        if (it == NULL) {
    #####:  977:            fprintf(stderr, "> NOT FOUND ");
        -:  978:        } else {
    #####:  979:            fprintf(stderr, "> FOUND KEY ");
        -:  980:        }
    #####:  981:        for (ii = 0; ii < nkey; ++ii) {
    #####:  982:            fprintf(stderr, "%c", key[ii]);
        -:  983:        }
        -:  984:    }
        -:  985:
   219975:  986:    if (it != NULL) {
    71044:  987:        was_found = 1;
    71044:  988:        if (item_is_flushed(it)) {
       68:  989:            do_item_unlink(it, hv);
       68:  990:            STORAGE_delete(c->thread->storage, it);
       68:  991:            do_item_remove(it);
       68:  992:            it = NULL;
       68:  993:            pthread_mutex_lock(&c->thread->stats.mutex);
       68:  994:            c->thread->stats.get_flushed++;
       68:  995:            pthread_mutex_unlock(&c->thread->stats.mutex);
       68:  996:            if (settings.verbose > 2) {
    #####:  997:                fprintf(stderr, " -nuked by flush");
        -:  998:            }
        -:  999:            was_found = 2;
    70976: 1000:        } else if (it->exptime != 0 && it->exptime <= current_time) {
        7: 1001:            do_item_unlink(it, hv);
        7: 1002:            STORAGE_delete(c->thread->storage, it);
        7: 1003:            do_item_remove(it);
        7: 1004:            it = NULL;
        7: 1005:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 1006:            c->thread->stats.get_expired++;
        7: 1007:            pthread_mutex_unlock(&c->thread->stats.mutex);
        7: 1008:            if (settings.verbose > 2) {
    #####: 1009:                fprintf(stderr, " -nuked by expire");
        -: 1010:            }
        -: 1011:            was_found = 3;
        -: 1012:        } else {
    70969: 1013:            if (do_update) {
        -: 1014:                /* We update the hit markers only during fetches.
        -: 1015:                 * An item needs to be hit twice overall to be considered
        -: 1016:                 * ACTIVE, but only needs a single hit to maintain activity
        -: 1017:                 * afterward.
        -: 1018:                 * FETCHED tells if an item has ever been active.
        -: 1019:                 */
    32213: 1020:                if (settings.lru_segmented) {
    31406: 1021:                    if ((it->it_flags & ITEM_ACTIVE) == 0) {
    31365: 1022:                        if ((it->it_flags & ITEM_FETCHED) == 0) {
    31339: 1023:                            it->it_flags |= ITEM_FETCHED;
        -: 1024:                        } else {
       26: 1025:                            it->it_flags |= ITEM_ACTIVE;
       26: 1026:                            if (ITEM_lruid(it) != COLD_LRU) {
       15: 1027:                                do_item_update(it); // bump LA time
       11: 1028:                            } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
        -: 1029:                                // add flag before async bump to avoid race.
    #####: 1030:                                it->it_flags &= ~ITEM_ACTIVE;
        -: 1031:                            }
        -: 1032:                        }
        -: 1033:                    }
        -: 1034:                } else {
      807: 1035:                    it->it_flags |= ITEM_FETCHED;
      807: 1036:                    do_item_update(it);
        -: 1037:                }
        -: 1038:            }
   219975: 1039:            DEBUG_REFCNT(it, '+');
        -: 1040:        }
        -: 1041:    }
        -: 1042:
   219975: 1043:    if (settings.verbose > 2)
    #####: 1044:        fprintf(stderr, "\n");
        -: 1045:    /* For now this is in addition to the above verbose logging. */
  219975*: 1046:    LOGGER_LOG(c->thread->l, LOG_FETCHERS, LOGGER_ITEM_GET, NULL, was_found, key, nkey,
        -: 1047:               (it) ? ITEM_clsid(it) : 0);
        -: 1048:
   219975: 1049:    return it;
        -: 1050:}
------------------
do_item_get:
   219975:  947:item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
   219975:  948:    item *it = assoc_find(key, nkey, hv);
   219975:  949:    if (it != NULL) {
    71044:  950:        refcount_incr(it);
        -:  951:        /* Optimization for slab reassignment. prevents popular items from
        -:  952:         * jamming in busy wait. Can only do this here to satisfy lock order
        -:  953:         * of item_lock, slabs_lock. */
        -:  954:        /* This was made unsafe by removal of the cache_lock:
        -:  955:         * slab_rebalance_signal and slab_rebal.* are modified in a separate
        -:  956:         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
        -:  957:         * NULL (0), but slab_end is still equal to some value, this would end
        -:  958:         * up unlinking every item fetched.
        -:  959:         * This is either an acceptable loss, or if slab_rebalance_signal is
        -:  960:         * true, slab_start/slab_end should be put behind the slabs_lock.
        -:  961:         * Which would cause a huge potential slowdown.
        -:  962:         * Could also use a specific lock for slab_rebal.* and
        -:  963:         * slab_rebalance_signal (shorter lock?)
        -:  964:         */
        -:  965:        /*if (slab_rebalance_signal &&
        -:  966:            ((void *)it >= slab_rebal.slab_start && (void *)it < slab_rebal.slab_end)) {
        -:  967:            do_item_unlink(it, hv);
        -:  968:            do_item_remove(it);
        -:  969:            it = NULL;
        -:  970:        }*/
        -:  971:    }
   219975:  972:    int was_found = 0;
        -:  973:
   219975:  974:    if (settings.verbose > 2) {
    #####:  975:        int ii;
    #####:  976:        if (it == NULL) {
    #####:  977:            fprintf(stderr, "> NOT FOUND ");
        -:  978:        } else {
    #####:  979:            fprintf(stderr, "> FOUND KEY ");
        -:  980:        }
    #####:  981:        for (ii = 0; ii < nkey; ++ii) {
    #####:  982:            fprintf(stderr, "%c", key[ii]);
        -:  983:        }
        -:  984:    }
        -:  985:
   219975:  986:    if (it != NULL) {
    71044:  987:        was_found = 1;
    71044:  988:        if (item_is_flushed(it)) {
       68:  989:            do_item_unlink(it, hv);
       68:  990:            STORAGE_delete(c->thread->storage, it);
       68:  991:            do_item_remove(it);
       68:  992:            it = NULL;
       68:  993:            pthread_mutex_lock(&c->thread->stats.mutex);
       68:  994:            c->thread->stats.get_flushed++;
       68:  995:            pthread_mutex_unlock(&c->thread->stats.mutex);
       68:  996:            if (settings.verbose > 2) {
    #####:  997:                fprintf(stderr, " -nuked by flush");
        -:  998:            }
        -:  999:            was_found = 2;
    70976: 1000:        } else if (it->exptime != 0 && it->exptime <= current_time) {
        7: 1001:            do_item_unlink(it, hv);
        7: 1002:            STORAGE_delete(c->thread->storage, it);
        7: 1003:            do_item_remove(it);
        7: 1004:            it = NULL;
        7: 1005:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 1006:            c->thread->stats.get_expired++;
        7: 1007:            pthread_mutex_unlock(&c->thread->stats.mutex);
        7: 1008:            if (settings.verbose > 2) {
    #####: 1009:                fprintf(stderr, " -nuked by expire");
        -: 1010:            }
        -: 1011:            was_found = 3;
        -: 1012:        } else {
    70969: 1013:            if (do_update) {
        -: 1014:                /* We update the hit markers only during fetches.
        -: 1015:                 * An item needs to be hit twice overall to be considered
        -: 1016:                 * ACTIVE, but only needs a single hit to maintain activity
        -: 1017:                 * afterward.
        -: 1018:                 * FETCHED tells if an item has ever been active.
        -: 1019:                 */
    32213: 1020:                if (settings.lru_segmented) {
    31406: 1021:                    if ((it->it_flags & ITEM_ACTIVE) == 0) {
    31365: 1022:                        if ((it->it_flags & ITEM_FETCHED) == 0) {
    31339: 1023:                            it->it_flags |= ITEM_FETCHED;
        -: 1024:                        } else {
       26: 1025:                            it->it_flags |= ITEM_ACTIVE;
       26: 1026:                            if (ITEM_lruid(it) != COLD_LRU) {
       15: 1027:                                do_item_update(it); // bump LA time
       11: 1028:                            } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
        -: 1029:                                // add flag before async bump to avoid race.
    #####: 1030:                                it->it_flags &= ~ITEM_ACTIVE;
        -: 1031:                            }
        -: 1032:                        }
        -: 1033:                    }
        -: 1034:                } else {
      807: 1035:                    it->it_flags |= ITEM_FETCHED;
      807: 1036:                    do_item_update(it);
        -: 1037:                }
        -: 1038:            }
   219975: 1039:            DEBUG_REFCNT(it, '+');
        -: 1040:        }
        -: 1041:    }
        -: 1042:
   219975: 1043:    if (settings.verbose > 2)
    #####: 1044:        fprintf(stderr, "\n");
        -: 1045:    /* For now this is in addition to the above verbose logging. */
  219975*: 1046:    LOGGER_LOG(c->thread->l, LOG_FETCHERS, LOGGER_ITEM_GET, NULL, was_found, key, nkey,
        -: 1047:               (it) ? ITEM_clsid(it) : 0);
        -: 1048:
   219975: 1049:    return it;
        -: 1050:}
------------------
do_item_get:
   219975:  947:item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
   219975:  948:    item *it = assoc_find(key, nkey, hv);
   219975:  949:    if (it != NULL) {
    71044:  950:        refcount_incr(it);
        -:  951:        /* Optimization for slab reassignment. prevents popular items from
        -:  952:         * jamming in busy wait. Can only do this here to satisfy lock order
        -:  953:         * of item_lock, slabs_lock. */
        -:  954:        /* This was made unsafe by removal of the cache_lock:
        -:  955:         * slab_rebalance_signal and slab_rebal.* are modified in a separate
        -:  956:         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
        -:  957:         * NULL (0), but slab_end is still equal to some value, this would end
        -:  958:         * up unlinking every item fetched.
        -:  959:         * This is either an acceptable loss, or if slab_rebalance_signal is
        -:  960:         * true, slab_start/slab_end should be put behind the slabs_lock.
        -:  961:         * Which would cause a huge potential slowdown.
        -:  962:         * Could also use a specific lock for slab_rebal.* and
        -:  963:         * slab_rebalance_signal (shorter lock?)
        -:  964:         */
        -:  965:        /*if (slab_rebalance_signal &&
        -:  966:            ((void *)it >= slab_rebal.slab_start && (void *)it < slab_rebal.slab_end)) {
        -:  967:            do_item_unlink(it, hv);
        -:  968:            do_item_remove(it);
        -:  969:            it = NULL;
        -:  970:        }*/
        -:  971:    }
   219975:  972:    int was_found = 0;
        -:  973:
   219975:  974:    if (settings.verbose > 2) {
    #####:  975:        int ii;
    #####:  976:        if (it == NULL) {
    #####:  977:            fprintf(stderr, "> NOT FOUND ");
        -:  978:        } else {
    #####:  979:            fprintf(stderr, "> FOUND KEY ");
        -:  980:        }
    #####:  981:        for (ii = 0; ii < nkey; ++ii) {
    #####:  982:            fprintf(stderr, "%c", key[ii]);
        -:  983:        }
        -:  984:    }
        -:  985:
   219975:  986:    if (it != NULL) {
    71044:  987:        was_found = 1;
    71044:  988:        if (item_is_flushed(it)) {
       68:  989:            do_item_unlink(it, hv);
       68:  990:            STORAGE_delete(c->thread->storage, it);
       68:  991:            do_item_remove(it);
       68:  992:            it = NULL;
       68:  993:            pthread_mutex_lock(&c->thread->stats.mutex);
       68:  994:            c->thread->stats.get_flushed++;
       68:  995:            pthread_mutex_unlock(&c->thread->stats.mutex);
       68:  996:            if (settings.verbose > 2) {
    #####:  997:                fprintf(stderr, " -nuked by flush");
        -:  998:            }
        -:  999:            was_found = 2;
    70976: 1000:        } else if (it->exptime != 0 && it->exptime <= current_time) {
        7: 1001:            do_item_unlink(it, hv);
        7: 1002:            STORAGE_delete(c->thread->storage, it);
        7: 1003:            do_item_remove(it);
        7: 1004:            it = NULL;
        7: 1005:            pthread_mutex_lock(&c->thread->stats.mutex);
        7: 1006:            c->thread->stats.get_expired++;
        7: 1007:            pthread_mutex_unlock(&c->thread->stats.mutex);
        7: 1008:            if (settings.verbose > 2) {
    #####: 1009:                fprintf(stderr, " -nuked by expire");
        -: 1010:            }
        -: 1011:            was_found = 3;
        -: 1012:        } else {
    70969: 1013:            if (do_update) {
        -: 1014:                /* We update the hit markers only during fetches.
        -: 1015:                 * An item needs to be hit twice overall to be considered
        -: 1016:                 * ACTIVE, but only needs a single hit to maintain activity
        -: 1017:                 * afterward.
        -: 1018:                 * FETCHED tells if an item has ever been active.
        -: 1019:                 */
    32213: 1020:                if (settings.lru_segmented) {
    31406: 1021:                    if ((it->it_flags & ITEM_ACTIVE) == 0) {
    31365: 1022:                        if ((it->it_flags & ITEM_FETCHED) == 0) {
    31339: 1023:                            it->it_flags |= ITEM_FETCHED;
        -: 1024:                        } else {
       26: 1025:                            it->it_flags |= ITEM_ACTIVE;
       26: 1026:                            if (ITEM_lruid(it) != COLD_LRU) {
       15: 1027:                                do_item_update(it); // bump LA time
       11: 1028:                            } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
        -: 1029:                                // add flag before async bump to avoid race.
    #####: 1030:                                it->it_flags &= ~ITEM_ACTIVE;
        -: 1031:                            }
        -: 1032:                        }
        -: 1033:                    }
        -: 1034:                } else {
      807: 1035:                    it->it_flags |= ITEM_FETCHED;
      807: 1036:                    do_item_update(it);
        -: 1037:                }
        -: 1038:            }
   219975: 1039:            DEBUG_REFCNT(it, '+');
        -: 1040:        }
        -: 1041:    }
        -: 1042:
   219975: 1043:    if (settings.verbose > 2)
    #####: 1044:        fprintf(stderr, "\n");
        -: 1045:    /* For now this is in addition to the above verbose logging. */
  219975*: 1046:    LOGGER_LOG(c->thread->l, LOG_FETCHERS, LOGGER_ITEM_GET, NULL, was_found, key, nkey,
        -: 1047:               (it) ? ITEM_clsid(it) : 0);
        -: 1048:
   219975: 1049:    return it;
        -: 1050:}
------------------
        -: 1051:
      460: 1052:item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
        -: 1053:                    const uint32_t hv, conn *c) {
      460: 1054:    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
      460: 1055:    if (it != NULL) {
      124: 1056:        it->exptime = exptime;
        -: 1057:    }
      460: 1058:    return it;
        -: 1059:}
------------------
do_item_touch:
      115: 1052:item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
        -: 1053:                    const uint32_t hv, conn *c) {
      115: 1054:    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
      115: 1055:    if (it != NULL) {
       31: 1056:        it->exptime = exptime;
        -: 1057:    }
      115: 1058:    return it;
        -: 1059:}
------------------
do_item_touch:
      115: 1052:item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
        -: 1053:                    const uint32_t hv, conn *c) {
      115: 1054:    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
      115: 1055:    if (it != NULL) {
       31: 1056:        it->exptime = exptime;
        -: 1057:    }
      115: 1058:    return it;
        -: 1059:}
------------------
do_item_touch:
      115: 1052:item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
        -: 1053:                    const uint32_t hv, conn *c) {
      115: 1054:    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
      115: 1055:    if (it != NULL) {
       31: 1056:        it->exptime = exptime;
        -: 1057:    }
      115: 1058:    return it;
        -: 1059:}
------------------
do_item_touch:
      115: 1052:item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
        -: 1053:                    const uint32_t hv, conn *c) {
      115: 1054:    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
      115: 1055:    if (it != NULL) {
       31: 1056:        it->exptime = exptime;
        -: 1057:    }
      115: 1058:    return it;
        -: 1059:}
------------------
        -: 1060:
        -: 1061:/*** LRU MAINTENANCE THREAD ***/
        -: 1062:
        -: 1063:/* Returns number of items remove, expired, or evicted.
        -: 1064: * Callable from worker threads or the LRU maintainer thread */
  3207864: 1065:int lru_pull_tail(const int orig_id, const int cur_lru,
        -: 1066:        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        -: 1067:        struct lru_pull_tail_return *ret_it) {
  3207864: 1068:    item *it = NULL;
  3207864: 1069:    int id = orig_id;
  3207864: 1070:    int removed = 0;
  3207864: 1071:    if (id == 0)
        -: 1072:        return 0;
        -: 1073:
  3207864: 1074:    int tries = 5;
  3207864: 1075:    item *search;
  3207864: 1076:    item *next_it;
  3207864: 1077:    void *hold_lock = NULL;
  3207864: 1078:    unsigned int move_to_lru = 0;
  3207864: 1079:    uint64_t limit = 0;
        -: 1080:
  3207864: 1081:    id |= cur_lru;
  3207864: 1082:    pthread_mutex_lock(&lru_locks[id]);
  3207864: 1083:    search = tails[id];
        -: 1084:    /* We walk up *only* for locked items, and if bottom is expired. */
  3238076: 1085:    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        -: 1086:        /* we might relink search mid-loop, so search->prev isn't reliable */
   473924: 1087:        next_it = search->prev;
   473924: 1088:        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
        -: 1089:            /* We are a crawler, ignore it. */
     1512: 1090:            if (flags & LRU_PULL_CRAWL_BLOCKS) {
     1512: 1091:                pthread_mutex_unlock(&lru_locks[id]);
     1512: 1092:                return 0;
        -: 1093:            }
    #####: 1094:            tries++;
    #####: 1095:            continue;
        -: 1096:        }
   472412: 1097:        uint32_t hv = hash(ITEM_key(search), search->nkey);
        -: 1098:        /* Attempt to hash item lock the "search" item. If locked, no
        -: 1099:         * other callers can incr the refcount. Also skip ourselves. */
   472412: 1100:        if ((hold_lock = item_trylock(hv)) == NULL)
        -: 1101:            continue;
        -: 1102:        /* Now see if the item is refcount locked */
   470092: 1103:        if (refcount_incr(search) != 2) {
        -: 1104:            /* Note pathological case with ref'ed items in tail.
        -: 1105:             * Can still unlink the item, but it won't be reusable yet */
       56: 1106:            itemstats[id].lrutail_reflocked++;
        -: 1107:            /* In case of refcount leaks, enable for quick workaround. */
        -: 1108:            /* WARNING: This can cause terrible corruption */
      56*: 1109:            if (settings.tail_repair_time &&
    #####: 1110:                    search->time + settings.tail_repair_time < current_time) {
    #####: 1111:                itemstats[id].tailrepairs++;
    #####: 1112:                search->refcount = 1;
        -: 1113:                /* This will call item_remove -> item_free since refcnt is 1 */
    #####: 1114:                STORAGE_delete(ext_storage, search);
    #####: 1115:                do_item_unlink_nolock(search, hv);
    #####: 1116:                item_trylock_unlock(hold_lock);
    #####: 1117:                continue;
        -: 1118:            }
        -: 1119:        }
        -: 1120:
        -: 1121:        /* Expired or flushed */
   470092: 1122:        if ((search->exptime != 0 && search->exptime < current_time)
   469992: 1123:            || item_is_flushed(search)) {
    27892: 1124:            itemstats[id].reclaimed++;
    27892: 1125:            if ((search->it_flags & ITEM_FETCHED) == 0) {
    10148: 1126:                itemstats[id].expired_unfetched++;
        -: 1127:            }
        -: 1128:            /* refcnt 2 -> 1 */
    27892: 1129:            do_item_unlink_nolock(search, hv);
    27892: 1130:            STORAGE_delete(ext_storage, search);
        -: 1131:            /* refcnt 1 -> 0 -> item_free */
    27892: 1132:            do_item_remove(search);
    27892: 1133:            item_trylock_unlock(hold_lock);
    27892: 1134:            removed++;
        -: 1135:
        -: 1136:            /* If all we're finding are expired, can keep going */
    27892: 1137:            continue;
        -: 1138:        }
        -: 1139:
        -: 1140:        /* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.
        -: 1141:         * If we're COLD_LRU, send to WARM_LRU unless we need to evict
        -: 1142:         */
   442200: 1143:        switch (cur_lru) {
   163620: 1144:            case HOT_LRU:
   163620: 1145:                limit = total_bytes * settings.hot_lru_pct / 100;
   164732: 1146:            case WARM_LRU:
   164732: 1147:                if (limit == 0)
     1112: 1148:                    limit = total_bytes * settings.warm_lru_pct / 100;
        -: 1149:                /* Rescue ACTIVE items aggressively */
   164732: 1150:                if ((search->it_flags & ITEM_ACTIVE) != 0) {
       28: 1151:                    search->it_flags &= ~ITEM_ACTIVE;
       28: 1152:                    removed++;
       28: 1153:                    if (cur_lru == WARM_LRU) {
    #####: 1154:                        itemstats[id].moves_within_lru++;
    #####: 1155:                        do_item_update_nolock(search);
    #####: 1156:                        do_item_remove(search);
    #####: 1157:                        item_trylock_unlock(hold_lock);
        -: 1158:                    } else {
        -: 1159:                        /* Active HOT_LRU items flow to WARM */
       28: 1160:                        itemstats[id].moves_to_warm++;
       28: 1161:                        move_to_lru = WARM_LRU;
       28: 1162:                        do_item_unlink_q(search);
       28: 1163:                        it = search;
        -: 1164:                    }
   164704: 1165:                } else if (sizes_bytes[id] > limit ||
    19296: 1166:                           current_time - search->time > max_age) {
   155316: 1167:                    itemstats[id].moves_to_cold++;
   155316: 1168:                    move_to_lru = COLD_LRU;
   155316: 1169:                    do_item_unlink_q(search);
   155316: 1170:                    it = search;
   155316: 1171:                    removed++;
   155316: 1172:                    break;
        -: 1173:                } else {
        -: 1174:                    /* Don't want to move to COLD, not active, bail out */
        -: 1175:                    it = search;
        -: 1176:                }
        -: 1177:                break;
   277464: 1178:            case COLD_LRU:
   277464: 1179:                it = search; /* No matter what, we're stopping */
   277464: 1180:                if (flags & LRU_PULL_EVICT) {
    70388: 1181:                    if (settings.evict_to_free == 0) {
        -: 1182:                        /* Don't think we need a counter for this. It'll OOM.  */
        -: 1183:                        break;
        -: 1184:                    }
    70192: 1185:                    itemstats[id].evicted++;
    70192: 1186:                    itemstats[id].evicted_time = current_time - search->time;
    70192: 1187:                    if (search->exptime != 0)
      364: 1188:                        itemstats[id].evicted_nonzero++;
    70192: 1189:                    if ((search->it_flags & ITEM_FETCHED) == 0) {
    64008: 1190:                        itemstats[id].evicted_unfetched++;
        -: 1191:                    }
    70192: 1192:                    if ((search->it_flags & ITEM_ACTIVE)) {
    #####: 1193:                        itemstats[id].evicted_active++;
        -: 1194:                    }
    70192: 1195:                    LOGGER_LOG(NULL, LOG_EVICTIONS, LOGGER_EVICTION, search);
    70192: 1196:                    STORAGE_delete(ext_storage, search);
    70192: 1197:                    do_item_unlink_nolock(search, hv);
    70192: 1198:                    removed++;
    70192: 1199:                    if (settings.slab_automove == 2) {
    #####: 1200:                        slabs_reassign(-1, orig_id);
        -: 1201:                    }
   207076: 1202:                } else if (flags & LRU_PULL_RETURN_ITEM) {
        -: 1203:                    /* Keep a reference to this item and return it. */
    #####: 1204:                    ret_it->it = it;
    #####: 1205:                    ret_it->hv = hv;
   207076: 1206:                } else if ((search->it_flags & ITEM_ACTIVE) != 0
       16: 1207:                        && settings.lru_segmented) {
       16: 1208:                    itemstats[id].moves_to_warm++;
       16: 1209:                    search->it_flags &= ~ITEM_ACTIVE;
       16: 1210:                    move_to_lru = WARM_LRU;
       16: 1211:                    do_item_unlink_q(search);
       16: 1212:                    removed++;
        -: 1213:                }
        -: 1214:                break;
        4: 1215:            case TEMP_LRU:
        4: 1216:                it = search; /* Kill the loop. Parent only interested in reclaims */
        4: 1217:                break;
        -: 1218:        }
   442200: 1219:        if (it != NULL)
        -: 1220:            break;
        -: 1221:    }
        -: 1222:
  3206352: 1223:    pthread_mutex_unlock(&lru_locks[id]);
        -: 1224:
  3206352: 1225:    if (it != NULL) {
   442200: 1226:        if (move_to_lru) {
   155360: 1227:            it->slabs_clsid = ITEM_clsid(it);
   155360: 1228:            it->slabs_clsid |= move_to_lru;
   155360: 1229:            item_link_q(it);
        -: 1230:        }
   442200: 1231:        if ((flags & LRU_PULL_RETURN_ITEM) == 0) {
   442200: 1232:            do_item_remove(it);
   442200: 1233:            item_trylock_unlock(hold_lock);
        -: 1234:        }
        -: 1235:    }
        -: 1236:
        -: 1237:    return removed;
        -: 1238:}
------------------
lru_pull_tail:
   801966: 1065:int lru_pull_tail(const int orig_id, const int cur_lru,
        -: 1066:        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        -: 1067:        struct lru_pull_tail_return *ret_it) {
   801966: 1068:    item *it = NULL;
   801966: 1069:    int id = orig_id;
   801966: 1070:    int removed = 0;
   801966: 1071:    if (id == 0)
        -: 1072:        return 0;
        -: 1073:
   801966: 1074:    int tries = 5;
   801966: 1075:    item *search;
   801966: 1076:    item *next_it;
   801966: 1077:    void *hold_lock = NULL;
   801966: 1078:    unsigned int move_to_lru = 0;
   801966: 1079:    uint64_t limit = 0;
        -: 1080:
   801966: 1081:    id |= cur_lru;
   801966: 1082:    pthread_mutex_lock(&lru_locks[id]);
   801966: 1083:    search = tails[id];
        -: 1084:    /* We walk up *only* for locked items, and if bottom is expired. */
   809519: 1085:    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        -: 1086:        /* we might relink search mid-loop, so search->prev isn't reliable */
   118481: 1087:        next_it = search->prev;
   118481: 1088:        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
        -: 1089:            /* We are a crawler, ignore it. */
      378: 1090:            if (flags & LRU_PULL_CRAWL_BLOCKS) {
      378: 1091:                pthread_mutex_unlock(&lru_locks[id]);
      378: 1092:                return 0;
        -: 1093:            }
    #####: 1094:            tries++;
    #####: 1095:            continue;
        -: 1096:        }
   118103: 1097:        uint32_t hv = hash(ITEM_key(search), search->nkey);
        -: 1098:        /* Attempt to hash item lock the "search" item. If locked, no
        -: 1099:         * other callers can incr the refcount. Also skip ourselves. */
   118103: 1100:        if ((hold_lock = item_trylock(hv)) == NULL)
        -: 1101:            continue;
        -: 1102:        /* Now see if the item is refcount locked */
   117523: 1103:        if (refcount_incr(search) != 2) {
        -: 1104:            /* Note pathological case with ref'ed items in tail.
        -: 1105:             * Can still unlink the item, but it won't be reusable yet */
       14: 1106:            itemstats[id].lrutail_reflocked++;
        -: 1107:            /* In case of refcount leaks, enable for quick workaround. */
        -: 1108:            /* WARNING: This can cause terrible corruption */
      14*: 1109:            if (settings.tail_repair_time &&
    #####: 1110:                    search->time + settings.tail_repair_time < current_time) {
    #####: 1111:                itemstats[id].tailrepairs++;
    #####: 1112:                search->refcount = 1;
        -: 1113:                /* This will call item_remove -> item_free since refcnt is 1 */
    #####: 1114:                STORAGE_delete(ext_storage, search);
    #####: 1115:                do_item_unlink_nolock(search, hv);
    #####: 1116:                item_trylock_unlock(hold_lock);
    #####: 1117:                continue;
        -: 1118:            }
        -: 1119:        }
        -: 1120:
        -: 1121:        /* Expired or flushed */
   117523: 1122:        if ((search->exptime != 0 && search->exptime < current_time)
   117498: 1123:            || item_is_flushed(search)) {
     6973: 1124:            itemstats[id].reclaimed++;
     6973: 1125:            if ((search->it_flags & ITEM_FETCHED) == 0) {
     2537: 1126:                itemstats[id].expired_unfetched++;
        -: 1127:            }
        -: 1128:            /* refcnt 2 -> 1 */
     6973: 1129:            do_item_unlink_nolock(search, hv);
     6973: 1130:            STORAGE_delete(ext_storage, search);
        -: 1131:            /* refcnt 1 -> 0 -> item_free */
     6973: 1132:            do_item_remove(search);
     6973: 1133:            item_trylock_unlock(hold_lock);
     6973: 1134:            removed++;
        -: 1135:
        -: 1136:            /* If all we're finding are expired, can keep going */
     6973: 1137:            continue;
        -: 1138:        }
        -: 1139:
        -: 1140:        /* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.
        -: 1141:         * If we're COLD_LRU, send to WARM_LRU unless we need to evict
        -: 1142:         */
   110550: 1143:        switch (cur_lru) {
    40905: 1144:            case HOT_LRU:
    40905: 1145:                limit = total_bytes * settings.hot_lru_pct / 100;
    41183: 1146:            case WARM_LRU:
    41183: 1147:                if (limit == 0)
      278: 1148:                    limit = total_bytes * settings.warm_lru_pct / 100;
        -: 1149:                /* Rescue ACTIVE items aggressively */
    41183: 1150:                if ((search->it_flags & ITEM_ACTIVE) != 0) {
        7: 1151:                    search->it_flags &= ~ITEM_ACTIVE;
        7: 1152:                    removed++;
        7: 1153:                    if (cur_lru == WARM_LRU) {
    #####: 1154:                        itemstats[id].moves_within_lru++;
    #####: 1155:                        do_item_update_nolock(search);
    #####: 1156:                        do_item_remove(search);
    #####: 1157:                        item_trylock_unlock(hold_lock);
        -: 1158:                    } else {
        -: 1159:                        /* Active HOT_LRU items flow to WARM */
        7: 1160:                        itemstats[id].moves_to_warm++;
        7: 1161:                        move_to_lru = WARM_LRU;
        7: 1162:                        do_item_unlink_q(search);
        7: 1163:                        it = search;
        -: 1164:                    }
    41176: 1165:                } else if (sizes_bytes[id] > limit ||
     4824: 1166:                           current_time - search->time > max_age) {
    38829: 1167:                    itemstats[id].moves_to_cold++;
    38829: 1168:                    move_to_lru = COLD_LRU;
    38829: 1169:                    do_item_unlink_q(search);
    38829: 1170:                    it = search;
    38829: 1171:                    removed++;
    38829: 1172:                    break;
        -: 1173:                } else {
        -: 1174:                    /* Don't want to move to COLD, not active, bail out */
        -: 1175:                    it = search;
        -: 1176:                }
        -: 1177:                break;
    69366: 1178:            case COLD_LRU:
    69366: 1179:                it = search; /* No matter what, we're stopping */
    69366: 1180:                if (flags & LRU_PULL_EVICT) {
    17597: 1181:                    if (settings.evict_to_free == 0) {
        -: 1182:                        /* Don't think we need a counter for this. It'll OOM.  */
        -: 1183:                        break;
        -: 1184:                    }
    17548: 1185:                    itemstats[id].evicted++;
    17548: 1186:                    itemstats[id].evicted_time = current_time - search->time;
    17548: 1187:                    if (search->exptime != 0)
       91: 1188:                        itemstats[id].evicted_nonzero++;
    17548: 1189:                    if ((search->it_flags & ITEM_FETCHED) == 0) {
    16002: 1190:                        itemstats[id].evicted_unfetched++;
        -: 1191:                    }
    17548: 1192:                    if ((search->it_flags & ITEM_ACTIVE)) {
    #####: 1193:                        itemstats[id].evicted_active++;
        -: 1194:                    }
    17548: 1195:                    LOGGER_LOG(NULL, LOG_EVICTIONS, LOGGER_EVICTION, search);
    17548: 1196:                    STORAGE_delete(ext_storage, search);
    17548: 1197:                    do_item_unlink_nolock(search, hv);
    17548: 1198:                    removed++;
    17548: 1199:                    if (settings.slab_automove == 2) {
    #####: 1200:                        slabs_reassign(-1, orig_id);
        -: 1201:                    }
    51769: 1202:                } else if (flags & LRU_PULL_RETURN_ITEM) {
        -: 1203:                    /* Keep a reference to this item and return it. */
    #####: 1204:                    ret_it->it = it;
    #####: 1205:                    ret_it->hv = hv;
    51769: 1206:                } else if ((search->it_flags & ITEM_ACTIVE) != 0
        4: 1207:                        && settings.lru_segmented) {
        4: 1208:                    itemstats[id].moves_to_warm++;
        4: 1209:                    search->it_flags &= ~ITEM_ACTIVE;
        4: 1210:                    move_to_lru = WARM_LRU;
        4: 1211:                    do_item_unlink_q(search);
        4: 1212:                    removed++;
        -: 1213:                }
        -: 1214:                break;
        1: 1215:            case TEMP_LRU:
        1: 1216:                it = search; /* Kill the loop. Parent only interested in reclaims */
        1: 1217:                break;
        -: 1218:        }
   110550: 1219:        if (it != NULL)
        -: 1220:            break;
        -: 1221:    }
        -: 1222:
   801588: 1223:    pthread_mutex_unlock(&lru_locks[id]);
        -: 1224:
   801588: 1225:    if (it != NULL) {
   110550: 1226:        if (move_to_lru) {
    38840: 1227:            it->slabs_clsid = ITEM_clsid(it);
    38840: 1228:            it->slabs_clsid |= move_to_lru;
    38840: 1229:            item_link_q(it);
        -: 1230:        }
   110550: 1231:        if ((flags & LRU_PULL_RETURN_ITEM) == 0) {
   110550: 1232:            do_item_remove(it);
   110550: 1233:            item_trylock_unlock(hold_lock);
        -: 1234:        }
        -: 1235:    }
        -: 1236:
        -: 1237:    return removed;
        -: 1238:}
------------------
lru_pull_tail:
   801966: 1065:int lru_pull_tail(const int orig_id, const int cur_lru,
        -: 1066:        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        -: 1067:        struct lru_pull_tail_return *ret_it) {
   801966: 1068:    item *it = NULL;
   801966: 1069:    int id = orig_id;
   801966: 1070:    int removed = 0;
   801966: 1071:    if (id == 0)
        -: 1072:        return 0;
        -: 1073:
   801966: 1074:    int tries = 5;
   801966: 1075:    item *search;
   801966: 1076:    item *next_it;
   801966: 1077:    void *hold_lock = NULL;
   801966: 1078:    unsigned int move_to_lru = 0;
   801966: 1079:    uint64_t limit = 0;
        -: 1080:
   801966: 1081:    id |= cur_lru;
   801966: 1082:    pthread_mutex_lock(&lru_locks[id]);
   801966: 1083:    search = tails[id];
        -: 1084:    /* We walk up *only* for locked items, and if bottom is expired. */
   809519: 1085:    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        -: 1086:        /* we might relink search mid-loop, so search->prev isn't reliable */
   118481: 1087:        next_it = search->prev;
   118481: 1088:        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
        -: 1089:            /* We are a crawler, ignore it. */
      378: 1090:            if (flags & LRU_PULL_CRAWL_BLOCKS) {
      378: 1091:                pthread_mutex_unlock(&lru_locks[id]);
      378: 1092:                return 0;
        -: 1093:            }
    #####: 1094:            tries++;
    #####: 1095:            continue;
        -: 1096:        }
   118103: 1097:        uint32_t hv = hash(ITEM_key(search), search->nkey);
        -: 1098:        /* Attempt to hash item lock the "search" item. If locked, no
        -: 1099:         * other callers can incr the refcount. Also skip ourselves. */
   118103: 1100:        if ((hold_lock = item_trylock(hv)) == NULL)
        -: 1101:            continue;
        -: 1102:        /* Now see if the item is refcount locked */
   117523: 1103:        if (refcount_incr(search) != 2) {
        -: 1104:            /* Note pathological case with ref'ed items in tail.
        -: 1105:             * Can still unlink the item, but it won't be reusable yet */
       14: 1106:            itemstats[id].lrutail_reflocked++;
        -: 1107:            /* In case of refcount leaks, enable for quick workaround. */
        -: 1108:            /* WARNING: This can cause terrible corruption */
      14*: 1109:            if (settings.tail_repair_time &&
    #####: 1110:                    search->time + settings.tail_repair_time < current_time) {
    #####: 1111:                itemstats[id].tailrepairs++;
    #####: 1112:                search->refcount = 1;
        -: 1113:                /* This will call item_remove -> item_free since refcnt is 1 */
    #####: 1114:                STORAGE_delete(ext_storage, search);
    #####: 1115:                do_item_unlink_nolock(search, hv);
    #####: 1116:                item_trylock_unlock(hold_lock);
    #####: 1117:                continue;
        -: 1118:            }
        -: 1119:        }
        -: 1120:
        -: 1121:        /* Expired or flushed */
   117523: 1122:        if ((search->exptime != 0 && search->exptime < current_time)
   117498: 1123:            || item_is_flushed(search)) {
     6973: 1124:            itemstats[id].reclaimed++;
     6973: 1125:            if ((search->it_flags & ITEM_FETCHED) == 0) {
     2537: 1126:                itemstats[id].expired_unfetched++;
        -: 1127:            }
        -: 1128:            /* refcnt 2 -> 1 */
     6973: 1129:            do_item_unlink_nolock(search, hv);
     6973: 1130:            STORAGE_delete(ext_storage, search);
        -: 1131:            /* refcnt 1 -> 0 -> item_free */
     6973: 1132:            do_item_remove(search);
     6973: 1133:            item_trylock_unlock(hold_lock);
     6973: 1134:            removed++;
        -: 1135:
        -: 1136:            /* If all we're finding are expired, can keep going */
     6973: 1137:            continue;
        -: 1138:        }
        -: 1139:
        -: 1140:        /* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.
        -: 1141:         * If we're COLD_LRU, send to WARM_LRU unless we need to evict
        -: 1142:         */
   110550: 1143:        switch (cur_lru) {
    40905: 1144:            case HOT_LRU:
    40905: 1145:                limit = total_bytes * settings.hot_lru_pct / 100;
    41183: 1146:            case WARM_LRU:
    41183: 1147:                if (limit == 0)
      278: 1148:                    limit = total_bytes * settings.warm_lru_pct / 100;
        -: 1149:                /* Rescue ACTIVE items aggressively */
    41183: 1150:                if ((search->it_flags & ITEM_ACTIVE) != 0) {
        7: 1151:                    search->it_flags &= ~ITEM_ACTIVE;
        7: 1152:                    removed++;
        7: 1153:                    if (cur_lru == WARM_LRU) {
    #####: 1154:                        itemstats[id].moves_within_lru++;
    #####: 1155:                        do_item_update_nolock(search);
    #####: 1156:                        do_item_remove(search);
    #####: 1157:                        item_trylock_unlock(hold_lock);
        -: 1158:                    } else {
        -: 1159:                        /* Active HOT_LRU items flow to WARM */
        7: 1160:                        itemstats[id].moves_to_warm++;
        7: 1161:                        move_to_lru = WARM_LRU;
        7: 1162:                        do_item_unlink_q(search);
        7: 1163:                        it = search;
        -: 1164:                    }
    41176: 1165:                } else if (sizes_bytes[id] > limit ||
     4824: 1166:                           current_time - search->time > max_age) {
    38829: 1167:                    itemstats[id].moves_to_cold++;
    38829: 1168:                    move_to_lru = COLD_LRU;
    38829: 1169:                    do_item_unlink_q(search);
    38829: 1170:                    it = search;
    38829: 1171:                    removed++;
    38829: 1172:                    break;
        -: 1173:                } else {
        -: 1174:                    /* Don't want to move to COLD, not active, bail out */
        -: 1175:                    it = search;
        -: 1176:                }
        -: 1177:                break;
    69366: 1178:            case COLD_LRU:
    69366: 1179:                it = search; /* No matter what, we're stopping */
    69366: 1180:                if (flags & LRU_PULL_EVICT) {
    17597: 1181:                    if (settings.evict_to_free == 0) {
        -: 1182:                        /* Don't think we need a counter for this. It'll OOM.  */
        -: 1183:                        break;
        -: 1184:                    }
    17548: 1185:                    itemstats[id].evicted++;
    17548: 1186:                    itemstats[id].evicted_time = current_time - search->time;
    17548: 1187:                    if (search->exptime != 0)
       91: 1188:                        itemstats[id].evicted_nonzero++;
    17548: 1189:                    if ((search->it_flags & ITEM_FETCHED) == 0) {
    16002: 1190:                        itemstats[id].evicted_unfetched++;
        -: 1191:                    }
    17548: 1192:                    if ((search->it_flags & ITEM_ACTIVE)) {
    #####: 1193:                        itemstats[id].evicted_active++;
        -: 1194:                    }
    17548: 1195:                    LOGGER_LOG(NULL, LOG_EVICTIONS, LOGGER_EVICTION, search);
    17548: 1196:                    STORAGE_delete(ext_storage, search);
    17548: 1197:                    do_item_unlink_nolock(search, hv);
    17548: 1198:                    removed++;
    17548: 1199:                    if (settings.slab_automove == 2) {
    #####: 1200:                        slabs_reassign(-1, orig_id);
        -: 1201:                    }
    51769: 1202:                } else if (flags & LRU_PULL_RETURN_ITEM) {
        -: 1203:                    /* Keep a reference to this item and return it. */
    #####: 1204:                    ret_it->it = it;
    #####: 1205:                    ret_it->hv = hv;
    51769: 1206:                } else if ((search->it_flags & ITEM_ACTIVE) != 0
        4: 1207:                        && settings.lru_segmented) {
        4: 1208:                    itemstats[id].moves_to_warm++;
        4: 1209:                    search->it_flags &= ~ITEM_ACTIVE;
        4: 1210:                    move_to_lru = WARM_LRU;
        4: 1211:                    do_item_unlink_q(search);
        4: 1212:                    removed++;
        -: 1213:                }
        -: 1214:                break;
        1: 1215:            case TEMP_LRU:
        1: 1216:                it = search; /* Kill the loop. Parent only interested in reclaims */
        1: 1217:                break;
        -: 1218:        }
   110550: 1219:        if (it != NULL)
        -: 1220:            break;
        -: 1221:    }
        -: 1222:
   801588: 1223:    pthread_mutex_unlock(&lru_locks[id]);
        -: 1224:
   801588: 1225:    if (it != NULL) {
   110550: 1226:        if (move_to_lru) {
    38840: 1227:            it->slabs_clsid = ITEM_clsid(it);
    38840: 1228:            it->slabs_clsid |= move_to_lru;
    38840: 1229:            item_link_q(it);
        -: 1230:        }
   110550: 1231:        if ((flags & LRU_PULL_RETURN_ITEM) == 0) {
   110550: 1232:            do_item_remove(it);
   110550: 1233:            item_trylock_unlock(hold_lock);
        -: 1234:        }
        -: 1235:    }
        -: 1236:
        -: 1237:    return removed;
        -: 1238:}
------------------
lru_pull_tail:
   801966: 1065:int lru_pull_tail(const int orig_id, const int cur_lru,
        -: 1066:        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        -: 1067:        struct lru_pull_tail_return *ret_it) {
   801966: 1068:    item *it = NULL;
   801966: 1069:    int id = orig_id;
   801966: 1070:    int removed = 0;
   801966: 1071:    if (id == 0)
        -: 1072:        return 0;
        -: 1073:
   801966: 1074:    int tries = 5;
   801966: 1075:    item *search;
   801966: 1076:    item *next_it;
   801966: 1077:    void *hold_lock = NULL;
   801966: 1078:    unsigned int move_to_lru = 0;
   801966: 1079:    uint64_t limit = 0;
        -: 1080:
   801966: 1081:    id |= cur_lru;
   801966: 1082:    pthread_mutex_lock(&lru_locks[id]);
   801966: 1083:    search = tails[id];
        -: 1084:    /* We walk up *only* for locked items, and if bottom is expired. */
   809519: 1085:    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        -: 1086:        /* we might relink search mid-loop, so search->prev isn't reliable */
   118481: 1087:        next_it = search->prev;
   118481: 1088:        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
        -: 1089:            /* We are a crawler, ignore it. */
      378: 1090:            if (flags & LRU_PULL_CRAWL_BLOCKS) {
      378: 1091:                pthread_mutex_unlock(&lru_locks[id]);
      378: 1092:                return 0;
        -: 1093:            }
    #####: 1094:            tries++;
    #####: 1095:            continue;
        -: 1096:        }
   118103: 1097:        uint32_t hv = hash(ITEM_key(search), search->nkey);
        -: 1098:        /* Attempt to hash item lock the "search" item. If locked, no
        -: 1099:         * other callers can incr the refcount. Also skip ourselves. */
   118103: 1100:        if ((hold_lock = item_trylock(hv)) == NULL)
        -: 1101:            continue;
        -: 1102:        /* Now see if the item is refcount locked */
   117523: 1103:        if (refcount_incr(search) != 2) {
        -: 1104:            /* Note pathological case with ref'ed items in tail.
        -: 1105:             * Can still unlink the item, but it won't be reusable yet */
       14: 1106:            itemstats[id].lrutail_reflocked++;
        -: 1107:            /* In case of refcount leaks, enable for quick workaround. */
        -: 1108:            /* WARNING: This can cause terrible corruption */
      14*: 1109:            if (settings.tail_repair_time &&
    #####: 1110:                    search->time + settings.tail_repair_time < current_time) {
    #####: 1111:                itemstats[id].tailrepairs++;
    #####: 1112:                search->refcount = 1;
        -: 1113:                /* This will call item_remove -> item_free since refcnt is 1 */
    #####: 1114:                STORAGE_delete(ext_storage, search);
    #####: 1115:                do_item_unlink_nolock(search, hv);
    #####: 1116:                item_trylock_unlock(hold_lock);
    #####: 1117:                continue;
        -: 1118:            }
        -: 1119:        }
        -: 1120:
        -: 1121:        /* Expired or flushed */
   117523: 1122:        if ((search->exptime != 0 && search->exptime < current_time)
   117498: 1123:            || item_is_flushed(search)) {
     6973: 1124:            itemstats[id].reclaimed++;
     6973: 1125:            if ((search->it_flags & ITEM_FETCHED) == 0) {
     2537: 1126:                itemstats[id].expired_unfetched++;
        -: 1127:            }
        -: 1128:            /* refcnt 2 -> 1 */
     6973: 1129:            do_item_unlink_nolock(search, hv);
     6973: 1130:            STORAGE_delete(ext_storage, search);
        -: 1131:            /* refcnt 1 -> 0 -> item_free */
     6973: 1132:            do_item_remove(search);
     6973: 1133:            item_trylock_unlock(hold_lock);
     6973: 1134:            removed++;
        -: 1135:
        -: 1136:            /* If all we're finding are expired, can keep going */
     6973: 1137:            continue;
        -: 1138:        }
        -: 1139:
        -: 1140:        /* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.
        -: 1141:         * If we're COLD_LRU, send to WARM_LRU unless we need to evict
        -: 1142:         */
   110550: 1143:        switch (cur_lru) {
    40905: 1144:            case HOT_LRU:
    40905: 1145:                limit = total_bytes * settings.hot_lru_pct / 100;
    41183: 1146:            case WARM_LRU:
    41183: 1147:                if (limit == 0)
      278: 1148:                    limit = total_bytes * settings.warm_lru_pct / 100;
        -: 1149:                /* Rescue ACTIVE items aggressively */
    41183: 1150:                if ((search->it_flags & ITEM_ACTIVE) != 0) {
        7: 1151:                    search->it_flags &= ~ITEM_ACTIVE;
        7: 1152:                    removed++;
        7: 1153:                    if (cur_lru == WARM_LRU) {
    #####: 1154:                        itemstats[id].moves_within_lru++;
    #####: 1155:                        do_item_update_nolock(search);
    #####: 1156:                        do_item_remove(search);
    #####: 1157:                        item_trylock_unlock(hold_lock);
        -: 1158:                    } else {
        -: 1159:                        /* Active HOT_LRU items flow to WARM */
        7: 1160:                        itemstats[id].moves_to_warm++;
        7: 1161:                        move_to_lru = WARM_LRU;
        7: 1162:                        do_item_unlink_q(search);
        7: 1163:                        it = search;
        -: 1164:                    }
    41176: 1165:                } else if (sizes_bytes[id] > limit ||
     4824: 1166:                           current_time - search->time > max_age) {
    38829: 1167:                    itemstats[id].moves_to_cold++;
    38829: 1168:                    move_to_lru = COLD_LRU;
    38829: 1169:                    do_item_unlink_q(search);
    38829: 1170:                    it = search;
    38829: 1171:                    removed++;
    38829: 1172:                    break;
        -: 1173:                } else {
        -: 1174:                    /* Don't want to move to COLD, not active, bail out */
        -: 1175:                    it = search;
        -: 1176:                }
        -: 1177:                break;
    69366: 1178:            case COLD_LRU:
    69366: 1179:                it = search; /* No matter what, we're stopping */
    69366: 1180:                if (flags & LRU_PULL_EVICT) {
    17597: 1181:                    if (settings.evict_to_free == 0) {
        -: 1182:                        /* Don't think we need a counter for this. It'll OOM.  */
        -: 1183:                        break;
        -: 1184:                    }
    17548: 1185:                    itemstats[id].evicted++;
    17548: 1186:                    itemstats[id].evicted_time = current_time - search->time;
    17548: 1187:                    if (search->exptime != 0)
       91: 1188:                        itemstats[id].evicted_nonzero++;
    17548: 1189:                    if ((search->it_flags & ITEM_FETCHED) == 0) {
    16002: 1190:                        itemstats[id].evicted_unfetched++;
        -: 1191:                    }
    17548: 1192:                    if ((search->it_flags & ITEM_ACTIVE)) {
    #####: 1193:                        itemstats[id].evicted_active++;
        -: 1194:                    }
    17548: 1195:                    LOGGER_LOG(NULL, LOG_EVICTIONS, LOGGER_EVICTION, search);
    17548: 1196:                    STORAGE_delete(ext_storage, search);
    17548: 1197:                    do_item_unlink_nolock(search, hv);
    17548: 1198:                    removed++;
    17548: 1199:                    if (settings.slab_automove == 2) {
    #####: 1200:                        slabs_reassign(-1, orig_id);
        -: 1201:                    }
    51769: 1202:                } else if (flags & LRU_PULL_RETURN_ITEM) {
        -: 1203:                    /* Keep a reference to this item and return it. */
    #####: 1204:                    ret_it->it = it;
    #####: 1205:                    ret_it->hv = hv;
    51769: 1206:                } else if ((search->it_flags & ITEM_ACTIVE) != 0
        4: 1207:                        && settings.lru_segmented) {
        4: 1208:                    itemstats[id].moves_to_warm++;
        4: 1209:                    search->it_flags &= ~ITEM_ACTIVE;
        4: 1210:                    move_to_lru = WARM_LRU;
        4: 1211:                    do_item_unlink_q(search);
        4: 1212:                    removed++;
        -: 1213:                }
        -: 1214:                break;
        1: 1215:            case TEMP_LRU:
        1: 1216:                it = search; /* Kill the loop. Parent only interested in reclaims */
        1: 1217:                break;
        -: 1218:        }
   110550: 1219:        if (it != NULL)
        -: 1220:            break;
        -: 1221:    }
        -: 1222:
   801588: 1223:    pthread_mutex_unlock(&lru_locks[id]);
        -: 1224:
   801588: 1225:    if (it != NULL) {
   110550: 1226:        if (move_to_lru) {
    38840: 1227:            it->slabs_clsid = ITEM_clsid(it);
    38840: 1228:            it->slabs_clsid |= move_to_lru;
    38840: 1229:            item_link_q(it);
        -: 1230:        }
   110550: 1231:        if ((flags & LRU_PULL_RETURN_ITEM) == 0) {
   110550: 1232:            do_item_remove(it);
   110550: 1233:            item_trylock_unlock(hold_lock);
        -: 1234:        }
        -: 1235:    }
        -: 1236:
        -: 1237:    return removed;
        -: 1238:}
------------------
lru_pull_tail:
   801966: 1065:int lru_pull_tail(const int orig_id, const int cur_lru,
        -: 1066:        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        -: 1067:        struct lru_pull_tail_return *ret_it) {
   801966: 1068:    item *it = NULL;
   801966: 1069:    int id = orig_id;
   801966: 1070:    int removed = 0;
   801966: 1071:    if (id == 0)
        -: 1072:        return 0;
        -: 1073:
   801966: 1074:    int tries = 5;
   801966: 1075:    item *search;
   801966: 1076:    item *next_it;
   801966: 1077:    void *hold_lock = NULL;
   801966: 1078:    unsigned int move_to_lru = 0;
   801966: 1079:    uint64_t limit = 0;
        -: 1080:
   801966: 1081:    id |= cur_lru;
   801966: 1082:    pthread_mutex_lock(&lru_locks[id]);
   801966: 1083:    search = tails[id];
        -: 1084:    /* We walk up *only* for locked items, and if bottom is expired. */
   809519: 1085:    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        -: 1086:        /* we might relink search mid-loop, so search->prev isn't reliable */
   118481: 1087:        next_it = search->prev;
   118481: 1088:        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
        -: 1089:            /* We are a crawler, ignore it. */
      378: 1090:            if (flags & LRU_PULL_CRAWL_BLOCKS) {
      378: 1091:                pthread_mutex_unlock(&lru_locks[id]);
      378: 1092:                return 0;
        -: 1093:            }
    #####: 1094:            tries++;
    #####: 1095:            continue;
        -: 1096:        }
   118103: 1097:        uint32_t hv = hash(ITEM_key(search), search->nkey);
        -: 1098:        /* Attempt to hash item lock the "search" item. If locked, no
        -: 1099:         * other callers can incr the refcount. Also skip ourselves. */
   118103: 1100:        if ((hold_lock = item_trylock(hv)) == NULL)
        -: 1101:            continue;
        -: 1102:        /* Now see if the item is refcount locked */
   117523: 1103:        if (refcount_incr(search) != 2) {
        -: 1104:            /* Note pathological case with ref'ed items in tail.
        -: 1105:             * Can still unlink the item, but it won't be reusable yet */
       14: 1106:            itemstats[id].lrutail_reflocked++;
        -: 1107:            /* In case of refcount leaks, enable for quick workaround. */
        -: 1108:            /* WARNING: This can cause terrible corruption */
      14*: 1109:            if (settings.tail_repair_time &&
    #####: 1110:                    search->time + settings.tail_repair_time < current_time) {
    #####: 1111:                itemstats[id].tailrepairs++;
    #####: 1112:                search->refcount = 1;
        -: 1113:                /* This will call item_remove -> item_free since refcnt is 1 */
    #####: 1114:                STORAGE_delete(ext_storage, search);
    #####: 1115:                do_item_unlink_nolock(search, hv);
    #####: 1116:                item_trylock_unlock(hold_lock);
    #####: 1117:                continue;
        -: 1118:            }
        -: 1119:        }
        -: 1120:
        -: 1121:        /* Expired or flushed */
   117523: 1122:        if ((search->exptime != 0 && search->exptime < current_time)
   117498: 1123:            || item_is_flushed(search)) {
     6973: 1124:            itemstats[id].reclaimed++;
     6973: 1125:            if ((search->it_flags & ITEM_FETCHED) == 0) {
     2537: 1126:                itemstats[id].expired_unfetched++;
        -: 1127:            }
        -: 1128:            /* refcnt 2 -> 1 */
     6973: 1129:            do_item_unlink_nolock(search, hv);
     6973: 1130:            STORAGE_delete(ext_storage, search);
        -: 1131:            /* refcnt 1 -> 0 -> item_free */
     6973: 1132:            do_item_remove(search);
     6973: 1133:            item_trylock_unlock(hold_lock);
     6973: 1134:            removed++;
        -: 1135:
        -: 1136:            /* If all we're finding are expired, can keep going */
     6973: 1137:            continue;
        -: 1138:        }
        -: 1139:
        -: 1140:        /* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.
        -: 1141:         * If we're COLD_LRU, send to WARM_LRU unless we need to evict
        -: 1142:         */
   110550: 1143:        switch (cur_lru) {
    40905: 1144:            case HOT_LRU:
    40905: 1145:                limit = total_bytes * settings.hot_lru_pct / 100;
    41183: 1146:            case WARM_LRU:
    41183: 1147:                if (limit == 0)
      278: 1148:                    limit = total_bytes * settings.warm_lru_pct / 100;
        -: 1149:                /* Rescue ACTIVE items aggressively */
    41183: 1150:                if ((search->it_flags & ITEM_ACTIVE) != 0) {
        7: 1151:                    search->it_flags &= ~ITEM_ACTIVE;
        7: 1152:                    removed++;
        7: 1153:                    if (cur_lru == WARM_LRU) {
    #####: 1154:                        itemstats[id].moves_within_lru++;
    #####: 1155:                        do_item_update_nolock(search);
    #####: 1156:                        do_item_remove(search);
    #####: 1157:                        item_trylock_unlock(hold_lock);
        -: 1158:                    } else {
        -: 1159:                        /* Active HOT_LRU items flow to WARM */
        7: 1160:                        itemstats[id].moves_to_warm++;
        7: 1161:                        move_to_lru = WARM_LRU;
        7: 1162:                        do_item_unlink_q(search);
        7: 1163:                        it = search;
        -: 1164:                    }
    41176: 1165:                } else if (sizes_bytes[id] > limit ||
     4824: 1166:                           current_time - search->time > max_age) {
    38829: 1167:                    itemstats[id].moves_to_cold++;
    38829: 1168:                    move_to_lru = COLD_LRU;
    38829: 1169:                    do_item_unlink_q(search);
    38829: 1170:                    it = search;
    38829: 1171:                    removed++;
    38829: 1172:                    break;
        -: 1173:                } else {
        -: 1174:                    /* Don't want to move to COLD, not active, bail out */
        -: 1175:                    it = search;
        -: 1176:                }
        -: 1177:                break;
    69366: 1178:            case COLD_LRU:
    69366: 1179:                it = search; /* No matter what, we're stopping */
    69366: 1180:                if (flags & LRU_PULL_EVICT) {
    17597: 1181:                    if (settings.evict_to_free == 0) {
        -: 1182:                        /* Don't think we need a counter for this. It'll OOM.  */
        -: 1183:                        break;
        -: 1184:                    }
    17548: 1185:                    itemstats[id].evicted++;
    17548: 1186:                    itemstats[id].evicted_time = current_time - search->time;
    17548: 1187:                    if (search->exptime != 0)
       91: 1188:                        itemstats[id].evicted_nonzero++;
    17548: 1189:                    if ((search->it_flags & ITEM_FETCHED) == 0) {
    16002: 1190:                        itemstats[id].evicted_unfetched++;
        -: 1191:                    }
    17548: 1192:                    if ((search->it_flags & ITEM_ACTIVE)) {
    #####: 1193:                        itemstats[id].evicted_active++;
        -: 1194:                    }
    17548: 1195:                    LOGGER_LOG(NULL, LOG_EVICTIONS, LOGGER_EVICTION, search);
    17548: 1196:                    STORAGE_delete(ext_storage, search);
    17548: 1197:                    do_item_unlink_nolock(search, hv);
    17548: 1198:                    removed++;
    17548: 1199:                    if (settings.slab_automove == 2) {
    #####: 1200:                        slabs_reassign(-1, orig_id);
        -: 1201:                    }
    51769: 1202:                } else if (flags & LRU_PULL_RETURN_ITEM) {
        -: 1203:                    /* Keep a reference to this item and return it. */
    #####: 1204:                    ret_it->it = it;
    #####: 1205:                    ret_it->hv = hv;
    51769: 1206:                } else if ((search->it_flags & ITEM_ACTIVE) != 0
        4: 1207:                        && settings.lru_segmented) {
        4: 1208:                    itemstats[id].moves_to_warm++;
        4: 1209:                    search->it_flags &= ~ITEM_ACTIVE;
        4: 1210:                    move_to_lru = WARM_LRU;
        4: 1211:                    do_item_unlink_q(search);
        4: 1212:                    removed++;
        -: 1213:                }
        -: 1214:                break;
        1: 1215:            case TEMP_LRU:
        1: 1216:                it = search; /* Kill the loop. Parent only interested in reclaims */
        1: 1217:                break;
        -: 1218:        }
   110550: 1219:        if (it != NULL)
        -: 1220:            break;
        -: 1221:    }
        -: 1222:
   801588: 1223:    pthread_mutex_unlock(&lru_locks[id]);
        -: 1224:
   801588: 1225:    if (it != NULL) {
   110550: 1226:        if (move_to_lru) {
    38840: 1227:            it->slabs_clsid = ITEM_clsid(it);
    38840: 1228:            it->slabs_clsid |= move_to_lru;
    38840: 1229:            item_link_q(it);
        -: 1230:        }
   110550: 1231:        if ((flags & LRU_PULL_RETURN_ITEM) == 0) {
   110550: 1232:            do_item_remove(it);
   110550: 1233:            item_trylock_unlock(hold_lock);
        -: 1234:        }
        -: 1235:    }
        -: 1236:
        -: 1237:    return removed;
        -: 1238:}
------------------
        -: 1239:
        -: 1240:
        -: 1241:/* TODO: Third place this code needs to be deduped */
     1536: 1242:static void lru_bump_buf_link_q(lru_bump_buf *b) {
     1536: 1243:    pthread_mutex_lock(&bump_buf_lock);
    1536*: 1244:    assert(b != bump_buf_head);
        -: 1245:
     1536: 1246:    b->prev = 0;
     1536: 1247:    b->next = bump_buf_head;
     1536: 1248:    if (b->next) b->next->prev = b;
     1536: 1249:    bump_buf_head = b;
     1536: 1250:    if (bump_buf_tail == 0) bump_buf_tail = b;
     1536: 1251:    pthread_mutex_unlock(&bump_buf_lock);
     1536: 1252:    return;
        -: 1253:}
------------------
lru_bump_buf_link_q:
      384: 1242:static void lru_bump_buf_link_q(lru_bump_buf *b) {
      384: 1243:    pthread_mutex_lock(&bump_buf_lock);
     384*: 1244:    assert(b != bump_buf_head);
        -: 1245:
      384: 1246:    b->prev = 0;
      384: 1247:    b->next = bump_buf_head;
      384: 1248:    if (b->next) b->next->prev = b;
      384: 1249:    bump_buf_head = b;
      384: 1250:    if (bump_buf_tail == 0) bump_buf_tail = b;
      384: 1251:    pthread_mutex_unlock(&bump_buf_lock);
      384: 1252:    return;
        -: 1253:}
------------------
lru_bump_buf_link_q:
      384: 1242:static void lru_bump_buf_link_q(lru_bump_buf *b) {
      384: 1243:    pthread_mutex_lock(&bump_buf_lock);
     384*: 1244:    assert(b != bump_buf_head);
        -: 1245:
      384: 1246:    b->prev = 0;
      384: 1247:    b->next = bump_buf_head;
      384: 1248:    if (b->next) b->next->prev = b;
      384: 1249:    bump_buf_head = b;
      384: 1250:    if (bump_buf_tail == 0) bump_buf_tail = b;
      384: 1251:    pthread_mutex_unlock(&bump_buf_lock);
      384: 1252:    return;
        -: 1253:}
------------------
lru_bump_buf_link_q:
      384: 1242:static void lru_bump_buf_link_q(lru_bump_buf *b) {
      384: 1243:    pthread_mutex_lock(&bump_buf_lock);
     384*: 1244:    assert(b != bump_buf_head);
        -: 1245:
      384: 1246:    b->prev = 0;
      384: 1247:    b->next = bump_buf_head;
      384: 1248:    if (b->next) b->next->prev = b;
      384: 1249:    bump_buf_head = b;
      384: 1250:    if (bump_buf_tail == 0) bump_buf_tail = b;
      384: 1251:    pthread_mutex_unlock(&bump_buf_lock);
      384: 1252:    return;
        -: 1253:}
------------------
lru_bump_buf_link_q:
      384: 1242:static void lru_bump_buf_link_q(lru_bump_buf *b) {
      384: 1243:    pthread_mutex_lock(&bump_buf_lock);
     384*: 1244:    assert(b != bump_buf_head);
        -: 1245:
      384: 1246:    b->prev = 0;
      384: 1247:    b->next = bump_buf_head;
      384: 1248:    if (b->next) b->next->prev = b;
      384: 1249:    bump_buf_head = b;
      384: 1250:    if (bump_buf_tail == 0) bump_buf_tail = b;
      384: 1251:    pthread_mutex_unlock(&bump_buf_lock);
      384: 1252:    return;
        -: 1253:}
------------------
        -: 1254:
     1536: 1255:void *item_lru_bump_buf_create(void) {
     1536: 1256:    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
     1536: 1257:    if (b == NULL) {
        -: 1258:        return NULL;
        -: 1259:    }
        -: 1260:
     1536: 1261:    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
     1536: 1262:    if (b->buf == NULL) {
    #####: 1263:        free(b);
    #####: 1264:        return NULL;
        -: 1265:    }
        -: 1266:
     1536: 1267:    pthread_mutex_init(&b->mutex, NULL);
        -: 1268:
     1536: 1269:    lru_bump_buf_link_q(b);
     1536: 1270:    return b;
        -: 1271:}
------------------
item_lru_bump_buf_create:
      384: 1255:void *item_lru_bump_buf_create(void) {
      384: 1256:    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
      384: 1257:    if (b == NULL) {
        -: 1258:        return NULL;
        -: 1259:    }
        -: 1260:
      384: 1261:    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
      384: 1262:    if (b->buf == NULL) {
    #####: 1263:        free(b);
    #####: 1264:        return NULL;
        -: 1265:    }
        -: 1266:
      384: 1267:    pthread_mutex_init(&b->mutex, NULL);
        -: 1268:
      384: 1269:    lru_bump_buf_link_q(b);
      384: 1270:    return b;
        -: 1271:}
------------------
item_lru_bump_buf_create:
      384: 1255:void *item_lru_bump_buf_create(void) {
      384: 1256:    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
      384: 1257:    if (b == NULL) {
        -: 1258:        return NULL;
        -: 1259:    }
        -: 1260:
      384: 1261:    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
      384: 1262:    if (b->buf == NULL) {
    #####: 1263:        free(b);
    #####: 1264:        return NULL;
        -: 1265:    }
        -: 1266:
      384: 1267:    pthread_mutex_init(&b->mutex, NULL);
        -: 1268:
      384: 1269:    lru_bump_buf_link_q(b);
      384: 1270:    return b;
        -: 1271:}
------------------
item_lru_bump_buf_create:
      384: 1255:void *item_lru_bump_buf_create(void) {
      384: 1256:    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
      384: 1257:    if (b == NULL) {
        -: 1258:        return NULL;
        -: 1259:    }
        -: 1260:
      384: 1261:    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
      384: 1262:    if (b->buf == NULL) {
    #####: 1263:        free(b);
    #####: 1264:        return NULL;
        -: 1265:    }
        -: 1266:
      384: 1267:    pthread_mutex_init(&b->mutex, NULL);
        -: 1268:
      384: 1269:    lru_bump_buf_link_q(b);
      384: 1270:    return b;
        -: 1271:}
------------------
item_lru_bump_buf_create:
      384: 1255:void *item_lru_bump_buf_create(void) {
      384: 1256:    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
      384: 1257:    if (b == NULL) {
        -: 1258:        return NULL;
        -: 1259:    }
        -: 1260:
      384: 1261:    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
      384: 1262:    if (b->buf == NULL) {
    #####: 1263:        free(b);
    #####: 1264:        return NULL;
        -: 1265:    }
        -: 1266:
      384: 1267:    pthread_mutex_init(&b->mutex, NULL);
        -: 1268:
      384: 1269:    lru_bump_buf_link_q(b);
      384: 1270:    return b;
        -: 1271:}
------------------
        -: 1272:
       44: 1273:static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {
       44: 1274:    bool ret = true;
       44: 1275:    refcount_incr(it);
       44: 1276:    pthread_mutex_lock(&b->mutex);
       44: 1277:    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
       44: 1278:    if (be != NULL) {
       44: 1279:        be->it = it;
       44: 1280:        be->hv = hv;
       44: 1281:        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
    #####: 1282:            ret = false;
    #####: 1283:            b->dropped++;
        -: 1284:        }
        -: 1285:    } else {
    #####: 1286:        ret = false;
    #####: 1287:        b->dropped++;
        -: 1288:    }
    #####: 1289:    if (!ret) {
    #####: 1290:        refcount_decr(it);
        -: 1291:    }
       44: 1292:    pthread_mutex_unlock(&b->mutex);
       44: 1293:    return ret;
        -: 1294:}
------------------
lru_bump_async:
       11: 1273:static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {
       11: 1274:    bool ret = true;
       11: 1275:    refcount_incr(it);
       11: 1276:    pthread_mutex_lock(&b->mutex);
       11: 1277:    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
       11: 1278:    if (be != NULL) {
       11: 1279:        be->it = it;
       11: 1280:        be->hv = hv;
       11: 1281:        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
    #####: 1282:            ret = false;
    #####: 1283:            b->dropped++;
        -: 1284:        }
        -: 1285:    } else {
    #####: 1286:        ret = false;
    #####: 1287:        b->dropped++;
        -: 1288:    }
    #####: 1289:    if (!ret) {
    #####: 1290:        refcount_decr(it);
        -: 1291:    }
       11: 1292:    pthread_mutex_unlock(&b->mutex);
       11: 1293:    return ret;
        -: 1294:}
------------------
lru_bump_async:
       11: 1273:static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {
       11: 1274:    bool ret = true;
       11: 1275:    refcount_incr(it);
       11: 1276:    pthread_mutex_lock(&b->mutex);
       11: 1277:    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
       11: 1278:    if (be != NULL) {
       11: 1279:        be->it = it;
       11: 1280:        be->hv = hv;
       11: 1281:        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
    #####: 1282:            ret = false;
    #####: 1283:            b->dropped++;
        -: 1284:        }
        -: 1285:    } else {
    #####: 1286:        ret = false;
    #####: 1287:        b->dropped++;
        -: 1288:    }
    #####: 1289:    if (!ret) {
    #####: 1290:        refcount_decr(it);
        -: 1291:    }
       11: 1292:    pthread_mutex_unlock(&b->mutex);
       11: 1293:    return ret;
        -: 1294:}
------------------
lru_bump_async:
       11: 1273:static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {
       11: 1274:    bool ret = true;
       11: 1275:    refcount_incr(it);
       11: 1276:    pthread_mutex_lock(&b->mutex);
       11: 1277:    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
       11: 1278:    if (be != NULL) {
       11: 1279:        be->it = it;
       11: 1280:        be->hv = hv;
       11: 1281:        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
    #####: 1282:            ret = false;
    #####: 1283:            b->dropped++;
        -: 1284:        }
        -: 1285:    } else {
    #####: 1286:        ret = false;
    #####: 1287:        b->dropped++;
        -: 1288:    }
    #####: 1289:    if (!ret) {
    #####: 1290:        refcount_decr(it);
        -: 1291:    }
       11: 1292:    pthread_mutex_unlock(&b->mutex);
       11: 1293:    return ret;
        -: 1294:}
------------------
lru_bump_async:
       11: 1273:static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {
       11: 1274:    bool ret = true;
       11: 1275:    refcount_incr(it);
       11: 1276:    pthread_mutex_lock(&b->mutex);
       11: 1277:    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
       11: 1278:    if (be != NULL) {
       11: 1279:        be->it = it;
       11: 1280:        be->hv = hv;
       11: 1281:        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
    #####: 1282:            ret = false;
    #####: 1283:            b->dropped++;
        -: 1284:        }
        -: 1285:    } else {
    #####: 1286:        ret = false;
    #####: 1287:        b->dropped++;
        -: 1288:    }
    #####: 1289:    if (!ret) {
    #####: 1290:        refcount_decr(it);
        -: 1291:    }
       11: 1292:    pthread_mutex_unlock(&b->mutex);
       11: 1293:    return ret;
        -: 1294:}
------------------
        -: 1295:
        -: 1296:/* TODO: Might be worth a micro-optimization of having bump buffers link
        -: 1297: * themselves back into the central queue when queue goes from zero to
        -: 1298: * non-zero, then remove from list if zero more than N times.
        -: 1299: * If very few hits on cold this would avoid extra memory barriers from LRU
        -: 1300: * maintainer thread. If many hits, they'll just stay in the list.
        -: 1301: */
    25952: 1302:static bool lru_maintainer_bumps(void) {
    25952: 1303:    lru_bump_buf *b;
    25952: 1304:    lru_bump_entry *be;
    25952: 1305:    unsigned int size;
    25952: 1306:    unsigned int todo;
    25952: 1307:    bool bumped = false;
    25952: 1308:    pthread_mutex_lock(&bump_buf_lock);
   129760: 1309:    for (b = bump_buf_head; b != NULL; b=b->next) {
   103808: 1310:        pthread_mutex_lock(&b->mutex);
   103808: 1311:        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
   103808: 1312:        pthread_mutex_unlock(&b->mutex);
        -: 1313:
   103808: 1314:        if (be == NULL) {
        -: 1315:            continue;
        -: 1316:        }
       20: 1317:        todo = size;
       20: 1318:        bumped = true;
        -: 1319:
       44: 1320:        while (todo) {
       24: 1321:            item_lock(be->hv);
       24: 1322:            do_item_update(be->it);
       24: 1323:            do_item_remove(be->it);
       24: 1324:            item_unlock(be->hv);
       24: 1325:            be++;
       24: 1326:            todo -= sizeof(lru_bump_entry);
        -: 1327:        }
        -: 1328:
       20: 1329:        pthread_mutex_lock(&b->mutex);
       20: 1330:        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
       20: 1331:        pthread_mutex_unlock(&b->mutex);
        -: 1332:    }
    25952: 1333:    pthread_mutex_unlock(&bump_buf_lock);
    25952: 1334:    return bumped;
        -: 1335:}
------------------
lru_maintainer_bumps:
     6488: 1302:static bool lru_maintainer_bumps(void) {
     6488: 1303:    lru_bump_buf *b;
     6488: 1304:    lru_bump_entry *be;
     6488: 1305:    unsigned int size;
     6488: 1306:    unsigned int todo;
     6488: 1307:    bool bumped = false;
     6488: 1308:    pthread_mutex_lock(&bump_buf_lock);
    32440: 1309:    for (b = bump_buf_head; b != NULL; b=b->next) {
    25952: 1310:        pthread_mutex_lock(&b->mutex);
    25952: 1311:        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
    25952: 1312:        pthread_mutex_unlock(&b->mutex);
        -: 1313:
    25952: 1314:        if (be == NULL) {
        -: 1315:            continue;
        -: 1316:        }
        5: 1317:        todo = size;
        5: 1318:        bumped = true;
        -: 1319:
       11: 1320:        while (todo) {
        6: 1321:            item_lock(be->hv);
        6: 1322:            do_item_update(be->it);
        6: 1323:            do_item_remove(be->it);
        6: 1324:            item_unlock(be->hv);
        6: 1325:            be++;
        6: 1326:            todo -= sizeof(lru_bump_entry);
        -: 1327:        }
        -: 1328:
        5: 1329:        pthread_mutex_lock(&b->mutex);
        5: 1330:        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        5: 1331:        pthread_mutex_unlock(&b->mutex);
        -: 1332:    }
     6488: 1333:    pthread_mutex_unlock(&bump_buf_lock);
     6488: 1334:    return bumped;
        -: 1335:}
------------------
lru_maintainer_bumps:
     6488: 1302:static bool lru_maintainer_bumps(void) {
     6488: 1303:    lru_bump_buf *b;
     6488: 1304:    lru_bump_entry *be;
     6488: 1305:    unsigned int size;
     6488: 1306:    unsigned int todo;
     6488: 1307:    bool bumped = false;
     6488: 1308:    pthread_mutex_lock(&bump_buf_lock);
    32440: 1309:    for (b = bump_buf_head; b != NULL; b=b->next) {
    25952: 1310:        pthread_mutex_lock(&b->mutex);
    25952: 1311:        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
    25952: 1312:        pthread_mutex_unlock(&b->mutex);
        -: 1313:
    25952: 1314:        if (be == NULL) {
        -: 1315:            continue;
        -: 1316:        }
        5: 1317:        todo = size;
        5: 1318:        bumped = true;
        -: 1319:
       11: 1320:        while (todo) {
        6: 1321:            item_lock(be->hv);
        6: 1322:            do_item_update(be->it);
        6: 1323:            do_item_remove(be->it);
        6: 1324:            item_unlock(be->hv);
        6: 1325:            be++;
        6: 1326:            todo -= sizeof(lru_bump_entry);
        -: 1327:        }
        -: 1328:
        5: 1329:        pthread_mutex_lock(&b->mutex);
        5: 1330:        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        5: 1331:        pthread_mutex_unlock(&b->mutex);
        -: 1332:    }
     6488: 1333:    pthread_mutex_unlock(&bump_buf_lock);
     6488: 1334:    return bumped;
        -: 1335:}
------------------
lru_maintainer_bumps:
     6488: 1302:static bool lru_maintainer_bumps(void) {
     6488: 1303:    lru_bump_buf *b;
     6488: 1304:    lru_bump_entry *be;
     6488: 1305:    unsigned int size;
     6488: 1306:    unsigned int todo;
     6488: 1307:    bool bumped = false;
     6488: 1308:    pthread_mutex_lock(&bump_buf_lock);
    32440: 1309:    for (b = bump_buf_head; b != NULL; b=b->next) {
    25952: 1310:        pthread_mutex_lock(&b->mutex);
    25952: 1311:        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
    25952: 1312:        pthread_mutex_unlock(&b->mutex);
        -: 1313:
    25952: 1314:        if (be == NULL) {
        -: 1315:            continue;
        -: 1316:        }
        5: 1317:        todo = size;
        5: 1318:        bumped = true;
        -: 1319:
       11: 1320:        while (todo) {
        6: 1321:            item_lock(be->hv);
        6: 1322:            do_item_update(be->it);
        6: 1323:            do_item_remove(be->it);
        6: 1324:            item_unlock(be->hv);
        6: 1325:            be++;
        6: 1326:            todo -= sizeof(lru_bump_entry);
        -: 1327:        }
        -: 1328:
        5: 1329:        pthread_mutex_lock(&b->mutex);
        5: 1330:        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        5: 1331:        pthread_mutex_unlock(&b->mutex);
        -: 1332:    }
     6488: 1333:    pthread_mutex_unlock(&bump_buf_lock);
     6488: 1334:    return bumped;
        -: 1335:}
------------------
lru_maintainer_bumps:
     6488: 1302:static bool lru_maintainer_bumps(void) {
     6488: 1303:    lru_bump_buf *b;
     6488: 1304:    lru_bump_entry *be;
     6488: 1305:    unsigned int size;
     6488: 1306:    unsigned int todo;
     6488: 1307:    bool bumped = false;
     6488: 1308:    pthread_mutex_lock(&bump_buf_lock);
    32440: 1309:    for (b = bump_buf_head; b != NULL; b=b->next) {
    25952: 1310:        pthread_mutex_lock(&b->mutex);
    25952: 1311:        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
    25952: 1312:        pthread_mutex_unlock(&b->mutex);
        -: 1313:
    25952: 1314:        if (be == NULL) {
        -: 1315:            continue;
        -: 1316:        }
        5: 1317:        todo = size;
        5: 1318:        bumped = true;
        -: 1319:
       11: 1320:        while (todo) {
        6: 1321:            item_lock(be->hv);
        6: 1322:            do_item_update(be->it);
        6: 1323:            do_item_remove(be->it);
        6: 1324:            item_unlock(be->hv);
        6: 1325:            be++;
        6: 1326:            todo -= sizeof(lru_bump_entry);
        -: 1327:        }
        -: 1328:
        5: 1329:        pthread_mutex_lock(&b->mutex);
        5: 1330:        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        5: 1331:        pthread_mutex_unlock(&b->mutex);
        -: 1332:    }
     6488: 1333:    pthread_mutex_unlock(&bump_buf_lock);
     6488: 1334:    return bumped;
        -: 1335:}
------------------
        -: 1336:
    10536: 1337:static uint64_t lru_total_bumps_dropped(void) {
    10536: 1338:    uint64_t total = 0;
    10536: 1339:    lru_bump_buf *b;
    10536: 1340:    pthread_mutex_lock(&bump_buf_lock);
    52680: 1341:    for (b = bump_buf_head; b != NULL; b=b->next) {
    42144: 1342:        pthread_mutex_lock(&b->mutex);
    42144: 1343:        total += b->dropped;
    42144: 1344:        pthread_mutex_unlock(&b->mutex);
        -: 1345:    }
    10536: 1346:    pthread_mutex_unlock(&bump_buf_lock);
    10536: 1347:    return total;
        -: 1348:}
------------------
lru_total_bumps_dropped:
     2634: 1337:static uint64_t lru_total_bumps_dropped(void) {
     2634: 1338:    uint64_t total = 0;
     2634: 1339:    lru_bump_buf *b;
     2634: 1340:    pthread_mutex_lock(&bump_buf_lock);
    13170: 1341:    for (b = bump_buf_head; b != NULL; b=b->next) {
    10536: 1342:        pthread_mutex_lock(&b->mutex);
    10536: 1343:        total += b->dropped;
    10536: 1344:        pthread_mutex_unlock(&b->mutex);
        -: 1345:    }
     2634: 1346:    pthread_mutex_unlock(&bump_buf_lock);
     2634: 1347:    return total;
        -: 1348:}
------------------
lru_total_bumps_dropped:
     2634: 1337:static uint64_t lru_total_bumps_dropped(void) {
     2634: 1338:    uint64_t total = 0;
     2634: 1339:    lru_bump_buf *b;
     2634: 1340:    pthread_mutex_lock(&bump_buf_lock);
    13170: 1341:    for (b = bump_buf_head; b != NULL; b=b->next) {
    10536: 1342:        pthread_mutex_lock(&b->mutex);
    10536: 1343:        total += b->dropped;
    10536: 1344:        pthread_mutex_unlock(&b->mutex);
        -: 1345:    }
     2634: 1346:    pthread_mutex_unlock(&bump_buf_lock);
     2634: 1347:    return total;
        -: 1348:}
------------------
lru_total_bumps_dropped:
     2634: 1337:static uint64_t lru_total_bumps_dropped(void) {
     2634: 1338:    uint64_t total = 0;
     2634: 1339:    lru_bump_buf *b;
     2634: 1340:    pthread_mutex_lock(&bump_buf_lock);
    13170: 1341:    for (b = bump_buf_head; b != NULL; b=b->next) {
    10536: 1342:        pthread_mutex_lock(&b->mutex);
    10536: 1343:        total += b->dropped;
    10536: 1344:        pthread_mutex_unlock(&b->mutex);
        -: 1345:    }
     2634: 1346:    pthread_mutex_unlock(&bump_buf_lock);
     2634: 1347:    return total;
        -: 1348:}
------------------
lru_total_bumps_dropped:
     2634: 1337:static uint64_t lru_total_bumps_dropped(void) {
     2634: 1338:    uint64_t total = 0;
     2634: 1339:    lru_bump_buf *b;
     2634: 1340:    pthread_mutex_lock(&bump_buf_lock);
    13170: 1341:    for (b = bump_buf_head; b != NULL; b=b->next) {
    10536: 1342:        pthread_mutex_lock(&b->mutex);
    10536: 1343:        total += b->dropped;
    10536: 1344:        pthread_mutex_unlock(&b->mutex);
        -: 1345:    }
     2634: 1346:    pthread_mutex_unlock(&bump_buf_lock);
     2634: 1347:    return total;
        -: 1348:}
------------------
        -: 1349:
        -: 1350:/* Loop up to N times:
        -: 1351: * If too many items are in HOT_LRU, push to COLD_LRU
        -: 1352: * If too many items are in WARM_LRU, push to COLD_LRU
        -: 1353: * If too many items are in COLD_LRU, poke COLD_LRU tail
        -: 1354: * 1000 loops with 1ms min sleep gives us under 1m items shifted/sec. The
        -: 1355: * locks can't handle much more than that. Leaving a TODO for how to
        -: 1356: * autoadjust in the future.
        -: 1357: */
   905392: 1358:static int lru_maintainer_juggle(const int slabs_clsid) {
   905392: 1359:    int i;
   905392: 1360:    int did_moves = 0;
   905392: 1361:    uint64_t total_bytes = 0;
   905392: 1362:    unsigned int chunks_perslab = 0;
        -: 1363:    //unsigned int chunks_free = 0;
        -: 1364:    /* TODO: if free_chunks below high watermark, increase aggressiveness */
   905392: 1365:    slabs_available_chunks(slabs_clsid, NULL,
        -: 1366:            &total_bytes, &chunks_perslab);
   905392: 1367:    if (settings.temp_lru) {
        -: 1368:        /* Only looking for reclaims. Run before we size the LRU. */
   10584*: 1369:        for (i = 0; i < 500; i++) {
    10584: 1370:            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
        -: 1371:                break;
        -: 1372:            } else {
    #####: 1373:                did_moves++;
        -: 1374:            }
        -: 1375:        }
    21168: 1376:        total_bytes -= temp_lru_size(slabs_clsid);
        -: 1377:    }
        -: 1378:
   905392: 1379:    rel_time_t cold_age = 0;
   905392: 1380:    rel_time_t hot_age = 0;
   905392: 1381:    rel_time_t warm_age = 0;
        -: 1382:    /* If LRU is in flat mode, force items to drain into COLD via max age */
   905392: 1383:    if (settings.lru_segmented) {
   905392: 1384:        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
   905392: 1385:        if (tails[slabs_clsid|COLD_LRU]) {
    11804: 1386:            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        -: 1387:        }
   905392: 1388:        pthread_mutex_unlock(&lru_locks[slabs_clsid|COLD_LRU]);
   905392: 1389:        hot_age = cold_age * settings.hot_max_factor;
   905392: 1390:        warm_age = cold_age * settings.warm_max_factor;
        -: 1391:    }
        -: 1392:
        -: 1393:    /* Juggle HOT/WARM up to N times */
  1023504: 1394:    for (i = 0; i < 500; i++) {
  1023396: 1395:        int do_more = 0;
  1934280: 1396:        if (lru_pull_tail(slabs_clsid, HOT_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, hot_age, NULL) ||
   910884: 1397:            lru_pull_tail(slabs_clsid, WARM_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, warm_age, NULL)) {
        -: 1398:            do_more++;
        -: 1399:        }
  1023396: 1400:        if (settings.lru_segmented) {
  1023396: 1401:            do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, 0, NULL);
        -: 1402:        }
  1023396: 1403:        if (do_more == 0)
        -: 1404:            break;
   118112: 1405:        did_moves++;
        -: 1406:    }
   905392: 1407:    return did_moves;
        -: 1408:}
------------------
lru_maintainer_juggle:
   226348: 1358:static int lru_maintainer_juggle(const int slabs_clsid) {
   226348: 1359:    int i;
   226348: 1360:    int did_moves = 0;
   226348: 1361:    uint64_t total_bytes = 0;
   226348: 1362:    unsigned int chunks_perslab = 0;
        -: 1363:    //unsigned int chunks_free = 0;
        -: 1364:    /* TODO: if free_chunks below high watermark, increase aggressiveness */
   226348: 1365:    slabs_available_chunks(slabs_clsid, NULL,
        -: 1366:            &total_bytes, &chunks_perslab);
   226348: 1367:    if (settings.temp_lru) {
        -: 1368:        /* Only looking for reclaims. Run before we size the LRU. */
    2646*: 1369:        for (i = 0; i < 500; i++) {
     2646: 1370:            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
        -: 1371:                break;
        -: 1372:            } else {
    #####: 1373:                did_moves++;
        -: 1374:            }
        -: 1375:        }
     5292: 1376:        total_bytes -= temp_lru_size(slabs_clsid);
        -: 1377:    }
        -: 1378:
   226348: 1379:    rel_time_t cold_age = 0;
   226348: 1380:    rel_time_t hot_age = 0;
   226348: 1381:    rel_time_t warm_age = 0;
        -: 1382:    /* If LRU is in flat mode, force items to drain into COLD via max age */
   226348: 1383:    if (settings.lru_segmented) {
   226348: 1384:        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1385:        if (tails[slabs_clsid|COLD_LRU]) {
     2951: 1386:            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        -: 1387:        }
   226348: 1388:        pthread_mutex_unlock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1389:        hot_age = cold_age * settings.hot_max_factor;
   226348: 1390:        warm_age = cold_age * settings.warm_max_factor;
        -: 1391:    }
        -: 1392:
        -: 1393:    /* Juggle HOT/WARM up to N times */
   255876: 1394:    for (i = 0; i < 500; i++) {
   255849: 1395:        int do_more = 0;
   483570: 1396:        if (lru_pull_tail(slabs_clsid, HOT_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, hot_age, NULL) ||
   227721: 1397:            lru_pull_tail(slabs_clsid, WARM_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, warm_age, NULL)) {
        -: 1398:            do_more++;
        -: 1399:        }
   255849: 1400:        if (settings.lru_segmented) {
   255849: 1401:            do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, 0, NULL);
        -: 1402:        }
   255849: 1403:        if (do_more == 0)
        -: 1404:            break;
    29528: 1405:        did_moves++;
        -: 1406:    }
   226348: 1407:    return did_moves;
        -: 1408:}
------------------
lru_maintainer_juggle:
   226348: 1358:static int lru_maintainer_juggle(const int slabs_clsid) {
   226348: 1359:    int i;
   226348: 1360:    int did_moves = 0;
   226348: 1361:    uint64_t total_bytes = 0;
   226348: 1362:    unsigned int chunks_perslab = 0;
        -: 1363:    //unsigned int chunks_free = 0;
        -: 1364:    /* TODO: if free_chunks below high watermark, increase aggressiveness */
   226348: 1365:    slabs_available_chunks(slabs_clsid, NULL,
        -: 1366:            &total_bytes, &chunks_perslab);
   226348: 1367:    if (settings.temp_lru) {
        -: 1368:        /* Only looking for reclaims. Run before we size the LRU. */
    2646*: 1369:        for (i = 0; i < 500; i++) {
     2646: 1370:            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
        -: 1371:                break;
        -: 1372:            } else {
    #####: 1373:                did_moves++;
        -: 1374:            }
        -: 1375:        }
     5292: 1376:        total_bytes -= temp_lru_size(slabs_clsid);
        -: 1377:    }
        -: 1378:
   226348: 1379:    rel_time_t cold_age = 0;
   226348: 1380:    rel_time_t hot_age = 0;
   226348: 1381:    rel_time_t warm_age = 0;
        -: 1382:    /* If LRU is in flat mode, force items to drain into COLD via max age */
   226348: 1383:    if (settings.lru_segmented) {
   226348: 1384:        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1385:        if (tails[slabs_clsid|COLD_LRU]) {
     2951: 1386:            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        -: 1387:        }
   226348: 1388:        pthread_mutex_unlock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1389:        hot_age = cold_age * settings.hot_max_factor;
   226348: 1390:        warm_age = cold_age * settings.warm_max_factor;
        -: 1391:    }
        -: 1392:
        -: 1393:    /* Juggle HOT/WARM up to N times */
   255876: 1394:    for (i = 0; i < 500; i++) {
   255849: 1395:        int do_more = 0;
   483570: 1396:        if (lru_pull_tail(slabs_clsid, HOT_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, hot_age, NULL) ||
   227721: 1397:            lru_pull_tail(slabs_clsid, WARM_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, warm_age, NULL)) {
        -: 1398:            do_more++;
        -: 1399:        }
   255849: 1400:        if (settings.lru_segmented) {
   255849: 1401:            do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, 0, NULL);
        -: 1402:        }
   255849: 1403:        if (do_more == 0)
        -: 1404:            break;
    29528: 1405:        did_moves++;
        -: 1406:    }
   226348: 1407:    return did_moves;
        -: 1408:}
------------------
lru_maintainer_juggle:
   226348: 1358:static int lru_maintainer_juggle(const int slabs_clsid) {
   226348: 1359:    int i;
   226348: 1360:    int did_moves = 0;
   226348: 1361:    uint64_t total_bytes = 0;
   226348: 1362:    unsigned int chunks_perslab = 0;
        -: 1363:    //unsigned int chunks_free = 0;
        -: 1364:    /* TODO: if free_chunks below high watermark, increase aggressiveness */
   226348: 1365:    slabs_available_chunks(slabs_clsid, NULL,
        -: 1366:            &total_bytes, &chunks_perslab);
   226348: 1367:    if (settings.temp_lru) {
        -: 1368:        /* Only looking for reclaims. Run before we size the LRU. */
    2646*: 1369:        for (i = 0; i < 500; i++) {
     2646: 1370:            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
        -: 1371:                break;
        -: 1372:            } else {
    #####: 1373:                did_moves++;
        -: 1374:            }
        -: 1375:        }
     5292: 1376:        total_bytes -= temp_lru_size(slabs_clsid);
        -: 1377:    }
        -: 1378:
   226348: 1379:    rel_time_t cold_age = 0;
   226348: 1380:    rel_time_t hot_age = 0;
   226348: 1381:    rel_time_t warm_age = 0;
        -: 1382:    /* If LRU is in flat mode, force items to drain into COLD via max age */
   226348: 1383:    if (settings.lru_segmented) {
   226348: 1384:        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1385:        if (tails[slabs_clsid|COLD_LRU]) {
     2951: 1386:            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        -: 1387:        }
   226348: 1388:        pthread_mutex_unlock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1389:        hot_age = cold_age * settings.hot_max_factor;
   226348: 1390:        warm_age = cold_age * settings.warm_max_factor;
        -: 1391:    }
        -: 1392:
        -: 1393:    /* Juggle HOT/WARM up to N times */
   255876: 1394:    for (i = 0; i < 500; i++) {
   255849: 1395:        int do_more = 0;
   483570: 1396:        if (lru_pull_tail(slabs_clsid, HOT_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, hot_age, NULL) ||
   227721: 1397:            lru_pull_tail(slabs_clsid, WARM_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, warm_age, NULL)) {
        -: 1398:            do_more++;
        -: 1399:        }
   255849: 1400:        if (settings.lru_segmented) {
   255849: 1401:            do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, 0, NULL);
        -: 1402:        }
   255849: 1403:        if (do_more == 0)
        -: 1404:            break;
    29528: 1405:        did_moves++;
        -: 1406:    }
   226348: 1407:    return did_moves;
        -: 1408:}
------------------
lru_maintainer_juggle:
   226348: 1358:static int lru_maintainer_juggle(const int slabs_clsid) {
   226348: 1359:    int i;
   226348: 1360:    int did_moves = 0;
   226348: 1361:    uint64_t total_bytes = 0;
   226348: 1362:    unsigned int chunks_perslab = 0;
        -: 1363:    //unsigned int chunks_free = 0;
        -: 1364:    /* TODO: if free_chunks below high watermark, increase aggressiveness */
   226348: 1365:    slabs_available_chunks(slabs_clsid, NULL,
        -: 1366:            &total_bytes, &chunks_perslab);
   226348: 1367:    if (settings.temp_lru) {
        -: 1368:        /* Only looking for reclaims. Run before we size the LRU. */
    2646*: 1369:        for (i = 0; i < 500; i++) {
     2646: 1370:            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
        -: 1371:                break;
        -: 1372:            } else {
    #####: 1373:                did_moves++;
        -: 1374:            }
        -: 1375:        }
     5292: 1376:        total_bytes -= temp_lru_size(slabs_clsid);
        -: 1377:    }
        -: 1378:
   226348: 1379:    rel_time_t cold_age = 0;
   226348: 1380:    rel_time_t hot_age = 0;
   226348: 1381:    rel_time_t warm_age = 0;
        -: 1382:    /* If LRU is in flat mode, force items to drain into COLD via max age */
   226348: 1383:    if (settings.lru_segmented) {
   226348: 1384:        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1385:        if (tails[slabs_clsid|COLD_LRU]) {
     2951: 1386:            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        -: 1387:        }
   226348: 1388:        pthread_mutex_unlock(&lru_locks[slabs_clsid|COLD_LRU]);
   226348: 1389:        hot_age = cold_age * settings.hot_max_factor;
   226348: 1390:        warm_age = cold_age * settings.warm_max_factor;
        -: 1391:    }
        -: 1392:
        -: 1393:    /* Juggle HOT/WARM up to N times */
   255876: 1394:    for (i = 0; i < 500; i++) {
   255849: 1395:        int do_more = 0;
   483570: 1396:        if (lru_pull_tail(slabs_clsid, HOT_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, hot_age, NULL) ||
   227721: 1397:            lru_pull_tail(slabs_clsid, WARM_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, warm_age, NULL)) {
        -: 1398:            do_more++;
        -: 1399:        }
   255849: 1400:        if (settings.lru_segmented) {
   255849: 1401:            do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, 0, NULL);
        -: 1402:        }
   255849: 1403:        if (do_more == 0)
        -: 1404:            break;
    29528: 1405:        did_moves++;
        -: 1406:    }
   226348: 1407:    return did_moves;
        -: 1408:}
------------------
        -: 1409:
        -: 1410:/* Will crawl all slab classes a minimum of once per hour */
        -: 1411:#define MAX_MAINTCRAWL_WAIT 60 * 60
        -: 1412:
        -: 1413:/* Hoping user input will improve this function. This is all a wild guess.
        -: 1414: * Operation: Kicks crawler for each slab id. Crawlers take some statistics as
        -: 1415: * to items with nonzero expirations. It then buckets how many items will
        -: 1416: * expire per minute for the next hour.
        -: 1417: * This function checks the results of a run, and if it things more than 1% of
        -: 1418: * expirable objects are ready to go, kick the crawler again to reap.
        -: 1419: * It will also kick the crawler once per minute regardless, waiting a minute
        -: 1420: * longer for each time it has no work to do, up to an hour wait time.
        -: 1421: * The latter is to avoid newly started daemons from waiting too long before
        -: 1422: * retrying a crawl.
        -: 1423: */
      732: 1424:static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
      732: 1425:    int i;
      732: 1426:    static rel_time_t next_crawls[POWER_LARGEST];
      732: 1427:    static rel_time_t next_crawl_wait[POWER_LARGEST];
      732: 1428:    uint8_t todo[POWER_LARGEST];
      732: 1429:    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
      732: 1430:    bool do_run = false;
      732: 1431:    unsigned int tocrawl_limit = 0;
        -: 1432:
        -: 1433:    // TODO: If not segmented LRU, skip non-cold
   187392: 1434:    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
   186660: 1435:        crawlerstats_t *s = &cdata->crawlerstats[i];
        -: 1436:        /* We've not successfully kicked off a crawl yet. */
   186660: 1437:        if (s->run_complete) {
    32640: 1438:            char *lru_name = "na";
    32640: 1439:            pthread_mutex_lock(&cdata->lock);
    32640: 1440:            int x;
        -: 1441:            /* Should we crawl again? */
    32640: 1442:            uint64_t possible_reclaims = s->seen - s->noexp;
    32640: 1443:            uint64_t available_reclaims = 0;
        -: 1444:            /* Need to think we can free at least 1% of the items before
        -: 1445:             * crawling. */
        -: 1446:            /* FIXME: Configurable? */
    32640: 1447:            uint64_t low_watermark = (possible_reclaims / 100) + 1;
    32640: 1448:            rel_time_t since_run = current_time - s->end_time;
        -: 1449:            /* Don't bother if the payoff is too low. */
  1991040: 1450:            for (x = 0; x < 60; x++) {
  1958400: 1451:                available_reclaims += s->histo[x];
  1958400: 1452:                if (available_reclaims > low_watermark) {
    #####: 1453:                    if (next_crawl_wait[i] < (x * 60)) {
    #####: 1454:                        next_crawl_wait[i] += 60;
    #####: 1455:                    } else if (next_crawl_wait[i] >= 60) {
    #####: 1456:                        next_crawl_wait[i] -= 60;
        -: 1457:                    }
        -: 1458:                    break;
        -: 1459:                }
        -: 1460:            }
        -: 1461:
    32640: 1462:            if (available_reclaims == 0) {
    32640: 1463:                next_crawl_wait[i] += 60;
        -: 1464:            }
        -: 1465:
    32640: 1466:            if (next_crawl_wait[i] > MAX_MAINTCRAWL_WAIT) {
    #####: 1467:                next_crawl_wait[i] = MAX_MAINTCRAWL_WAIT;
        -: 1468:            }
        -: 1469:
    32640: 1470:            next_crawls[i] = current_time + next_crawl_wait[i] + 5;
    32640: 1471:            switch (GET_LRU(i)) {
     8064: 1472:                case HOT_LRU:
     8064: 1473:                    lru_name = "hot";
     8064: 1474:                    break;
     8192: 1475:                case WARM_LRU:
     8192: 1476:                    lru_name = "warm";
     8192: 1477:                    break;
     8192: 1478:                case COLD_LRU:
     8192: 1479:                    lru_name = "cold";
     8192: 1480:                    break;
     8192: 1481:                case TEMP_LRU:
     8192: 1482:                    lru_name = "temp";
     8192: 1483:                    break;
        -: 1484:            }
   32640*: 1485:            LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_CRAWLER_STATUS, NULL,
        -: 1486:                    CLEAR_LRU(i),
        -: 1487:                    lru_name,
        -: 1488:                    (unsigned long long)low_watermark,
        -: 1489:                    (unsigned long long)available_reclaims,
        -: 1490:                    (unsigned int)since_run,
        -: 1491:                    next_crawls[i] - current_time,
        -: 1492:                    s->end_time - s->start_time,
        -: 1493:                    s->seen,
        -: 1494:                    s->reclaimed);
        -: 1495:            // Got our calculation, avoid running until next actual run.
    32640: 1496:            s->run_complete = false;
    32640: 1497:            pthread_mutex_unlock(&cdata->lock);
        -: 1498:        }
   186660: 1499:        if (current_time > next_crawls[i]) {
    89760: 1500:            pthread_mutex_lock(&lru_locks[i]);
    89760: 1501:            if (sizes[i] > tocrawl_limit) {
    #####: 1502:                tocrawl_limit = sizes[i];
        -: 1503:            }
    89760: 1504:            pthread_mutex_unlock(&lru_locks[i]);
    89760: 1505:            todo[i] = 1;
    89760: 1506:            do_run = true;
    89760: 1507:            next_crawls[i] = current_time + 5; // minimum retry wait.
        -: 1508:        }
        -: 1509:    }
      732: 1510:    if (do_run) {
     352*: 1511:        if (settings.lru_crawler_tocrawl && settings.lru_crawler_tocrawl < tocrawl_limit) {
    #####: 1512:            tocrawl_limit = settings.lru_crawler_tocrawl;
        -: 1513:        }
      352: 1514:        lru_crawler_start(todo, tocrawl_limit, CRAWLER_AUTOEXPIRE, cdata, NULL, 0);
        -: 1515:    }
      732: 1516:}
------------------
lru_maintainer_crawler_check:
      183: 1424:static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
      183: 1425:    int i;
      183: 1426:    static rel_time_t next_crawls[POWER_LARGEST];
      183: 1427:    static rel_time_t next_crawl_wait[POWER_LARGEST];
      183: 1428:    uint8_t todo[POWER_LARGEST];
      183: 1429:    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
      183: 1430:    bool do_run = false;
      183: 1431:    unsigned int tocrawl_limit = 0;
        -: 1432:
        -: 1433:    // TODO: If not segmented LRU, skip non-cold
    46848: 1434:    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
    46665: 1435:        crawlerstats_t *s = &cdata->crawlerstats[i];
        -: 1436:        /* We've not successfully kicked off a crawl yet. */
    46665: 1437:        if (s->run_complete) {
     8160: 1438:            char *lru_name = "na";
     8160: 1439:            pthread_mutex_lock(&cdata->lock);
     8160: 1440:            int x;
        -: 1441:            /* Should we crawl again? */
     8160: 1442:            uint64_t possible_reclaims = s->seen - s->noexp;
     8160: 1443:            uint64_t available_reclaims = 0;
        -: 1444:            /* Need to think we can free at least 1% of the items before
        -: 1445:             * crawling. */
        -: 1446:            /* FIXME: Configurable? */
     8160: 1447:            uint64_t low_watermark = (possible_reclaims / 100) + 1;
     8160: 1448:            rel_time_t since_run = current_time - s->end_time;
        -: 1449:            /* Don't bother if the payoff is too low. */
   497760: 1450:            for (x = 0; x < 60; x++) {
   489600: 1451:                available_reclaims += s->histo[x];
   489600: 1452:                if (available_reclaims > low_watermark) {
    #####: 1453:                    if (next_crawl_wait[i] < (x * 60)) {
    #####: 1454:                        next_crawl_wait[i] += 60;
    #####: 1455:                    } else if (next_crawl_wait[i] >= 60) {
    #####: 1456:                        next_crawl_wait[i] -= 60;
        -: 1457:                    }
        -: 1458:                    break;
        -: 1459:                }
        -: 1460:            }
        -: 1461:
     8160: 1462:            if (available_reclaims == 0) {
     8160: 1463:                next_crawl_wait[i] += 60;
        -: 1464:            }
        -: 1465:
     8160: 1466:            if (next_crawl_wait[i] > MAX_MAINTCRAWL_WAIT) {
    #####: 1467:                next_crawl_wait[i] = MAX_MAINTCRAWL_WAIT;
        -: 1468:            }
        -: 1469:
     8160: 1470:            next_crawls[i] = current_time + next_crawl_wait[i] + 5;
     8160: 1471:            switch (GET_LRU(i)) {
     2016: 1472:                case HOT_LRU:
     2016: 1473:                    lru_name = "hot";
     2016: 1474:                    break;
     2048: 1475:                case WARM_LRU:
     2048: 1476:                    lru_name = "warm";
     2048: 1477:                    break;
     2048: 1478:                case COLD_LRU:
     2048: 1479:                    lru_name = "cold";
     2048: 1480:                    break;
     2048: 1481:                case TEMP_LRU:
     2048: 1482:                    lru_name = "temp";
     2048: 1483:                    break;
        -: 1484:            }
    8160*: 1485:            LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_CRAWLER_STATUS, NULL,
        -: 1486:                    CLEAR_LRU(i),
        -: 1487:                    lru_name,
        -: 1488:                    (unsigned long long)low_watermark,
        -: 1489:                    (unsigned long long)available_reclaims,
        -: 1490:                    (unsigned int)since_run,
        -: 1491:                    next_crawls[i] - current_time,
        -: 1492:                    s->end_time - s->start_time,
        -: 1493:                    s->seen,
        -: 1494:                    s->reclaimed);
        -: 1495:            // Got our calculation, avoid running until next actual run.
     8160: 1496:            s->run_complete = false;
     8160: 1497:            pthread_mutex_unlock(&cdata->lock);
        -: 1498:        }
    46665: 1499:        if (current_time > next_crawls[i]) {
    22440: 1500:            pthread_mutex_lock(&lru_locks[i]);
    22440: 1501:            if (sizes[i] > tocrawl_limit) {
    #####: 1502:                tocrawl_limit = sizes[i];
        -: 1503:            }
    22440: 1504:            pthread_mutex_unlock(&lru_locks[i]);
    22440: 1505:            todo[i] = 1;
    22440: 1506:            do_run = true;
    22440: 1507:            next_crawls[i] = current_time + 5; // minimum retry wait.
        -: 1508:        }
        -: 1509:    }
      183: 1510:    if (do_run) {
      88*: 1511:        if (settings.lru_crawler_tocrawl && settings.lru_crawler_tocrawl < tocrawl_limit) {
    #####: 1512:            tocrawl_limit = settings.lru_crawler_tocrawl;
        -: 1513:        }
       88: 1514:        lru_crawler_start(todo, tocrawl_limit, CRAWLER_AUTOEXPIRE, cdata, NULL, 0);
        -: 1515:    }
      183: 1516:}
------------------
lru_maintainer_crawler_check:
      183: 1424:static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
      183: 1425:    int i;
      183: 1426:    static rel_time_t next_crawls[POWER_LARGEST];
      183: 1427:    static rel_time_t next_crawl_wait[POWER_LARGEST];
      183: 1428:    uint8_t todo[POWER_LARGEST];
      183: 1429:    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
      183: 1430:    bool do_run = false;
      183: 1431:    unsigned int tocrawl_limit = 0;
        -: 1432:
        -: 1433:    // TODO: If not segmented LRU, skip non-cold
    46848: 1434:    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
    46665: 1435:        crawlerstats_t *s = &cdata->crawlerstats[i];
        -: 1436:        /* We've not successfully kicked off a crawl yet. */
    46665: 1437:        if (s->run_complete) {
     8160: 1438:            char *lru_name = "na";
     8160: 1439:            pthread_mutex_lock(&cdata->lock);
     8160: 1440:            int x;
        -: 1441:            /* Should we crawl again? */
     8160: 1442:            uint64_t possible_reclaims = s->seen - s->noexp;
     8160: 1443:            uint64_t available_reclaims = 0;
        -: 1444:            /* Need to think we can free at least 1% of the items before
        -: 1445:             * crawling. */
        -: 1446:            /* FIXME: Configurable? */
     8160: 1447:            uint64_t low_watermark = (possible_reclaims / 100) + 1;
     8160: 1448:            rel_time_t since_run = current_time - s->end_time;
        -: 1449:            /* Don't bother if the payoff is too low. */
   497760: 1450:            for (x = 0; x < 60; x++) {
   489600: 1451:                available_reclaims += s->histo[x];
   489600: 1452:                if (available_reclaims > low_watermark) {
    #####: 1453:                    if (next_crawl_wait[i] < (x * 60)) {
    #####: 1454:                        next_crawl_wait[i] += 60;
    #####: 1455:                    } else if (next_crawl_wait[i] >= 60) {
    #####: 1456:                        next_crawl_wait[i] -= 60;
        -: 1457:                    }
        -: 1458:                    break;
        -: 1459:                }
        -: 1460:            }
        -: 1461:
     8160: 1462:            if (available_reclaims == 0) {
     8160: 1463:                next_crawl_wait[i] += 60;
        -: 1464:            }
        -: 1465:
     8160: 1466:            if (next_crawl_wait[i] > MAX_MAINTCRAWL_WAIT) {
    #####: 1467:                next_crawl_wait[i] = MAX_MAINTCRAWL_WAIT;
        -: 1468:            }
        -: 1469:
     8160: 1470:            next_crawls[i] = current_time + next_crawl_wait[i] + 5;
     8160: 1471:            switch (GET_LRU(i)) {
     2016: 1472:                case HOT_LRU:
     2016: 1473:                    lru_name = "hot";
     2016: 1474:                    break;
     2048: 1475:                case WARM_LRU:
     2048: 1476:                    lru_name = "warm";
     2048: 1477:                    break;
     2048: 1478:                case COLD_LRU:
     2048: 1479:                    lru_name = "cold";
     2048: 1480:                    break;
     2048: 1481:                case TEMP_LRU:
     2048: 1482:                    lru_name = "temp";
     2048: 1483:                    break;
        -: 1484:            }
    8160*: 1485:            LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_CRAWLER_STATUS, NULL,
        -: 1486:                    CLEAR_LRU(i),
        -: 1487:                    lru_name,
        -: 1488:                    (unsigned long long)low_watermark,
        -: 1489:                    (unsigned long long)available_reclaims,
        -: 1490:                    (unsigned int)since_run,
        -: 1491:                    next_crawls[i] - current_time,
        -: 1492:                    s->end_time - s->start_time,
        -: 1493:                    s->seen,
        -: 1494:                    s->reclaimed);
        -: 1495:            // Got our calculation, avoid running until next actual run.
     8160: 1496:            s->run_complete = false;
     8160: 1497:            pthread_mutex_unlock(&cdata->lock);
        -: 1498:        }
    46665: 1499:        if (current_time > next_crawls[i]) {
    22440: 1500:            pthread_mutex_lock(&lru_locks[i]);
    22440: 1501:            if (sizes[i] > tocrawl_limit) {
    #####: 1502:                tocrawl_limit = sizes[i];
        -: 1503:            }
    22440: 1504:            pthread_mutex_unlock(&lru_locks[i]);
    22440: 1505:            todo[i] = 1;
    22440: 1506:            do_run = true;
    22440: 1507:            next_crawls[i] = current_time + 5; // minimum retry wait.
        -: 1508:        }
        -: 1509:    }
      183: 1510:    if (do_run) {
      88*: 1511:        if (settings.lru_crawler_tocrawl && settings.lru_crawler_tocrawl < tocrawl_limit) {
    #####: 1512:            tocrawl_limit = settings.lru_crawler_tocrawl;
        -: 1513:        }
       88: 1514:        lru_crawler_start(todo, tocrawl_limit, CRAWLER_AUTOEXPIRE, cdata, NULL, 0);
        -: 1515:    }
      183: 1516:}
------------------
lru_maintainer_crawler_check:
      183: 1424:static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
      183: 1425:    int i;
      183: 1426:    static rel_time_t next_crawls[POWER_LARGEST];
      183: 1427:    static rel_time_t next_crawl_wait[POWER_LARGEST];
      183: 1428:    uint8_t todo[POWER_LARGEST];
      183: 1429:    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
      183: 1430:    bool do_run = false;
      183: 1431:    unsigned int tocrawl_limit = 0;
        -: 1432:
        -: 1433:    // TODO: If not segmented LRU, skip non-cold
    46848: 1434:    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
    46665: 1435:        crawlerstats_t *s = &cdata->crawlerstats[i];
        -: 1436:        /* We've not successfully kicked off a crawl yet. */
    46665: 1437:        if (s->run_complete) {
     8160: 1438:            char *lru_name = "na";
     8160: 1439:            pthread_mutex_lock(&cdata->lock);
     8160: 1440:            int x;
        -: 1441:            /* Should we crawl again? */
     8160: 1442:            uint64_t possible_reclaims = s->seen - s->noexp;
     8160: 1443:            uint64_t available_reclaims = 0;
        -: 1444:            /* Need to think we can free at least 1% of the items before
        -: 1445:             * crawling. */
        -: 1446:            /* FIXME: Configurable? */
     8160: 1447:            uint64_t low_watermark = (possible_reclaims / 100) + 1;
     8160: 1448:            rel_time_t since_run = current_time - s->end_time;
        -: 1449:            /* Don't bother if the payoff is too low. */
   497760: 1450:            for (x = 0; x < 60; x++) {
   489600: 1451:                available_reclaims += s->histo[x];
   489600: 1452:                if (available_reclaims > low_watermark) {
    #####: 1453:                    if (next_crawl_wait[i] < (x * 60)) {
    #####: 1454:                        next_crawl_wait[i] += 60;
    #####: 1455:                    } else if (next_crawl_wait[i] >= 60) {
    #####: 1456:                        next_crawl_wait[i] -= 60;
        -: 1457:                    }
        -: 1458:                    break;
        -: 1459:                }
        -: 1460:            }
        -: 1461:
     8160: 1462:            if (available_reclaims == 0) {
     8160: 1463:                next_crawl_wait[i] += 60;
        -: 1464:            }
        -: 1465:
     8160: 1466:            if (next_crawl_wait[i] > MAX_MAINTCRAWL_WAIT) {
    #####: 1467:                next_crawl_wait[i] = MAX_MAINTCRAWL_WAIT;
        -: 1468:            }
        -: 1469:
     8160: 1470:            next_crawls[i] = current_time + next_crawl_wait[i] + 5;
     8160: 1471:            switch (GET_LRU(i)) {
     2016: 1472:                case HOT_LRU:
     2016: 1473:                    lru_name = "hot";
     2016: 1474:                    break;
     2048: 1475:                case WARM_LRU:
     2048: 1476:                    lru_name = "warm";
     2048: 1477:                    break;
     2048: 1478:                case COLD_LRU:
     2048: 1479:                    lru_name = "cold";
     2048: 1480:                    break;
     2048: 1481:                case TEMP_LRU:
     2048: 1482:                    lru_name = "temp";
     2048: 1483:                    break;
        -: 1484:            }
    8160*: 1485:            LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_CRAWLER_STATUS, NULL,
        -: 1486:                    CLEAR_LRU(i),
        -: 1487:                    lru_name,
        -: 1488:                    (unsigned long long)low_watermark,
        -: 1489:                    (unsigned long long)available_reclaims,
        -: 1490:                    (unsigned int)since_run,
        -: 1491:                    next_crawls[i] - current_time,
        -: 1492:                    s->end_time - s->start_time,
        -: 1493:                    s->seen,
        -: 1494:                    s->reclaimed);
        -: 1495:            // Got our calculation, avoid running until next actual run.
     8160: 1496:            s->run_complete = false;
     8160: 1497:            pthread_mutex_unlock(&cdata->lock);
        -: 1498:        }
    46665: 1499:        if (current_time > next_crawls[i]) {
    22440: 1500:            pthread_mutex_lock(&lru_locks[i]);
    22440: 1501:            if (sizes[i] > tocrawl_limit) {
    #####: 1502:                tocrawl_limit = sizes[i];
        -: 1503:            }
    22440: 1504:            pthread_mutex_unlock(&lru_locks[i]);
    22440: 1505:            todo[i] = 1;
    22440: 1506:            do_run = true;
    22440: 1507:            next_crawls[i] = current_time + 5; // minimum retry wait.
        -: 1508:        }
        -: 1509:    }
      183: 1510:    if (do_run) {
      88*: 1511:        if (settings.lru_crawler_tocrawl && settings.lru_crawler_tocrawl < tocrawl_limit) {
    #####: 1512:            tocrawl_limit = settings.lru_crawler_tocrawl;
        -: 1513:        }
       88: 1514:        lru_crawler_start(todo, tocrawl_limit, CRAWLER_AUTOEXPIRE, cdata, NULL, 0);
        -: 1515:    }
      183: 1516:}
------------------
lru_maintainer_crawler_check:
      183: 1424:static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
      183: 1425:    int i;
      183: 1426:    static rel_time_t next_crawls[POWER_LARGEST];
      183: 1427:    static rel_time_t next_crawl_wait[POWER_LARGEST];
      183: 1428:    uint8_t todo[POWER_LARGEST];
      183: 1429:    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
      183: 1430:    bool do_run = false;
      183: 1431:    unsigned int tocrawl_limit = 0;
        -: 1432:
        -: 1433:    // TODO: If not segmented LRU, skip non-cold
    46848: 1434:    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
    46665: 1435:        crawlerstats_t *s = &cdata->crawlerstats[i];
        -: 1436:        /* We've not successfully kicked off a crawl yet. */
    46665: 1437:        if (s->run_complete) {
     8160: 1438:            char *lru_name = "na";
     8160: 1439:            pthread_mutex_lock(&cdata->lock);
     8160: 1440:            int x;
        -: 1441:            /* Should we crawl again? */
     8160: 1442:            uint64_t possible_reclaims = s->seen - s->noexp;
     8160: 1443:            uint64_t available_reclaims = 0;
        -: 1444:            /* Need to think we can free at least 1% of the items before
        -: 1445:             * crawling. */
        -: 1446:            /* FIXME: Configurable? */
     8160: 1447:            uint64_t low_watermark = (possible_reclaims / 100) + 1;
     8160: 1448:            rel_time_t since_run = current_time - s->end_time;
        -: 1449:            /* Don't bother if the payoff is too low. */
   497760: 1450:            for (x = 0; x < 60; x++) {
   489600: 1451:                available_reclaims += s->histo[x];
   489600: 1452:                if (available_reclaims > low_watermark) {
    #####: 1453:                    if (next_crawl_wait[i] < (x * 60)) {
    #####: 1454:                        next_crawl_wait[i] += 60;
    #####: 1455:                    } else if (next_crawl_wait[i] >= 60) {
    #####: 1456:                        next_crawl_wait[i] -= 60;
        -: 1457:                    }
        -: 1458:                    break;
        -: 1459:                }
        -: 1460:            }
        -: 1461:
     8160: 1462:            if (available_reclaims == 0) {
     8160: 1463:                next_crawl_wait[i] += 60;
        -: 1464:            }
        -: 1465:
     8160: 1466:            if (next_crawl_wait[i] > MAX_MAINTCRAWL_WAIT) {
    #####: 1467:                next_crawl_wait[i] = MAX_MAINTCRAWL_WAIT;
        -: 1468:            }
        -: 1469:
     8160: 1470:            next_crawls[i] = current_time + next_crawl_wait[i] + 5;
     8160: 1471:            switch (GET_LRU(i)) {
     2016: 1472:                case HOT_LRU:
     2016: 1473:                    lru_name = "hot";
     2016: 1474:                    break;
     2048: 1475:                case WARM_LRU:
     2048: 1476:                    lru_name = "warm";
     2048: 1477:                    break;
     2048: 1478:                case COLD_LRU:
     2048: 1479:                    lru_name = "cold";
     2048: 1480:                    break;
     2048: 1481:                case TEMP_LRU:
     2048: 1482:                    lru_name = "temp";
     2048: 1483:                    break;
        -: 1484:            }
    8160*: 1485:            LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_CRAWLER_STATUS, NULL,
        -: 1486:                    CLEAR_LRU(i),
        -: 1487:                    lru_name,
        -: 1488:                    (unsigned long long)low_watermark,
        -: 1489:                    (unsigned long long)available_reclaims,
        -: 1490:                    (unsigned int)since_run,
        -: 1491:                    next_crawls[i] - current_time,
        -: 1492:                    s->end_time - s->start_time,
        -: 1493:                    s->seen,
        -: 1494:                    s->reclaimed);
        -: 1495:            // Got our calculation, avoid running until next actual run.
     8160: 1496:            s->run_complete = false;
     8160: 1497:            pthread_mutex_unlock(&cdata->lock);
        -: 1498:        }
    46665: 1499:        if (current_time > next_crawls[i]) {
    22440: 1500:            pthread_mutex_lock(&lru_locks[i]);
    22440: 1501:            if (sizes[i] > tocrawl_limit) {
    #####: 1502:                tocrawl_limit = sizes[i];
        -: 1503:            }
    22440: 1504:            pthread_mutex_unlock(&lru_locks[i]);
    22440: 1505:            todo[i] = 1;
    22440: 1506:            do_run = true;
    22440: 1507:            next_crawls[i] = current_time + 5; // minimum retry wait.
        -: 1508:        }
        -: 1509:    }
      183: 1510:    if (do_run) {
      88*: 1511:        if (settings.lru_crawler_tocrawl && settings.lru_crawler_tocrawl < tocrawl_limit) {
    #####: 1512:            tocrawl_limit = settings.lru_crawler_tocrawl;
        -: 1513:        }
       88: 1514:        lru_crawler_start(todo, tocrawl_limit, CRAWLER_AUTOEXPIRE, cdata, NULL, 0);
        -: 1515:    }
      183: 1516:}
------------------
        -: 1517:
        -: 1518:slab_automove_reg_t slab_automove_default = {
        -: 1519:    .init = slab_automove_init,
        -: 1520:    .free = slab_automove_free,
        -: 1521:    .run = slab_automove_run
        -: 1522:};
        -: 1523:#ifdef EXTSTORE
        -: 1524:slab_automove_reg_t slab_automove_extstore = {
        -: 1525:    .init = slab_automove_extstore_init,
        -: 1526:    .free = slab_automove_extstore_free,
        -: 1527:    .run = slab_automove_extstore_run
        -: 1528:};
        -: 1529:#endif
        -: 1530:static pthread_t lru_maintainer_tid;
        -: 1531:
        -: 1532:#define MAX_LRU_MAINTAINER_SLEEP 1000000
        -: 1533:#define MIN_LRU_MAINTAINER_SLEEP 1000
        -: 1534:
      352: 1535:static void *lru_maintainer_thread(void *arg) {
      352: 1536:    slab_automove_reg_t *sam = &slab_automove_default;
        -: 1537:#ifdef EXTSTORE
        -: 1538:    void *storage = arg;
        -: 1539:    if (storage != NULL)
        -: 1540:        sam = &slab_automove_extstore;
        -: 1541:#endif
      352: 1542:    int i;
      352: 1543:    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
      352: 1544:    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
      352: 1545:    rel_time_t last_crawler_check = 0;
      352: 1546:    rel_time_t last_automove_check = 0;
      352: 1547:    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
      352: 1548:    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
      352: 1549:    struct crawler_expired_data *cdata =
      352: 1550:        calloc(1, sizeof(struct crawler_expired_data));
      352: 1551:    if (cdata == NULL) {
    #####: 1552:        fprintf(stderr, "Failed to allocate crawler data for LRU maintainer thread\n");
    #####: 1553:        abort();
        -: 1554:    }
      352: 1555:    pthread_mutex_init(&cdata->lock, NULL);
      352: 1556:    cdata->crawl_complete = true; // kick off the crawler.
      352: 1557:    logger *l = logger_create();
      352: 1558:    if (l == NULL) {
    #####: 1559:        fprintf(stderr, "Failed to allocate logger for LRU maintainer thread\n");
    #####: 1560:        abort();
        -: 1561:    }
        -: 1562:
      352: 1563:    double last_ratio = settings.slab_automove_ratio;
      352: 1564:    void *am = sam->init(&settings);
        -: 1565:
      352: 1566:    pthread_mutex_lock(&lru_maintainer_lock);
      352: 1567:    if (settings.verbose > 2)
    #####: 1568:        fprintf(stderr, "Starting LRU maintainer background thread\n");
    26304: 1569:    while (do_run_lru_maintainer_thread) {
    26304: 1570:        pthread_mutex_unlock(&lru_maintainer_lock);
    26304: 1571:        if (to_sleep)
    23836: 1572:            usleep(to_sleep);
    25952: 1573:        pthread_mutex_lock(&lru_maintainer_lock);
        -: 1574:        /* A sleep of zero counts as a minimum of a 1ms wait */
    25952: 1575:        last_sleep = to_sleep > 1000 ? to_sleep : 1000;
    25952: 1576:        to_sleep = MAX_LRU_MAINTAINER_SLEEP;
        -: 1577:
    25952: 1578:        STATS_LOCK();
    25952: 1579:        stats.lru_maintainer_juggles++;
    25952: 1580:        STATS_UNLOCK();
        -: 1581:
        -: 1582:        /* Each slab class gets its own sleep to avoid hammering locks */
  1660928: 1583:        for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
  1634976: 1584:            next_juggles[i] = next_juggles[i] > last_sleep ? next_juggles[i] - last_sleep : 0;
        -: 1585:
  1634976: 1586:            if (next_juggles[i] > 0) {
        -: 1587:                // Sleep the thread just for the minimum amount (or not at all)
   729584: 1588:                if (next_juggles[i] < to_sleep)
    15972: 1589:                    to_sleep = next_juggles[i];
   729584: 1590:                continue;
        -: 1591:            }
        -: 1592:
   905392: 1593:            int did_moves = lru_maintainer_juggle(i);
   905392: 1594:            if (did_moves == 0) {
   901740: 1595:                if (backoff_juggles[i] != 0) {
   877420: 1596:                    backoff_juggles[i] += backoff_juggles[i] / 8;
        -: 1597:                } else {
    24320: 1598:                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
        -: 1599:                }
   901740: 1600:                if (backoff_juggles[i] > MAX_LRU_MAINTAINER_SLEEP)
     1228: 1601:                    backoff_juggles[i] = MAX_LRU_MAINTAINER_SLEEP;
     3652: 1602:            } else if (backoff_juggles[i] > 0) {
     3328: 1603:                backoff_juggles[i] /= 2;
     3328: 1604:                if (backoff_juggles[i] < MIN_LRU_MAINTAINER_SLEEP) {
     2144: 1605:                    backoff_juggles[i] = 0;
        -: 1606:                }
        -: 1607:            }
   905392: 1608:            next_juggles[i] = backoff_juggles[i];
   905392: 1609:            if (next_juggles[i] < to_sleep)
    24440: 1610:                to_sleep = next_juggles[i];
        -: 1611:        }
        -: 1612:
        -: 1613:        /* Minimize the sleep if we had async LRU bumps to process */
    25952: 1614:        if (settings.lru_segmented && lru_maintainer_bumps() && to_sleep > 1000) {
       20: 1615:            to_sleep = 1000;
        -: 1616:        }
        -: 1617:
        -: 1618:        /* Once per second at most */
    25952: 1619:        if (settings.lru_crawler && last_crawler_check != current_time) {
      732: 1620:            lru_maintainer_crawler_check(cdata, l);
      732: 1621:            last_crawler_check = current_time;
        -: 1622:        }
        -: 1623:
    25952: 1624:        if (settings.slab_automove == 1 && last_automove_check != current_time) {
     1096: 1625:            if (last_ratio != settings.slab_automove_ratio) {
    #####: 1626:                sam->free(am);
    #####: 1627:                am = sam->init(&settings);
    #####: 1628:                last_ratio = settings.slab_automove_ratio;
        -: 1629:            }
     1096: 1630:            int src, dst;
     1096: 1631:            sam->run(am, &src, &dst);
     1096: 1632:            if (src != -1 && dst != -1) {
      364: 1633:                slabs_reassign(src, dst);
     364*: 1634:                LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
        -: 1635:                        src, dst);
        -: 1636:            }
        -: 1637:            // dst == 0 means reclaim to global pool, be more aggressive
     1096: 1638:            if (dst != 0) {
      732: 1639:                last_automove_check = current_time;
        -: 1640:            } else if (dst == 0) {
        -: 1641:                // also ensure we minimize the thread sleep
        -: 1642:                to_sleep = 1000;
        -: 1643:            }
        -: 1644:        }
        -: 1645:    }
    #####: 1646:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1647:    sam->free(am);
        -: 1648:    // LRU crawler *must* be stopped.
    #####: 1649:    free(cdata);
    #####: 1650:    if (settings.verbose > 2)
    #####: 1651:        fprintf(stderr, "LRU maintainer thread stopping\n");
        -: 1652:
    #####: 1653:    return NULL;
        -: 1654:}
------------------
lru_maintainer_thread:
       88: 1535:static void *lru_maintainer_thread(void *arg) {
       88: 1536:    slab_automove_reg_t *sam = &slab_automove_default;
        -: 1537:#ifdef EXTSTORE
        -: 1538:    void *storage = arg;
        -: 1539:    if (storage != NULL)
        -: 1540:        sam = &slab_automove_extstore;
        -: 1541:#endif
       88: 1542:    int i;
       88: 1543:    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1544:    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1545:    rel_time_t last_crawler_check = 0;
       88: 1546:    rel_time_t last_automove_check = 0;
       88: 1547:    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1548:    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1549:    struct crawler_expired_data *cdata =
       88: 1550:        calloc(1, sizeof(struct crawler_expired_data));
       88: 1551:    if (cdata == NULL) {
    #####: 1552:        fprintf(stderr, "Failed to allocate crawler data for LRU maintainer thread\n");
    #####: 1553:        abort();
        -: 1554:    }
       88: 1555:    pthread_mutex_init(&cdata->lock, NULL);
       88: 1556:    cdata->crawl_complete = true; // kick off the crawler.
       88: 1557:    logger *l = logger_create();
       88: 1558:    if (l == NULL) {
    #####: 1559:        fprintf(stderr, "Failed to allocate logger for LRU maintainer thread\n");
    #####: 1560:        abort();
        -: 1561:    }
        -: 1562:
       88: 1563:    double last_ratio = settings.slab_automove_ratio;
       88: 1564:    void *am = sam->init(&settings);
        -: 1565:
       88: 1566:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1567:    if (settings.verbose > 2)
    #####: 1568:        fprintf(stderr, "Starting LRU maintainer background thread\n");
     6576: 1569:    while (do_run_lru_maintainer_thread) {
     6576: 1570:        pthread_mutex_unlock(&lru_maintainer_lock);
     6576: 1571:        if (to_sleep)
     5959: 1572:            usleep(to_sleep);
     6488: 1573:        pthread_mutex_lock(&lru_maintainer_lock);
        -: 1574:        /* A sleep of zero counts as a minimum of a 1ms wait */
     6488: 1575:        last_sleep = to_sleep > 1000 ? to_sleep : 1000;
     6488: 1576:        to_sleep = MAX_LRU_MAINTAINER_SLEEP;
        -: 1577:
     6488: 1578:        STATS_LOCK();
     6488: 1579:        stats.lru_maintainer_juggles++;
     6488: 1580:        STATS_UNLOCK();
        -: 1581:
        -: 1582:        /* Each slab class gets its own sleep to avoid hammering locks */
   415232: 1583:        for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
   408744: 1584:            next_juggles[i] = next_juggles[i] > last_sleep ? next_juggles[i] - last_sleep : 0;
        -: 1585:
   408744: 1586:            if (next_juggles[i] > 0) {
        -: 1587:                // Sleep the thread just for the minimum amount (or not at all)
   182396: 1588:                if (next_juggles[i] < to_sleep)
     3993: 1589:                    to_sleep = next_juggles[i];
   182396: 1590:                continue;
        -: 1591:            }
        -: 1592:
   226348: 1593:            int did_moves = lru_maintainer_juggle(i);
   226348: 1594:            if (did_moves == 0) {
   225435: 1595:                if (backoff_juggles[i] != 0) {
   219355: 1596:                    backoff_juggles[i] += backoff_juggles[i] / 8;
        -: 1597:                } else {
     6080: 1598:                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
        -: 1599:                }
   225435: 1600:                if (backoff_juggles[i] > MAX_LRU_MAINTAINER_SLEEP)
      307: 1601:                    backoff_juggles[i] = MAX_LRU_MAINTAINER_SLEEP;
      913: 1602:            } else if (backoff_juggles[i] > 0) {
      832: 1603:                backoff_juggles[i] /= 2;
      832: 1604:                if (backoff_juggles[i] < MIN_LRU_MAINTAINER_SLEEP) {
      536: 1605:                    backoff_juggles[i] = 0;
        -: 1606:                }
        -: 1607:            }
   226348: 1608:            next_juggles[i] = backoff_juggles[i];
   226348: 1609:            if (next_juggles[i] < to_sleep)
     6110: 1610:                to_sleep = next_juggles[i];
        -: 1611:        }
        -: 1612:
        -: 1613:        /* Minimize the sleep if we had async LRU bumps to process */
     6488: 1614:        if (settings.lru_segmented && lru_maintainer_bumps() && to_sleep > 1000) {
        5: 1615:            to_sleep = 1000;
        -: 1616:        }
        -: 1617:
        -: 1618:        /* Once per second at most */
     6488: 1619:        if (settings.lru_crawler && last_crawler_check != current_time) {
      183: 1620:            lru_maintainer_crawler_check(cdata, l);
      183: 1621:            last_crawler_check = current_time;
        -: 1622:        }
        -: 1623:
     6488: 1624:        if (settings.slab_automove == 1 && last_automove_check != current_time) {
      274: 1625:            if (last_ratio != settings.slab_automove_ratio) {
    #####: 1626:                sam->free(am);
    #####: 1627:                am = sam->init(&settings);
    #####: 1628:                last_ratio = settings.slab_automove_ratio;
        -: 1629:            }
      274: 1630:            int src, dst;
      274: 1631:            sam->run(am, &src, &dst);
      274: 1632:            if (src != -1 && dst != -1) {
       91: 1633:                slabs_reassign(src, dst);
      91*: 1634:                LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
        -: 1635:                        src, dst);
        -: 1636:            }
        -: 1637:            // dst == 0 means reclaim to global pool, be more aggressive
      274: 1638:            if (dst != 0) {
      183: 1639:                last_automove_check = current_time;
        -: 1640:            } else if (dst == 0) {
        -: 1641:                // also ensure we minimize the thread sleep
        -: 1642:                to_sleep = 1000;
        -: 1643:            }
        -: 1644:        }
        -: 1645:    }
    #####: 1646:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1647:    sam->free(am);
        -: 1648:    // LRU crawler *must* be stopped.
    #####: 1649:    free(cdata);
    #####: 1650:    if (settings.verbose > 2)
    #####: 1651:        fprintf(stderr, "LRU maintainer thread stopping\n");
        -: 1652:
    #####: 1653:    return NULL;
        -: 1654:}
------------------
lru_maintainer_thread:
       88: 1535:static void *lru_maintainer_thread(void *arg) {
       88: 1536:    slab_automove_reg_t *sam = &slab_automove_default;
        -: 1537:#ifdef EXTSTORE
        -: 1538:    void *storage = arg;
        -: 1539:    if (storage != NULL)
        -: 1540:        sam = &slab_automove_extstore;
        -: 1541:#endif
       88: 1542:    int i;
       88: 1543:    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1544:    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1545:    rel_time_t last_crawler_check = 0;
       88: 1546:    rel_time_t last_automove_check = 0;
       88: 1547:    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1548:    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1549:    struct crawler_expired_data *cdata =
       88: 1550:        calloc(1, sizeof(struct crawler_expired_data));
       88: 1551:    if (cdata == NULL) {
    #####: 1552:        fprintf(stderr, "Failed to allocate crawler data for LRU maintainer thread\n");
    #####: 1553:        abort();
        -: 1554:    }
       88: 1555:    pthread_mutex_init(&cdata->lock, NULL);
       88: 1556:    cdata->crawl_complete = true; // kick off the crawler.
       88: 1557:    logger *l = logger_create();
       88: 1558:    if (l == NULL) {
    #####: 1559:        fprintf(stderr, "Failed to allocate logger for LRU maintainer thread\n");
    #####: 1560:        abort();
        -: 1561:    }
        -: 1562:
       88: 1563:    double last_ratio = settings.slab_automove_ratio;
       88: 1564:    void *am = sam->init(&settings);
        -: 1565:
       88: 1566:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1567:    if (settings.verbose > 2)
    #####: 1568:        fprintf(stderr, "Starting LRU maintainer background thread\n");
     6576: 1569:    while (do_run_lru_maintainer_thread) {
     6576: 1570:        pthread_mutex_unlock(&lru_maintainer_lock);
     6576: 1571:        if (to_sleep)
     5959: 1572:            usleep(to_sleep);
     6488: 1573:        pthread_mutex_lock(&lru_maintainer_lock);
        -: 1574:        /* A sleep of zero counts as a minimum of a 1ms wait */
     6488: 1575:        last_sleep = to_sleep > 1000 ? to_sleep : 1000;
     6488: 1576:        to_sleep = MAX_LRU_MAINTAINER_SLEEP;
        -: 1577:
     6488: 1578:        STATS_LOCK();
     6488: 1579:        stats.lru_maintainer_juggles++;
     6488: 1580:        STATS_UNLOCK();
        -: 1581:
        -: 1582:        /* Each slab class gets its own sleep to avoid hammering locks */
   415232: 1583:        for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
   408744: 1584:            next_juggles[i] = next_juggles[i] > last_sleep ? next_juggles[i] - last_sleep : 0;
        -: 1585:
   408744: 1586:            if (next_juggles[i] > 0) {
        -: 1587:                // Sleep the thread just for the minimum amount (or not at all)
   182396: 1588:                if (next_juggles[i] < to_sleep)
     3993: 1589:                    to_sleep = next_juggles[i];
   182396: 1590:                continue;
        -: 1591:            }
        -: 1592:
   226348: 1593:            int did_moves = lru_maintainer_juggle(i);
   226348: 1594:            if (did_moves == 0) {
   225435: 1595:                if (backoff_juggles[i] != 0) {
   219355: 1596:                    backoff_juggles[i] += backoff_juggles[i] / 8;
        -: 1597:                } else {
     6080: 1598:                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
        -: 1599:                }
   225435: 1600:                if (backoff_juggles[i] > MAX_LRU_MAINTAINER_SLEEP)
      307: 1601:                    backoff_juggles[i] = MAX_LRU_MAINTAINER_SLEEP;
      913: 1602:            } else if (backoff_juggles[i] > 0) {
      832: 1603:                backoff_juggles[i] /= 2;
      832: 1604:                if (backoff_juggles[i] < MIN_LRU_MAINTAINER_SLEEP) {
      536: 1605:                    backoff_juggles[i] = 0;
        -: 1606:                }
        -: 1607:            }
   226348: 1608:            next_juggles[i] = backoff_juggles[i];
   226348: 1609:            if (next_juggles[i] < to_sleep)
     6110: 1610:                to_sleep = next_juggles[i];
        -: 1611:        }
        -: 1612:
        -: 1613:        /* Minimize the sleep if we had async LRU bumps to process */
     6488: 1614:        if (settings.lru_segmented && lru_maintainer_bumps() && to_sleep > 1000) {
        5: 1615:            to_sleep = 1000;
        -: 1616:        }
        -: 1617:
        -: 1618:        /* Once per second at most */
     6488: 1619:        if (settings.lru_crawler && last_crawler_check != current_time) {
      183: 1620:            lru_maintainer_crawler_check(cdata, l);
      183: 1621:            last_crawler_check = current_time;
        -: 1622:        }
        -: 1623:
     6488: 1624:        if (settings.slab_automove == 1 && last_automove_check != current_time) {
      274: 1625:            if (last_ratio != settings.slab_automove_ratio) {
    #####: 1626:                sam->free(am);
    #####: 1627:                am = sam->init(&settings);
    #####: 1628:                last_ratio = settings.slab_automove_ratio;
        -: 1629:            }
      274: 1630:            int src, dst;
      274: 1631:            sam->run(am, &src, &dst);
      274: 1632:            if (src != -1 && dst != -1) {
       91: 1633:                slabs_reassign(src, dst);
      91*: 1634:                LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
        -: 1635:                        src, dst);
        -: 1636:            }
        -: 1637:            // dst == 0 means reclaim to global pool, be more aggressive
      274: 1638:            if (dst != 0) {
      183: 1639:                last_automove_check = current_time;
        -: 1640:            } else if (dst == 0) {
        -: 1641:                // also ensure we minimize the thread sleep
        -: 1642:                to_sleep = 1000;
        -: 1643:            }
        -: 1644:        }
        -: 1645:    }
    #####: 1646:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1647:    sam->free(am);
        -: 1648:    // LRU crawler *must* be stopped.
    #####: 1649:    free(cdata);
    #####: 1650:    if (settings.verbose > 2)
    #####: 1651:        fprintf(stderr, "LRU maintainer thread stopping\n");
        -: 1652:
    #####: 1653:    return NULL;
        -: 1654:}
------------------
lru_maintainer_thread:
       88: 1535:static void *lru_maintainer_thread(void *arg) {
       88: 1536:    slab_automove_reg_t *sam = &slab_automove_default;
        -: 1537:#ifdef EXTSTORE
        -: 1538:    void *storage = arg;
        -: 1539:    if (storage != NULL)
        -: 1540:        sam = &slab_automove_extstore;
        -: 1541:#endif
       88: 1542:    int i;
       88: 1543:    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1544:    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1545:    rel_time_t last_crawler_check = 0;
       88: 1546:    rel_time_t last_automove_check = 0;
       88: 1547:    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1548:    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1549:    struct crawler_expired_data *cdata =
       88: 1550:        calloc(1, sizeof(struct crawler_expired_data));
       88: 1551:    if (cdata == NULL) {
    #####: 1552:        fprintf(stderr, "Failed to allocate crawler data for LRU maintainer thread\n");
    #####: 1553:        abort();
        -: 1554:    }
       88: 1555:    pthread_mutex_init(&cdata->lock, NULL);
       88: 1556:    cdata->crawl_complete = true; // kick off the crawler.
       88: 1557:    logger *l = logger_create();
       88: 1558:    if (l == NULL) {
    #####: 1559:        fprintf(stderr, "Failed to allocate logger for LRU maintainer thread\n");
    #####: 1560:        abort();
        -: 1561:    }
        -: 1562:
       88: 1563:    double last_ratio = settings.slab_automove_ratio;
       88: 1564:    void *am = sam->init(&settings);
        -: 1565:
       88: 1566:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1567:    if (settings.verbose > 2)
    #####: 1568:        fprintf(stderr, "Starting LRU maintainer background thread\n");
     6576: 1569:    while (do_run_lru_maintainer_thread) {
     6576: 1570:        pthread_mutex_unlock(&lru_maintainer_lock);
     6576: 1571:        if (to_sleep)
     5959: 1572:            usleep(to_sleep);
     6488: 1573:        pthread_mutex_lock(&lru_maintainer_lock);
        -: 1574:        /* A sleep of zero counts as a minimum of a 1ms wait */
     6488: 1575:        last_sleep = to_sleep > 1000 ? to_sleep : 1000;
     6488: 1576:        to_sleep = MAX_LRU_MAINTAINER_SLEEP;
        -: 1577:
     6488: 1578:        STATS_LOCK();
     6488: 1579:        stats.lru_maintainer_juggles++;
     6488: 1580:        STATS_UNLOCK();
        -: 1581:
        -: 1582:        /* Each slab class gets its own sleep to avoid hammering locks */
   415232: 1583:        for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
   408744: 1584:            next_juggles[i] = next_juggles[i] > last_sleep ? next_juggles[i] - last_sleep : 0;
        -: 1585:
   408744: 1586:            if (next_juggles[i] > 0) {
        -: 1587:                // Sleep the thread just for the minimum amount (or not at all)
   182396: 1588:                if (next_juggles[i] < to_sleep)
     3993: 1589:                    to_sleep = next_juggles[i];
   182396: 1590:                continue;
        -: 1591:            }
        -: 1592:
   226348: 1593:            int did_moves = lru_maintainer_juggle(i);
   226348: 1594:            if (did_moves == 0) {
   225435: 1595:                if (backoff_juggles[i] != 0) {
   219355: 1596:                    backoff_juggles[i] += backoff_juggles[i] / 8;
        -: 1597:                } else {
     6080: 1598:                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
        -: 1599:                }
   225435: 1600:                if (backoff_juggles[i] > MAX_LRU_MAINTAINER_SLEEP)
      307: 1601:                    backoff_juggles[i] = MAX_LRU_MAINTAINER_SLEEP;
      913: 1602:            } else if (backoff_juggles[i] > 0) {
      832: 1603:                backoff_juggles[i] /= 2;
      832: 1604:                if (backoff_juggles[i] < MIN_LRU_MAINTAINER_SLEEP) {
      536: 1605:                    backoff_juggles[i] = 0;
        -: 1606:                }
        -: 1607:            }
   226348: 1608:            next_juggles[i] = backoff_juggles[i];
   226348: 1609:            if (next_juggles[i] < to_sleep)
     6110: 1610:                to_sleep = next_juggles[i];
        -: 1611:        }
        -: 1612:
        -: 1613:        /* Minimize the sleep if we had async LRU bumps to process */
     6488: 1614:        if (settings.lru_segmented && lru_maintainer_bumps() && to_sleep > 1000) {
        5: 1615:            to_sleep = 1000;
        -: 1616:        }
        -: 1617:
        -: 1618:        /* Once per second at most */
     6488: 1619:        if (settings.lru_crawler && last_crawler_check != current_time) {
      183: 1620:            lru_maintainer_crawler_check(cdata, l);
      183: 1621:            last_crawler_check = current_time;
        -: 1622:        }
        -: 1623:
     6488: 1624:        if (settings.slab_automove == 1 && last_automove_check != current_time) {
      274: 1625:            if (last_ratio != settings.slab_automove_ratio) {
    #####: 1626:                sam->free(am);
    #####: 1627:                am = sam->init(&settings);
    #####: 1628:                last_ratio = settings.slab_automove_ratio;
        -: 1629:            }
      274: 1630:            int src, dst;
      274: 1631:            sam->run(am, &src, &dst);
      274: 1632:            if (src != -1 && dst != -1) {
       91: 1633:                slabs_reassign(src, dst);
      91*: 1634:                LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
        -: 1635:                        src, dst);
        -: 1636:            }
        -: 1637:            // dst == 0 means reclaim to global pool, be more aggressive
      274: 1638:            if (dst != 0) {
      183: 1639:                last_automove_check = current_time;
        -: 1640:            } else if (dst == 0) {
        -: 1641:                // also ensure we minimize the thread sleep
        -: 1642:                to_sleep = 1000;
        -: 1643:            }
        -: 1644:        }
        -: 1645:    }
    #####: 1646:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1647:    sam->free(am);
        -: 1648:    // LRU crawler *must* be stopped.
    #####: 1649:    free(cdata);
    #####: 1650:    if (settings.verbose > 2)
    #####: 1651:        fprintf(stderr, "LRU maintainer thread stopping\n");
        -: 1652:
    #####: 1653:    return NULL;
        -: 1654:}
------------------
lru_maintainer_thread:
       88: 1535:static void *lru_maintainer_thread(void *arg) {
       88: 1536:    slab_automove_reg_t *sam = &slab_automove_default;
        -: 1537:#ifdef EXTSTORE
        -: 1538:    void *storage = arg;
        -: 1539:    if (storage != NULL)
        -: 1540:        sam = &slab_automove_extstore;
        -: 1541:#endif
       88: 1542:    int i;
       88: 1543:    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1544:    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
       88: 1545:    rel_time_t last_crawler_check = 0;
       88: 1546:    rel_time_t last_automove_check = 0;
       88: 1547:    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1548:    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
       88: 1549:    struct crawler_expired_data *cdata =
       88: 1550:        calloc(1, sizeof(struct crawler_expired_data));
       88: 1551:    if (cdata == NULL) {
    #####: 1552:        fprintf(stderr, "Failed to allocate crawler data for LRU maintainer thread\n");
    #####: 1553:        abort();
        -: 1554:    }
       88: 1555:    pthread_mutex_init(&cdata->lock, NULL);
       88: 1556:    cdata->crawl_complete = true; // kick off the crawler.
       88: 1557:    logger *l = logger_create();
       88: 1558:    if (l == NULL) {
    #####: 1559:        fprintf(stderr, "Failed to allocate logger for LRU maintainer thread\n");
    #####: 1560:        abort();
        -: 1561:    }
        -: 1562:
       88: 1563:    double last_ratio = settings.slab_automove_ratio;
       88: 1564:    void *am = sam->init(&settings);
        -: 1565:
       88: 1566:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1567:    if (settings.verbose > 2)
    #####: 1568:        fprintf(stderr, "Starting LRU maintainer background thread\n");
     6576: 1569:    while (do_run_lru_maintainer_thread) {
     6576: 1570:        pthread_mutex_unlock(&lru_maintainer_lock);
     6576: 1571:        if (to_sleep)
     5959: 1572:            usleep(to_sleep);
     6488: 1573:        pthread_mutex_lock(&lru_maintainer_lock);
        -: 1574:        /* A sleep of zero counts as a minimum of a 1ms wait */
     6488: 1575:        last_sleep = to_sleep > 1000 ? to_sleep : 1000;
     6488: 1576:        to_sleep = MAX_LRU_MAINTAINER_SLEEP;
        -: 1577:
     6488: 1578:        STATS_LOCK();
     6488: 1579:        stats.lru_maintainer_juggles++;
     6488: 1580:        STATS_UNLOCK();
        -: 1581:
        -: 1582:        /* Each slab class gets its own sleep to avoid hammering locks */
   415232: 1583:        for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
   408744: 1584:            next_juggles[i] = next_juggles[i] > last_sleep ? next_juggles[i] - last_sleep : 0;
        -: 1585:
   408744: 1586:            if (next_juggles[i] > 0) {
        -: 1587:                // Sleep the thread just for the minimum amount (or not at all)
   182396: 1588:                if (next_juggles[i] < to_sleep)
     3993: 1589:                    to_sleep = next_juggles[i];
   182396: 1590:                continue;
        -: 1591:            }
        -: 1592:
   226348: 1593:            int did_moves = lru_maintainer_juggle(i);
   226348: 1594:            if (did_moves == 0) {
   225435: 1595:                if (backoff_juggles[i] != 0) {
   219355: 1596:                    backoff_juggles[i] += backoff_juggles[i] / 8;
        -: 1597:                } else {
     6080: 1598:                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
        -: 1599:                }
   225435: 1600:                if (backoff_juggles[i] > MAX_LRU_MAINTAINER_SLEEP)
      307: 1601:                    backoff_juggles[i] = MAX_LRU_MAINTAINER_SLEEP;
      913: 1602:            } else if (backoff_juggles[i] > 0) {
      832: 1603:                backoff_juggles[i] /= 2;
      832: 1604:                if (backoff_juggles[i] < MIN_LRU_MAINTAINER_SLEEP) {
      536: 1605:                    backoff_juggles[i] = 0;
        -: 1606:                }
        -: 1607:            }
   226348: 1608:            next_juggles[i] = backoff_juggles[i];
   226348: 1609:            if (next_juggles[i] < to_sleep)
     6110: 1610:                to_sleep = next_juggles[i];
        -: 1611:        }
        -: 1612:
        -: 1613:        /* Minimize the sleep if we had async LRU bumps to process */
     6488: 1614:        if (settings.lru_segmented && lru_maintainer_bumps() && to_sleep > 1000) {
        5: 1615:            to_sleep = 1000;
        -: 1616:        }
        -: 1617:
        -: 1618:        /* Once per second at most */
     6488: 1619:        if (settings.lru_crawler && last_crawler_check != current_time) {
      183: 1620:            lru_maintainer_crawler_check(cdata, l);
      183: 1621:            last_crawler_check = current_time;
        -: 1622:        }
        -: 1623:
     6488: 1624:        if (settings.slab_automove == 1 && last_automove_check != current_time) {
      274: 1625:            if (last_ratio != settings.slab_automove_ratio) {
    #####: 1626:                sam->free(am);
    #####: 1627:                am = sam->init(&settings);
    #####: 1628:                last_ratio = settings.slab_automove_ratio;
        -: 1629:            }
      274: 1630:            int src, dst;
      274: 1631:            sam->run(am, &src, &dst);
      274: 1632:            if (src != -1 && dst != -1) {
       91: 1633:                slabs_reassign(src, dst);
      91*: 1634:                LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
        -: 1635:                        src, dst);
        -: 1636:            }
        -: 1637:            // dst == 0 means reclaim to global pool, be more aggressive
      274: 1638:            if (dst != 0) {
      183: 1639:                last_automove_check = current_time;
        -: 1640:            } else if (dst == 0) {
        -: 1641:                // also ensure we minimize the thread sleep
        -: 1642:                to_sleep = 1000;
        -: 1643:            }
        -: 1644:        }
        -: 1645:    }
    #####: 1646:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1647:    sam->free(am);
        -: 1648:    // LRU crawler *must* be stopped.
    #####: 1649:    free(cdata);
    #####: 1650:    if (settings.verbose > 2)
    #####: 1651:        fprintf(stderr, "LRU maintainer thread stopping\n");
        -: 1652:
    #####: 1653:    return NULL;
        -: 1654:}
------------------
        -: 1655:
    #####: 1656:int stop_lru_maintainer_thread(void) {
    #####: 1657:    int ret;
    #####: 1658:    pthread_mutex_lock(&lru_maintainer_lock);
        -: 1659:    /* LRU thread is a sleep loop, will die on its own */
    #####: 1660:    do_run_lru_maintainer_thread = 0;
    #####: 1661:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1662:    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
    #####: 1663:        fprintf(stderr, "Failed to stop LRU maintainer thread: %s\n", strerror(ret));
    #####: 1664:        return -1;
        -: 1665:    }
    #####: 1666:    settings.lru_maintainer_thread = false;
    #####: 1667:    return 0;
        -: 1668:}
------------------
stop_lru_maintainer_thread:
    #####: 1656:int stop_lru_maintainer_thread(void) {
    #####: 1657:    int ret;
    #####: 1658:    pthread_mutex_lock(&lru_maintainer_lock);
        -: 1659:    /* LRU thread is a sleep loop, will die on its own */
    #####: 1660:    do_run_lru_maintainer_thread = 0;
    #####: 1661:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1662:    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
    #####: 1663:        fprintf(stderr, "Failed to stop LRU maintainer thread: %s\n", strerror(ret));
    #####: 1664:        return -1;
        -: 1665:    }
    #####: 1666:    settings.lru_maintainer_thread = false;
    #####: 1667:    return 0;
        -: 1668:}
------------------
stop_lru_maintainer_thread:
    #####: 1656:int stop_lru_maintainer_thread(void) {
    #####: 1657:    int ret;
    #####: 1658:    pthread_mutex_lock(&lru_maintainer_lock);
        -: 1659:    /* LRU thread is a sleep loop, will die on its own */
    #####: 1660:    do_run_lru_maintainer_thread = 0;
    #####: 1661:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1662:    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
    #####: 1663:        fprintf(stderr, "Failed to stop LRU maintainer thread: %s\n", strerror(ret));
    #####: 1664:        return -1;
        -: 1665:    }
    #####: 1666:    settings.lru_maintainer_thread = false;
    #####: 1667:    return 0;
        -: 1668:}
------------------
stop_lru_maintainer_thread:
    #####: 1656:int stop_lru_maintainer_thread(void) {
    #####: 1657:    int ret;
    #####: 1658:    pthread_mutex_lock(&lru_maintainer_lock);
        -: 1659:    /* LRU thread is a sleep loop, will die on its own */
    #####: 1660:    do_run_lru_maintainer_thread = 0;
    #####: 1661:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1662:    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
    #####: 1663:        fprintf(stderr, "Failed to stop LRU maintainer thread: %s\n", strerror(ret));
    #####: 1664:        return -1;
        -: 1665:    }
    #####: 1666:    settings.lru_maintainer_thread = false;
    #####: 1667:    return 0;
        -: 1668:}
------------------
stop_lru_maintainer_thread:
    #####: 1656:int stop_lru_maintainer_thread(void) {
    #####: 1657:    int ret;
    #####: 1658:    pthread_mutex_lock(&lru_maintainer_lock);
        -: 1659:    /* LRU thread is a sleep loop, will die on its own */
    #####: 1660:    do_run_lru_maintainer_thread = 0;
    #####: 1661:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1662:    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
    #####: 1663:        fprintf(stderr, "Failed to stop LRU maintainer thread: %s\n", strerror(ret));
    #####: 1664:        return -1;
        -: 1665:    }
    #####: 1666:    settings.lru_maintainer_thread = false;
    #####: 1667:    return 0;
        -: 1668:}
------------------
        -: 1669:
      352: 1670:int start_lru_maintainer_thread(void *arg) {
      352: 1671:    int ret;
        -: 1672:
      352: 1673:    pthread_mutex_lock(&lru_maintainer_lock);
      352: 1674:    do_run_lru_maintainer_thread = 1;
      352: 1675:    settings.lru_maintainer_thread = true;
      352: 1676:    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        -: 1677:        lru_maintainer_thread, arg)) != 0) {
    #####: 1678:        fprintf(stderr, "Can't create LRU maintainer thread: %s\n",
        -: 1679:            strerror(ret));
    #####: 1680:        pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1681:        return -1;
        -: 1682:    }
      352: 1683:    pthread_mutex_unlock(&lru_maintainer_lock);
        -: 1684:
      352: 1685:    return 0;
        -: 1686:}
------------------
start_lru_maintainer_thread:
       88: 1670:int start_lru_maintainer_thread(void *arg) {
       88: 1671:    int ret;
        -: 1672:
       88: 1673:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1674:    do_run_lru_maintainer_thread = 1;
       88: 1675:    settings.lru_maintainer_thread = true;
       88: 1676:    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        -: 1677:        lru_maintainer_thread, arg)) != 0) {
    #####: 1678:        fprintf(stderr, "Can't create LRU maintainer thread: %s\n",
        -: 1679:            strerror(ret));
    #####: 1680:        pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1681:        return -1;
        -: 1682:    }
       88: 1683:    pthread_mutex_unlock(&lru_maintainer_lock);
        -: 1684:
       88: 1685:    return 0;
        -: 1686:}
------------------
start_lru_maintainer_thread:
       88: 1670:int start_lru_maintainer_thread(void *arg) {
       88: 1671:    int ret;
        -: 1672:
       88: 1673:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1674:    do_run_lru_maintainer_thread = 1;
       88: 1675:    settings.lru_maintainer_thread = true;
       88: 1676:    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        -: 1677:        lru_maintainer_thread, arg)) != 0) {
    #####: 1678:        fprintf(stderr, "Can't create LRU maintainer thread: %s\n",
        -: 1679:            strerror(ret));
    #####: 1680:        pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1681:        return -1;
        -: 1682:    }
       88: 1683:    pthread_mutex_unlock(&lru_maintainer_lock);
        -: 1684:
       88: 1685:    return 0;
        -: 1686:}
------------------
start_lru_maintainer_thread:
       88: 1670:int start_lru_maintainer_thread(void *arg) {
       88: 1671:    int ret;
        -: 1672:
       88: 1673:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1674:    do_run_lru_maintainer_thread = 1;
       88: 1675:    settings.lru_maintainer_thread = true;
       88: 1676:    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        -: 1677:        lru_maintainer_thread, arg)) != 0) {
    #####: 1678:        fprintf(stderr, "Can't create LRU maintainer thread: %s\n",
        -: 1679:            strerror(ret));
    #####: 1680:        pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1681:        return -1;
        -: 1682:    }
       88: 1683:    pthread_mutex_unlock(&lru_maintainer_lock);
        -: 1684:
       88: 1685:    return 0;
        -: 1686:}
------------------
start_lru_maintainer_thread:
       88: 1670:int start_lru_maintainer_thread(void *arg) {
       88: 1671:    int ret;
        -: 1672:
       88: 1673:    pthread_mutex_lock(&lru_maintainer_lock);
       88: 1674:    do_run_lru_maintainer_thread = 1;
       88: 1675:    settings.lru_maintainer_thread = true;
       88: 1676:    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        -: 1677:        lru_maintainer_thread, arg)) != 0) {
    #####: 1678:        fprintf(stderr, "Can't create LRU maintainer thread: %s\n",
        -: 1679:            strerror(ret));
    #####: 1680:        pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1681:        return -1;
        -: 1682:    }
       88: 1683:    pthread_mutex_unlock(&lru_maintainer_lock);
        -: 1684:
       88: 1685:    return 0;
        -: 1686:}
------------------
        -: 1687:
        -: 1688:/* If we hold this lock, crawler can't wake up or move */
    #####: 1689:void lru_maintainer_pause(void) {
    #####: 1690:    pthread_mutex_lock(&lru_maintainer_lock);
    #####: 1691:}
------------------
lru_maintainer_pause:
    #####: 1689:void lru_maintainer_pause(void) {
    #####: 1690:    pthread_mutex_lock(&lru_maintainer_lock);
    #####: 1691:}
------------------
lru_maintainer_pause:
    #####: 1689:void lru_maintainer_pause(void) {
    #####: 1690:    pthread_mutex_lock(&lru_maintainer_lock);
    #####: 1691:}
------------------
lru_maintainer_pause:
    #####: 1689:void lru_maintainer_pause(void) {
    #####: 1690:    pthread_mutex_lock(&lru_maintainer_lock);
    #####: 1691:}
------------------
lru_maintainer_pause:
    #####: 1689:void lru_maintainer_pause(void) {
    #####: 1690:    pthread_mutex_lock(&lru_maintainer_lock);
    #####: 1691:}
------------------
        -: 1692:
    #####: 1693:void lru_maintainer_resume(void) {
    #####: 1694:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1695:}
------------------
lru_maintainer_resume:
    #####: 1693:void lru_maintainer_resume(void) {
    #####: 1694:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1695:}
------------------
lru_maintainer_resume:
    #####: 1693:void lru_maintainer_resume(void) {
    #####: 1694:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1695:}
------------------
lru_maintainer_resume:
    #####: 1693:void lru_maintainer_resume(void) {
    #####: 1694:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1695:}
------------------
lru_maintainer_resume:
    #####: 1693:void lru_maintainer_resume(void) {
    #####: 1694:    pthread_mutex_unlock(&lru_maintainer_lock);
    #####: 1695:}
------------------
        -: 1696:
      940: 1697:int init_lru_maintainer(void) {
      940: 1698:    if (lru_maintainer_initialized == 0) {
      940: 1699:        pthread_mutex_init(&lru_maintainer_lock, NULL);
      940: 1700:        lru_maintainer_initialized = 1;
        -: 1701:    }
      940: 1702:    return 0;
        -: 1703:}
------------------
init_lru_maintainer:
      235: 1697:int init_lru_maintainer(void) {
      235: 1698:    if (lru_maintainer_initialized == 0) {
      235: 1699:        pthread_mutex_init(&lru_maintainer_lock, NULL);
      235: 1700:        lru_maintainer_initialized = 1;
        -: 1701:    }
      235: 1702:    return 0;
        -: 1703:}
------------------
init_lru_maintainer:
      235: 1697:int init_lru_maintainer(void) {
      235: 1698:    if (lru_maintainer_initialized == 0) {
      235: 1699:        pthread_mutex_init(&lru_maintainer_lock, NULL);
      235: 1700:        lru_maintainer_initialized = 1;
        -: 1701:    }
      235: 1702:    return 0;
        -: 1703:}
------------------
init_lru_maintainer:
      235: 1697:int init_lru_maintainer(void) {
      235: 1698:    if (lru_maintainer_initialized == 0) {
      235: 1699:        pthread_mutex_init(&lru_maintainer_lock, NULL);
      235: 1700:        lru_maintainer_initialized = 1;
        -: 1701:    }
      235: 1702:    return 0;
        -: 1703:}
------------------
init_lru_maintainer:
      235: 1697:int init_lru_maintainer(void) {
      235: 1698:    if (lru_maintainer_initialized == 0) {
      235: 1699:        pthread_mutex_init(&lru_maintainer_lock, NULL);
      235: 1700:        lru_maintainer_initialized = 1;
        -: 1701:    }
      235: 1702:    return 0;
        -: 1703:}
------------------
        -: 1704:
        -: 1705:/* Tail linkers and crawler for the LRU crawler. */
    90812: 1706:void do_item_linktail_q(item *it) { /* item is the new tail */
    90812: 1707:    item **head, **tail;
   90812*: 1708:    assert(it->it_flags == 1);
   90812*: 1709:    assert(it->nbytes == 0);
        -: 1710:
    90812: 1711:    head = &heads[it->slabs_clsid];
    90812: 1712:    tail = &tails[it->slabs_clsid];
        -: 1713:    //assert(*tail != 0);
   90812*: 1714:    assert(it != *tail);
   90812*: 1715:    assert((*head && *tail) || (*head == 0 && *tail == 0));
    90812: 1716:    it->prev = *tail;
    90812: 1717:    it->next = 0;
    90812: 1718:    if (it->prev) {
      12*: 1719:        assert(it->prev->next == 0);
       12: 1720:        it->prev->next = it;
        -: 1721:    }
    90812: 1722:    *tail = it;
    90812: 1723:    if (*head == 0) *head = it;
    90812: 1724:    return;
        -: 1725:}
------------------
do_item_linktail_q:
    22703: 1706:void do_item_linktail_q(item *it) { /* item is the new tail */
    22703: 1707:    item **head, **tail;
   22703*: 1708:    assert(it->it_flags == 1);
   22703*: 1709:    assert(it->nbytes == 0);
        -: 1710:
    22703: 1711:    head = &heads[it->slabs_clsid];
    22703: 1712:    tail = &tails[it->slabs_clsid];
        -: 1713:    //assert(*tail != 0);
   22703*: 1714:    assert(it != *tail);
   22703*: 1715:    assert((*head && *tail) || (*head == 0 && *tail == 0));
    22703: 1716:    it->prev = *tail;
    22703: 1717:    it->next = 0;
    22703: 1718:    if (it->prev) {
       3*: 1719:        assert(it->prev->next == 0);
        3: 1720:        it->prev->next = it;
        -: 1721:    }
    22703: 1722:    *tail = it;
    22703: 1723:    if (*head == 0) *head = it;
    22703: 1724:    return;
        -: 1725:}
------------------
do_item_linktail_q:
    22703: 1706:void do_item_linktail_q(item *it) { /* item is the new tail */
    22703: 1707:    item **head, **tail;
   22703*: 1708:    assert(it->it_flags == 1);
   22703*: 1709:    assert(it->nbytes == 0);
        -: 1710:
    22703: 1711:    head = &heads[it->slabs_clsid];
    22703: 1712:    tail = &tails[it->slabs_clsid];
        -: 1713:    //assert(*tail != 0);
   22703*: 1714:    assert(it != *tail);
   22703*: 1715:    assert((*head && *tail) || (*head == 0 && *tail == 0));
    22703: 1716:    it->prev = *tail;
    22703: 1717:    it->next = 0;
    22703: 1718:    if (it->prev) {
       3*: 1719:        assert(it->prev->next == 0);
        3: 1720:        it->prev->next = it;
        -: 1721:    }
    22703: 1722:    *tail = it;
    22703: 1723:    if (*head == 0) *head = it;
    22703: 1724:    return;
        -: 1725:}
------------------
do_item_linktail_q:
    22703: 1706:void do_item_linktail_q(item *it) { /* item is the new tail */
    22703: 1707:    item **head, **tail;
   22703*: 1708:    assert(it->it_flags == 1);
   22703*: 1709:    assert(it->nbytes == 0);
        -: 1710:
    22703: 1711:    head = &heads[it->slabs_clsid];
    22703: 1712:    tail = &tails[it->slabs_clsid];
        -: 1713:    //assert(*tail != 0);
   22703*: 1714:    assert(it != *tail);
   22703*: 1715:    assert((*head && *tail) || (*head == 0 && *tail == 0));
    22703: 1716:    it->prev = *tail;
    22703: 1717:    it->next = 0;
    22703: 1718:    if (it->prev) {
       3*: 1719:        assert(it->prev->next == 0);
        3: 1720:        it->prev->next = it;
        -: 1721:    }
    22703: 1722:    *tail = it;
    22703: 1723:    if (*head == 0) *head = it;
    22703: 1724:    return;
        -: 1725:}
------------------
do_item_linktail_q:
    22703: 1706:void do_item_linktail_q(item *it) { /* item is the new tail */
    22703: 1707:    item **head, **tail;
   22703*: 1708:    assert(it->it_flags == 1);
   22703*: 1709:    assert(it->nbytes == 0);
        -: 1710:
    22703: 1711:    head = &heads[it->slabs_clsid];
    22703: 1712:    tail = &tails[it->slabs_clsid];
        -: 1713:    //assert(*tail != 0);
   22703*: 1714:    assert(it != *tail);
   22703*: 1715:    assert((*head && *tail) || (*head == 0 && *tail == 0));
    22703: 1716:    it->prev = *tail;
    22703: 1717:    it->next = 0;
    22703: 1718:    if (it->prev) {
       3*: 1719:        assert(it->prev->next == 0);
        3: 1720:        it->prev->next = it;
        -: 1721:    }
    22703: 1722:    *tail = it;
    22703: 1723:    if (*head == 0) *head = it;
    22703: 1724:    return;
        -: 1725:}
------------------
        -: 1726:
    90812: 1727:void do_item_unlinktail_q(item *it) {
    90812: 1728:    item **head, **tail;
    90812: 1729:    head = &heads[it->slabs_clsid];
    90812: 1730:    tail = &tails[it->slabs_clsid];
        -: 1731:
    90812: 1732:    if (*head == it) {
   90804*: 1733:        assert(it->prev == 0);
    90804: 1734:        *head = it->next;
        -: 1735:    }
    90812: 1736:    if (*tail == it) {
   90804*: 1737:        assert(it->next == 0);
    90804: 1738:        *tail = it->prev;
        -: 1739:    }
   90812*: 1740:    assert(it->next != it);
   90812*: 1741:    assert(it->prev != it);
        -: 1742:
    90812: 1743:    if (it->next) it->next->prev = it->prev;
   90812*: 1744:    if (it->prev) it->prev->next = it->next;
    90812: 1745:    return;
        -: 1746:}
------------------
do_item_unlinktail_q:
    22703: 1727:void do_item_unlinktail_q(item *it) {
    22703: 1728:    item **head, **tail;
    22703: 1729:    head = &heads[it->slabs_clsid];
    22703: 1730:    tail = &tails[it->slabs_clsid];
        -: 1731:
    22703: 1732:    if (*head == it) {
   22701*: 1733:        assert(it->prev == 0);
    22701: 1734:        *head = it->next;
        -: 1735:    }
    22703: 1736:    if (*tail == it) {
   22701*: 1737:        assert(it->next == 0);
    22701: 1738:        *tail = it->prev;
        -: 1739:    }
   22703*: 1740:    assert(it->next != it);
   22703*: 1741:    assert(it->prev != it);
        -: 1742:
    22703: 1743:    if (it->next) it->next->prev = it->prev;
   22703*: 1744:    if (it->prev) it->prev->next = it->next;
    22703: 1745:    return;
        -: 1746:}
------------------
do_item_unlinktail_q:
    22703: 1727:void do_item_unlinktail_q(item *it) {
    22703: 1728:    item **head, **tail;
    22703: 1729:    head = &heads[it->slabs_clsid];
    22703: 1730:    tail = &tails[it->slabs_clsid];
        -: 1731:
    22703: 1732:    if (*head == it) {
   22701*: 1733:        assert(it->prev == 0);
    22701: 1734:        *head = it->next;
        -: 1735:    }
    22703: 1736:    if (*tail == it) {
   22701*: 1737:        assert(it->next == 0);
    22701: 1738:        *tail = it->prev;
        -: 1739:    }
   22703*: 1740:    assert(it->next != it);
   22703*: 1741:    assert(it->prev != it);
        -: 1742:
    22703: 1743:    if (it->next) it->next->prev = it->prev;
   22703*: 1744:    if (it->prev) it->prev->next = it->next;
    22703: 1745:    return;
        -: 1746:}
------------------
do_item_unlinktail_q:
    22703: 1727:void do_item_unlinktail_q(item *it) {
    22703: 1728:    item **head, **tail;
    22703: 1729:    head = &heads[it->slabs_clsid];
    22703: 1730:    tail = &tails[it->slabs_clsid];
        -: 1731:
    22703: 1732:    if (*head == it) {
   22701*: 1733:        assert(it->prev == 0);
    22701: 1734:        *head = it->next;
        -: 1735:    }
    22703: 1736:    if (*tail == it) {
   22701*: 1737:        assert(it->next == 0);
    22701: 1738:        *tail = it->prev;
        -: 1739:    }
   22703*: 1740:    assert(it->next != it);
   22703*: 1741:    assert(it->prev != it);
        -: 1742:
    22703: 1743:    if (it->next) it->next->prev = it->prev;
   22703*: 1744:    if (it->prev) it->prev->next = it->next;
    22703: 1745:    return;
        -: 1746:}
------------------
do_item_unlinktail_q:
    22703: 1727:void do_item_unlinktail_q(item *it) {
    22703: 1728:    item **head, **tail;
    22703: 1729:    head = &heads[it->slabs_clsid];
    22703: 1730:    tail = &tails[it->slabs_clsid];
        -: 1731:
    22703: 1732:    if (*head == it) {
   22701*: 1733:        assert(it->prev == 0);
    22701: 1734:        *head = it->next;
        -: 1735:    }
    22703: 1736:    if (*tail == it) {
   22701*: 1737:        assert(it->next == 0);
    22701: 1738:        *tail = it->prev;
        -: 1739:    }
   22703*: 1740:    assert(it->next != it);
   22703*: 1741:    assert(it->prev != it);
        -: 1742:
    22703: 1743:    if (it->next) it->next->prev = it->prev;
   22703*: 1744:    if (it->prev) it->prev->next = it->next;
    22703: 1745:    return;
        -: 1746:}
------------------
        -: 1747:
        -: 1748:/* This is too convoluted, but it's a difficult shuffle. Try to rewrite it
        -: 1749: * more clearly. */
    91532: 1750:item *do_item_crawl_q(item *it) {
    91532: 1751:    item **head, **tail;
   91532*: 1752:    assert(it->it_flags == 1);
   91532*: 1753:    assert(it->nbytes == 0);
    91532: 1754:    head = &heads[it->slabs_clsid];
    91532: 1755:    tail = &tails[it->slabs_clsid];
        -: 1756:
        -: 1757:    /* We've hit the head, pop off */
    91532: 1758:    if (it->prev == 0) {
   90812*: 1759:        assert(*head == it);
    90812: 1760:        if (it->next) {
        8: 1761:            *head = it->next;
       8*: 1762:            assert(it->next->prev == it);
        8: 1763:            it->next->prev = 0;
        -: 1764:        }
    90812: 1765:        return NULL; /* Done */
        -: 1766:    }
        -: 1767:
        -: 1768:    /* Swing ourselves in front of the next item */
        -: 1769:    /* NB: If there is a prev, we can't be the head */
     720*: 1770:    assert(it->prev != it);
      720: 1771:    if (it->prev) {
      720: 1772:        if (*head == it->prev) {
        -: 1773:            /* Prev was the head, now we're the head */
       12: 1774:            *head = it;
        -: 1775:        }
      720: 1776:        if (*tail == it) {
        -: 1777:            /* We are the tail, now they are the tail */
      128: 1778:            *tail = it->prev;
        -: 1779:        }
     720*: 1780:        assert(it->next != it);
      720: 1781:        if (it->next) {
     592*: 1782:            assert(it->prev->next == it);
      592: 1783:            it->prev->next = it->next;
      592: 1784:            it->next->prev = it->prev;
        -: 1785:        } else {
        -: 1786:            /* Tail. Move this above? */
      128: 1787:            it->prev->next = 0;
        -: 1788:        }
        -: 1789:        /* prev->prev's next is it->prev */
      720: 1790:        it->next = it->prev;
      720: 1791:        it->prev = it->next->prev;
      720: 1792:        it->next->prev = it;
        -: 1793:        /* New it->prev now, if we're not at the head. */
      720: 1794:        if (it->prev) {
      708: 1795:            it->prev->next = it;
        -: 1796:        }
        -: 1797:    }
     720*: 1798:    assert(it->next != it);
     720*: 1799:    assert(it->prev != it);
        -: 1800:
        -: 1801:    return it->next; /* success */
        -: 1802:}
