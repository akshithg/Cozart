        -:    0:Source:authfile.c
        -:    0:Programs:54
        -:    0:Source is newer than graph
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:#include <sys/types.h>
        -:    6:#include <sys/stat.h>
        -:    7:#include <unistd.h>
        -:    8:
        -:    9:#include "authfile.h"
        -:   10:
        -:   11:// TODO: frontend needs a refactor so this can avoid global objects.
        -:   12:
        -:   13:#define MAX_ENTRY_LEN 256
        -:   14:// Not supposed to be a huge database!
        -:   15:#define MAX_ENTRIES 8
        -:   16:
        -:   17:typedef struct auth_entry {
        -:   18:    char *user;
        -:   19:    size_t ulen;
        -:   20:    char *pass;
        -:   21:    size_t plen;
        -:   22:} auth_t;
        -:   23:
        -:   24:auth_t main_auth_entries[MAX_ENTRIES];
        -:   25:int entry_cnt = 0;
        -:   26:char *main_auth_data = NULL;
        -:   27:
        3:   28:enum authfile_ret authfile_load(const char *file) {
        3:   29:    struct stat sb;
        3:   30:    char *auth_data = NULL;
        3:   31:    auth_t auth_entries[MAX_ENTRIES];
        -:   32:
        3:   33:    if (stat(file, &sb) == -1) {
        -:   34:        return AUTHFILE_MISSING;
        -:   35:    }
        -:   36:
        3:   37:    auth_data = calloc(1, sb.st_size);
        -:   38:
        3:   39:    if (auth_data == NULL) {
        -:   40:        return AUTHFILE_OOM;
        -:   41:    }
        -:   42:
        3:   43:    FILE *pwfile = fopen(file, "r");
        3:   44:    if (pwfile == NULL) {
        -:   45:        // not strictly necessary but to be safe.
    #####:   46:        free(auth_data);
    #####:   47:        return AUTHFILE_OPENFAIL;
        -:   48:    }
        -:   49:
        -:   50:    char *auth_cur = auth_data;
        -:   51:    auth_t *entry_cur = auth_entries;
        -:   52:    int used = 0;
        -:   53:
       18:   54:    while ((fgets(auth_cur, MAX_ENTRY_LEN, pwfile)) != NULL) {
        -:   55:        int x;
        -:   56:        int found = 0;
        -:   57:
       57:   58:        for (x = 0; x < MAX_ENTRY_LEN; x++) {
       57:   59:            if (!found && auth_cur[x] == ':') {
        6:   60:                entry_cur->user = auth_cur;
        6:   61:                entry_cur->ulen = x;
        6:   62:                entry_cur->pass = &auth_cur[x+1];
        6:   63:                found = 1;
       51:   64:            } else if (found) {
        -:   65:                // Find end of password.
       27:   66:                if (auth_cur[x] == '\n' ||
       21:   67:                    auth_cur[x] == '\r' ||
        -:   68:                    auth_cur[x] == '\0') {
        6:   69:                    entry_cur->plen = x - (entry_cur->ulen + 1);
        6:   70:                    break;
        -:   71:                }
        -:   72:            }
        -:   73:        }
        -:   74:
        -:   75:        // malformed line.
        6:   76:        if (!found) {
    #####:   77:            (void)fclose(pwfile);
    #####:   78:            free(auth_data);
    #####:   79:            return AUTHFILE_MALFORMED;
        -:   80:        }
        -:   81:
        -:   82:        // FIXME: no silent truncation.
        6:   83:        if (++used == MAX_ENTRIES) {
        -:   84:            break;
        -:   85:        }
        -:   86:        // EOF
        6:   87:        if (auth_cur[x] == '\0')
        -:   88:            break;
        -:   89:
        6:   90:        auth_cur += x;
        6:   91:        entry_cur++;
        -:   92:    }
        -:   93:
        -:   94:    // swap the main pointer out now, so if there's an error reloading we
        -:   95:    // don't break the existing authentication.
        3:   96:    if (main_auth_data != NULL) {
    #####:   97:        free(main_auth_data);
        -:   98:    }
        -:   99:
        3:  100:    entry_cnt = used;
        3:  101:    main_auth_data = auth_data;
        3:  102:    memcpy(main_auth_entries, auth_entries, sizeof(auth_entries));
        -:  103:
        3:  104:    (void)fclose(pwfile);
        -:  105:
        3:  106:    return AUTHFILE_OK;
        -:  107:}
------------------
authfile_load:
        1:   28:enum authfile_ret authfile_load(const char *file) {
        1:   29:    struct stat sb;
        1:   30:    char *auth_data = NULL;
        1:   31:    auth_t auth_entries[MAX_ENTRIES];
        -:   32:
        1:   33:    if (stat(file, &sb) == -1) {
        -:   34:        return AUTHFILE_MISSING;
        -:   35:    }
        -:   36:
        1:   37:    auth_data = calloc(1, sb.st_size);
        -:   38:
        1:   39:    if (auth_data == NULL) {
        -:   40:        return AUTHFILE_OOM;
        -:   41:    }
        -:   42:
        1:   43:    FILE *pwfile = fopen(file, "r");
        1:   44:    if (pwfile == NULL) {
        -:   45:        // not strictly necessary but to be safe.
    #####:   46:        free(auth_data);
    #####:   47:        return AUTHFILE_OPENFAIL;
        -:   48:    }
        -:   49:
        -:   50:    char *auth_cur = auth_data;
        -:   51:    auth_t *entry_cur = auth_entries;
        -:   52:    int used = 0;
        -:   53:
        6:   54:    while ((fgets(auth_cur, MAX_ENTRY_LEN, pwfile)) != NULL) {
        -:   55:        int x;
        -:   56:        int found = 0;
        -:   57:
       19:   58:        for (x = 0; x < MAX_ENTRY_LEN; x++) {
       19:   59:            if (!found && auth_cur[x] == ':') {
        2:   60:                entry_cur->user = auth_cur;
        2:   61:                entry_cur->ulen = x;
        2:   62:                entry_cur->pass = &auth_cur[x+1];
        2:   63:                found = 1;
       17:   64:            } else if (found) {
        -:   65:                // Find end of password.
        9:   66:                if (auth_cur[x] == '\n' ||
        7:   67:                    auth_cur[x] == '\r' ||
        -:   68:                    auth_cur[x] == '\0') {
        2:   69:                    entry_cur->plen = x - (entry_cur->ulen + 1);
        2:   70:                    break;
        -:   71:                }
        -:   72:            }
        -:   73:        }
        -:   74:
        -:   75:        // malformed line.
        2:   76:        if (!found) {
    #####:   77:            (void)fclose(pwfile);
    #####:   78:            free(auth_data);
    #####:   79:            return AUTHFILE_MALFORMED;
        -:   80:        }
        -:   81:
        -:   82:        // FIXME: no silent truncation.
        2:   83:        if (++used == MAX_ENTRIES) {
        -:   84:            break;
        -:   85:        }
        -:   86:        // EOF
        2:   87:        if (auth_cur[x] == '\0')
        -:   88:            break;
        -:   89:
        2:   90:        auth_cur += x;
        2:   91:        entry_cur++;
        -:   92:    }
        -:   93:
        -:   94:    // swap the main pointer out now, so if there's an error reloading we
        -:   95:    // don't break the existing authentication.
        1:   96:    if (main_auth_data != NULL) {
    #####:   97:        free(main_auth_data);
        -:   98:    }
        -:   99:
        1:  100:    entry_cnt = used;
        1:  101:    main_auth_data = auth_data;
        1:  102:    memcpy(main_auth_entries, auth_entries, sizeof(auth_entries));
        -:  103:
        1:  104:    (void)fclose(pwfile);
        -:  105:
        1:  106:    return AUTHFILE_OK;
        -:  107:}
------------------
authfile_load:
        1:   28:enum authfile_ret authfile_load(const char *file) {
        1:   29:    struct stat sb;
        1:   30:    char *auth_data = NULL;
        1:   31:    auth_t auth_entries[MAX_ENTRIES];
        -:   32:
        1:   33:    if (stat(file, &sb) == -1) {
        -:   34:        return AUTHFILE_MISSING;
        -:   35:    }
        -:   36:
        1:   37:    auth_data = calloc(1, sb.st_size);
        -:   38:
        1:   39:    if (auth_data == NULL) {
        -:   40:        return AUTHFILE_OOM;
        -:   41:    }
        -:   42:
        1:   43:    FILE *pwfile = fopen(file, "r");
        1:   44:    if (pwfile == NULL) {
        -:   45:        // not strictly necessary but to be safe.
    #####:   46:        free(auth_data);
    #####:   47:        return AUTHFILE_OPENFAIL;
        -:   48:    }
        -:   49:
        -:   50:    char *auth_cur = auth_data;
        -:   51:    auth_t *entry_cur = auth_entries;
        -:   52:    int used = 0;
        -:   53:
        6:   54:    while ((fgets(auth_cur, MAX_ENTRY_LEN, pwfile)) != NULL) {
        -:   55:        int x;
        -:   56:        int found = 0;
        -:   57:
       19:   58:        for (x = 0; x < MAX_ENTRY_LEN; x++) {
       19:   59:            if (!found && auth_cur[x] == ':') {
        2:   60:                entry_cur->user = auth_cur;
        2:   61:                entry_cur->ulen = x;
        2:   62:                entry_cur->pass = &auth_cur[x+1];
        2:   63:                found = 1;
       17:   64:            } else if (found) {
        -:   65:                // Find end of password.
        9:   66:                if (auth_cur[x] == '\n' ||
        7:   67:                    auth_cur[x] == '\r' ||
        -:   68:                    auth_cur[x] == '\0') {
        2:   69:                    entry_cur->plen = x - (entry_cur->ulen + 1);
        2:   70:                    break;
        -:   71:                }
        -:   72:            }
        -:   73:        }
        -:   74:
        -:   75:        // malformed line.
        2:   76:        if (!found) {
    #####:   77:            (void)fclose(pwfile);
    #####:   78:            free(auth_data);
    #####:   79:            return AUTHFILE_MALFORMED;
        -:   80:        }
        -:   81:
        -:   82:        // FIXME: no silent truncation.
        2:   83:        if (++used == MAX_ENTRIES) {
        -:   84:            break;
        -:   85:        }
        -:   86:        // EOF
        2:   87:        if (auth_cur[x] == '\0')
        -:   88:            break;
        -:   89:
        2:   90:        auth_cur += x;
        2:   91:        entry_cur++;
        -:   92:    }
        -:   93:
        -:   94:    // swap the main pointer out now, so if there's an error reloading we
        -:   95:    // don't break the existing authentication.
        1:   96:    if (main_auth_data != NULL) {
    #####:   97:        free(main_auth_data);
        -:   98:    }
        -:   99:
        1:  100:    entry_cnt = used;
        1:  101:    main_auth_data = auth_data;
        1:  102:    memcpy(main_auth_entries, auth_entries, sizeof(auth_entries));
        -:  103:
        1:  104:    (void)fclose(pwfile);
        -:  105:
        1:  106:    return AUTHFILE_OK;
        -:  107:}
------------------
authfile_load:
        1:   28:enum authfile_ret authfile_load(const char *file) {
        1:   29:    struct stat sb;
        1:   30:    char *auth_data = NULL;
        1:   31:    auth_t auth_entries[MAX_ENTRIES];
        -:   32:
        1:   33:    if (stat(file, &sb) == -1) {
        -:   34:        return AUTHFILE_MISSING;
        -:   35:    }
        -:   36:
        1:   37:    auth_data = calloc(1, sb.st_size);
        -:   38:
        1:   39:    if (auth_data == NULL) {
        -:   40:        return AUTHFILE_OOM;
        -:   41:    }
        -:   42:
        1:   43:    FILE *pwfile = fopen(file, "r");
        1:   44:    if (pwfile == NULL) {
        -:   45:        // not strictly necessary but to be safe.
    #####:   46:        free(auth_data);
    #####:   47:        return AUTHFILE_OPENFAIL;
        -:   48:    }
        -:   49:
        -:   50:    char *auth_cur = auth_data;
        -:   51:    auth_t *entry_cur = auth_entries;
        -:   52:    int used = 0;
        -:   53:
        6:   54:    while ((fgets(auth_cur, MAX_ENTRY_LEN, pwfile)) != NULL) {
        -:   55:        int x;
        -:   56:        int found = 0;
        -:   57:
       19:   58:        for (x = 0; x < MAX_ENTRY_LEN; x++) {
       19:   59:            if (!found && auth_cur[x] == ':') {
        2:   60:                entry_cur->user = auth_cur;
        2:   61:                entry_cur->ulen = x;
        2:   62:                entry_cur->pass = &auth_cur[x+1];
        2:   63:                found = 1;
       17:   64:            } else if (found) {
        -:   65:                // Find end of password.
        9:   66:                if (auth_cur[x] == '\n' ||
        7:   67:                    auth_cur[x] == '\r' ||
        -:   68:                    auth_cur[x] == '\0') {
        2:   69:                    entry_cur->plen = x - (entry_cur->ulen + 1);
        2:   70:                    break;
        -:   71:                }
        -:   72:            }
        -:   73:        }
        -:   74:
        -:   75:        // malformed line.
        2:   76:        if (!found) {
    #####:   77:            (void)fclose(pwfile);
    #####:   78:            free(auth_data);
    #####:   79:            return AUTHFILE_MALFORMED;
        -:   80:        }
        -:   81:
        -:   82:        // FIXME: no silent truncation.
        2:   83:        if (++used == MAX_ENTRIES) {
        -:   84:            break;
        -:   85:        }
        -:   86:        // EOF
        2:   87:        if (auth_cur[x] == '\0')
        -:   88:            break;
        -:   89:
        2:   90:        auth_cur += x;
        2:   91:        entry_cur++;
        -:   92:    }
        -:   93:
        -:   94:    // swap the main pointer out now, so if there's an error reloading we
        -:   95:    // don't break the existing authentication.
        1:   96:    if (main_auth_data != NULL) {
    #####:   97:        free(main_auth_data);
        -:   98:    }
        -:   99:
        1:  100:    entry_cnt = used;
        1:  101:    main_auth_data = auth_data;
        1:  102:    memcpy(main_auth_entries, auth_entries, sizeof(auth_entries));
        -:  103:
        1:  104:    (void)fclose(pwfile);
        -:  105:
        1:  106:    return AUTHFILE_OK;
        -:  107:}
------------------
        -:  108:
        -:  109:// if only loading the file could be this short...
        9:  110:int authfile_check(const char *user, const char *pass) {
        9:  111:    size_t ulen = strlen(user);
        9:  112:    size_t plen = strlen(pass);
        -:  113:
       18:  114:    for (int x = 0; x < entry_cnt; x++) {
       15:  115:        auth_t *e = &main_auth_entries[x];
       15:  116:        if (ulen == e->ulen && plen == e->plen &&
        9:  117:            memcmp(user, e->user, e->ulen) == 0 &&
        9:  118:            memcmp(pass, e->pass, e->plen) == 0) {
        -:  119:            return 1;
        -:  120:        }
        -:  121:    }
        -:  122:
        -:  123:    return 0;
        -:  124:}
