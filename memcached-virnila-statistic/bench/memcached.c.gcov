        -:    0:Source:memcached.c
        -:    0:Programs:54
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: *  memcached - memory caching daemon
        -:    4: *
        -:    5: *       https://www.memcached.org/
        -:    6: *
        -:    7: *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.
        -:    8: *
        -:    9: *  Use and distribution licensed under the BSD license.  See
        -:   10: *  the LICENSE file for full text.
        -:   11: *
        -:   12: *  Authors:
        -:   13: *      Anatoly Vorobey <mellon@pobox.com>
        -:   14: *      Brad Fitzpatrick <brad@danga.com>
        -:   15: */
        -:   16:#include "memcached.h"
        -:   17:#ifdef EXTSTORE
        -:   18:#include "storage.h"
        -:   19:#endif
        -:   20:#include "authfile.h"
        -:   21:#include <sys/stat.h>
        -:   22:#include <sys/socket.h>
        -:   23:#include <sys/un.h>
        -:   24:#include <signal.h>
        -:   25:#include <sys/param.h>
        -:   26:#include <sys/resource.h>
        -:   27:#include <sys/uio.h>
        -:   28:#include <ctype.h>
        -:   29:#include <stdarg.h>
        -:   30:
        -:   31:/* some POSIX systems need the following definition
        -:   32: * to get mlockall flags out of sys/mman.h.  */
        -:   33:#ifndef _P1003_1B_VISIBLE
        -:   34:#define _P1003_1B_VISIBLE
        -:   35:#endif
        -:   36:/* need this to get IOV_MAX on some platforms. */
        -:   37:#ifndef __need_IOV_MAX
        -:   38:#define __need_IOV_MAX
        -:   39:#endif
        -:   40:#include <pwd.h>
        -:   41:#include <sys/mman.h>
        -:   42:#include <fcntl.h>
        -:   43:#include <netinet/tcp.h>
        -:   44:#include <arpa/inet.h>
        -:   45:#include <errno.h>
        -:   46:#include <stdlib.h>
        -:   47:#include <stdio.h>
        -:   48:#include <string.h>
        -:   49:#include <time.h>
        -:   50:#include <assert.h>
        -:   51:#include <limits.h>
        -:   52:#include <sysexits.h>
        -:   53:#include <stddef.h>
        -:   54:
        -:   55:#ifdef HAVE_GETOPT_LONG
        -:   56:#include <getopt.h>
        -:   57:#endif
        -:   58:
        -:   59:#ifdef TLS
        -:   60:#include "tls.h"
        -:   61:#endif
        -:   62:
        -:   63:#if defined(__FreeBSD__)
        -:   64:#include <sys/sysctl.h>
        -:   65:#endif
        -:   66:/* FreeBSD 4.x doesn't have IOV_MAX exposed. */
        -:   67:#ifndef IOV_MAX
        -:   68:#if defined(__FreeBSD__) || defined(__APPLE__) || defined(__GNU__)
        -:   69:# define IOV_MAX 1024
        -:   70:/* GNU/Hurd don't set MAXPATHLEN
        -:   71: * http://www.gnu.org/software/hurd/hurd/porting/guidelines.html#PATH_MAX_tt_MAX_PATH_tt_MAXPATHL */
        -:   72:#ifndef MAXPATHLEN
        -:   73:#define MAXPATHLEN 4096
        -:   74:#endif
        -:   75:#endif
        -:   76:#endif
        -:   77:
        -:   78:/*
        -:   79: * forward declarations
        -:   80: */
        -:   81:static void drive_machine(conn *c);
        -:   82:static int new_socket(struct addrinfo *ai);
        -:   83:static ssize_t tcp_read(conn *arg, void *buf, size_t count);
        -:   84:static ssize_t tcp_sendmsg(conn *arg, struct msghdr *msg, int flags);
        -:   85:static ssize_t tcp_write(conn *arg, void *buf, size_t count);
        -:   86:
        -:   87:enum try_read_result {
        -:   88:    READ_DATA_RECEIVED,
        -:   89:    READ_NO_DATA_RECEIVED,
        -:   90:    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */
        -:   91:    READ_MEMORY_ERROR      /** failed to allocate more memory */
        -:   92:};
        -:   93:
        -:   94:static int try_read_command_negotiate(conn *c);
        -:   95:static int try_read_command_udp(conn *c);
        -:   96:static int try_read_command_binary(conn *c);
        -:   97:static int try_read_command_ascii(conn *c);
        -:   98:static int try_read_command_asciiauth(conn *c);
        -:   99:
        -:  100:static enum try_read_result try_read_network(conn *c);
        -:  101:static enum try_read_result try_read_udp(conn *c);
        -:  102:
        -:  103:static void conn_set_state(conn *c, enum conn_states state);
        -:  104:static int start_conn_timeout_thread();
        -:  105:
        -:  106:/* stats */
        -:  107:static void stats_init(void);
        -:  108:static void server_stats(ADD_STAT add_stats, conn *c);
        -:  109:static void process_stat_settings(ADD_STAT add_stats, void *c);
        -:  110:static void conn_to_str(const conn *c, char *buf);
        -:  111:
        -:  112:
        -:  113:/* defaults */
        -:  114:static void settings_init(void);
        -:  115:
        -:  116:/* event handling, network IO */
        -:  117:static void event_handler(const int fd, const short which, void *arg);
        -:  118:static void conn_close(conn *c);
        -:  119:static void conn_init(void);
        -:  120:static bool update_event(conn *c, const int new_flags);
        -:  121:static void complete_nread(conn *c);
        -:  122:static void process_command(conn *c, char *command);
        -:  123:static void write_and_free(conn *c, char *buf, int bytes);
        -:  124:static int ensure_iov_space(conn *c);
        -:  125:static int add_iov(conn *c, const void *buf, int len);
        -:  126:static int add_chunked_item_iovs(conn *c, item *it, int len);
        -:  127:static int add_msghdr(conn *c);
        -:  128:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -:  129:                            const char *errstr, int swallow);
        -:  130:static void write_bin_miss_response(conn *c, char *key, size_t nkey);
        -:  131:
        -:  132:#ifdef EXTSTORE
        -:  133:static void _get_extstore_cb(void *e, obj_io *io, int ret);
        -:  134:static inline int _get_extstore(conn *c, item *it, int iovst, int iovcnt);
        -:  135:#endif
        -:  136:static void conn_free(conn *c);
        -:  137:
        -:  138:/** exported globals **/
        -:  139:struct stats stats;
        -:  140:struct stats_state stats_state;
        -:  141:struct settings settings;
        -:  142:time_t process_started;     /* when the process was started */
        -:  143:conn **conns;
        -:  144:
        -:  145:struct slab_rebalance slab_rebal;
        -:  146:volatile int slab_rebalance_signal;
        -:  147:#ifdef EXTSTORE
        -:  148:/* hoping this is temporary; I'd prefer to cut globals, but will complete this
        -:  149: * battle another day.
        -:  150: */
        -:  151:void *ext_storage;
        -:  152:#endif
        -:  153:/** file scope variables **/
        -:  154:static conn *listen_conn = NULL;
        -:  155:static int max_fds;
        -:  156:static struct event_base *main_base;
        -:  157:
        -:  158:enum transmit_result {
        -:  159:    TRANSMIT_COMPLETE,   /** All done writing. */
        -:  160:    TRANSMIT_INCOMPLETE, /** More data remaining to write. */
        -:  161:    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */
        -:  162:    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */
        -:  163:};
        -:  164:
        -:  165:/* Default methods to read from/ write to a socket */
   300600:  166:ssize_t tcp_read(conn *c, void *buf, size_t count) {
  300600*:  167:    assert (c != NULL);
   300600:  168:    return read(c->sfd, buf, count);
        -:  169:}
------------------
tcp_read:
   100200:  166:ssize_t tcp_read(conn *c, void *buf, size_t count) {
  100200*:  167:    assert (c != NULL);
   100200:  168:    return read(c->sfd, buf, count);
        -:  169:}
------------------
tcp_read:
   100200:  166:ssize_t tcp_read(conn *c, void *buf, size_t count) {
  100200*:  167:    assert (c != NULL);
   100200:  168:    return read(c->sfd, buf, count);
        -:  169:}
------------------
tcp_read:
   100200:  166:ssize_t tcp_read(conn *c, void *buf, size_t count) {
  100200*:  167:    assert (c != NULL);
   100200:  168:    return read(c->sfd, buf, count);
        -:  169:}
------------------
        -:  170:
   300000:  171:ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {
  300000*:  172:    assert (c != NULL);
   300000:  173:    return sendmsg(c->sfd, msg, flags);
        -:  174:}
------------------
tcp_sendmsg:
   100000:  171:ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {
  100000*:  172:    assert (c != NULL);
   100000:  173:    return sendmsg(c->sfd, msg, flags);
        -:  174:}
------------------
tcp_sendmsg:
   100000:  171:ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {
  100000*:  172:    assert (c != NULL);
   100000:  173:    return sendmsg(c->sfd, msg, flags);
        -:  174:}
------------------
tcp_sendmsg:
   100000:  171:ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {
  100000*:  172:    assert (c != NULL);
   100000:  173:    return sendmsg(c->sfd, msg, flags);
        -:  174:}
------------------
        -:  175:
    #####:  176:ssize_t tcp_write(conn *c, void *buf, size_t count) {
    #####:  177:    assert (c != NULL);
    #####:  178:    return write(c->sfd, buf, count);
        -:  179:}
------------------
tcp_write:
    #####:  176:ssize_t tcp_write(conn *c, void *buf, size_t count) {
    #####:  177:    assert (c != NULL);
    #####:  178:    return write(c->sfd, buf, count);
        -:  179:}
------------------
tcp_write:
    #####:  176:ssize_t tcp_write(conn *c, void *buf, size_t count) {
    #####:  177:    assert (c != NULL);
    #####:  178:    return write(c->sfd, buf, count);
        -:  179:}
------------------
tcp_write:
    #####:  176:ssize_t tcp_write(conn *c, void *buf, size_t count) {
    #####:  177:    assert (c != NULL);
    #####:  178:    return write(c->sfd, buf, count);
        -:  179:}
------------------
        -:  180:
        -:  181:static enum transmit_result transmit(conn *c);
        -:  182:
        -:  183:/* This reduces the latency without adding lots of extra wiring to be able to
        -:  184: * notify the listener thread of when to listen again.
        -:  185: * Also, the clock timer could be broken out into its own thread and we
        -:  186: * can block the listener via a condition.
        -:  187: */
        -:  188:static volatile bool allow_new_conns = true;
        -:  189:static struct event maxconnsevent;
    #####:  190:static void maxconns_handler(const int fd, const short which, void *arg) {
    #####:  191:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  192:
    #####:  193:    if (fd == -42 || allow_new_conns == false) {
        -:  194:        /* reschedule in 10ms if we need to keep polling */
    #####:  195:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  196:        event_base_set(main_base, &maxconnsevent);
    #####:  197:        evtimer_add(&maxconnsevent, &t);
        -:  198:    } else {
    #####:  199:        evtimer_del(&maxconnsevent);
    #####:  200:        accept_new_conns(true);
        -:  201:    }
    #####:  202:}
------------------
maxconns_handler:
    #####:  190:static void maxconns_handler(const int fd, const short which, void *arg) {
    #####:  191:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  192:
    #####:  193:    if (fd == -42 || allow_new_conns == false) {
        -:  194:        /* reschedule in 10ms if we need to keep polling */
    #####:  195:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  196:        event_base_set(main_base, &maxconnsevent);
    #####:  197:        evtimer_add(&maxconnsevent, &t);
        -:  198:    } else {
    #####:  199:        evtimer_del(&maxconnsevent);
    #####:  200:        accept_new_conns(true);
        -:  201:    }
    #####:  202:}
------------------
maxconns_handler:
    #####:  190:static void maxconns_handler(const int fd, const short which, void *arg) {
    #####:  191:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  192:
    #####:  193:    if (fd == -42 || allow_new_conns == false) {
        -:  194:        /* reschedule in 10ms if we need to keep polling */
    #####:  195:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  196:        event_base_set(main_base, &maxconnsevent);
    #####:  197:        evtimer_add(&maxconnsevent, &t);
        -:  198:    } else {
    #####:  199:        evtimer_del(&maxconnsevent);
    #####:  200:        accept_new_conns(true);
        -:  201:    }
    #####:  202:}
------------------
maxconns_handler:
    #####:  190:static void maxconns_handler(const int fd, const short which, void *arg) {
    #####:  191:    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};
        -:  192:
    #####:  193:    if (fd == -42 || allow_new_conns == false) {
        -:  194:        /* reschedule in 10ms if we need to keep polling */
    #####:  195:        evtimer_set(&maxconnsevent, maxconns_handler, 0);
    #####:  196:        event_base_set(main_base, &maxconnsevent);
    #####:  197:        evtimer_add(&maxconnsevent, &t);
        -:  198:    } else {
    #####:  199:        evtimer_del(&maxconnsevent);
    #####:  200:        accept_new_conns(true);
        -:  201:    }
    #####:  202:}
------------------
        -:  203:
        -:  204:#define REALTIME_MAXDELTA 60*60*24*30
        -:  205:
        -:  206:/*
        -:  207: * given time value that's either unix time or delta from current unix time, return
        -:  208: * unix time. Use the fact that delta can't exceed one month (and real time value can't
        -:  209: * be that low).
        -:  210: */
        -:  211:static rel_time_t realtime(const time_t exptime) {
        -:  212:    /* no. of seconds in 30 days - largest possible delta exptime */
        -:  213:
   27600*:  214:    if (exptime == 0) return 0; /* 0 means never expire */
        -:  215:
    #####:  216:    if (exptime > REALTIME_MAXDELTA) {
        -:  217:        /* if item expiration is at/before the server started, give it an
        -:  218:           expiration time of 1 second after the server started.
        -:  219:           (because 0 means don't expire).  without this, we'd
        -:  220:           underflow and wrap around to some large value way in the
        -:  221:           future, effectively making items expiring in the past
        -:  222:           really expiring never */
    #####:  223:        if (exptime <= process_started)
        -:  224:            return (rel_time_t)1;
    #####:  225:        return (rel_time_t)(exptime - process_started);
        -:  226:    } else {
    #####:  227:        return (rel_time_t)(exptime + current_time);
        -:  228:    }
        -:  229:}
        -:  230:
        3:  231:static void stats_init(void) {
        3:  232:    memset(&stats, 0, sizeof(struct stats));
        3:  233:    memset(&stats_state, 0, sizeof(struct stats_state));
        3:  234:    stats_state.accepting_conns = true; /* assuming we start in this state. */
        -:  235:
        -:  236:    /* make the time we started always be 2 seconds before we really
        -:  237:       did, so time(0) - time.started is never zero.  if so, things
        -:  238:       like 'settings.oldest_live' which act as booleans as well as
        -:  239:       values are now false in boolean context... */
        3:  240:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
        3:  241:    stats_prefix_init();
        3:  242:}
------------------
stats_init:
        1:  231:static void stats_init(void) {
        1:  232:    memset(&stats, 0, sizeof(struct stats));
        1:  233:    memset(&stats_state, 0, sizeof(struct stats_state));
        1:  234:    stats_state.accepting_conns = true; /* assuming we start in this state. */
        -:  235:
        -:  236:    /* make the time we started always be 2 seconds before we really
        -:  237:       did, so time(0) - time.started is never zero.  if so, things
        -:  238:       like 'settings.oldest_live' which act as booleans as well as
        -:  239:       values are now false in boolean context... */
        1:  240:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
        1:  241:    stats_prefix_init();
        1:  242:}
------------------
stats_init:
        1:  231:static void stats_init(void) {
        1:  232:    memset(&stats, 0, sizeof(struct stats));
        1:  233:    memset(&stats_state, 0, sizeof(struct stats_state));
        1:  234:    stats_state.accepting_conns = true; /* assuming we start in this state. */
        -:  235:
        -:  236:    /* make the time we started always be 2 seconds before we really
        -:  237:       did, so time(0) - time.started is never zero.  if so, things
        -:  238:       like 'settings.oldest_live' which act as booleans as well as
        -:  239:       values are now false in boolean context... */
        1:  240:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
        1:  241:    stats_prefix_init();
        1:  242:}
------------------
stats_init:
        1:  231:static void stats_init(void) {
        1:  232:    memset(&stats, 0, sizeof(struct stats));
        1:  233:    memset(&stats_state, 0, sizeof(struct stats_state));
        1:  234:    stats_state.accepting_conns = true; /* assuming we start in this state. */
        -:  235:
        -:  236:    /* make the time we started always be 2 seconds before we really
        -:  237:       did, so time(0) - time.started is never zero.  if so, things
        -:  238:       like 'settings.oldest_live' which act as booleans as well as
        -:  239:       values are now false in boolean context... */
        1:  240:    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
        1:  241:    stats_prefix_init();
        1:  242:}
------------------
        -:  243:
    #####:  244:static void stats_reset(void) {
    #####:  245:    STATS_LOCK();
    #####:  246:    memset(&stats, 0, sizeof(struct stats));
    #####:  247:    stats_prefix_clear();
    #####:  248:    STATS_UNLOCK();
    #####:  249:    threadlocal_stats_reset();
    #####:  250:    item_stats_reset();
    #####:  251:}
------------------
stats_reset:
    #####:  244:static void stats_reset(void) {
    #####:  245:    STATS_LOCK();
    #####:  246:    memset(&stats, 0, sizeof(struct stats));
    #####:  247:    stats_prefix_clear();
    #####:  248:    STATS_UNLOCK();
    #####:  249:    threadlocal_stats_reset();
    #####:  250:    item_stats_reset();
    #####:  251:}
------------------
stats_reset:
    #####:  244:static void stats_reset(void) {
    #####:  245:    STATS_LOCK();
    #####:  246:    memset(&stats, 0, sizeof(struct stats));
    #####:  247:    stats_prefix_clear();
    #####:  248:    STATS_UNLOCK();
    #####:  249:    threadlocal_stats_reset();
    #####:  250:    item_stats_reset();
    #####:  251:}
------------------
stats_reset:
    #####:  244:static void stats_reset(void) {
    #####:  245:    STATS_LOCK();
    #####:  246:    memset(&stats, 0, sizeof(struct stats));
    #####:  247:    stats_prefix_clear();
    #####:  248:    STATS_UNLOCK();
    #####:  249:    threadlocal_stats_reset();
    #####:  250:    item_stats_reset();
    #####:  251:}
------------------
        -:  252:
        3:  253:static void settings_init(void) {
        3:  254:    settings.use_cas = true;
        3:  255:    settings.access = 0700;
        3:  256:    settings.port = 11211;
        3:  257:    settings.udpport = 0;
        -:  258:#ifdef TLS
        -:  259:    settings.ssl_enabled = false;
        -:  260:    settings.ssl_ctx = NULL;
        -:  261:    settings.ssl_chain_cert = NULL;
        -:  262:    settings.ssl_key = NULL;
        -:  263:    settings.ssl_verify_mode = SSL_VERIFY_NONE;
        -:  264:    settings.ssl_keyformat = SSL_FILETYPE_PEM;
        -:  265:    settings.ssl_ciphers = NULL;
        -:  266:    settings.ssl_ca_cert = NULL;
        -:  267:    settings.ssl_last_cert_refresh_time = current_time;
        -:  268:    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
        -:  269:#endif
        -:  270:    /* By default this string should be NULL for getaddrinfo() */
        3:  271:    settings.inter = NULL;
        3:  272:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
        3:  273:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
        3:  274:    settings.verbose = 0;
        3:  275:    settings.oldest_live = 0;
        3:  276:    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */
        3:  277:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
        3:  278:    settings.socketpath = NULL;       /* by default, not using a unix socket */
        3:  279:    settings.auth_file = NULL;        /* by default, not using ASCII authentication tokens */
        3:  280:    settings.factor = 1.25;
        3:  281:    settings.chunk_size = 48;         /* space for a modest key and value */
        3:  282:    settings.num_threads = 4;         /* N workers */
        3:  283:    settings.num_threads_per_udp = 0;
        3:  284:    settings.prefix_delimiter = ':';
        3:  285:    settings.detail_enabled = 0;
        3:  286:    settings.reqs_per_event = 20;
        3:  287:    settings.backlog = 1024;
        3:  288:    settings.binding_protocol = negotiating_prot;
        3:  289:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
        3:  290:    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */
        3:  291:    settings.slab_chunk_size_max = settings.slab_page_size / 2;
        3:  292:    settings.sasl = false;
        3:  293:    settings.maxconns_fast = true;
        3:  294:    settings.lru_crawler = false;
        3:  295:    settings.lru_crawler_sleep = 100;
        3:  296:    settings.lru_crawler_tocrawl = 0;
        3:  297:    settings.lru_maintainer_thread = false;
        3:  298:    settings.lru_segmented = true;
        3:  299:    settings.hot_lru_pct = 20;
        3:  300:    settings.warm_lru_pct = 40;
        3:  301:    settings.hot_max_factor = 0.2;
        3:  302:    settings.warm_max_factor = 2.0;
        3:  303:    settings.temp_lru = false;
        3:  304:    settings.temporary_ttl = 61;
        3:  305:    settings.idle_timeout = 0; /* disabled */
        3:  306:    settings.hashpower_init = 0;
        3:  307:    settings.slab_reassign = true;
        3:  308:    settings.slab_automove = 1;
        3:  309:    settings.slab_automove_ratio = 0.8;
        3:  310:    settings.slab_automove_window = 30;
        3:  311:    settings.shutdown_command = false;
        3:  312:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
        3:  313:    settings.flush_enabled = true;
        3:  314:    settings.dump_enabled = true;
        3:  315:    settings.crawls_persleep = 1000;
        3:  316:    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;
        3:  317:    settings.logger_buf_size = LOGGER_BUF_SIZE;
        3:  318:    settings.drop_privileges = false;
        -:  319:#ifdef MEMCACHED_DEBUG
        3:  320:    settings.relaxed_privileges = false;
        -:  321:#endif
        3:  322:}
------------------
settings_init:
        1:  253:static void settings_init(void) {
        1:  254:    settings.use_cas = true;
        1:  255:    settings.access = 0700;
        1:  256:    settings.port = 11211;
        1:  257:    settings.udpport = 0;
        -:  258:#ifdef TLS
        -:  259:    settings.ssl_enabled = false;
        -:  260:    settings.ssl_ctx = NULL;
        -:  261:    settings.ssl_chain_cert = NULL;
        -:  262:    settings.ssl_key = NULL;
        -:  263:    settings.ssl_verify_mode = SSL_VERIFY_NONE;
        -:  264:    settings.ssl_keyformat = SSL_FILETYPE_PEM;
        -:  265:    settings.ssl_ciphers = NULL;
        -:  266:    settings.ssl_ca_cert = NULL;
        -:  267:    settings.ssl_last_cert_refresh_time = current_time;
        -:  268:    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
        -:  269:#endif
        -:  270:    /* By default this string should be NULL for getaddrinfo() */
        1:  271:    settings.inter = NULL;
        1:  272:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
        1:  273:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
        1:  274:    settings.verbose = 0;
        1:  275:    settings.oldest_live = 0;
        1:  276:    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */
        1:  277:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
        1:  278:    settings.socketpath = NULL;       /* by default, not using a unix socket */
        1:  279:    settings.auth_file = NULL;        /* by default, not using ASCII authentication tokens */
        1:  280:    settings.factor = 1.25;
        1:  281:    settings.chunk_size = 48;         /* space for a modest key and value */
        1:  282:    settings.num_threads = 4;         /* N workers */
        1:  283:    settings.num_threads_per_udp = 0;
        1:  284:    settings.prefix_delimiter = ':';
        1:  285:    settings.detail_enabled = 0;
        1:  286:    settings.reqs_per_event = 20;
        1:  287:    settings.backlog = 1024;
        1:  288:    settings.binding_protocol = negotiating_prot;
        1:  289:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
        1:  290:    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */
        1:  291:    settings.slab_chunk_size_max = settings.slab_page_size / 2;
        1:  292:    settings.sasl = false;
        1:  293:    settings.maxconns_fast = true;
        1:  294:    settings.lru_crawler = false;
        1:  295:    settings.lru_crawler_sleep = 100;
        1:  296:    settings.lru_crawler_tocrawl = 0;
        1:  297:    settings.lru_maintainer_thread = false;
        1:  298:    settings.lru_segmented = true;
        1:  299:    settings.hot_lru_pct = 20;
        1:  300:    settings.warm_lru_pct = 40;
        1:  301:    settings.hot_max_factor = 0.2;
        1:  302:    settings.warm_max_factor = 2.0;
        1:  303:    settings.temp_lru = false;
        1:  304:    settings.temporary_ttl = 61;
        1:  305:    settings.idle_timeout = 0; /* disabled */
        1:  306:    settings.hashpower_init = 0;
        1:  307:    settings.slab_reassign = true;
        1:  308:    settings.slab_automove = 1;
        1:  309:    settings.slab_automove_ratio = 0.8;
        1:  310:    settings.slab_automove_window = 30;
        1:  311:    settings.shutdown_command = false;
        1:  312:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
        1:  313:    settings.flush_enabled = true;
        1:  314:    settings.dump_enabled = true;
        1:  315:    settings.crawls_persleep = 1000;
        1:  316:    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;
        1:  317:    settings.logger_buf_size = LOGGER_BUF_SIZE;
        1:  318:    settings.drop_privileges = false;
        -:  319:#ifdef MEMCACHED_DEBUG
        1:  320:    settings.relaxed_privileges = false;
        -:  321:#endif
        1:  322:}
------------------
settings_init:
        1:  253:static void settings_init(void) {
        1:  254:    settings.use_cas = true;
        1:  255:    settings.access = 0700;
        1:  256:    settings.port = 11211;
        1:  257:    settings.udpport = 0;
        -:  258:#ifdef TLS
        -:  259:    settings.ssl_enabled = false;
        -:  260:    settings.ssl_ctx = NULL;
        -:  261:    settings.ssl_chain_cert = NULL;
        -:  262:    settings.ssl_key = NULL;
        -:  263:    settings.ssl_verify_mode = SSL_VERIFY_NONE;
        -:  264:    settings.ssl_keyformat = SSL_FILETYPE_PEM;
        -:  265:    settings.ssl_ciphers = NULL;
        -:  266:    settings.ssl_ca_cert = NULL;
        -:  267:    settings.ssl_last_cert_refresh_time = current_time;
        -:  268:    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
        -:  269:#endif
        -:  270:    /* By default this string should be NULL for getaddrinfo() */
        1:  271:    settings.inter = NULL;
        1:  272:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
        1:  273:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
        1:  274:    settings.verbose = 0;
        1:  275:    settings.oldest_live = 0;
        1:  276:    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */
        1:  277:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
        1:  278:    settings.socketpath = NULL;       /* by default, not using a unix socket */
        1:  279:    settings.auth_file = NULL;        /* by default, not using ASCII authentication tokens */
        1:  280:    settings.factor = 1.25;
        1:  281:    settings.chunk_size = 48;         /* space for a modest key and value */
        1:  282:    settings.num_threads = 4;         /* N workers */
        1:  283:    settings.num_threads_per_udp = 0;
        1:  284:    settings.prefix_delimiter = ':';
        1:  285:    settings.detail_enabled = 0;
        1:  286:    settings.reqs_per_event = 20;
        1:  287:    settings.backlog = 1024;
        1:  288:    settings.binding_protocol = negotiating_prot;
        1:  289:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
        1:  290:    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */
        1:  291:    settings.slab_chunk_size_max = settings.slab_page_size / 2;
        1:  292:    settings.sasl = false;
        1:  293:    settings.maxconns_fast = true;
        1:  294:    settings.lru_crawler = false;
        1:  295:    settings.lru_crawler_sleep = 100;
        1:  296:    settings.lru_crawler_tocrawl = 0;
        1:  297:    settings.lru_maintainer_thread = false;
        1:  298:    settings.lru_segmented = true;
        1:  299:    settings.hot_lru_pct = 20;
        1:  300:    settings.warm_lru_pct = 40;
        1:  301:    settings.hot_max_factor = 0.2;
        1:  302:    settings.warm_max_factor = 2.0;
        1:  303:    settings.temp_lru = false;
        1:  304:    settings.temporary_ttl = 61;
        1:  305:    settings.idle_timeout = 0; /* disabled */
        1:  306:    settings.hashpower_init = 0;
        1:  307:    settings.slab_reassign = true;
        1:  308:    settings.slab_automove = 1;
        1:  309:    settings.slab_automove_ratio = 0.8;
        1:  310:    settings.slab_automove_window = 30;
        1:  311:    settings.shutdown_command = false;
        1:  312:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
        1:  313:    settings.flush_enabled = true;
        1:  314:    settings.dump_enabled = true;
        1:  315:    settings.crawls_persleep = 1000;
        1:  316:    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;
        1:  317:    settings.logger_buf_size = LOGGER_BUF_SIZE;
        1:  318:    settings.drop_privileges = false;
        -:  319:#ifdef MEMCACHED_DEBUG
        1:  320:    settings.relaxed_privileges = false;
        -:  321:#endif
        1:  322:}
------------------
settings_init:
        1:  253:static void settings_init(void) {
        1:  254:    settings.use_cas = true;
        1:  255:    settings.access = 0700;
        1:  256:    settings.port = 11211;
        1:  257:    settings.udpport = 0;
        -:  258:#ifdef TLS
        -:  259:    settings.ssl_enabled = false;
        -:  260:    settings.ssl_ctx = NULL;
        -:  261:    settings.ssl_chain_cert = NULL;
        -:  262:    settings.ssl_key = NULL;
        -:  263:    settings.ssl_verify_mode = SSL_VERIFY_NONE;
        -:  264:    settings.ssl_keyformat = SSL_FILETYPE_PEM;
        -:  265:    settings.ssl_ciphers = NULL;
        -:  266:    settings.ssl_ca_cert = NULL;
        -:  267:    settings.ssl_last_cert_refresh_time = current_time;
        -:  268:    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
        -:  269:#endif
        -:  270:    /* By default this string should be NULL for getaddrinfo() */
        1:  271:    settings.inter = NULL;
        1:  272:    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
        1:  273:    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
        1:  274:    settings.verbose = 0;
        1:  275:    settings.oldest_live = 0;
        1:  276:    settings.oldest_cas = 0;          /* supplements accuracy of oldest_live */
        1:  277:    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */
        1:  278:    settings.socketpath = NULL;       /* by default, not using a unix socket */
        1:  279:    settings.auth_file = NULL;        /* by default, not using ASCII authentication tokens */
        1:  280:    settings.factor = 1.25;
        1:  281:    settings.chunk_size = 48;         /* space for a modest key and value */
        1:  282:    settings.num_threads = 4;         /* N workers */
        1:  283:    settings.num_threads_per_udp = 0;
        1:  284:    settings.prefix_delimiter = ':';
        1:  285:    settings.detail_enabled = 0;
        1:  286:    settings.reqs_per_event = 20;
        1:  287:    settings.backlog = 1024;
        1:  288:    settings.binding_protocol = negotiating_prot;
        1:  289:    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */
        1:  290:    settings.slab_page_size = 1024 * 1024; /* chunks are split from 1MB pages. */
        1:  291:    settings.slab_chunk_size_max = settings.slab_page_size / 2;
        1:  292:    settings.sasl = false;
        1:  293:    settings.maxconns_fast = true;
        1:  294:    settings.lru_crawler = false;
        1:  295:    settings.lru_crawler_sleep = 100;
        1:  296:    settings.lru_crawler_tocrawl = 0;
        1:  297:    settings.lru_maintainer_thread = false;
        1:  298:    settings.lru_segmented = true;
        1:  299:    settings.hot_lru_pct = 20;
        1:  300:    settings.warm_lru_pct = 40;
        1:  301:    settings.hot_max_factor = 0.2;
        1:  302:    settings.warm_max_factor = 2.0;
        1:  303:    settings.temp_lru = false;
        1:  304:    settings.temporary_ttl = 61;
        1:  305:    settings.idle_timeout = 0; /* disabled */
        1:  306:    settings.hashpower_init = 0;
        1:  307:    settings.slab_reassign = true;
        1:  308:    settings.slab_automove = 1;
        1:  309:    settings.slab_automove_ratio = 0.8;
        1:  310:    settings.slab_automove_window = 30;
        1:  311:    settings.shutdown_command = false;
        1:  312:    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;
        1:  313:    settings.flush_enabled = true;
        1:  314:    settings.dump_enabled = true;
        1:  315:    settings.crawls_persleep = 1000;
        1:  316:    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;
        1:  317:    settings.logger_buf_size = LOGGER_BUF_SIZE;
        1:  318:    settings.drop_privileges = false;
        -:  319:#ifdef MEMCACHED_DEBUG
        1:  320:    settings.relaxed_privileges = false;
        -:  321:#endif
        1:  322:}
------------------
        -:  323:
        -:  324:/*
        -:  325: * Adds a message header to a connection.
        -:  326: *
        -:  327: * Returns 0 on success, -1 on out-of-memory.
        -:  328: */
   600000:  329:static int add_msghdr(conn *c)
        -:  330:{
   600000:  331:    struct msghdr *msg;
        -:  332:
  600000*:  333:    assert(c != NULL);
        -:  334:
   600000:  335:    if (c->msgsize == c->msgused) {
    #####:  336:        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
    #####:  337:        if (! msg) {
    #####:  338:            STATS_LOCK();
    #####:  339:            stats.malloc_fails++;
    #####:  340:            STATS_UNLOCK();
    #####:  341:            return -1;
        -:  342:        }
    #####:  343:        c->msglist = msg;
    #####:  344:        c->msgsize *= 2;
        -:  345:    }
        -:  346:
   600000:  347:    msg = c->msglist + c->msgused;
        -:  348:
        -:  349:    /* this wipes msg_iovlen, msg_control, msg_controllen, and
        -:  350:       msg_flags, the last 3 of which aren't defined on solaris: */
   600000:  351:    memset(msg, 0, sizeof(struct msghdr));
        -:  352:
   600000:  353:    msg->msg_iov = &c->iov[c->iovused];
        -:  354:
  600000*:  355:    if (IS_UDP(c->transport) && c->request_addr_size > 0) {
    #####:  356:        msg->msg_name = &c->request_addr;
    #####:  357:        msg->msg_namelen = c->request_addr_size;
        -:  358:    }
        -:  359:
   600000:  360:    c->msgbytes = 0;
   600000:  361:    c->msgused++;
        -:  362:
   600000:  363:    if (IS_UDP(c->transport)) {
        -:  364:        /* Leave room for the UDP header, which we'll fill in later. */
    #####:  365:        return add_iov(c, NULL, UDP_HEADER_SIZE);
        -:  366:    }
        -:  367:
        -:  368:    return 0;
        -:  369:}
------------------
add_msghdr:
   200000:  329:static int add_msghdr(conn *c)
        -:  330:{
   200000:  331:    struct msghdr *msg;
        -:  332:
  200000*:  333:    assert(c != NULL);
        -:  334:
   200000:  335:    if (c->msgsize == c->msgused) {
    #####:  336:        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
    #####:  337:        if (! msg) {
    #####:  338:            STATS_LOCK();
    #####:  339:            stats.malloc_fails++;
    #####:  340:            STATS_UNLOCK();
    #####:  341:            return -1;
        -:  342:        }
    #####:  343:        c->msglist = msg;
    #####:  344:        c->msgsize *= 2;
        -:  345:    }
        -:  346:
   200000:  347:    msg = c->msglist + c->msgused;
        -:  348:
        -:  349:    /* this wipes msg_iovlen, msg_control, msg_controllen, and
        -:  350:       msg_flags, the last 3 of which aren't defined on solaris: */
   200000:  351:    memset(msg, 0, sizeof(struct msghdr));
        -:  352:
   200000:  353:    msg->msg_iov = &c->iov[c->iovused];
        -:  354:
  200000*:  355:    if (IS_UDP(c->transport) && c->request_addr_size > 0) {
    #####:  356:        msg->msg_name = &c->request_addr;
    #####:  357:        msg->msg_namelen = c->request_addr_size;
        -:  358:    }
        -:  359:
   200000:  360:    c->msgbytes = 0;
   200000:  361:    c->msgused++;
        -:  362:
   200000:  363:    if (IS_UDP(c->transport)) {
        -:  364:        /* Leave room for the UDP header, which we'll fill in later. */
    #####:  365:        return add_iov(c, NULL, UDP_HEADER_SIZE);
        -:  366:    }
        -:  367:
        -:  368:    return 0;
        -:  369:}
------------------
add_msghdr:
   200000:  329:static int add_msghdr(conn *c)
        -:  330:{
   200000:  331:    struct msghdr *msg;
        -:  332:
  200000*:  333:    assert(c != NULL);
        -:  334:
   200000:  335:    if (c->msgsize == c->msgused) {
    #####:  336:        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
    #####:  337:        if (! msg) {
    #####:  338:            STATS_LOCK();
    #####:  339:            stats.malloc_fails++;
    #####:  340:            STATS_UNLOCK();
    #####:  341:            return -1;
        -:  342:        }
    #####:  343:        c->msglist = msg;
    #####:  344:        c->msgsize *= 2;
        -:  345:    }
        -:  346:
   200000:  347:    msg = c->msglist + c->msgused;
        -:  348:
        -:  349:    /* this wipes msg_iovlen, msg_control, msg_controllen, and
        -:  350:       msg_flags, the last 3 of which aren't defined on solaris: */
   200000:  351:    memset(msg, 0, sizeof(struct msghdr));
        -:  352:
   200000:  353:    msg->msg_iov = &c->iov[c->iovused];
        -:  354:
  200000*:  355:    if (IS_UDP(c->transport) && c->request_addr_size > 0) {
    #####:  356:        msg->msg_name = &c->request_addr;
    #####:  357:        msg->msg_namelen = c->request_addr_size;
        -:  358:    }
        -:  359:
   200000:  360:    c->msgbytes = 0;
   200000:  361:    c->msgused++;
        -:  362:
   200000:  363:    if (IS_UDP(c->transport)) {
        -:  364:        /* Leave room for the UDP header, which we'll fill in later. */
    #####:  365:        return add_iov(c, NULL, UDP_HEADER_SIZE);
        -:  366:    }
        -:  367:
        -:  368:    return 0;
        -:  369:}
------------------
add_msghdr:
   200000:  329:static int add_msghdr(conn *c)
        -:  330:{
   200000:  331:    struct msghdr *msg;
        -:  332:
  200000*:  333:    assert(c != NULL);
        -:  334:
   200000:  335:    if (c->msgsize == c->msgused) {
    #####:  336:        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
    #####:  337:        if (! msg) {
    #####:  338:            STATS_LOCK();
    #####:  339:            stats.malloc_fails++;
    #####:  340:            STATS_UNLOCK();
    #####:  341:            return -1;
        -:  342:        }
    #####:  343:        c->msglist = msg;
    #####:  344:        c->msgsize *= 2;
        -:  345:    }
        -:  346:
   200000:  347:    msg = c->msglist + c->msgused;
        -:  348:
        -:  349:    /* this wipes msg_iovlen, msg_control, msg_controllen, and
        -:  350:       msg_flags, the last 3 of which aren't defined on solaris: */
   200000:  351:    memset(msg, 0, sizeof(struct msghdr));
        -:  352:
   200000:  353:    msg->msg_iov = &c->iov[c->iovused];
        -:  354:
  200000*:  355:    if (IS_UDP(c->transport) && c->request_addr_size > 0) {
    #####:  356:        msg->msg_name = &c->request_addr;
    #####:  357:        msg->msg_namelen = c->request_addr_size;
        -:  358:    }
        -:  359:
   200000:  360:    c->msgbytes = 0;
   200000:  361:    c->msgused++;
        -:  362:
   200000:  363:    if (IS_UDP(c->transport)) {
        -:  364:        /* Leave room for the UDP header, which we'll fill in later. */
    #####:  365:        return add_iov(c, NULL, UDP_HEADER_SIZE);
        -:  366:    }
        -:  367:
        -:  368:    return 0;
        -:  369:}
------------------
        -:  370:
        -:  371:extern pthread_mutex_t conn_lock;
        -:  372:
        -:  373:/* Connection timeout thread bits */
        -:  374:static pthread_t conn_timeout_tid;
        -:  375:
        -:  376:#define CONNS_PER_SLICE 100
        -:  377:#define TIMEOUT_MSG_SIZE (1 + sizeof(int))
    #####:  378:static void *conn_timeout_thread(void *arg) {
    #####:  379:    int i;
    #####:  380:    conn *c;
    #####:  381:    char buf[TIMEOUT_MSG_SIZE];
    #####:  382:    rel_time_t oldest_last_cmd;
    #####:  383:    int sleep_time;
    #####:  384:    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);
        -:  385:
    #####:  386:    while(1) {
    #####:  387:        if (settings.verbose > 2)
    #####:  388:            fprintf(stderr, "idle timeout thread at top of connection list\n");
        -:  389:
    #####:  390:        oldest_last_cmd = current_time;
        -:  391:
    #####:  392:        for (i = 0; i < max_fds; i++) {
    #####:  393:            if ((i % CONNS_PER_SLICE) == 0) {
    #####:  394:                if (settings.verbose > 2)
    #####:  395:                    fprintf(stderr, "idle timeout thread sleeping for %ulus\n",
        -:  396:                        (unsigned int)timeslice);
    #####:  397:                usleep(timeslice);
        -:  398:            }
        -:  399:
    #####:  400:            if (!conns[i])
        -:  401:                continue;
        -:  402:
    #####:  403:            c = conns[i];
        -:  404:
    #####:  405:            if (!IS_TCP(c->transport))
        -:  406:                continue;
        -:  407:
    #####:  408:            if (c->state != conn_new_cmd && c->state != conn_read)
        -:  409:                continue;
        -:  410:
    #####:  411:            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  412:                buf[0] = 't';
    #####:  413:                memcpy(&buf[1], &i, sizeof(int));
    #####:  414:                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)
        -:  415:                    != TIMEOUT_MSG_SIZE)
    #####:  416:                    perror("Failed to write timeout to notify pipe");
        -:  417:            } else {
    #####:  418:                if (c->last_cmd_time < oldest_last_cmd)
    #####:  419:                    oldest_last_cmd = c->last_cmd_time;
        -:  420:            }
        -:  421:        }
        -:  422:
        -:  423:        /* This is the soonest we could have another connection time out */
    #####:  424:        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;
    #####:  425:        if (sleep_time <= 0)
    #####:  426:            sleep_time = 1;
        -:  427:
    #####:  428:        if (settings.verbose > 2)
    #####:  429:            fprintf(stderr,
        -:  430:                    "idle timeout thread finished pass, sleeping for %ds\n",
        -:  431:                    sleep_time);
    #####:  432:        usleep((useconds_t) sleep_time * 1000000);
        -:  433:    }
        -:  434:
        -:  435:    return NULL;
        -:  436:}
------------------
conn_timeout_thread:
    #####:  378:static void *conn_timeout_thread(void *arg) {
    #####:  379:    int i;
    #####:  380:    conn *c;
    #####:  381:    char buf[TIMEOUT_MSG_SIZE];
    #####:  382:    rel_time_t oldest_last_cmd;
    #####:  383:    int sleep_time;
    #####:  384:    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);
        -:  385:
    #####:  386:    while(1) {
    #####:  387:        if (settings.verbose > 2)
    #####:  388:            fprintf(stderr, "idle timeout thread at top of connection list\n");
        -:  389:
    #####:  390:        oldest_last_cmd = current_time;
        -:  391:
    #####:  392:        for (i = 0; i < max_fds; i++) {
    #####:  393:            if ((i % CONNS_PER_SLICE) == 0) {
    #####:  394:                if (settings.verbose > 2)
    #####:  395:                    fprintf(stderr, "idle timeout thread sleeping for %ulus\n",
        -:  396:                        (unsigned int)timeslice);
    #####:  397:                usleep(timeslice);
        -:  398:            }
        -:  399:
    #####:  400:            if (!conns[i])
        -:  401:                continue;
        -:  402:
    #####:  403:            c = conns[i];
        -:  404:
    #####:  405:            if (!IS_TCP(c->transport))
        -:  406:                continue;
        -:  407:
    #####:  408:            if (c->state != conn_new_cmd && c->state != conn_read)
        -:  409:                continue;
        -:  410:
    #####:  411:            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  412:                buf[0] = 't';
    #####:  413:                memcpy(&buf[1], &i, sizeof(int));
    #####:  414:                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)
        -:  415:                    != TIMEOUT_MSG_SIZE)
    #####:  416:                    perror("Failed to write timeout to notify pipe");
        -:  417:            } else {
    #####:  418:                if (c->last_cmd_time < oldest_last_cmd)
    #####:  419:                    oldest_last_cmd = c->last_cmd_time;
        -:  420:            }
        -:  421:        }
        -:  422:
        -:  423:        /* This is the soonest we could have another connection time out */
    #####:  424:        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;
    #####:  425:        if (sleep_time <= 0)
    #####:  426:            sleep_time = 1;
        -:  427:
    #####:  428:        if (settings.verbose > 2)
    #####:  429:            fprintf(stderr,
        -:  430:                    "idle timeout thread finished pass, sleeping for %ds\n",
        -:  431:                    sleep_time);
    #####:  432:        usleep((useconds_t) sleep_time * 1000000);
        -:  433:    }
        -:  434:
        -:  435:    return NULL;
        -:  436:}
------------------
conn_timeout_thread:
    #####:  378:static void *conn_timeout_thread(void *arg) {
    #####:  379:    int i;
    #####:  380:    conn *c;
    #####:  381:    char buf[TIMEOUT_MSG_SIZE];
    #####:  382:    rel_time_t oldest_last_cmd;
    #####:  383:    int sleep_time;
    #####:  384:    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);
        -:  385:
    #####:  386:    while(1) {
    #####:  387:        if (settings.verbose > 2)
    #####:  388:            fprintf(stderr, "idle timeout thread at top of connection list\n");
        -:  389:
    #####:  390:        oldest_last_cmd = current_time;
        -:  391:
    #####:  392:        for (i = 0; i < max_fds; i++) {
    #####:  393:            if ((i % CONNS_PER_SLICE) == 0) {
    #####:  394:                if (settings.verbose > 2)
    #####:  395:                    fprintf(stderr, "idle timeout thread sleeping for %ulus\n",
        -:  396:                        (unsigned int)timeslice);
    #####:  397:                usleep(timeslice);
        -:  398:            }
        -:  399:
    #####:  400:            if (!conns[i])
        -:  401:                continue;
        -:  402:
    #####:  403:            c = conns[i];
        -:  404:
    #####:  405:            if (!IS_TCP(c->transport))
        -:  406:                continue;
        -:  407:
    #####:  408:            if (c->state != conn_new_cmd && c->state != conn_read)
        -:  409:                continue;
        -:  410:
    #####:  411:            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  412:                buf[0] = 't';
    #####:  413:                memcpy(&buf[1], &i, sizeof(int));
    #####:  414:                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)
        -:  415:                    != TIMEOUT_MSG_SIZE)
    #####:  416:                    perror("Failed to write timeout to notify pipe");
        -:  417:            } else {
    #####:  418:                if (c->last_cmd_time < oldest_last_cmd)
    #####:  419:                    oldest_last_cmd = c->last_cmd_time;
        -:  420:            }
        -:  421:        }
        -:  422:
        -:  423:        /* This is the soonest we could have another connection time out */
    #####:  424:        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;
    #####:  425:        if (sleep_time <= 0)
    #####:  426:            sleep_time = 1;
        -:  427:
    #####:  428:        if (settings.verbose > 2)
    #####:  429:            fprintf(stderr,
        -:  430:                    "idle timeout thread finished pass, sleeping for %ds\n",
        -:  431:                    sleep_time);
    #####:  432:        usleep((useconds_t) sleep_time * 1000000);
        -:  433:    }
        -:  434:
        -:  435:    return NULL;
        -:  436:}
------------------
conn_timeout_thread:
    #####:  378:static void *conn_timeout_thread(void *arg) {
    #####:  379:    int i;
    #####:  380:    conn *c;
    #####:  381:    char buf[TIMEOUT_MSG_SIZE];
    #####:  382:    rel_time_t oldest_last_cmd;
    #####:  383:    int sleep_time;
    #####:  384:    useconds_t timeslice = 1000000 / (max_fds / CONNS_PER_SLICE);
        -:  385:
    #####:  386:    while(1) {
    #####:  387:        if (settings.verbose > 2)
    #####:  388:            fprintf(stderr, "idle timeout thread at top of connection list\n");
        -:  389:
    #####:  390:        oldest_last_cmd = current_time;
        -:  391:
    #####:  392:        for (i = 0; i < max_fds; i++) {
    #####:  393:            if ((i % CONNS_PER_SLICE) == 0) {
    #####:  394:                if (settings.verbose > 2)
    #####:  395:                    fprintf(stderr, "idle timeout thread sleeping for %ulus\n",
        -:  396:                        (unsigned int)timeslice);
    #####:  397:                usleep(timeslice);
        -:  398:            }
        -:  399:
    #####:  400:            if (!conns[i])
        -:  401:                continue;
        -:  402:
    #####:  403:            c = conns[i];
        -:  404:
    #####:  405:            if (!IS_TCP(c->transport))
        -:  406:                continue;
        -:  407:
    #####:  408:            if (c->state != conn_new_cmd && c->state != conn_read)
        -:  409:                continue;
        -:  410:
    #####:  411:            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  412:                buf[0] = 't';
    #####:  413:                memcpy(&buf[1], &i, sizeof(int));
    #####:  414:                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)
        -:  415:                    != TIMEOUT_MSG_SIZE)
    #####:  416:                    perror("Failed to write timeout to notify pipe");
        -:  417:            } else {
    #####:  418:                if (c->last_cmd_time < oldest_last_cmd)
    #####:  419:                    oldest_last_cmd = c->last_cmd_time;
        -:  420:            }
        -:  421:        }
        -:  422:
        -:  423:        /* This is the soonest we could have another connection time out */
    #####:  424:        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;
    #####:  425:        if (sleep_time <= 0)
    #####:  426:            sleep_time = 1;
        -:  427:
    #####:  428:        if (settings.verbose > 2)
    #####:  429:            fprintf(stderr,
        -:  430:                    "idle timeout thread finished pass, sleeping for %ds\n",
        -:  431:                    sleep_time);
    #####:  432:        usleep((useconds_t) sleep_time * 1000000);
        -:  433:    }
        -:  434:
        -:  435:    return NULL;
        -:  436:}
------------------
        -:  437:
    #####:  438:static int start_conn_timeout_thread() {
    #####:  439:    int ret;
        -:  440:
    #####:  441:    if (settings.idle_timeout == 0)
        -:  442:        return -1;
        -:  443:
    #####:  444:    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        -:  445:        conn_timeout_thread, NULL)) != 0) {
    #####:  446:        fprintf(stderr, "Can't create idle connection timeout thread: %s\n",
        -:  447:            strerror(ret));
    #####:  448:        return -1;
        -:  449:    }
        -:  450:
        -:  451:    return 0;
        -:  452:}
------------------
start_conn_timeout_thread:
    #####:  438:static int start_conn_timeout_thread() {
    #####:  439:    int ret;
        -:  440:
    #####:  441:    if (settings.idle_timeout == 0)
        -:  442:        return -1;
        -:  443:
    #####:  444:    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        -:  445:        conn_timeout_thread, NULL)) != 0) {
    #####:  446:        fprintf(stderr, "Can't create idle connection timeout thread: %s\n",
        -:  447:            strerror(ret));
    #####:  448:        return -1;
        -:  449:    }
        -:  450:
        -:  451:    return 0;
        -:  452:}
------------------
start_conn_timeout_thread:
    #####:  438:static int start_conn_timeout_thread() {
    #####:  439:    int ret;
        -:  440:
    #####:  441:    if (settings.idle_timeout == 0)
        -:  442:        return -1;
        -:  443:
    #####:  444:    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        -:  445:        conn_timeout_thread, NULL)) != 0) {
    #####:  446:        fprintf(stderr, "Can't create idle connection timeout thread: %s\n",
        -:  447:            strerror(ret));
    #####:  448:        return -1;
        -:  449:    }
        -:  450:
        -:  451:    return 0;
        -:  452:}
------------------
start_conn_timeout_thread:
    #####:  438:static int start_conn_timeout_thread() {
    #####:  439:    int ret;
        -:  440:
    #####:  441:    if (settings.idle_timeout == 0)
        -:  442:        return -1;
        -:  443:
    #####:  444:    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        -:  445:        conn_timeout_thread, NULL)) != 0) {
    #####:  446:        fprintf(stderr, "Can't create idle connection timeout thread: %s\n",
        -:  447:            strerror(ret));
    #####:  448:        return -1;
        -:  449:    }
        -:  450:
        -:  451:    return 0;
        -:  452:}
------------------
        -:  453:
        -:  454:/*
        -:  455: * Initializes the connections array. We don't actually allocate connection
        -:  456: * structures until they're needed, so as to avoid wasting memory when the
        -:  457: * maximum connection count is much higher than the actual number of
        -:  458: * connections.
        -:  459: *
        -:  460: * This does end up wasting a few pointers' worth of memory for FDs that are
        -:  461: * used for things other than connections, but that's worth it in exchange for
        -:  462: * being able to directly index the conns array by FD.
        -:  463: */
        3:  464:static void conn_init(void) {
        -:  465:    /* We're unlikely to see an FD much higher than maxconns. */
        3:  466:    int next_fd = dup(1);
        3:  467:    int headroom = 10;      /* account for extra unexpected open FDs */
        3:  468:    struct rlimit rl;
        -:  469:
        3:  470:    max_fds = settings.maxconns + headroom + next_fd;
        -:  471:
        -:  472:    /* But if possible, get the actual highest FD we can possibly ever see. */
        3:  473:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        3:  474:        max_fds = rl.rlim_max;
        -:  475:    } else {
    #####:  476:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  477:                        "falling back to maxconns\n");
        -:  478:    }
        -:  479:
        3:  480:    close(next_fd);
        -:  481:
        3:  482:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  483:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  484:        /* This is unrecoverable so bail out early. */
    #####:  485:        exit(1);
        -:  486:    }
        3:  487:}
------------------
conn_init:
        1:  464:static void conn_init(void) {
        -:  465:    /* We're unlikely to see an FD much higher than maxconns. */
        1:  466:    int next_fd = dup(1);
        1:  467:    int headroom = 10;      /* account for extra unexpected open FDs */
        1:  468:    struct rlimit rl;
        -:  469:
        1:  470:    max_fds = settings.maxconns + headroom + next_fd;
        -:  471:
        -:  472:    /* But if possible, get the actual highest FD we can possibly ever see. */
        1:  473:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        1:  474:        max_fds = rl.rlim_max;
        -:  475:    } else {
    #####:  476:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  477:                        "falling back to maxconns\n");
        -:  478:    }
        -:  479:
        1:  480:    close(next_fd);
        -:  481:
        1:  482:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  483:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  484:        /* This is unrecoverable so bail out early. */
    #####:  485:        exit(1);
        -:  486:    }
        1:  487:}
------------------
conn_init:
        1:  464:static void conn_init(void) {
        -:  465:    /* We're unlikely to see an FD much higher than maxconns. */
        1:  466:    int next_fd = dup(1);
        1:  467:    int headroom = 10;      /* account for extra unexpected open FDs */
        1:  468:    struct rlimit rl;
        -:  469:
        1:  470:    max_fds = settings.maxconns + headroom + next_fd;
        -:  471:
        -:  472:    /* But if possible, get the actual highest FD we can possibly ever see. */
        1:  473:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        1:  474:        max_fds = rl.rlim_max;
        -:  475:    } else {
    #####:  476:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  477:                        "falling back to maxconns\n");
        -:  478:    }
        -:  479:
        1:  480:    close(next_fd);
        -:  481:
        1:  482:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  483:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  484:        /* This is unrecoverable so bail out early. */
    #####:  485:        exit(1);
        -:  486:    }
        1:  487:}
------------------
conn_init:
        1:  464:static void conn_init(void) {
        -:  465:    /* We're unlikely to see an FD much higher than maxconns. */
        1:  466:    int next_fd = dup(1);
        1:  467:    int headroom = 10;      /* account for extra unexpected open FDs */
        1:  468:    struct rlimit rl;
        -:  469:
        1:  470:    max_fds = settings.maxconns + headroom + next_fd;
        -:  471:
        -:  472:    /* But if possible, get the actual highest FD we can possibly ever see. */
        1:  473:    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        1:  474:        max_fds = rl.rlim_max;
        -:  475:    } else {
    #####:  476:        fprintf(stderr, "Failed to query maximum file descriptor; "
        -:  477:                        "falling back to maxconns\n");
        -:  478:    }
        -:  479:
        1:  480:    close(next_fd);
        -:  481:
        1:  482:    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
    #####:  483:        fprintf(stderr, "Failed to allocate connection structures\n");
        -:  484:        /* This is unrecoverable so bail out early. */
    #####:  485:        exit(1);
        -:  486:    }
        1:  487:}
------------------
        -:  488:
        -:  489:static const char *prot_text(enum protocol prot) {
    #####:  490:    char *rv = "unknown";
    #####:  491:    switch(prot) {
    #####:  492:        case ascii_prot:
    #####:  493:            rv = "ascii";
    #####:  494:            break;
    #####:  495:        case binary_prot:
    #####:  496:            rv = "binary";
    #####:  497:            break;
    #####:  498:        case negotiating_prot:
    #####:  499:            rv = "auto-negotiate";
    #####:  500:            break;
        -:  501:    }
    #####:  502:    return rv;
        -:  503:}
        -:  504:
    #####:  505:void conn_close_idle(conn *c) {
    #####:  506:    if (settings.idle_timeout > 0 &&
    #####:  507:        (current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  508:        if (c->state != conn_new_cmd && c->state != conn_read) {
    #####:  509:            if (settings.verbose > 1)
    #####:  510:                fprintf(stderr,
        -:  511:                    "fd %d wants to timeout, but isn't in read state", c->sfd);
    #####:  512:            return;
        -:  513:        }
        -:  514:
    #####:  515:        if (settings.verbose > 1)
    #####:  516:            fprintf(stderr, "Closing idle fd %d\n", c->sfd);
        -:  517:
    #####:  518:        c->thread->stats.idle_kicks++;
        -:  519:
    #####:  520:        conn_set_state(c, conn_closing);
    #####:  521:        drive_machine(c);
        -:  522:    }
        -:  523:}
------------------
conn_close_idle:
    #####:  505:void conn_close_idle(conn *c) {
    #####:  506:    if (settings.idle_timeout > 0 &&
    #####:  507:        (current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  508:        if (c->state != conn_new_cmd && c->state != conn_read) {
    #####:  509:            if (settings.verbose > 1)
    #####:  510:                fprintf(stderr,
        -:  511:                    "fd %d wants to timeout, but isn't in read state", c->sfd);
    #####:  512:            return;
        -:  513:        }
        -:  514:
    #####:  515:        if (settings.verbose > 1)
    #####:  516:            fprintf(stderr, "Closing idle fd %d\n", c->sfd);
        -:  517:
    #####:  518:        c->thread->stats.idle_kicks++;
        -:  519:
    #####:  520:        conn_set_state(c, conn_closing);
    #####:  521:        drive_machine(c);
        -:  522:    }
        -:  523:}
------------------
conn_close_idle:
    #####:  505:void conn_close_idle(conn *c) {
    #####:  506:    if (settings.idle_timeout > 0 &&
    #####:  507:        (current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  508:        if (c->state != conn_new_cmd && c->state != conn_read) {
    #####:  509:            if (settings.verbose > 1)
    #####:  510:                fprintf(stderr,
        -:  511:                    "fd %d wants to timeout, but isn't in read state", c->sfd);
    #####:  512:            return;
        -:  513:        }
        -:  514:
    #####:  515:        if (settings.verbose > 1)
    #####:  516:            fprintf(stderr, "Closing idle fd %d\n", c->sfd);
        -:  517:
    #####:  518:        c->thread->stats.idle_kicks++;
        -:  519:
    #####:  520:        conn_set_state(c, conn_closing);
    #####:  521:        drive_machine(c);
        -:  522:    }
        -:  523:}
------------------
conn_close_idle:
    #####:  505:void conn_close_idle(conn *c) {
    #####:  506:    if (settings.idle_timeout > 0 &&
    #####:  507:        (current_time - c->last_cmd_time) > settings.idle_timeout) {
    #####:  508:        if (c->state != conn_new_cmd && c->state != conn_read) {
    #####:  509:            if (settings.verbose > 1)
    #####:  510:                fprintf(stderr,
        -:  511:                    "fd %d wants to timeout, but isn't in read state", c->sfd);
    #####:  512:            return;
        -:  513:        }
        -:  514:
    #####:  515:        if (settings.verbose > 1)
    #####:  516:            fprintf(stderr, "Closing idle fd %d\n", c->sfd);
        -:  517:
    #####:  518:        c->thread->stats.idle_kicks++;
        -:  519:
    #####:  520:        conn_set_state(c, conn_closing);
    #####:  521:        drive_machine(c);
        -:  522:    }
        -:  523:}
------------------
        -:  524:
        -:  525:/* bring conn back from a sidethread. could have had its event base moved. */
    #####:  526:void conn_worker_readd(conn *c) {
    #####:  527:    c->ev_flags = EV_READ | EV_PERSIST;
    #####:  528:    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    #####:  529:    event_base_set(c->thread->base, &c->event);
    #####:  530:    c->state = conn_new_cmd;
        -:  531:
        -:  532:    // TODO: call conn_cleanup/fail/etc
    #####:  533:    if (event_add(&c->event, 0) == -1) {
    #####:  534:        perror("event_add");
        -:  535:    }
        -:  536:#ifdef EXTSTORE
        -:  537:    // If we had IO objects, process
        -:  538:    if (c->io_wraplist) {
        -:  539:        //assert(c->io_wrapleft == 0); // assert no more to process
        -:  540:        conn_set_state(c, conn_mwrite);
        -:  541:        drive_machine(c);
        -:  542:    }
        -:  543:#endif
    #####:  544:}
------------------
conn_worker_readd:
    #####:  526:void conn_worker_readd(conn *c) {
    #####:  527:    c->ev_flags = EV_READ | EV_PERSIST;
    #####:  528:    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    #####:  529:    event_base_set(c->thread->base, &c->event);
    #####:  530:    c->state = conn_new_cmd;
        -:  531:
        -:  532:    // TODO: call conn_cleanup/fail/etc
    #####:  533:    if (event_add(&c->event, 0) == -1) {
    #####:  534:        perror("event_add");
        -:  535:    }
        -:  536:#ifdef EXTSTORE
        -:  537:    // If we had IO objects, process
        -:  538:    if (c->io_wraplist) {
        -:  539:        //assert(c->io_wrapleft == 0); // assert no more to process
        -:  540:        conn_set_state(c, conn_mwrite);
        -:  541:        drive_machine(c);
        -:  542:    }
        -:  543:#endif
    #####:  544:}
------------------
conn_worker_readd:
    #####:  526:void conn_worker_readd(conn *c) {
    #####:  527:    c->ev_flags = EV_READ | EV_PERSIST;
    #####:  528:    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    #####:  529:    event_base_set(c->thread->base, &c->event);
    #####:  530:    c->state = conn_new_cmd;
        -:  531:
        -:  532:    // TODO: call conn_cleanup/fail/etc
    #####:  533:    if (event_add(&c->event, 0) == -1) {
    #####:  534:        perror("event_add");
        -:  535:    }
        -:  536:#ifdef EXTSTORE
        -:  537:    // If we had IO objects, process
        -:  538:    if (c->io_wraplist) {
        -:  539:        //assert(c->io_wrapleft == 0); // assert no more to process
        -:  540:        conn_set_state(c, conn_mwrite);
        -:  541:        drive_machine(c);
        -:  542:    }
        -:  543:#endif
    #####:  544:}
------------------
conn_worker_readd:
    #####:  526:void conn_worker_readd(conn *c) {
    #####:  527:    c->ev_flags = EV_READ | EV_PERSIST;
    #####:  528:    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    #####:  529:    event_base_set(c->thread->base, &c->event);
    #####:  530:    c->state = conn_new_cmd;
        -:  531:
        -:  532:    // TODO: call conn_cleanup/fail/etc
    #####:  533:    if (event_add(&c->event, 0) == -1) {
    #####:  534:        perror("event_add");
        -:  535:    }
        -:  536:#ifdef EXTSTORE
        -:  537:    // If we had IO objects, process
        -:  538:    if (c->io_wraplist) {
        -:  539:        //assert(c->io_wrapleft == 0); // assert no more to process
        -:  540:        conn_set_state(c, conn_mwrite);
        -:  541:        drive_machine(c);
        -:  542:    }
        -:  543:#endif
    #####:  544:}
------------------
        -:  545:
      606:  546:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  547:                const int event_flags,
        -:  548:                const int read_buffer_size, enum network_transport transport,
        -:  549:                struct event_base *base, void *ssl) {
      606:  550:    conn *c;
        -:  551:
     606*:  552:    assert(sfd >= 0 && sfd < max_fds);
      606:  553:    c = conns[sfd];
        -:  554:
      606:  555:    if (NULL == c) {
      606:  556:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  557:            STATS_LOCK();
    #####:  558:            stats.malloc_fails++;
    #####:  559:            STATS_UNLOCK();
    #####:  560:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  561:            return NULL;
        -:  562:        }
      606:  563:        MEMCACHED_CONN_CREATE(c);
      606:  564:        c->read = NULL;
      606:  565:        c->sendmsg = NULL;
      606:  566:        c->write = NULL;
      606:  567:        c->rbuf = c->wbuf = 0;
      606:  568:        c->ilist = 0;
      606:  569:        c->suffixlist = 0;
      606:  570:        c->iov = 0;
      606:  571:        c->msglist = 0;
      606:  572:        c->hdrbuf = 0;
        -:  573:
      606:  574:        c->rsize = read_buffer_size;
      606:  575:        c->wsize = DATA_BUFFER_SIZE;
      606:  576:        c->isize = ITEM_LIST_INITIAL;
      606:  577:        c->suffixsize = SUFFIX_LIST_INITIAL;
      606:  578:        c->iovsize = IOV_LIST_INITIAL;
      606:  579:        c->msgsize = MSG_LIST_INITIAL;
      606:  580:        c->hdrsize = 0;
        -:  581:
      606:  582:        c->rbuf = (char *)malloc((size_t)c->rsize);
      606:  583:        c->wbuf = (char *)malloc((size_t)c->wsize);
      606:  584:        c->ilist = (item **)malloc(sizeof(item *) * c->isize);
      606:  585:        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
      606:  586:        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
      606:  587:        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);
        -:  588:
      606:  589:        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
      606:  590:                c->msglist == 0 || c->suffixlist == 0) {
    #####:  591:            conn_free(c);
    #####:  592:            STATS_LOCK();
    #####:  593:            stats.malloc_fails++;
    #####:  594:            STATS_UNLOCK();
    #####:  595:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  596:            return NULL;
        -:  597:        }
        -:  598:
      606:  599:        STATS_LOCK();
      606:  600:        stats_state.conn_structs++;
      606:  601:        STATS_UNLOCK();
        -:  602:
      606:  603:        c->sfd = sfd;
      606:  604:        conns[sfd] = c;
        -:  605:    }
        -:  606:
      606:  607:    c->transport = transport;
      606:  608:    c->protocol = settings.binding_protocol;
        -:  609:
        -:  610:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  611:     * is this done for every command?  presumably for UDP
        -:  612:     * mode.  */
      606:  613:    if (!settings.socketpath) {
      606:  614:        c->request_addr_size = sizeof(c->request_addr);
        -:  615:    } else {
    #####:  616:        c->request_addr_size = 0;
        -:  617:    }
        -:  618:
      606:  619:    if (transport == tcp_transport && init_state == conn_new_cmd) {
      600:  620:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  621:                        &c->request_addr_size)) {
    #####:  622:            perror("getpeername");
    #####:  623:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  624:        }
        -:  625:    }
        -:  626:
      606:  627:    if (settings.verbose > 1) {
    #####:  628:        if (init_state == conn_listening) {
    #####:  629:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  630:                prot_text(c->protocol));
    #####:  631:        } else if (IS_UDP(transport)) {
    #####:  632:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
    #####:  633:        } else if (c->protocol == negotiating_prot) {
    #####:  634:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  635:                    sfd);
    #####:  636:        } else if (c->protocol == ascii_prot) {
    #####:  637:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
    #####:  638:        } else if (c->protocol == binary_prot) {
    #####:  639:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  640:        } else {
    #####:  641:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  642:                sfd, c->protocol);
    #####:  643:            assert(false);
        -:  644:        }
        -:  645:    }
        -:  646:
        -:  647:#ifdef TLS
        -:  648:    c->ssl = NULL;
        -:  649:    c->ssl_wbuf = NULL;
        -:  650:    c->ssl_enabled = false;
        -:  651:#endif
      606:  652:    c->state = init_state;
      606:  653:    c->rlbytes = 0;
      606:  654:    c->cmd = -1;
      606:  655:    c->rbytes = c->wbytes = 0;
      606:  656:    c->wcurr = c->wbuf;
      606:  657:    c->rcurr = c->rbuf;
      606:  658:    c->ritem = 0;
      606:  659:    c->icurr = c->ilist;
      606:  660:    c->suffixcurr = c->suffixlist;
      606:  661:    c->ileft = 0;
      606:  662:    c->suffixleft = 0;
      606:  663:    c->iovused = 0;
      606:  664:    c->msgcurr = 0;
      606:  665:    c->msgused = 0;
      606:  666:    c->sasl_started = false;
      606:  667:    c->last_cmd_time = current_time; /* initialize for idle kicker */
        -:  668:#ifdef EXTSTORE
        -:  669:    c->io_wraplist = NULL;
        -:  670:    c->io_wrapleft = 0;
        -:  671:#endif
        -:  672:
      606:  673:    c->write_and_go = init_state;
      606:  674:    c->write_and_free = 0;
      606:  675:    c->item = 0;
        -:  676:
      606:  677:    c->noreply = false;
        -:  678:
        -:  679:#ifdef TLS
        -:  680:    if (ssl) {
        -:  681:        c->ssl = (SSL*)ssl;
        -:  682:        c->read = ssl_read;
        -:  683:        c->sendmsg = ssl_sendmsg;
        -:  684:        c->write = ssl_write;
        -:  685:        c->ssl_enabled = true;
        -:  686:        SSL_set_info_callback(c->ssl, ssl_callback);
        -:  687:    } else
        -:  688:#else
        -:  689:    // This must be NULL if TLS is not enabled.
     606*:  690:    assert(ssl == NULL);
        -:  691:#endif
        -:  692:    {
      606:  693:        c->read = tcp_read;
      606:  694:        c->sendmsg = tcp_sendmsg;
      606:  695:        c->write = tcp_write;
        -:  696:    }
        -:  697:
      606:  698:    if (IS_UDP(transport)) {
    #####:  699:        c->try_read_command = try_read_command_udp;
        -:  700:    } else {
      606:  701:        switch (c->protocol) {
    #####:  702:            case ascii_prot:
    #####:  703:                if (settings.auth_file == NULL) {
    #####:  704:                    c->authenticated = true;
    #####:  705:                    c->try_read_command = try_read_command_ascii;
        -:  706:                } else {
    #####:  707:                    c->authenticated = false;
    #####:  708:                    c->try_read_command = try_read_command_asciiauth;
        -:  709:                }
        -:  710:                break;
    #####:  711:            case binary_prot:
        -:  712:                // binprot handles its own authentication via SASL parsing.
    #####:  713:                c->authenticated = false;
    #####:  714:                c->try_read_command = try_read_command_binary;
    #####:  715:                break;
      606:  716:            case negotiating_prot:
      606:  717:                c->try_read_command = try_read_command_negotiate;
      606:  718:                break;
        -:  719:        }
      606:  720:    }
        -:  721:
      606:  722:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
      606:  723:    event_base_set(base, &c->event);
      606:  724:    c->ev_flags = event_flags;
        -:  725:
      606:  726:    if (event_add(&c->event, 0) == -1) {
    #####:  727:        perror("event_add");
    #####:  728:        return NULL;
        -:  729:    }
        -:  730:
      606:  731:    STATS_LOCK();
      606:  732:    stats_state.curr_conns++;
      606:  733:    stats.total_conns++;
      606:  734:    STATS_UNLOCK();
        -:  735:
      606:  736:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  737:
      606:  738:    return c;
        -:  739:}
------------------
conn_new:
      202:  546:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  547:                const int event_flags,
        -:  548:                const int read_buffer_size, enum network_transport transport,
        -:  549:                struct event_base *base, void *ssl) {
      202:  550:    conn *c;
        -:  551:
     202*:  552:    assert(sfd >= 0 && sfd < max_fds);
      202:  553:    c = conns[sfd];
        -:  554:
      202:  555:    if (NULL == c) {
      202:  556:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  557:            STATS_LOCK();
    #####:  558:            stats.malloc_fails++;
    #####:  559:            STATS_UNLOCK();
    #####:  560:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  561:            return NULL;
        -:  562:        }
      202:  563:        MEMCACHED_CONN_CREATE(c);
      202:  564:        c->read = NULL;
      202:  565:        c->sendmsg = NULL;
      202:  566:        c->write = NULL;
      202:  567:        c->rbuf = c->wbuf = 0;
      202:  568:        c->ilist = 0;
      202:  569:        c->suffixlist = 0;
      202:  570:        c->iov = 0;
      202:  571:        c->msglist = 0;
      202:  572:        c->hdrbuf = 0;
        -:  573:
      202:  574:        c->rsize = read_buffer_size;
      202:  575:        c->wsize = DATA_BUFFER_SIZE;
      202:  576:        c->isize = ITEM_LIST_INITIAL;
      202:  577:        c->suffixsize = SUFFIX_LIST_INITIAL;
      202:  578:        c->iovsize = IOV_LIST_INITIAL;
      202:  579:        c->msgsize = MSG_LIST_INITIAL;
      202:  580:        c->hdrsize = 0;
        -:  581:
      202:  582:        c->rbuf = (char *)malloc((size_t)c->rsize);
      202:  583:        c->wbuf = (char *)malloc((size_t)c->wsize);
      202:  584:        c->ilist = (item **)malloc(sizeof(item *) * c->isize);
      202:  585:        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
      202:  586:        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
      202:  587:        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);
        -:  588:
      202:  589:        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
      202:  590:                c->msglist == 0 || c->suffixlist == 0) {
    #####:  591:            conn_free(c);
    #####:  592:            STATS_LOCK();
    #####:  593:            stats.malloc_fails++;
    #####:  594:            STATS_UNLOCK();
    #####:  595:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  596:            return NULL;
        -:  597:        }
        -:  598:
      202:  599:        STATS_LOCK();
      202:  600:        stats_state.conn_structs++;
      202:  601:        STATS_UNLOCK();
        -:  602:
      202:  603:        c->sfd = sfd;
      202:  604:        conns[sfd] = c;
        -:  605:    }
        -:  606:
      202:  607:    c->transport = transport;
      202:  608:    c->protocol = settings.binding_protocol;
        -:  609:
        -:  610:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  611:     * is this done for every command?  presumably for UDP
        -:  612:     * mode.  */
      202:  613:    if (!settings.socketpath) {
      202:  614:        c->request_addr_size = sizeof(c->request_addr);
        -:  615:    } else {
    #####:  616:        c->request_addr_size = 0;
        -:  617:    }
        -:  618:
      202:  619:    if (transport == tcp_transport && init_state == conn_new_cmd) {
      200:  620:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  621:                        &c->request_addr_size)) {
    #####:  622:            perror("getpeername");
    #####:  623:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  624:        }
        -:  625:    }
        -:  626:
      202:  627:    if (settings.verbose > 1) {
    #####:  628:        if (init_state == conn_listening) {
    #####:  629:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  630:                prot_text(c->protocol));
    #####:  631:        } else if (IS_UDP(transport)) {
    #####:  632:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
    #####:  633:        } else if (c->protocol == negotiating_prot) {
    #####:  634:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  635:                    sfd);
    #####:  636:        } else if (c->protocol == ascii_prot) {
    #####:  637:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
    #####:  638:        } else if (c->protocol == binary_prot) {
    #####:  639:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  640:        } else {
    #####:  641:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  642:                sfd, c->protocol);
    #####:  643:            assert(false);
        -:  644:        }
        -:  645:    }
        -:  646:
        -:  647:#ifdef TLS
        -:  648:    c->ssl = NULL;
        -:  649:    c->ssl_wbuf = NULL;
        -:  650:    c->ssl_enabled = false;
        -:  651:#endif
      202:  652:    c->state = init_state;
      202:  653:    c->rlbytes = 0;
      202:  654:    c->cmd = -1;
      202:  655:    c->rbytes = c->wbytes = 0;
      202:  656:    c->wcurr = c->wbuf;
      202:  657:    c->rcurr = c->rbuf;
      202:  658:    c->ritem = 0;
      202:  659:    c->icurr = c->ilist;
      202:  660:    c->suffixcurr = c->suffixlist;
      202:  661:    c->ileft = 0;
      202:  662:    c->suffixleft = 0;
      202:  663:    c->iovused = 0;
      202:  664:    c->msgcurr = 0;
      202:  665:    c->msgused = 0;
      202:  666:    c->sasl_started = false;
      202:  667:    c->last_cmd_time = current_time; /* initialize for idle kicker */
        -:  668:#ifdef EXTSTORE
        -:  669:    c->io_wraplist = NULL;
        -:  670:    c->io_wrapleft = 0;
        -:  671:#endif
        -:  672:
      202:  673:    c->write_and_go = init_state;
      202:  674:    c->write_and_free = 0;
      202:  675:    c->item = 0;
        -:  676:
      202:  677:    c->noreply = false;
        -:  678:
        -:  679:#ifdef TLS
        -:  680:    if (ssl) {
        -:  681:        c->ssl = (SSL*)ssl;
        -:  682:        c->read = ssl_read;
        -:  683:        c->sendmsg = ssl_sendmsg;
        -:  684:        c->write = ssl_write;
        -:  685:        c->ssl_enabled = true;
        -:  686:        SSL_set_info_callback(c->ssl, ssl_callback);
        -:  687:    } else
        -:  688:#else
        -:  689:    // This must be NULL if TLS is not enabled.
     202*:  690:    assert(ssl == NULL);
        -:  691:#endif
        -:  692:    {
      202:  693:        c->read = tcp_read;
      202:  694:        c->sendmsg = tcp_sendmsg;
      202:  695:        c->write = tcp_write;
        -:  696:    }
        -:  697:
      202:  698:    if (IS_UDP(transport)) {
    #####:  699:        c->try_read_command = try_read_command_udp;
        -:  700:    } else {
      202:  701:        switch (c->protocol) {
    #####:  702:            case ascii_prot:
    #####:  703:                if (settings.auth_file == NULL) {
    #####:  704:                    c->authenticated = true;
    #####:  705:                    c->try_read_command = try_read_command_ascii;
        -:  706:                } else {
    #####:  707:                    c->authenticated = false;
    #####:  708:                    c->try_read_command = try_read_command_asciiauth;
        -:  709:                }
        -:  710:                break;
    #####:  711:            case binary_prot:
        -:  712:                // binprot handles its own authentication via SASL parsing.
    #####:  713:                c->authenticated = false;
    #####:  714:                c->try_read_command = try_read_command_binary;
    #####:  715:                break;
      202:  716:            case negotiating_prot:
      202:  717:                c->try_read_command = try_read_command_negotiate;
      202:  718:                break;
        -:  719:        }
      202:  720:    }
        -:  721:
      202:  722:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
      202:  723:    event_base_set(base, &c->event);
      202:  724:    c->ev_flags = event_flags;
        -:  725:
      202:  726:    if (event_add(&c->event, 0) == -1) {
    #####:  727:        perror("event_add");
    #####:  728:        return NULL;
        -:  729:    }
        -:  730:
      202:  731:    STATS_LOCK();
      202:  732:    stats_state.curr_conns++;
      202:  733:    stats.total_conns++;
      202:  734:    STATS_UNLOCK();
        -:  735:
      202:  736:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  737:
      202:  738:    return c;
        -:  739:}
------------------
conn_new:
      202:  546:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  547:                const int event_flags,
        -:  548:                const int read_buffer_size, enum network_transport transport,
        -:  549:                struct event_base *base, void *ssl) {
      202:  550:    conn *c;
        -:  551:
     202*:  552:    assert(sfd >= 0 && sfd < max_fds);
      202:  553:    c = conns[sfd];
        -:  554:
      202:  555:    if (NULL == c) {
      202:  556:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  557:            STATS_LOCK();
    #####:  558:            stats.malloc_fails++;
    #####:  559:            STATS_UNLOCK();
    #####:  560:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  561:            return NULL;
        -:  562:        }
      202:  563:        MEMCACHED_CONN_CREATE(c);
      202:  564:        c->read = NULL;
      202:  565:        c->sendmsg = NULL;
      202:  566:        c->write = NULL;
      202:  567:        c->rbuf = c->wbuf = 0;
      202:  568:        c->ilist = 0;
      202:  569:        c->suffixlist = 0;
      202:  570:        c->iov = 0;
      202:  571:        c->msglist = 0;
      202:  572:        c->hdrbuf = 0;
        -:  573:
      202:  574:        c->rsize = read_buffer_size;
      202:  575:        c->wsize = DATA_BUFFER_SIZE;
      202:  576:        c->isize = ITEM_LIST_INITIAL;
      202:  577:        c->suffixsize = SUFFIX_LIST_INITIAL;
      202:  578:        c->iovsize = IOV_LIST_INITIAL;
      202:  579:        c->msgsize = MSG_LIST_INITIAL;
      202:  580:        c->hdrsize = 0;
        -:  581:
      202:  582:        c->rbuf = (char *)malloc((size_t)c->rsize);
      202:  583:        c->wbuf = (char *)malloc((size_t)c->wsize);
      202:  584:        c->ilist = (item **)malloc(sizeof(item *) * c->isize);
      202:  585:        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
      202:  586:        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
      202:  587:        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);
        -:  588:
      202:  589:        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
      202:  590:                c->msglist == 0 || c->suffixlist == 0) {
    #####:  591:            conn_free(c);
    #####:  592:            STATS_LOCK();
    #####:  593:            stats.malloc_fails++;
    #####:  594:            STATS_UNLOCK();
    #####:  595:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  596:            return NULL;
        -:  597:        }
        -:  598:
      202:  599:        STATS_LOCK();
      202:  600:        stats_state.conn_structs++;
      202:  601:        STATS_UNLOCK();
        -:  602:
      202:  603:        c->sfd = sfd;
      202:  604:        conns[sfd] = c;
        -:  605:    }
        -:  606:
      202:  607:    c->transport = transport;
      202:  608:    c->protocol = settings.binding_protocol;
        -:  609:
        -:  610:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  611:     * is this done for every command?  presumably for UDP
        -:  612:     * mode.  */
      202:  613:    if (!settings.socketpath) {
      202:  614:        c->request_addr_size = sizeof(c->request_addr);
        -:  615:    } else {
    #####:  616:        c->request_addr_size = 0;
        -:  617:    }
        -:  618:
      202:  619:    if (transport == tcp_transport && init_state == conn_new_cmd) {
      200:  620:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  621:                        &c->request_addr_size)) {
    #####:  622:            perror("getpeername");
    #####:  623:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  624:        }
        -:  625:    }
        -:  626:
      202:  627:    if (settings.verbose > 1) {
    #####:  628:        if (init_state == conn_listening) {
    #####:  629:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  630:                prot_text(c->protocol));
    #####:  631:        } else if (IS_UDP(transport)) {
    #####:  632:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
    #####:  633:        } else if (c->protocol == negotiating_prot) {
    #####:  634:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  635:                    sfd);
    #####:  636:        } else if (c->protocol == ascii_prot) {
    #####:  637:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
    #####:  638:        } else if (c->protocol == binary_prot) {
    #####:  639:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  640:        } else {
    #####:  641:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  642:                sfd, c->protocol);
    #####:  643:            assert(false);
        -:  644:        }
        -:  645:    }
        -:  646:
        -:  647:#ifdef TLS
        -:  648:    c->ssl = NULL;
        -:  649:    c->ssl_wbuf = NULL;
        -:  650:    c->ssl_enabled = false;
        -:  651:#endif
      202:  652:    c->state = init_state;
      202:  653:    c->rlbytes = 0;
      202:  654:    c->cmd = -1;
      202:  655:    c->rbytes = c->wbytes = 0;
      202:  656:    c->wcurr = c->wbuf;
      202:  657:    c->rcurr = c->rbuf;
      202:  658:    c->ritem = 0;
      202:  659:    c->icurr = c->ilist;
      202:  660:    c->suffixcurr = c->suffixlist;
      202:  661:    c->ileft = 0;
      202:  662:    c->suffixleft = 0;
      202:  663:    c->iovused = 0;
      202:  664:    c->msgcurr = 0;
      202:  665:    c->msgused = 0;
      202:  666:    c->sasl_started = false;
      202:  667:    c->last_cmd_time = current_time; /* initialize for idle kicker */
        -:  668:#ifdef EXTSTORE
        -:  669:    c->io_wraplist = NULL;
        -:  670:    c->io_wrapleft = 0;
        -:  671:#endif
        -:  672:
      202:  673:    c->write_and_go = init_state;
      202:  674:    c->write_and_free = 0;
      202:  675:    c->item = 0;
        -:  676:
      202:  677:    c->noreply = false;
        -:  678:
        -:  679:#ifdef TLS
        -:  680:    if (ssl) {
        -:  681:        c->ssl = (SSL*)ssl;
        -:  682:        c->read = ssl_read;
        -:  683:        c->sendmsg = ssl_sendmsg;
        -:  684:        c->write = ssl_write;
        -:  685:        c->ssl_enabled = true;
        -:  686:        SSL_set_info_callback(c->ssl, ssl_callback);
        -:  687:    } else
        -:  688:#else
        -:  689:    // This must be NULL if TLS is not enabled.
     202*:  690:    assert(ssl == NULL);
        -:  691:#endif
        -:  692:    {
      202:  693:        c->read = tcp_read;
      202:  694:        c->sendmsg = tcp_sendmsg;
      202:  695:        c->write = tcp_write;
        -:  696:    }
        -:  697:
      202:  698:    if (IS_UDP(transport)) {
    #####:  699:        c->try_read_command = try_read_command_udp;
        -:  700:    } else {
      202:  701:        switch (c->protocol) {
    #####:  702:            case ascii_prot:
    #####:  703:                if (settings.auth_file == NULL) {
    #####:  704:                    c->authenticated = true;
    #####:  705:                    c->try_read_command = try_read_command_ascii;
        -:  706:                } else {
    #####:  707:                    c->authenticated = false;
    #####:  708:                    c->try_read_command = try_read_command_asciiauth;
        -:  709:                }
        -:  710:                break;
    #####:  711:            case binary_prot:
        -:  712:                // binprot handles its own authentication via SASL parsing.
    #####:  713:                c->authenticated = false;
    #####:  714:                c->try_read_command = try_read_command_binary;
    #####:  715:                break;
      202:  716:            case negotiating_prot:
      202:  717:                c->try_read_command = try_read_command_negotiate;
      202:  718:                break;
        -:  719:        }
      202:  720:    }
        -:  721:
      202:  722:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
      202:  723:    event_base_set(base, &c->event);
      202:  724:    c->ev_flags = event_flags;
        -:  725:
      202:  726:    if (event_add(&c->event, 0) == -1) {
    #####:  727:        perror("event_add");
    #####:  728:        return NULL;
        -:  729:    }
        -:  730:
      202:  731:    STATS_LOCK();
      202:  732:    stats_state.curr_conns++;
      202:  733:    stats.total_conns++;
      202:  734:    STATS_UNLOCK();
        -:  735:
      202:  736:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  737:
      202:  738:    return c;
        -:  739:}
------------------
conn_new:
      202:  546:conn *conn_new(const int sfd, enum conn_states init_state,
        -:  547:                const int event_flags,
        -:  548:                const int read_buffer_size, enum network_transport transport,
        -:  549:                struct event_base *base, void *ssl) {
      202:  550:    conn *c;
        -:  551:
     202*:  552:    assert(sfd >= 0 && sfd < max_fds);
      202:  553:    c = conns[sfd];
        -:  554:
      202:  555:    if (NULL == c) {
      202:  556:        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
    #####:  557:            STATS_LOCK();
    #####:  558:            stats.malloc_fails++;
    #####:  559:            STATS_UNLOCK();
    #####:  560:            fprintf(stderr, "Failed to allocate connection object\n");
    #####:  561:            return NULL;
        -:  562:        }
      202:  563:        MEMCACHED_CONN_CREATE(c);
      202:  564:        c->read = NULL;
      202:  565:        c->sendmsg = NULL;
      202:  566:        c->write = NULL;
      202:  567:        c->rbuf = c->wbuf = 0;
      202:  568:        c->ilist = 0;
      202:  569:        c->suffixlist = 0;
      202:  570:        c->iov = 0;
      202:  571:        c->msglist = 0;
      202:  572:        c->hdrbuf = 0;
        -:  573:
      202:  574:        c->rsize = read_buffer_size;
      202:  575:        c->wsize = DATA_BUFFER_SIZE;
      202:  576:        c->isize = ITEM_LIST_INITIAL;
      202:  577:        c->suffixsize = SUFFIX_LIST_INITIAL;
      202:  578:        c->iovsize = IOV_LIST_INITIAL;
      202:  579:        c->msgsize = MSG_LIST_INITIAL;
      202:  580:        c->hdrsize = 0;
        -:  581:
      202:  582:        c->rbuf = (char *)malloc((size_t)c->rsize);
      202:  583:        c->wbuf = (char *)malloc((size_t)c->wsize);
      202:  584:        c->ilist = (item **)malloc(sizeof(item *) * c->isize);
      202:  585:        c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize);
      202:  586:        c->iov = (struct iovec *)malloc(sizeof(struct iovec) * c->iovsize);
      202:  587:        c->msglist = (struct msghdr *)malloc(sizeof(struct msghdr) * c->msgsize);
        -:  588:
      202:  589:        if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
      202:  590:                c->msglist == 0 || c->suffixlist == 0) {
    #####:  591:            conn_free(c);
    #####:  592:            STATS_LOCK();
    #####:  593:            stats.malloc_fails++;
    #####:  594:            STATS_UNLOCK();
    #####:  595:            fprintf(stderr, "Failed to allocate buffers for connection\n");
    #####:  596:            return NULL;
        -:  597:        }
        -:  598:
      202:  599:        STATS_LOCK();
      202:  600:        stats_state.conn_structs++;
      202:  601:        STATS_UNLOCK();
        -:  602:
      202:  603:        c->sfd = sfd;
      202:  604:        conns[sfd] = c;
        -:  605:    }
        -:  606:
      202:  607:    c->transport = transport;
      202:  608:    c->protocol = settings.binding_protocol;
        -:  609:
        -:  610:    /* unix socket mode doesn't need this, so zeroed out.  but why
        -:  611:     * is this done for every command?  presumably for UDP
        -:  612:     * mode.  */
      202:  613:    if (!settings.socketpath) {
      202:  614:        c->request_addr_size = sizeof(c->request_addr);
        -:  615:    } else {
    #####:  616:        c->request_addr_size = 0;
        -:  617:    }
        -:  618:
      202:  619:    if (transport == tcp_transport && init_state == conn_new_cmd) {
      200:  620:        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
        -:  621:                        &c->request_addr_size)) {
    #####:  622:            perror("getpeername");
    #####:  623:            memset(&c->request_addr, 0, sizeof(c->request_addr));
        -:  624:        }
        -:  625:    }
        -:  626:
      202:  627:    if (settings.verbose > 1) {
    #####:  628:        if (init_state == conn_listening) {
    #####:  629:            fprintf(stderr, "<%d server listening (%s)\n", sfd,
        -:  630:                prot_text(c->protocol));
    #####:  631:        } else if (IS_UDP(transport)) {
    #####:  632:            fprintf(stderr, "<%d server listening (udp)\n", sfd);
    #####:  633:        } else if (c->protocol == negotiating_prot) {
    #####:  634:            fprintf(stderr, "<%d new auto-negotiating client connection\n",
        -:  635:                    sfd);
    #####:  636:        } else if (c->protocol == ascii_prot) {
    #####:  637:            fprintf(stderr, "<%d new ascii client connection.\n", sfd);
    #####:  638:        } else if (c->protocol == binary_prot) {
    #####:  639:            fprintf(stderr, "<%d new binary client connection.\n", sfd);
        -:  640:        } else {
    #####:  641:            fprintf(stderr, "<%d new unknown (%d) client connection\n",
        -:  642:                sfd, c->protocol);
    #####:  643:            assert(false);
        -:  644:        }
        -:  645:    }
        -:  646:
        -:  647:#ifdef TLS
        -:  648:    c->ssl = NULL;
        -:  649:    c->ssl_wbuf = NULL;
        -:  650:    c->ssl_enabled = false;
        -:  651:#endif
      202:  652:    c->state = init_state;
      202:  653:    c->rlbytes = 0;
      202:  654:    c->cmd = -1;
      202:  655:    c->rbytes = c->wbytes = 0;
      202:  656:    c->wcurr = c->wbuf;
      202:  657:    c->rcurr = c->rbuf;
      202:  658:    c->ritem = 0;
      202:  659:    c->icurr = c->ilist;
      202:  660:    c->suffixcurr = c->suffixlist;
      202:  661:    c->ileft = 0;
      202:  662:    c->suffixleft = 0;
      202:  663:    c->iovused = 0;
      202:  664:    c->msgcurr = 0;
      202:  665:    c->msgused = 0;
      202:  666:    c->sasl_started = false;
      202:  667:    c->last_cmd_time = current_time; /* initialize for idle kicker */
        -:  668:#ifdef EXTSTORE
        -:  669:    c->io_wraplist = NULL;
        -:  670:    c->io_wrapleft = 0;
        -:  671:#endif
        -:  672:
      202:  673:    c->write_and_go = init_state;
      202:  674:    c->write_and_free = 0;
      202:  675:    c->item = 0;
        -:  676:
      202:  677:    c->noreply = false;
        -:  678:
        -:  679:#ifdef TLS
        -:  680:    if (ssl) {
        -:  681:        c->ssl = (SSL*)ssl;
        -:  682:        c->read = ssl_read;
        -:  683:        c->sendmsg = ssl_sendmsg;
        -:  684:        c->write = ssl_write;
        -:  685:        c->ssl_enabled = true;
        -:  686:        SSL_set_info_callback(c->ssl, ssl_callback);
        -:  687:    } else
        -:  688:#else
        -:  689:    // This must be NULL if TLS is not enabled.
     202*:  690:    assert(ssl == NULL);
        -:  691:#endif
        -:  692:    {
      202:  693:        c->read = tcp_read;
      202:  694:        c->sendmsg = tcp_sendmsg;
      202:  695:        c->write = tcp_write;
        -:  696:    }
        -:  697:
      202:  698:    if (IS_UDP(transport)) {
    #####:  699:        c->try_read_command = try_read_command_udp;
        -:  700:    } else {
      202:  701:        switch (c->protocol) {
    #####:  702:            case ascii_prot:
    #####:  703:                if (settings.auth_file == NULL) {
    #####:  704:                    c->authenticated = true;
    #####:  705:                    c->try_read_command = try_read_command_ascii;
        -:  706:                } else {
    #####:  707:                    c->authenticated = false;
    #####:  708:                    c->try_read_command = try_read_command_asciiauth;
        -:  709:                }
        -:  710:                break;
    #####:  711:            case binary_prot:
        -:  712:                // binprot handles its own authentication via SASL parsing.
    #####:  713:                c->authenticated = false;
    #####:  714:                c->try_read_command = try_read_command_binary;
    #####:  715:                break;
      202:  716:            case negotiating_prot:
      202:  717:                c->try_read_command = try_read_command_negotiate;
      202:  718:                break;
        -:  719:        }
      202:  720:    }
        -:  721:
      202:  722:    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
      202:  723:    event_base_set(base, &c->event);
      202:  724:    c->ev_flags = event_flags;
        -:  725:
      202:  726:    if (event_add(&c->event, 0) == -1) {
    #####:  727:        perror("event_add");
    #####:  728:        return NULL;
        -:  729:    }
        -:  730:
      202:  731:    STATS_LOCK();
      202:  732:    stats_state.curr_conns++;
      202:  733:    stats.total_conns++;
      202:  734:    STATS_UNLOCK();
        -:  735:
      202:  736:    MEMCACHED_CONN_ALLOCATE(c->sfd);
        -:  737:
      202:  738:    return c;
        -:  739:}
------------------
        -:  740:#ifdef EXTSTORE
        -:  741:static void recache_or_free(conn *c, io_wrap *wrap) {
        -:  742:    item *it;
        -:  743:    it = (item *)wrap->io.buf;
        -:  744:    bool do_free = true;
        -:  745:    if (wrap->active) {
        -:  746:        // If request never dispatched, free the read buffer but leave the
        -:  747:        // item header alone.
        -:  748:        do_free = false;
        -:  749:        size_t ntotal = ITEM_ntotal(wrap->hdr_it);
        -:  750:        slabs_free(it, ntotal, slabs_clsid(ntotal));
        -:  751:        c->io_wrapleft--;
        -:  752:        assert(c->io_wrapleft >= 0);
        -:  753:        pthread_mutex_lock(&c->thread->stats.mutex);
        -:  754:        c->thread->stats.get_aborted_extstore++;
        -:  755:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  756:    } else if (wrap->miss) {
        -:  757:        // If request was ultimately a miss, unlink the header.
        -:  758:        do_free = false;
        -:  759:        size_t ntotal = ITEM_ntotal(wrap->hdr_it);
        -:  760:        item_unlink(wrap->hdr_it);
        -:  761:        slabs_free(it, ntotal, slabs_clsid(ntotal));
        -:  762:        pthread_mutex_lock(&c->thread->stats.mutex);
        -:  763:        c->thread->stats.miss_from_extstore++;
        -:  764:        if (wrap->badcrc)
        -:  765:            c->thread->stats.badcrc_from_extstore++;
        -:  766:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  767:    } else if (settings.ext_recache_rate) {
        -:  768:        // hashvalue is cuddled during store
        -:  769:        uint32_t hv = (uint32_t)it->time;
        -:  770:        // opt to throw away rather than wait on a lock.
        -:  771:        void *hold_lock = item_trylock(hv);
        -:  772:        if (hold_lock != NULL) {
        -:  773:            item *h_it = wrap->hdr_it;
        -:  774:            uint8_t flags = ITEM_LINKED|ITEM_FETCHED|ITEM_ACTIVE;
        -:  775:            // Item must be recently hit at least twice to recache.
        -:  776:            if (((h_it->it_flags & flags) == flags) &&
        -:  777:                    h_it->time > current_time - ITEM_UPDATE_INTERVAL &&
        -:  778:                    c->recache_counter++ % settings.ext_recache_rate == 0) {
        -:  779:                do_free = false;
        -:  780:                // In case it's been updated.
        -:  781:                it->exptime = h_it->exptime;
        -:  782:                it->it_flags &= ~ITEM_LINKED;
        -:  783:                it->refcount = 0;
        -:  784:                it->h_next = NULL; // might not be necessary.
        -:  785:                STORAGE_delete(c->thread->storage, h_it);
        -:  786:                item_replace(h_it, it, hv);
        -:  787:                pthread_mutex_lock(&c->thread->stats.mutex);
        -:  788:                c->thread->stats.recache_from_extstore++;
        -:  789:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -:  790:            }
        -:  791:        }
        -:  792:        if (hold_lock)
        -:  793:            item_trylock_unlock(hold_lock);
        -:  794:    }
        -:  795:    if (do_free)
        -:  796:        slabs_free(it, ITEM_ntotal(it), ITEM_clsid(it));
        -:  797:
        -:  798:    wrap->io.buf = NULL; // sanity.
        -:  799:    wrap->io.next = NULL;
        -:  800:    wrap->next = NULL;
        -:  801:    wrap->active = false;
        -:  802:
        -:  803:    // TODO: reuse lock and/or hv.
        -:  804:    item_remove(wrap->hdr_it);
        -:  805:}
        -:  806:#endif
   300600:  807:static void conn_release_items(conn *c) {
  300600*:  808:    assert(c != NULL);
        -:  809:
   300600:  810:    if (c->item) {
    #####:  811:        item_remove(c->item);
    #####:  812:        c->item = 0;
        -:  813:    }
        -:  814:
   300600:  815:    while (c->ileft > 0) {
    #####:  816:        item *it = *(c->icurr);
    #####:  817:        assert((it->it_flags & ITEM_SLABBED) == 0);
    #####:  818:        item_remove(it);
    #####:  819:        c->icurr++;
    #####:  820:        c->ileft--;
        -:  821:    }
        -:  822:
   300600:  823:    if (c->suffixleft != 0) {
    #####:  824:        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
    #####:  825:            do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));
        -:  826:        }
        -:  827:    }
        -:  828:#ifdef EXTSTORE
        -:  829:    if (c->io_wraplist) {
        -:  830:        io_wrap *tmp = c->io_wraplist;
        -:  831:        while (tmp) {
        -:  832:            io_wrap *next = tmp->next;
        -:  833:            recache_or_free(c, tmp);
        -:  834:            do_cache_free(c->thread->io_cache, tmp); // lockless
        -:  835:            tmp = next;
        -:  836:        }
        -:  837:        c->io_wraplist = NULL;
        -:  838:    }
        -:  839:#endif
   300600:  840:    c->icurr = c->ilist;
   300600:  841:    c->suffixcurr = c->suffixlist;
   300600:  842:}
------------------
conn_release_items:
   100200:  807:static void conn_release_items(conn *c) {
  100200*:  808:    assert(c != NULL);
        -:  809:
   100200:  810:    if (c->item) {
    #####:  811:        item_remove(c->item);
    #####:  812:        c->item = 0;
        -:  813:    }
        -:  814:
   100200:  815:    while (c->ileft > 0) {
    #####:  816:        item *it = *(c->icurr);
    #####:  817:        assert((it->it_flags & ITEM_SLABBED) == 0);
    #####:  818:        item_remove(it);
    #####:  819:        c->icurr++;
    #####:  820:        c->ileft--;
        -:  821:    }
        -:  822:
   100200:  823:    if (c->suffixleft != 0) {
    #####:  824:        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
    #####:  825:            do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));
        -:  826:        }
        -:  827:    }
        -:  828:#ifdef EXTSTORE
        -:  829:    if (c->io_wraplist) {
        -:  830:        io_wrap *tmp = c->io_wraplist;
        -:  831:        while (tmp) {
        -:  832:            io_wrap *next = tmp->next;
        -:  833:            recache_or_free(c, tmp);
        -:  834:            do_cache_free(c->thread->io_cache, tmp); // lockless
        -:  835:            tmp = next;
        -:  836:        }
        -:  837:        c->io_wraplist = NULL;
        -:  838:    }
        -:  839:#endif
   100200:  840:    c->icurr = c->ilist;
   100200:  841:    c->suffixcurr = c->suffixlist;
   100200:  842:}
------------------
conn_release_items:
   100200:  807:static void conn_release_items(conn *c) {
  100200*:  808:    assert(c != NULL);
        -:  809:
   100200:  810:    if (c->item) {
    #####:  811:        item_remove(c->item);
    #####:  812:        c->item = 0;
        -:  813:    }
        -:  814:
   100200:  815:    while (c->ileft > 0) {
    #####:  816:        item *it = *(c->icurr);
    #####:  817:        assert((it->it_flags & ITEM_SLABBED) == 0);
    #####:  818:        item_remove(it);
    #####:  819:        c->icurr++;
    #####:  820:        c->ileft--;
        -:  821:    }
        -:  822:
   100200:  823:    if (c->suffixleft != 0) {
    #####:  824:        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
    #####:  825:            do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));
        -:  826:        }
        -:  827:    }
        -:  828:#ifdef EXTSTORE
        -:  829:    if (c->io_wraplist) {
        -:  830:        io_wrap *tmp = c->io_wraplist;
        -:  831:        while (tmp) {
        -:  832:            io_wrap *next = tmp->next;
        -:  833:            recache_or_free(c, tmp);
        -:  834:            do_cache_free(c->thread->io_cache, tmp); // lockless
        -:  835:            tmp = next;
        -:  836:        }
        -:  837:        c->io_wraplist = NULL;
        -:  838:    }
        -:  839:#endif
   100200:  840:    c->icurr = c->ilist;
   100200:  841:    c->suffixcurr = c->suffixlist;
   100200:  842:}
------------------
conn_release_items:
   100200:  807:static void conn_release_items(conn *c) {
  100200*:  808:    assert(c != NULL);
        -:  809:
   100200:  810:    if (c->item) {
    #####:  811:        item_remove(c->item);
    #####:  812:        c->item = 0;
        -:  813:    }
        -:  814:
   100200:  815:    while (c->ileft > 0) {
    #####:  816:        item *it = *(c->icurr);
    #####:  817:        assert((it->it_flags & ITEM_SLABBED) == 0);
    #####:  818:        item_remove(it);
    #####:  819:        c->icurr++;
    #####:  820:        c->ileft--;
        -:  821:    }
        -:  822:
   100200:  823:    if (c->suffixleft != 0) {
    #####:  824:        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
    #####:  825:            do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));
        -:  826:        }
        -:  827:    }
        -:  828:#ifdef EXTSTORE
        -:  829:    if (c->io_wraplist) {
        -:  830:        io_wrap *tmp = c->io_wraplist;
        -:  831:        while (tmp) {
        -:  832:            io_wrap *next = tmp->next;
        -:  833:            recache_or_free(c, tmp);
        -:  834:            do_cache_free(c->thread->io_cache, tmp); // lockless
        -:  835:            tmp = next;
        -:  836:        }
        -:  837:        c->io_wraplist = NULL;
        -:  838:    }
        -:  839:#endif
   100200:  840:    c->icurr = c->ilist;
   100200:  841:    c->suffixcurr = c->suffixlist;
   100200:  842:}
------------------
        -:  843:
      600:  844:static void conn_cleanup(conn *c) {
     600*:  845:    assert(c != NULL);
        -:  846:
      600:  847:    conn_release_items(c);
        -:  848:
      600:  849:    if (c->write_and_free) {
    #####:  850:        free(c->write_and_free);
    #####:  851:        c->write_and_free = 0;
        -:  852:    }
        -:  853:
      600:  854:    if (c->sasl_conn) {
    #####:  855:        assert(settings.sasl);
    #####:  856:        sasl_dispose(&c->sasl_conn);
    #####:  857:        c->sasl_conn = NULL;
        -:  858:    }
        -:  859:
      600:  860:    if (IS_UDP(c->transport)) {
    #####:  861:        conn_set_state(c, conn_read);
        -:  862:    }
      600:  863:}
------------------
conn_cleanup:
      200:  844:static void conn_cleanup(conn *c) {
     200*:  845:    assert(c != NULL);
        -:  846:
      200:  847:    conn_release_items(c);
        -:  848:
      200:  849:    if (c->write_and_free) {
    #####:  850:        free(c->write_and_free);
    #####:  851:        c->write_and_free = 0;
        -:  852:    }
        -:  853:
      200:  854:    if (c->sasl_conn) {
    #####:  855:        assert(settings.sasl);
    #####:  856:        sasl_dispose(&c->sasl_conn);
    #####:  857:        c->sasl_conn = NULL;
        -:  858:    }
        -:  859:
      200:  860:    if (IS_UDP(c->transport)) {
    #####:  861:        conn_set_state(c, conn_read);
        -:  862:    }
      200:  863:}
------------------
conn_cleanup:
      200:  844:static void conn_cleanup(conn *c) {
     200*:  845:    assert(c != NULL);
        -:  846:
      200:  847:    conn_release_items(c);
        -:  848:
      200:  849:    if (c->write_and_free) {
    #####:  850:        free(c->write_and_free);
    #####:  851:        c->write_and_free = 0;
        -:  852:    }
        -:  853:
      200:  854:    if (c->sasl_conn) {
    #####:  855:        assert(settings.sasl);
    #####:  856:        sasl_dispose(&c->sasl_conn);
    #####:  857:        c->sasl_conn = NULL;
        -:  858:    }
        -:  859:
      200:  860:    if (IS_UDP(c->transport)) {
    #####:  861:        conn_set_state(c, conn_read);
        -:  862:    }
      200:  863:}
------------------
conn_cleanup:
      200:  844:static void conn_cleanup(conn *c) {
     200*:  845:    assert(c != NULL);
        -:  846:
      200:  847:    conn_release_items(c);
        -:  848:
      200:  849:    if (c->write_and_free) {
    #####:  850:        free(c->write_and_free);
    #####:  851:        c->write_and_free = 0;
        -:  852:    }
        -:  853:
      200:  854:    if (c->sasl_conn) {
    #####:  855:        assert(settings.sasl);
    #####:  856:        sasl_dispose(&c->sasl_conn);
    #####:  857:        c->sasl_conn = NULL;
        -:  858:    }
        -:  859:
      200:  860:    if (IS_UDP(c->transport)) {
    #####:  861:        conn_set_state(c, conn_read);
        -:  862:    }
      200:  863:}
------------------
        -:  864:
        -:  865:/*
        -:  866: * Frees a connection.
        -:  867: */
    #####:  868:void conn_free(conn *c) {
    #####:  869:    if (c) {
    #####:  870:        assert(c != NULL);
    #####:  871:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  872:
    #####:  873:        MEMCACHED_CONN_DESTROY(c);
    #####:  874:        conns[c->sfd] = NULL;
    #####:  875:        if (c->hdrbuf)
    #####:  876:            free(c->hdrbuf);
    #####:  877:        if (c->msglist)
    #####:  878:            free(c->msglist);
    #####:  879:        if (c->rbuf)
    #####:  880:            free(c->rbuf);
    #####:  881:        if (c->wbuf)
    #####:  882:            free(c->wbuf);
    #####:  883:        if (c->ilist)
    #####:  884:            free(c->ilist);
    #####:  885:        if (c->suffixlist)
    #####:  886:            free(c->suffixlist);
    #####:  887:        if (c->iov)
    #####:  888:            free(c->iov);
        -:  889:#ifdef TLS
        -:  890:        if (c->ssl_wbuf)
        -:  891:            c->ssl_wbuf = NULL;
        -:  892:#endif
        -:  893:
    #####:  894:        free(c);
        -:  895:    }
    #####:  896:}
------------------
conn_free:
    #####:  868:void conn_free(conn *c) {
    #####:  869:    if (c) {
    #####:  870:        assert(c != NULL);
    #####:  871:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  872:
    #####:  873:        MEMCACHED_CONN_DESTROY(c);
    #####:  874:        conns[c->sfd] = NULL;
    #####:  875:        if (c->hdrbuf)
    #####:  876:            free(c->hdrbuf);
    #####:  877:        if (c->msglist)
    #####:  878:            free(c->msglist);
    #####:  879:        if (c->rbuf)
    #####:  880:            free(c->rbuf);
    #####:  881:        if (c->wbuf)
    #####:  882:            free(c->wbuf);
    #####:  883:        if (c->ilist)
    #####:  884:            free(c->ilist);
    #####:  885:        if (c->suffixlist)
    #####:  886:            free(c->suffixlist);
    #####:  887:        if (c->iov)
    #####:  888:            free(c->iov);
        -:  889:#ifdef TLS
        -:  890:        if (c->ssl_wbuf)
        -:  891:            c->ssl_wbuf = NULL;
        -:  892:#endif
        -:  893:
    #####:  894:        free(c);
        -:  895:    }
    #####:  896:}
------------------
conn_free:
    #####:  868:void conn_free(conn *c) {
    #####:  869:    if (c) {
    #####:  870:        assert(c != NULL);
    #####:  871:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  872:
    #####:  873:        MEMCACHED_CONN_DESTROY(c);
    #####:  874:        conns[c->sfd] = NULL;
    #####:  875:        if (c->hdrbuf)
    #####:  876:            free(c->hdrbuf);
    #####:  877:        if (c->msglist)
    #####:  878:            free(c->msglist);
    #####:  879:        if (c->rbuf)
    #####:  880:            free(c->rbuf);
    #####:  881:        if (c->wbuf)
    #####:  882:            free(c->wbuf);
    #####:  883:        if (c->ilist)
    #####:  884:            free(c->ilist);
    #####:  885:        if (c->suffixlist)
    #####:  886:            free(c->suffixlist);
    #####:  887:        if (c->iov)
    #####:  888:            free(c->iov);
        -:  889:#ifdef TLS
        -:  890:        if (c->ssl_wbuf)
        -:  891:            c->ssl_wbuf = NULL;
        -:  892:#endif
        -:  893:
    #####:  894:        free(c);
        -:  895:    }
    #####:  896:}
------------------
conn_free:
    #####:  868:void conn_free(conn *c) {
    #####:  869:    if (c) {
    #####:  870:        assert(c != NULL);
    #####:  871:        assert(c->sfd >= 0 && c->sfd < max_fds);
        -:  872:
    #####:  873:        MEMCACHED_CONN_DESTROY(c);
    #####:  874:        conns[c->sfd] = NULL;
    #####:  875:        if (c->hdrbuf)
    #####:  876:            free(c->hdrbuf);
    #####:  877:        if (c->msglist)
    #####:  878:            free(c->msglist);
    #####:  879:        if (c->rbuf)
    #####:  880:            free(c->rbuf);
    #####:  881:        if (c->wbuf)
    #####:  882:            free(c->wbuf);
    #####:  883:        if (c->ilist)
    #####:  884:            free(c->ilist);
    #####:  885:        if (c->suffixlist)
    #####:  886:            free(c->suffixlist);
    #####:  887:        if (c->iov)
    #####:  888:            free(c->iov);
        -:  889:#ifdef TLS
        -:  890:        if (c->ssl_wbuf)
        -:  891:            c->ssl_wbuf = NULL;
        -:  892:#endif
        -:  893:
    #####:  894:        free(c);
        -:  895:    }
    #####:  896:}
------------------
        -:  897:
      600:  898:static void conn_close(conn *c) {
     600*:  899:    assert(c != NULL);
        -:  900:
        -:  901:    /* delete the event, the socket and the conn */
      600:  902:    event_del(&c->event);
        -:  903:
      600:  904:    if (settings.verbose > 1)
    #####:  905:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  906:
      600:  907:    conn_cleanup(c);
        -:  908:
      600:  909:    MEMCACHED_CONN_RELEASE(c->sfd);
      600:  910:    conn_set_state(c, conn_closed);
        -:  911:#ifdef TLS
        -:  912:    if (c->ssl) {
        -:  913:        SSL_shutdown(c->ssl);
        -:  914:        SSL_free(c->ssl);
        -:  915:    }
        -:  916:#endif
      600:  917:    close(c->sfd);
      600:  918:    pthread_mutex_lock(&conn_lock);
      600:  919:    allow_new_conns = true;
      600:  920:    pthread_mutex_unlock(&conn_lock);
        -:  921:
      600:  922:    STATS_LOCK();
      600:  923:    stats_state.curr_conns--;
      600:  924:    STATS_UNLOCK();
        -:  925:
      600:  926:    return;
        -:  927:}
------------------
conn_close:
      200:  898:static void conn_close(conn *c) {
     200*:  899:    assert(c != NULL);
        -:  900:
        -:  901:    /* delete the event, the socket and the conn */
      200:  902:    event_del(&c->event);
        -:  903:
      200:  904:    if (settings.verbose > 1)
    #####:  905:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  906:
      200:  907:    conn_cleanup(c);
        -:  908:
      200:  909:    MEMCACHED_CONN_RELEASE(c->sfd);
      200:  910:    conn_set_state(c, conn_closed);
        -:  911:#ifdef TLS
        -:  912:    if (c->ssl) {
        -:  913:        SSL_shutdown(c->ssl);
        -:  914:        SSL_free(c->ssl);
        -:  915:    }
        -:  916:#endif
      200:  917:    close(c->sfd);
      200:  918:    pthread_mutex_lock(&conn_lock);
      200:  919:    allow_new_conns = true;
      200:  920:    pthread_mutex_unlock(&conn_lock);
        -:  921:
      200:  922:    STATS_LOCK();
      200:  923:    stats_state.curr_conns--;
      200:  924:    STATS_UNLOCK();
        -:  925:
      200:  926:    return;
        -:  927:}
------------------
conn_close:
      200:  898:static void conn_close(conn *c) {
     200*:  899:    assert(c != NULL);
        -:  900:
        -:  901:    /* delete the event, the socket and the conn */
      200:  902:    event_del(&c->event);
        -:  903:
      200:  904:    if (settings.verbose > 1)
    #####:  905:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  906:
      200:  907:    conn_cleanup(c);
        -:  908:
      200:  909:    MEMCACHED_CONN_RELEASE(c->sfd);
      200:  910:    conn_set_state(c, conn_closed);
        -:  911:#ifdef TLS
        -:  912:    if (c->ssl) {
        -:  913:        SSL_shutdown(c->ssl);
        -:  914:        SSL_free(c->ssl);
        -:  915:    }
        -:  916:#endif
      200:  917:    close(c->sfd);
      200:  918:    pthread_mutex_lock(&conn_lock);
      200:  919:    allow_new_conns = true;
      200:  920:    pthread_mutex_unlock(&conn_lock);
        -:  921:
      200:  922:    STATS_LOCK();
      200:  923:    stats_state.curr_conns--;
      200:  924:    STATS_UNLOCK();
        -:  925:
      200:  926:    return;
        -:  927:}
------------------
conn_close:
      200:  898:static void conn_close(conn *c) {
     200*:  899:    assert(c != NULL);
        -:  900:
        -:  901:    /* delete the event, the socket and the conn */
      200:  902:    event_del(&c->event);
        -:  903:
      200:  904:    if (settings.verbose > 1)
    #####:  905:        fprintf(stderr, "<%d connection closed.\n", c->sfd);
        -:  906:
      200:  907:    conn_cleanup(c);
        -:  908:
      200:  909:    MEMCACHED_CONN_RELEASE(c->sfd);
      200:  910:    conn_set_state(c, conn_closed);
        -:  911:#ifdef TLS
        -:  912:    if (c->ssl) {
        -:  913:        SSL_shutdown(c->ssl);
        -:  914:        SSL_free(c->ssl);
        -:  915:    }
        -:  916:#endif
      200:  917:    close(c->sfd);
      200:  918:    pthread_mutex_lock(&conn_lock);
      200:  919:    allow_new_conns = true;
      200:  920:    pthread_mutex_unlock(&conn_lock);
        -:  921:
      200:  922:    STATS_LOCK();
      200:  923:    stats_state.curr_conns--;
      200:  924:    STATS_UNLOCK();
        -:  925:
      200:  926:    return;
        -:  927:}
------------------
        -:  928:
        -:  929:/*
        -:  930: * Shrinks a connection's buffers if they're too big.  This prevents
        -:  931: * periodic large "get" requests from permanently chewing lots of server
        -:  932: * memory.
        -:  933: *
        -:  934: * This should only be called in between requests since it can wipe output
        -:  935: * buffers!
        -:  936: */
   300600:  937:static void conn_shrink(conn *c) {
  300600*:  938:    assert(c != NULL);
        -:  939:
   300600:  940:    if (IS_UDP(c->transport))
        -:  941:        return;
        -:  942:
  300600*:  943:    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
    #####:  944:        char *newbuf;
        -:  945:
    #####:  946:        if (c->rcurr != c->rbuf)
    #####:  947:            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);
        -:  948:
    #####:  949:        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);
        -:  950:
    #####:  951:        if (newbuf) {
    #####:  952:            c->rbuf = newbuf;
    #####:  953:            c->rsize = DATA_BUFFER_SIZE;
        -:  954:        }
        -:  955:        /* TODO check other branch... */
    #####:  956:        c->rcurr = c->rbuf;
        -:  957:    }
        -:  958:
   300600:  959:    if (c->isize > ITEM_LIST_HIGHWAT) {
    #####:  960:        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
    #####:  961:        if (newbuf) {
    #####:  962:            c->ilist = newbuf;
    #####:  963:            c->isize = ITEM_LIST_INITIAL;
        -:  964:        }
        -:  965:    /* TODO check error condition? */
        -:  966:    }
        -:  967:
   300600:  968:    if (c->msgsize > MSG_LIST_HIGHWAT) {
    #####:  969:        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
    #####:  970:        if (newbuf) {
    #####:  971:            c->msglist = newbuf;
    #####:  972:            c->msgsize = MSG_LIST_INITIAL;
        -:  973:        }
        -:  974:    /* TODO check error condition? */
        -:  975:    }
        -:  976:
   300600:  977:    if (c->iovsize > IOV_LIST_HIGHWAT) {
    #####:  978:        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
    #####:  979:        if (newbuf) {
    #####:  980:            c->iov = newbuf;
    #####:  981:            c->iovsize = IOV_LIST_INITIAL;
        -:  982:        }
        -:  983:    /* TODO check return value */
        -:  984:    }
        -:  985:}
------------------
conn_shrink:
   100200:  937:static void conn_shrink(conn *c) {
  100200*:  938:    assert(c != NULL);
        -:  939:
   100200:  940:    if (IS_UDP(c->transport))
        -:  941:        return;
        -:  942:
  100200*:  943:    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
    #####:  944:        char *newbuf;
        -:  945:
    #####:  946:        if (c->rcurr != c->rbuf)
    #####:  947:            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);
        -:  948:
    #####:  949:        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);
        -:  950:
    #####:  951:        if (newbuf) {
    #####:  952:            c->rbuf = newbuf;
    #####:  953:            c->rsize = DATA_BUFFER_SIZE;
        -:  954:        }
        -:  955:        /* TODO check other branch... */
    #####:  956:        c->rcurr = c->rbuf;
        -:  957:    }
        -:  958:
   100200:  959:    if (c->isize > ITEM_LIST_HIGHWAT) {
    #####:  960:        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
    #####:  961:        if (newbuf) {
    #####:  962:            c->ilist = newbuf;
    #####:  963:            c->isize = ITEM_LIST_INITIAL;
        -:  964:        }
        -:  965:    /* TODO check error condition? */
        -:  966:    }
        -:  967:
   100200:  968:    if (c->msgsize > MSG_LIST_HIGHWAT) {
    #####:  969:        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
    #####:  970:        if (newbuf) {
    #####:  971:            c->msglist = newbuf;
    #####:  972:            c->msgsize = MSG_LIST_INITIAL;
        -:  973:        }
        -:  974:    /* TODO check error condition? */
        -:  975:    }
        -:  976:
   100200:  977:    if (c->iovsize > IOV_LIST_HIGHWAT) {
    #####:  978:        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
    #####:  979:        if (newbuf) {
    #####:  980:            c->iov = newbuf;
    #####:  981:            c->iovsize = IOV_LIST_INITIAL;
        -:  982:        }
        -:  983:    /* TODO check return value */
        -:  984:    }
        -:  985:}
------------------
conn_shrink:
   100200:  937:static void conn_shrink(conn *c) {
  100200*:  938:    assert(c != NULL);
        -:  939:
   100200:  940:    if (IS_UDP(c->transport))
        -:  941:        return;
        -:  942:
  100200*:  943:    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
    #####:  944:        char *newbuf;
        -:  945:
    #####:  946:        if (c->rcurr != c->rbuf)
    #####:  947:            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);
        -:  948:
    #####:  949:        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);
        -:  950:
    #####:  951:        if (newbuf) {
    #####:  952:            c->rbuf = newbuf;
    #####:  953:            c->rsize = DATA_BUFFER_SIZE;
        -:  954:        }
        -:  955:        /* TODO check other branch... */
    #####:  956:        c->rcurr = c->rbuf;
        -:  957:    }
        -:  958:
   100200:  959:    if (c->isize > ITEM_LIST_HIGHWAT) {
    #####:  960:        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
    #####:  961:        if (newbuf) {
    #####:  962:            c->ilist = newbuf;
    #####:  963:            c->isize = ITEM_LIST_INITIAL;
        -:  964:        }
        -:  965:    /* TODO check error condition? */
        -:  966:    }
        -:  967:
   100200:  968:    if (c->msgsize > MSG_LIST_HIGHWAT) {
    #####:  969:        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
    #####:  970:        if (newbuf) {
    #####:  971:            c->msglist = newbuf;
    #####:  972:            c->msgsize = MSG_LIST_INITIAL;
        -:  973:        }
        -:  974:    /* TODO check error condition? */
        -:  975:    }
        -:  976:
   100200:  977:    if (c->iovsize > IOV_LIST_HIGHWAT) {
    #####:  978:        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
    #####:  979:        if (newbuf) {
    #####:  980:            c->iov = newbuf;
    #####:  981:            c->iovsize = IOV_LIST_INITIAL;
        -:  982:        }
        -:  983:    /* TODO check return value */
        -:  984:    }
        -:  985:}
------------------
conn_shrink:
   100200:  937:static void conn_shrink(conn *c) {
  100200*:  938:    assert(c != NULL);
        -:  939:
   100200:  940:    if (IS_UDP(c->transport))
        -:  941:        return;
        -:  942:
  100200*:  943:    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
    #####:  944:        char *newbuf;
        -:  945:
    #####:  946:        if (c->rcurr != c->rbuf)
    #####:  947:            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);
        -:  948:
    #####:  949:        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);
        -:  950:
    #####:  951:        if (newbuf) {
    #####:  952:            c->rbuf = newbuf;
    #####:  953:            c->rsize = DATA_BUFFER_SIZE;
        -:  954:        }
        -:  955:        /* TODO check other branch... */
    #####:  956:        c->rcurr = c->rbuf;
        -:  957:    }
        -:  958:
   100200:  959:    if (c->isize > ITEM_LIST_HIGHWAT) {
    #####:  960:        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
    #####:  961:        if (newbuf) {
    #####:  962:            c->ilist = newbuf;
    #####:  963:            c->isize = ITEM_LIST_INITIAL;
        -:  964:        }
        -:  965:    /* TODO check error condition? */
        -:  966:    }
        -:  967:
   100200:  968:    if (c->msgsize > MSG_LIST_HIGHWAT) {
    #####:  969:        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
    #####:  970:        if (newbuf) {
    #####:  971:            c->msglist = newbuf;
    #####:  972:            c->msgsize = MSG_LIST_INITIAL;
        -:  973:        }
        -:  974:    /* TODO check error condition? */
        -:  975:    }
        -:  976:
   100200:  977:    if (c->iovsize > IOV_LIST_HIGHWAT) {
    #####:  978:        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
    #####:  979:        if (newbuf) {
    #####:  980:            c->iov = newbuf;
    #####:  981:            c->iovsize = IOV_LIST_INITIAL;
        -:  982:        }
        -:  983:    /* TODO check return value */
        -:  984:    }
        -:  985:}
------------------
        -:  986:
        -:  987:/**
        -:  988: * Convert a state name to a human readable form.
        -:  989: */
        -:  990:static const char *state_text(enum conn_states state) {
    #####:  991:    const char* const statenames[] = { "conn_listening",
        -:  992:                                       "conn_new_cmd",
        -:  993:                                       "conn_waiting",
        -:  994:                                       "conn_read",
        -:  995:                                       "conn_parse_cmd",
        -:  996:                                       "conn_write",
        -:  997:                                       "conn_nread",
        -:  998:                                       "conn_swallow",
        -:  999:                                       "conn_closing",
        -: 1000:                                       "conn_mwrite",
        -: 1001:                                       "conn_closed",
        -: 1002:                                       "conn_watch" };
    #####: 1003:    return statenames[state];
        -: 1004:}
        -: 1005:
        -: 1006:/*
        -: 1007: * Sets a connection's current state in the state machine. Any special
        -: 1008: * processing that needs to happen on certain state transitions can
        -: 1009: * happen here.
        -: 1010: */
  1830000: 1011:static void conn_set_state(conn *c, enum conn_states state) {
 1830000*: 1012:    assert(c != NULL);
 1830000*: 1013:    assert(state >= conn_listening && state < conn_max_state);
        -: 1014:
  1830000: 1015:    if (state != c->state) {
  1802400: 1016:        if (settings.verbose > 2) {
    #####: 1017:            fprintf(stderr, "%d: going from %s to %s\n",
        -: 1018:                    c->sfd, state_text(c->state),
        -: 1019:                    state_text(state));
        -: 1020:        }
        -: 1021:
  1802400: 1022:        if (state == conn_write || state == conn_mwrite) {
  1802400: 1023:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
        -: 1024:        }
  1802400: 1025:        c->state = state;
        -: 1026:    }
  1830000: 1027:}
------------------
conn_set_state:
   610000: 1011:static void conn_set_state(conn *c, enum conn_states state) {
  610000*: 1012:    assert(c != NULL);
  610000*: 1013:    assert(state >= conn_listening && state < conn_max_state);
        -: 1014:
   610000: 1015:    if (state != c->state) {
   600800: 1016:        if (settings.verbose > 2) {
    #####: 1017:            fprintf(stderr, "%d: going from %s to %s\n",
        -: 1018:                    c->sfd, state_text(c->state),
        -: 1019:                    state_text(state));
        -: 1020:        }
        -: 1021:
   600800: 1022:        if (state == conn_write || state == conn_mwrite) {
   600800: 1023:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
        -: 1024:        }
   600800: 1025:        c->state = state;
        -: 1026:    }
   610000: 1027:}
------------------
conn_set_state:
   610000: 1011:static void conn_set_state(conn *c, enum conn_states state) {
  610000*: 1012:    assert(c != NULL);
  610000*: 1013:    assert(state >= conn_listening && state < conn_max_state);
        -: 1014:
   610000: 1015:    if (state != c->state) {
   600800: 1016:        if (settings.verbose > 2) {
    #####: 1017:            fprintf(stderr, "%d: going from %s to %s\n",
        -: 1018:                    c->sfd, state_text(c->state),
        -: 1019:                    state_text(state));
        -: 1020:        }
        -: 1021:
   600800: 1022:        if (state == conn_write || state == conn_mwrite) {
   600800: 1023:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
        -: 1024:        }
   600800: 1025:        c->state = state;
        -: 1026:    }
   610000: 1027:}
------------------
conn_set_state:
   610000: 1011:static void conn_set_state(conn *c, enum conn_states state) {
  610000*: 1012:    assert(c != NULL);
  610000*: 1013:    assert(state >= conn_listening && state < conn_max_state);
        -: 1014:
   610000: 1015:    if (state != c->state) {
   600800: 1016:        if (settings.verbose > 2) {
    #####: 1017:            fprintf(stderr, "%d: going from %s to %s\n",
        -: 1018:                    c->sfd, state_text(c->state),
        -: 1019:                    state_text(state));
        -: 1020:        }
        -: 1021:
   600800: 1022:        if (state == conn_write || state == conn_mwrite) {
   600800: 1023:            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);
        -: 1024:        }
   600800: 1025:        c->state = state;
        -: 1026:    }
   610000: 1027:}
------------------
        -: 1028:
        -: 1029:/*
        -: 1030: * Ensures that there is room for another struct iovec in a connection's
        -: 1031: * iov list.
        -: 1032: *
        -: 1033: * Returns 0 on success, -1 on out-of-memory.
        -: 1034: */
   572400: 1035:static int ensure_iov_space(conn *c) {
  572400*: 1036:    assert(c != NULL);
        -: 1037:
   572400: 1038:    if (c->iovused >= c->iovsize) {
    #####: 1039:        int i, iovnum;
    #####: 1040:        struct iovec *new_iov = (struct iovec *)realloc(c->iov,
    #####: 1041:                                (c->iovsize * 2) * sizeof(struct iovec));
    #####: 1042:        if (! new_iov) {
    #####: 1043:            STATS_LOCK();
    #####: 1044:            stats.malloc_fails++;
    #####: 1045:            STATS_UNLOCK();
    #####: 1046:            return -1;
        -: 1047:        }
    #####: 1048:        c->iov = new_iov;
    #####: 1049:        c->iovsize *= 2;
        -: 1050:
        -: 1051:        /* Point all the msghdr structures at the new list. */
    #####: 1052:        for (i = 0, iovnum = 0; i < c->msgused; i++) {
    #####: 1053:            c->msglist[i].msg_iov = &c->iov[iovnum];
    #####: 1054:            iovnum += c->msglist[i].msg_iovlen;
        -: 1055:        }
        -: 1056:    }
        -: 1057:
        -: 1058:    return 0;
        -: 1059:}
------------------
ensure_iov_space:
   190800: 1035:static int ensure_iov_space(conn *c) {
  190800*: 1036:    assert(c != NULL);
        -: 1037:
   190800: 1038:    if (c->iovused >= c->iovsize) {
    #####: 1039:        int i, iovnum;
    #####: 1040:        struct iovec *new_iov = (struct iovec *)realloc(c->iov,
    #####: 1041:                                (c->iovsize * 2) * sizeof(struct iovec));
    #####: 1042:        if (! new_iov) {
    #####: 1043:            STATS_LOCK();
    #####: 1044:            stats.malloc_fails++;
    #####: 1045:            STATS_UNLOCK();
    #####: 1046:            return -1;
        -: 1047:        }
    #####: 1048:        c->iov = new_iov;
    #####: 1049:        c->iovsize *= 2;
        -: 1050:
        -: 1051:        /* Point all the msghdr structures at the new list. */
    #####: 1052:        for (i = 0, iovnum = 0; i < c->msgused; i++) {
    #####: 1053:            c->msglist[i].msg_iov = &c->iov[iovnum];
    #####: 1054:            iovnum += c->msglist[i].msg_iovlen;
        -: 1055:        }
        -: 1056:    }
        -: 1057:
        -: 1058:    return 0;
        -: 1059:}
------------------
ensure_iov_space:
   190800: 1035:static int ensure_iov_space(conn *c) {
  190800*: 1036:    assert(c != NULL);
        -: 1037:
   190800: 1038:    if (c->iovused >= c->iovsize) {
    #####: 1039:        int i, iovnum;
    #####: 1040:        struct iovec *new_iov = (struct iovec *)realloc(c->iov,
    #####: 1041:                                (c->iovsize * 2) * sizeof(struct iovec));
    #####: 1042:        if (! new_iov) {
    #####: 1043:            STATS_LOCK();
    #####: 1044:            stats.malloc_fails++;
    #####: 1045:            STATS_UNLOCK();
    #####: 1046:            return -1;
        -: 1047:        }
    #####: 1048:        c->iov = new_iov;
    #####: 1049:        c->iovsize *= 2;
        -: 1050:
        -: 1051:        /* Point all the msghdr structures at the new list. */
    #####: 1052:        for (i = 0, iovnum = 0; i < c->msgused; i++) {
    #####: 1053:            c->msglist[i].msg_iov = &c->iov[iovnum];
    #####: 1054:            iovnum += c->msglist[i].msg_iovlen;
        -: 1055:        }
        -: 1056:    }
        -: 1057:
        -: 1058:    return 0;
        -: 1059:}
------------------
ensure_iov_space:
   190800: 1035:static int ensure_iov_space(conn *c) {
  190800*: 1036:    assert(c != NULL);
        -: 1037:
   190800: 1038:    if (c->iovused >= c->iovsize) {
    #####: 1039:        int i, iovnum;
    #####: 1040:        struct iovec *new_iov = (struct iovec *)realloc(c->iov,
    #####: 1041:                                (c->iovsize * 2) * sizeof(struct iovec));
    #####: 1042:        if (! new_iov) {
    #####: 1043:            STATS_LOCK();
    #####: 1044:            stats.malloc_fails++;
    #####: 1045:            STATS_UNLOCK();
    #####: 1046:            return -1;
        -: 1047:        }
    #####: 1048:        c->iov = new_iov;
    #####: 1049:        c->iovsize *= 2;
        -: 1050:
        -: 1051:        /* Point all the msghdr structures at the new list. */
    #####: 1052:        for (i = 0, iovnum = 0; i < c->msgused; i++) {
    #####: 1053:            c->msglist[i].msg_iov = &c->iov[iovnum];
    #####: 1054:            iovnum += c->msglist[i].msg_iovlen;
        -: 1055:        }
        -: 1056:    }
        -: 1057:
        -: 1058:    return 0;
        -: 1059:}
------------------
        -: 1060:
        -: 1061:
        -: 1062:/*
        -: 1063: * Adds data to the list of pending data that will be written out to a
        -: 1064: * connection.
        -: 1065: *
        -: 1066: * Returns 0 on success, -1 on out-of-memory.
        -: 1067: * Note: This is a hot path for at least ASCII protocol. While there is
        -: 1068: * redundant code in splitting TCP/UDP handling, any reduction in steps has a
        -: 1069: * large impact for TCP connections.
        -: 1070: */
        -: 1071:
   572400: 1072:static int add_iov(conn *c, const void *buf, int len) {
   572400: 1073:    struct msghdr *m;
   572400: 1074:    int leftover;
        -: 1075:
  572400*: 1076:    assert(c != NULL);
        -: 1077:
   572400: 1078:    if (IS_UDP(c->transport)) {
    #####: 1079:        do {
    #####: 1080:            m = &c->msglist[c->msgused - 1];
        -: 1081:
        -: 1082:            /*
        -: 1083:             * Limit UDP packets to UDP_MAX_PAYLOAD_SIZE bytes.
        -: 1084:             */
        -: 1085:
        -: 1086:            /* We may need to start a new msghdr if this one is full. */
    #####: 1087:            if (m->msg_iovlen == IOV_MAX ||
    #####: 1088:                (c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
    #####: 1089:                add_msghdr(c);
    #####: 1090:                m = &c->msglist[c->msgused - 1];
        -: 1091:            }
        -: 1092:
    #####: 1093:            if (ensure_iov_space(c) != 0)
        -: 1094:                return -1;
        -: 1095:
        -: 1096:            /* If the fragment is too big to fit in the datagram, split it up */
    #####: 1097:            if (len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
    #####: 1098:                leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
    #####: 1099:                len -= leftover;
        -: 1100:            } else {
        -: 1101:                leftover = 0;
        -: 1102:            }
        -: 1103:
    #####: 1104:            m = &c->msglist[c->msgused - 1];
    #####: 1105:            m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
    #####: 1106:            m->msg_iov[m->msg_iovlen].iov_len = len;
        -: 1107:
    #####: 1108:            c->msgbytes += len;
    #####: 1109:            c->iovused++;
    #####: 1110:            m->msg_iovlen++;
        -: 1111:
    #####: 1112:            buf = ((char *)buf) + len;
    #####: 1113:            len = leftover;
    #####: 1114:        } while (leftover > 0);
        -: 1115:    } else {
        -: 1116:        /* Optimized path for TCP connections */
   572400: 1117:        m = &c->msglist[c->msgused - 1];
   572400: 1118:        if (m->msg_iovlen == IOV_MAX) {
    #####: 1119:            add_msghdr(c);
    #####: 1120:            m = &c->msglist[c->msgused - 1];
        -: 1121:        }
        -: 1122:
   572400: 1123:        if (ensure_iov_space(c) != 0)
        -: 1124:            return -1;
        -: 1125:
   572400: 1126:        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
   572400: 1127:        m->msg_iov[m->msg_iovlen].iov_len = len;
   572400: 1128:        c->msgbytes += len;
   572400: 1129:        c->iovused++;
   572400: 1130:        m->msg_iovlen++;
        -: 1131:    }
        -: 1132:
        -: 1133:    return 0;
        -: 1134:}
------------------
add_iov:
   190800: 1072:static int add_iov(conn *c, const void *buf, int len) {
   190800: 1073:    struct msghdr *m;
   190800: 1074:    int leftover;
        -: 1075:
  190800*: 1076:    assert(c != NULL);
        -: 1077:
   190800: 1078:    if (IS_UDP(c->transport)) {
    #####: 1079:        do {
    #####: 1080:            m = &c->msglist[c->msgused - 1];
        -: 1081:
        -: 1082:            /*
        -: 1083:             * Limit UDP packets to UDP_MAX_PAYLOAD_SIZE bytes.
        -: 1084:             */
        -: 1085:
        -: 1086:            /* We may need to start a new msghdr if this one is full. */
    #####: 1087:            if (m->msg_iovlen == IOV_MAX ||
    #####: 1088:                (c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
    #####: 1089:                add_msghdr(c);
    #####: 1090:                m = &c->msglist[c->msgused - 1];
        -: 1091:            }
        -: 1092:
    #####: 1093:            if (ensure_iov_space(c) != 0)
        -: 1094:                return -1;
        -: 1095:
        -: 1096:            /* If the fragment is too big to fit in the datagram, split it up */
    #####: 1097:            if (len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
    #####: 1098:                leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
    #####: 1099:                len -= leftover;
        -: 1100:            } else {
        -: 1101:                leftover = 0;
        -: 1102:            }
        -: 1103:
    #####: 1104:            m = &c->msglist[c->msgused - 1];
    #####: 1105:            m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
    #####: 1106:            m->msg_iov[m->msg_iovlen].iov_len = len;
        -: 1107:
    #####: 1108:            c->msgbytes += len;
    #####: 1109:            c->iovused++;
    #####: 1110:            m->msg_iovlen++;
        -: 1111:
    #####: 1112:            buf = ((char *)buf) + len;
    #####: 1113:            len = leftover;
    #####: 1114:        } while (leftover > 0);
        -: 1115:    } else {
        -: 1116:        /* Optimized path for TCP connections */
   190800: 1117:        m = &c->msglist[c->msgused - 1];
   190800: 1118:        if (m->msg_iovlen == IOV_MAX) {
    #####: 1119:            add_msghdr(c);
    #####: 1120:            m = &c->msglist[c->msgused - 1];
        -: 1121:        }
        -: 1122:
   190800: 1123:        if (ensure_iov_space(c) != 0)
        -: 1124:            return -1;
        -: 1125:
   190800: 1126:        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
   190800: 1127:        m->msg_iov[m->msg_iovlen].iov_len = len;
   190800: 1128:        c->msgbytes += len;
   190800: 1129:        c->iovused++;
   190800: 1130:        m->msg_iovlen++;
        -: 1131:    }
        -: 1132:
        -: 1133:    return 0;
        -: 1134:}
------------------
add_iov:
   190800: 1072:static int add_iov(conn *c, const void *buf, int len) {
   190800: 1073:    struct msghdr *m;
   190800: 1074:    int leftover;
        -: 1075:
  190800*: 1076:    assert(c != NULL);
        -: 1077:
   190800: 1078:    if (IS_UDP(c->transport)) {
    #####: 1079:        do {
    #####: 1080:            m = &c->msglist[c->msgused - 1];
        -: 1081:
        -: 1082:            /*
        -: 1083:             * Limit UDP packets to UDP_MAX_PAYLOAD_SIZE bytes.
        -: 1084:             */
        -: 1085:
        -: 1086:            /* We may need to start a new msghdr if this one is full. */
    #####: 1087:            if (m->msg_iovlen == IOV_MAX ||
    #####: 1088:                (c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
    #####: 1089:                add_msghdr(c);
    #####: 1090:                m = &c->msglist[c->msgused - 1];
        -: 1091:            }
        -: 1092:
    #####: 1093:            if (ensure_iov_space(c) != 0)
        -: 1094:                return -1;
        -: 1095:
        -: 1096:            /* If the fragment is too big to fit in the datagram, split it up */
    #####: 1097:            if (len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
    #####: 1098:                leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
    #####: 1099:                len -= leftover;
        -: 1100:            } else {
        -: 1101:                leftover = 0;
        -: 1102:            }
        -: 1103:
    #####: 1104:            m = &c->msglist[c->msgused - 1];
    #####: 1105:            m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
    #####: 1106:            m->msg_iov[m->msg_iovlen].iov_len = len;
        -: 1107:
    #####: 1108:            c->msgbytes += len;
    #####: 1109:            c->iovused++;
    #####: 1110:            m->msg_iovlen++;
        -: 1111:
    #####: 1112:            buf = ((char *)buf) + len;
    #####: 1113:            len = leftover;
    #####: 1114:        } while (leftover > 0);
        -: 1115:    } else {
        -: 1116:        /* Optimized path for TCP connections */
   190800: 1117:        m = &c->msglist[c->msgused - 1];
   190800: 1118:        if (m->msg_iovlen == IOV_MAX) {
    #####: 1119:            add_msghdr(c);
    #####: 1120:            m = &c->msglist[c->msgused - 1];
        -: 1121:        }
        -: 1122:
   190800: 1123:        if (ensure_iov_space(c) != 0)
        -: 1124:            return -1;
        -: 1125:
   190800: 1126:        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
   190800: 1127:        m->msg_iov[m->msg_iovlen].iov_len = len;
   190800: 1128:        c->msgbytes += len;
   190800: 1129:        c->iovused++;
   190800: 1130:        m->msg_iovlen++;
        -: 1131:    }
        -: 1132:
        -: 1133:    return 0;
        -: 1134:}
------------------
add_iov:
   190800: 1072:static int add_iov(conn *c, const void *buf, int len) {
   190800: 1073:    struct msghdr *m;
   190800: 1074:    int leftover;
        -: 1075:
  190800*: 1076:    assert(c != NULL);
        -: 1077:
   190800: 1078:    if (IS_UDP(c->transport)) {
    #####: 1079:        do {
    #####: 1080:            m = &c->msglist[c->msgused - 1];
        -: 1081:
        -: 1082:            /*
        -: 1083:             * Limit UDP packets to UDP_MAX_PAYLOAD_SIZE bytes.
        -: 1084:             */
        -: 1085:
        -: 1086:            /* We may need to start a new msghdr if this one is full. */
    #####: 1087:            if (m->msg_iovlen == IOV_MAX ||
    #####: 1088:                (c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {
    #####: 1089:                add_msghdr(c);
    #####: 1090:                m = &c->msglist[c->msgused - 1];
        -: 1091:            }
        -: 1092:
    #####: 1093:            if (ensure_iov_space(c) != 0)
        -: 1094:                return -1;
        -: 1095:
        -: 1096:            /* If the fragment is too big to fit in the datagram, split it up */
    #####: 1097:            if (len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
    #####: 1098:                leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
    #####: 1099:                len -= leftover;
        -: 1100:            } else {
        -: 1101:                leftover = 0;
        -: 1102:            }
        -: 1103:
    #####: 1104:            m = &c->msglist[c->msgused - 1];
    #####: 1105:            m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
    #####: 1106:            m->msg_iov[m->msg_iovlen].iov_len = len;
        -: 1107:
    #####: 1108:            c->msgbytes += len;
    #####: 1109:            c->iovused++;
    #####: 1110:            m->msg_iovlen++;
        -: 1111:
    #####: 1112:            buf = ((char *)buf) + len;
    #####: 1113:            len = leftover;
    #####: 1114:        } while (leftover > 0);
        -: 1115:    } else {
        -: 1116:        /* Optimized path for TCP connections */
   190800: 1117:        m = &c->msglist[c->msgused - 1];
   190800: 1118:        if (m->msg_iovlen == IOV_MAX) {
    #####: 1119:            add_msghdr(c);
    #####: 1120:            m = &c->msglist[c->msgused - 1];
        -: 1121:        }
        -: 1122:
   190800: 1123:        if (ensure_iov_space(c) != 0)
        -: 1124:            return -1;
        -: 1125:
   190800: 1126:        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;
   190800: 1127:        m->msg_iov[m->msg_iovlen].iov_len = len;
   190800: 1128:        c->msgbytes += len;
   190800: 1129:        c->iovused++;
   190800: 1130:        m->msg_iovlen++;
        -: 1131:    }
        -: 1132:
        -: 1133:    return 0;
        -: 1134:}
------------------
        -: 1135:
    #####: 1136:static int add_chunked_item_iovs(conn *c, item *it, int len) {
    #####: 1137:    assert(it->it_flags & ITEM_CHUNKED);
    #####: 1138:    item_chunk *ch = (item_chunk *) ITEM_schunk(it);
    #####: 1139:    while (ch) {
    #####: 1140:        int todo = (len > ch->used) ? ch->used : len;
    #####: 1141:        if (add_iov(c, ch->data, todo) != 0) {
        -: 1142:            return -1;
        -: 1143:        }
    #####: 1144:        ch = ch->next;
    #####: 1145:        len -= todo;
        -: 1146:    }
        -: 1147:    return 0;
        -: 1148:}
------------------
add_chunked_item_iovs:
    #####: 1136:static int add_chunked_item_iovs(conn *c, item *it, int len) {
    #####: 1137:    assert(it->it_flags & ITEM_CHUNKED);
    #####: 1138:    item_chunk *ch = (item_chunk *) ITEM_schunk(it);
    #####: 1139:    while (ch) {
    #####: 1140:        int todo = (len > ch->used) ? ch->used : len;
    #####: 1141:        if (add_iov(c, ch->data, todo) != 0) {
        -: 1142:            return -1;
        -: 1143:        }
    #####: 1144:        ch = ch->next;
    #####: 1145:        len -= todo;
        -: 1146:    }
        -: 1147:    return 0;
        -: 1148:}
------------------
add_chunked_item_iovs:
    #####: 1136:static int add_chunked_item_iovs(conn *c, item *it, int len) {
    #####: 1137:    assert(it->it_flags & ITEM_CHUNKED);
    #####: 1138:    item_chunk *ch = (item_chunk *) ITEM_schunk(it);
    #####: 1139:    while (ch) {
    #####: 1140:        int todo = (len > ch->used) ? ch->used : len;
    #####: 1141:        if (add_iov(c, ch->data, todo) != 0) {
        -: 1142:            return -1;
        -: 1143:        }
    #####: 1144:        ch = ch->next;
    #####: 1145:        len -= todo;
        -: 1146:    }
        -: 1147:    return 0;
        -: 1148:}
------------------
add_chunked_item_iovs:
    #####: 1136:static int add_chunked_item_iovs(conn *c, item *it, int len) {
    #####: 1137:    assert(it->it_flags & ITEM_CHUNKED);
    #####: 1138:    item_chunk *ch = (item_chunk *) ITEM_schunk(it);
    #####: 1139:    while (ch) {
    #####: 1140:        int todo = (len > ch->used) ? ch->used : len;
    #####: 1141:        if (add_iov(c, ch->data, todo) != 0) {
        -: 1142:            return -1;
        -: 1143:        }
    #####: 1144:        ch = ch->next;
    #####: 1145:        len -= todo;
        -: 1146:    }
        -: 1147:    return 0;
        -: 1148:}
------------------
        -: 1149:
        -: 1150:/*
        -: 1151: * Constructs a set of UDP headers and attaches them to the outgoing messages.
        -: 1152: */
    #####: 1153:static int build_udp_headers(conn *c) {
    #####: 1154:    int i;
    #####: 1155:    unsigned char *hdr;
        -: 1156:
    #####: 1157:    assert(c != NULL);
        -: 1158:
    #####: 1159:    if (c->msgused > c->hdrsize) {
    #####: 1160:        void *new_hdrbuf;
    #####: 1161:        if (c->hdrbuf) {
    #####: 1162:            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1163:        } else {
    #####: 1164:            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1165:        }
        -: 1166:
    #####: 1167:        if (! new_hdrbuf) {
    #####: 1168:            STATS_LOCK();
    #####: 1169:            stats.malloc_fails++;
    #####: 1170:            STATS_UNLOCK();
    #####: 1171:            return -1;
        -: 1172:        }
    #####: 1173:        c->hdrbuf = (unsigned char *)new_hdrbuf;
    #####: 1174:        c->hdrsize = c->msgused * 2;
        -: 1175:    }
        -: 1176:
    #####: 1177:    hdr = c->hdrbuf;
    #####: 1178:    for (i = 0; i < c->msgused; i++) {
    #####: 1179:        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
    #####: 1180:        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
    #####: 1181:        *hdr++ = c->request_id / 256;
    #####: 1182:        *hdr++ = c->request_id % 256;
    #####: 1183:        *hdr++ = i / 256;
    #####: 1184:        *hdr++ = i % 256;
    #####: 1185:        *hdr++ = c->msgused / 256;
    #####: 1186:        *hdr++ = c->msgused % 256;
    #####: 1187:        *hdr++ = 0;
    #####: 1188:        *hdr++ = 0;
    #####: 1189:        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
        -: 1190:    }
        -: 1191:
        -: 1192:    return 0;
        -: 1193:}
------------------
build_udp_headers:
    #####: 1153:static int build_udp_headers(conn *c) {
    #####: 1154:    int i;
    #####: 1155:    unsigned char *hdr;
        -: 1156:
    #####: 1157:    assert(c != NULL);
        -: 1158:
    #####: 1159:    if (c->msgused > c->hdrsize) {
    #####: 1160:        void *new_hdrbuf;
    #####: 1161:        if (c->hdrbuf) {
    #####: 1162:            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1163:        } else {
    #####: 1164:            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1165:        }
        -: 1166:
    #####: 1167:        if (! new_hdrbuf) {
    #####: 1168:            STATS_LOCK();
    #####: 1169:            stats.malloc_fails++;
    #####: 1170:            STATS_UNLOCK();
    #####: 1171:            return -1;
        -: 1172:        }
    #####: 1173:        c->hdrbuf = (unsigned char *)new_hdrbuf;
    #####: 1174:        c->hdrsize = c->msgused * 2;
        -: 1175:    }
        -: 1176:
    #####: 1177:    hdr = c->hdrbuf;
    #####: 1178:    for (i = 0; i < c->msgused; i++) {
    #####: 1179:        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
    #####: 1180:        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
    #####: 1181:        *hdr++ = c->request_id / 256;
    #####: 1182:        *hdr++ = c->request_id % 256;
    #####: 1183:        *hdr++ = i / 256;
    #####: 1184:        *hdr++ = i % 256;
    #####: 1185:        *hdr++ = c->msgused / 256;
    #####: 1186:        *hdr++ = c->msgused % 256;
    #####: 1187:        *hdr++ = 0;
    #####: 1188:        *hdr++ = 0;
    #####: 1189:        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
        -: 1190:    }
        -: 1191:
        -: 1192:    return 0;
        -: 1193:}
------------------
build_udp_headers:
    #####: 1153:static int build_udp_headers(conn *c) {
    #####: 1154:    int i;
    #####: 1155:    unsigned char *hdr;
        -: 1156:
    #####: 1157:    assert(c != NULL);
        -: 1158:
    #####: 1159:    if (c->msgused > c->hdrsize) {
    #####: 1160:        void *new_hdrbuf;
    #####: 1161:        if (c->hdrbuf) {
    #####: 1162:            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1163:        } else {
    #####: 1164:            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1165:        }
        -: 1166:
    #####: 1167:        if (! new_hdrbuf) {
    #####: 1168:            STATS_LOCK();
    #####: 1169:            stats.malloc_fails++;
    #####: 1170:            STATS_UNLOCK();
    #####: 1171:            return -1;
        -: 1172:        }
    #####: 1173:        c->hdrbuf = (unsigned char *)new_hdrbuf;
    #####: 1174:        c->hdrsize = c->msgused * 2;
        -: 1175:    }
        -: 1176:
    #####: 1177:    hdr = c->hdrbuf;
    #####: 1178:    for (i = 0; i < c->msgused; i++) {
    #####: 1179:        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
    #####: 1180:        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
    #####: 1181:        *hdr++ = c->request_id / 256;
    #####: 1182:        *hdr++ = c->request_id % 256;
    #####: 1183:        *hdr++ = i / 256;
    #####: 1184:        *hdr++ = i % 256;
    #####: 1185:        *hdr++ = c->msgused / 256;
    #####: 1186:        *hdr++ = c->msgused % 256;
    #####: 1187:        *hdr++ = 0;
    #####: 1188:        *hdr++ = 0;
    #####: 1189:        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
        -: 1190:    }
        -: 1191:
        -: 1192:    return 0;
        -: 1193:}
------------------
build_udp_headers:
    #####: 1153:static int build_udp_headers(conn *c) {
    #####: 1154:    int i;
    #####: 1155:    unsigned char *hdr;
        -: 1156:
    #####: 1157:    assert(c != NULL);
        -: 1158:
    #####: 1159:    if (c->msgused > c->hdrsize) {
    #####: 1160:        void *new_hdrbuf;
    #####: 1161:        if (c->hdrbuf) {
    #####: 1162:            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1163:        } else {
    #####: 1164:            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);
        -: 1165:        }
        -: 1166:
    #####: 1167:        if (! new_hdrbuf) {
    #####: 1168:            STATS_LOCK();
    #####: 1169:            stats.malloc_fails++;
    #####: 1170:            STATS_UNLOCK();
    #####: 1171:            return -1;
        -: 1172:        }
    #####: 1173:        c->hdrbuf = (unsigned char *)new_hdrbuf;
    #####: 1174:        c->hdrsize = c->msgused * 2;
        -: 1175:    }
        -: 1176:
    #####: 1177:    hdr = c->hdrbuf;
    #####: 1178:    for (i = 0; i < c->msgused; i++) {
    #####: 1179:        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;
    #####: 1180:        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;
    #####: 1181:        *hdr++ = c->request_id / 256;
    #####: 1182:        *hdr++ = c->request_id % 256;
    #####: 1183:        *hdr++ = i / 256;
    #####: 1184:        *hdr++ = i % 256;
    #####: 1185:        *hdr++ = c->msgused / 256;
    #####: 1186:        *hdr++ = c->msgused % 256;
    #####: 1187:        *hdr++ = 0;
    #####: 1188:        *hdr++ = 0;
    #####: 1189:        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);
        -: 1190:    }
        -: 1191:
        -: 1192:    return 0;
        -: 1193:}
------------------
        -: 1194:
        -: 1195:
    #####: 1196:static void out_string(conn *c, const char *str) {
    #####: 1197:    size_t len;
        -: 1198:
    #####: 1199:    assert(c != NULL);
        -: 1200:
    #####: 1201:    if (c->noreply) {
    #####: 1202:        if (settings.verbose > 1)
    #####: 1203:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
    #####: 1204:        c->noreply = false;
    #####: 1205:        conn_set_state(c, conn_new_cmd);
    #####: 1206:        return;
        -: 1207:    }
        -: 1208:
    #####: 1209:    if (settings.verbose > 1)
    #####: 1210:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -: 1211:
        -: 1212:    /* Nuke a partial output... */
    #####: 1213:    c->msgcurr = 0;
    #####: 1214:    c->msgused = 0;
    #####: 1215:    c->iovused = 0;
    #####: 1216:    add_msghdr(c);
        -: 1217:
    #####: 1218:    len = strlen(str);
    #####: 1219:    if ((len + 2) > c->wsize) {
        -: 1220:        /* ought to be always enough. just fail for simplicity */
    #####: 1221:        str = "SERVER_ERROR output line too long";
    #####: 1222:        len = strlen(str);
        -: 1223:    }
        -: 1224:
    #####: 1225:    memcpy(c->wbuf, str, len);
    #####: 1226:    memcpy(c->wbuf + len, "\r\n", 2);
    #####: 1227:    c->wbytes = len + 2;
    #####: 1228:    c->wcurr = c->wbuf;
        -: 1229:
    #####: 1230:    conn_set_state(c, conn_write);
    #####: 1231:    c->write_and_go = conn_new_cmd;
    #####: 1232:    return;
        -: 1233:}
------------------
out_string:
    #####: 1196:static void out_string(conn *c, const char *str) {
    #####: 1197:    size_t len;
        -: 1198:
    #####: 1199:    assert(c != NULL);
        -: 1200:
    #####: 1201:    if (c->noreply) {
    #####: 1202:        if (settings.verbose > 1)
    #####: 1203:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
    #####: 1204:        c->noreply = false;
    #####: 1205:        conn_set_state(c, conn_new_cmd);
    #####: 1206:        return;
        -: 1207:    }
        -: 1208:
    #####: 1209:    if (settings.verbose > 1)
    #####: 1210:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -: 1211:
        -: 1212:    /* Nuke a partial output... */
    #####: 1213:    c->msgcurr = 0;
    #####: 1214:    c->msgused = 0;
    #####: 1215:    c->iovused = 0;
    #####: 1216:    add_msghdr(c);
        -: 1217:
    #####: 1218:    len = strlen(str);
    #####: 1219:    if ((len + 2) > c->wsize) {
        -: 1220:        /* ought to be always enough. just fail for simplicity */
    #####: 1221:        str = "SERVER_ERROR output line too long";
    #####: 1222:        len = strlen(str);
        -: 1223:    }
        -: 1224:
    #####: 1225:    memcpy(c->wbuf, str, len);
    #####: 1226:    memcpy(c->wbuf + len, "\r\n", 2);
    #####: 1227:    c->wbytes = len + 2;
    #####: 1228:    c->wcurr = c->wbuf;
        -: 1229:
    #####: 1230:    conn_set_state(c, conn_write);
    #####: 1231:    c->write_and_go = conn_new_cmd;
    #####: 1232:    return;
        -: 1233:}
------------------
out_string:
    #####: 1196:static void out_string(conn *c, const char *str) {
    #####: 1197:    size_t len;
        -: 1198:
    #####: 1199:    assert(c != NULL);
        -: 1200:
    #####: 1201:    if (c->noreply) {
    #####: 1202:        if (settings.verbose > 1)
    #####: 1203:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
    #####: 1204:        c->noreply = false;
    #####: 1205:        conn_set_state(c, conn_new_cmd);
    #####: 1206:        return;
        -: 1207:    }
        -: 1208:
    #####: 1209:    if (settings.verbose > 1)
    #####: 1210:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -: 1211:
        -: 1212:    /* Nuke a partial output... */
    #####: 1213:    c->msgcurr = 0;
    #####: 1214:    c->msgused = 0;
    #####: 1215:    c->iovused = 0;
    #####: 1216:    add_msghdr(c);
        -: 1217:
    #####: 1218:    len = strlen(str);
    #####: 1219:    if ((len + 2) > c->wsize) {
        -: 1220:        /* ought to be always enough. just fail for simplicity */
    #####: 1221:        str = "SERVER_ERROR output line too long";
    #####: 1222:        len = strlen(str);
        -: 1223:    }
        -: 1224:
    #####: 1225:    memcpy(c->wbuf, str, len);
    #####: 1226:    memcpy(c->wbuf + len, "\r\n", 2);
    #####: 1227:    c->wbytes = len + 2;
    #####: 1228:    c->wcurr = c->wbuf;
        -: 1229:
    #####: 1230:    conn_set_state(c, conn_write);
    #####: 1231:    c->write_and_go = conn_new_cmd;
    #####: 1232:    return;
        -: 1233:}
------------------
out_string:
    #####: 1196:static void out_string(conn *c, const char *str) {
    #####: 1197:    size_t len;
        -: 1198:
    #####: 1199:    assert(c != NULL);
        -: 1200:
    #####: 1201:    if (c->noreply) {
    #####: 1202:        if (settings.verbose > 1)
    #####: 1203:            fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
    #####: 1204:        c->noreply = false;
    #####: 1205:        conn_set_state(c, conn_new_cmd);
    #####: 1206:        return;
        -: 1207:    }
        -: 1208:
    #####: 1209:    if (settings.verbose > 1)
    #####: 1210:        fprintf(stderr, ">%d %s\n", c->sfd, str);
        -: 1211:
        -: 1212:    /* Nuke a partial output... */
    #####: 1213:    c->msgcurr = 0;
    #####: 1214:    c->msgused = 0;
    #####: 1215:    c->iovused = 0;
    #####: 1216:    add_msghdr(c);
        -: 1217:
    #####: 1218:    len = strlen(str);
    #####: 1219:    if ((len + 2) > c->wsize) {
        -: 1220:        /* ought to be always enough. just fail for simplicity */
    #####: 1221:        str = "SERVER_ERROR output line too long";
    #####: 1222:        len = strlen(str);
        -: 1223:    }
        -: 1224:
    #####: 1225:    memcpy(c->wbuf, str, len);
    #####: 1226:    memcpy(c->wbuf + len, "\r\n", 2);
    #####: 1227:    c->wbytes = len + 2;
    #####: 1228:    c->wcurr = c->wbuf;
        -: 1229:
    #####: 1230:    conn_set_state(c, conn_write);
    #####: 1231:    c->write_and_go = conn_new_cmd;
    #####: 1232:    return;
        -: 1233:}
------------------
        -: 1234:
        -: 1235:/*
        -: 1236: * Outputs a protocol-specific "out of memory" error. For ASCII clients,
        -: 1237: * this is equivalent to out_string().
        -: 1238: */
    #####: 1239:static void out_of_memory(conn *c, char *ascii_error) {
    #####: 1240:    const static char error_prefix[] = "SERVER_ERROR ";
    #####: 1241:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -: 1242:
    #####: 1243:    if (c->protocol == binary_prot) {
        -: 1244:        /* Strip off the generic error prefix; it's irrelevant in binary */
    #####: 1245:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    #####: 1246:            ascii_error += error_prefix_len;
        -: 1247:        }
    #####: 1248:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -: 1249:    } else {
    #####: 1250:        out_string(c, ascii_error);
        -: 1251:    }
    #####: 1252:}
------------------
out_of_memory:
    #####: 1239:static void out_of_memory(conn *c, char *ascii_error) {
    #####: 1240:    const static char error_prefix[] = "SERVER_ERROR ";
    #####: 1241:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -: 1242:
    #####: 1243:    if (c->protocol == binary_prot) {
        -: 1244:        /* Strip off the generic error prefix; it's irrelevant in binary */
    #####: 1245:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    #####: 1246:            ascii_error += error_prefix_len;
        -: 1247:        }
    #####: 1248:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -: 1249:    } else {
    #####: 1250:        out_string(c, ascii_error);
        -: 1251:    }
    #####: 1252:}
------------------
out_of_memory:
    #####: 1239:static void out_of_memory(conn *c, char *ascii_error) {
    #####: 1240:    const static char error_prefix[] = "SERVER_ERROR ";
    #####: 1241:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -: 1242:
    #####: 1243:    if (c->protocol == binary_prot) {
        -: 1244:        /* Strip off the generic error prefix; it's irrelevant in binary */
    #####: 1245:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    #####: 1246:            ascii_error += error_prefix_len;
        -: 1247:        }
    #####: 1248:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -: 1249:    } else {
    #####: 1250:        out_string(c, ascii_error);
        -: 1251:    }
    #####: 1252:}
------------------
out_of_memory:
    #####: 1239:static void out_of_memory(conn *c, char *ascii_error) {
    #####: 1240:    const static char error_prefix[] = "SERVER_ERROR ";
    #####: 1241:    const static int error_prefix_len = sizeof(error_prefix) - 1;
        -: 1242:
    #####: 1243:    if (c->protocol == binary_prot) {
        -: 1244:        /* Strip off the generic error prefix; it's irrelevant in binary */
    #####: 1245:        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
    #####: 1246:            ascii_error += error_prefix_len;
        -: 1247:        }
    #####: 1248:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
        -: 1249:    } else {
    #####: 1250:        out_string(c, ascii_error);
        -: 1251:    }
    #####: 1252:}
------------------
        -: 1253:
        -: 1254:/*
        -: 1255: * we get here after reading the value in set/add/replace commands. The command
        -: 1256: * has been stored in c->cmd, and the item is ready in c->item.
        -: 1257: */
    #####: 1258:static void complete_nread_ascii(conn *c) {
    #####: 1259:    assert(c != NULL);
        -: 1260:
    #####: 1261:    item *it = c->item;
    #####: 1262:    int comm = c->cmd;
    #####: 1263:    enum store_item_type ret;
    #####: 1264:    bool is_valid = false;
        -: 1265:
    #####: 1266:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1267:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    #####: 1268:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1269:
    #####: 1270:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1271:        if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
        -: 1272:            is_valid = true;
        -: 1273:        }
        -: 1274:    } else {
    #####: 1275:        char buf[2];
        -: 1276:        /* should point to the final item chunk */
    #####: 1277:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1278:        assert(ch->used != 0);
        -: 1279:        /* :( We need to look at the last two bytes. This could span two
        -: 1280:         * chunks.
        -: 1281:         */
    #####: 1282:        if (ch->used > 1) {
    #####: 1283:            buf[0] = ch->data[ch->used - 2];
    #####: 1284:            buf[1] = ch->data[ch->used - 1];
        -: 1285:        } else {
    #####: 1286:            assert(ch->prev);
    #####: 1287:            assert(ch->used == 1);
    #####: 1288:            buf[0] = ch->prev->data[ch->prev->used - 1];
    #####: 1289:            buf[1] = ch->data[ch->used - 1];
        -: 1290:        }
    #####: 1291:        if (strncmp(buf, "\r\n", 2) == 0) {
    #####: 1292:            is_valid = true;
        -: 1293:        } else {
    #####: 1294:            assert(1 == 0);
        -: 1295:        }
        -: 1296:    }
        -: 1297:
    #####: 1298:    if (!is_valid) {
    #####: 1299:        out_string(c, "CLIENT_ERROR bad data chunk");
        -: 1300:    } else {
    #####: 1301:      ret = store_item(it, comm, c);
        -: 1302:
        -: 1303:#ifdef ENABLE_DTRACE
        -: 1304:      uint64_t cas = ITEM_get_cas(it);
        -: 1305:      switch (c->cmd) {
        -: 1306:      case NREAD_ADD:
        -: 1307:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1308:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1309:          break;
        -: 1310:      case NREAD_REPLACE:
        -: 1311:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1312:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1313:          break;
        -: 1314:      case NREAD_APPEND:
        -: 1315:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1316:                                   (ret == 1) ? it->nbytes : -1, cas);
        -: 1317:          break;
        -: 1318:      case NREAD_PREPEND:
        -: 1319:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1320:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1321:          break;
        -: 1322:      case NREAD_SET:
        -: 1323:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1324:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1325:          break;
        -: 1326:      case NREAD_CAS:
        -: 1327:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -: 1328:                                cas);
        -: 1329:          break;
        -: 1330:      }
        -: 1331:#endif
        -: 1332:
    #####: 1333:      switch (ret) {
    #####: 1334:      case STORED:
    #####: 1335:          out_string(c, "STORED");
    #####: 1336:          break;
    #####: 1337:      case EXISTS:
    #####: 1338:          out_string(c, "EXISTS");
    #####: 1339:          break;
    #####: 1340:      case NOT_FOUND:
    #####: 1341:          out_string(c, "NOT_FOUND");
    #####: 1342:          break;
    #####: 1343:      case NOT_STORED:
    #####: 1344:          out_string(c, "NOT_STORED");
    #####: 1345:          break;
    #####: 1346:      default:
    #####: 1347:          out_string(c, "SERVER_ERROR Unhandled storage type.");
        -: 1348:      }
        -: 1349:
        -: 1350:    }
        -: 1351:
    #####: 1352:    item_remove(c->item);       /* release the c->item reference */
    #####: 1353:    c->item = 0;
    #####: 1354:}
------------------
complete_nread_ascii:
    #####: 1258:static void complete_nread_ascii(conn *c) {
    #####: 1259:    assert(c != NULL);
        -: 1260:
    #####: 1261:    item *it = c->item;
    #####: 1262:    int comm = c->cmd;
    #####: 1263:    enum store_item_type ret;
    #####: 1264:    bool is_valid = false;
        -: 1265:
    #####: 1266:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1267:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    #####: 1268:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1269:
    #####: 1270:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1271:        if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
        -: 1272:            is_valid = true;
        -: 1273:        }
        -: 1274:    } else {
    #####: 1275:        char buf[2];
        -: 1276:        /* should point to the final item chunk */
    #####: 1277:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1278:        assert(ch->used != 0);
        -: 1279:        /* :( We need to look at the last two bytes. This could span two
        -: 1280:         * chunks.
        -: 1281:         */
    #####: 1282:        if (ch->used > 1) {
    #####: 1283:            buf[0] = ch->data[ch->used - 2];
    #####: 1284:            buf[1] = ch->data[ch->used - 1];
        -: 1285:        } else {
    #####: 1286:            assert(ch->prev);
    #####: 1287:            assert(ch->used == 1);
    #####: 1288:            buf[0] = ch->prev->data[ch->prev->used - 1];
    #####: 1289:            buf[1] = ch->data[ch->used - 1];
        -: 1290:        }
    #####: 1291:        if (strncmp(buf, "\r\n", 2) == 0) {
    #####: 1292:            is_valid = true;
        -: 1293:        } else {
    #####: 1294:            assert(1 == 0);
        -: 1295:        }
        -: 1296:    }
        -: 1297:
    #####: 1298:    if (!is_valid) {
    #####: 1299:        out_string(c, "CLIENT_ERROR bad data chunk");
        -: 1300:    } else {
    #####: 1301:      ret = store_item(it, comm, c);
        -: 1302:
        -: 1303:#ifdef ENABLE_DTRACE
        -: 1304:      uint64_t cas = ITEM_get_cas(it);
        -: 1305:      switch (c->cmd) {
        -: 1306:      case NREAD_ADD:
        -: 1307:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1308:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1309:          break;
        -: 1310:      case NREAD_REPLACE:
        -: 1311:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1312:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1313:          break;
        -: 1314:      case NREAD_APPEND:
        -: 1315:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1316:                                   (ret == 1) ? it->nbytes : -1, cas);
        -: 1317:          break;
        -: 1318:      case NREAD_PREPEND:
        -: 1319:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1320:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1321:          break;
        -: 1322:      case NREAD_SET:
        -: 1323:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1324:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1325:          break;
        -: 1326:      case NREAD_CAS:
        -: 1327:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -: 1328:                                cas);
        -: 1329:          break;
        -: 1330:      }
        -: 1331:#endif
        -: 1332:
    #####: 1333:      switch (ret) {
    #####: 1334:      case STORED:
    #####: 1335:          out_string(c, "STORED");
    #####: 1336:          break;
    #####: 1337:      case EXISTS:
    #####: 1338:          out_string(c, "EXISTS");
    #####: 1339:          break;
    #####: 1340:      case NOT_FOUND:
    #####: 1341:          out_string(c, "NOT_FOUND");
    #####: 1342:          break;
    #####: 1343:      case NOT_STORED:
    #####: 1344:          out_string(c, "NOT_STORED");
    #####: 1345:          break;
    #####: 1346:      default:
    #####: 1347:          out_string(c, "SERVER_ERROR Unhandled storage type.");
        -: 1348:      }
        -: 1349:
        -: 1350:    }
        -: 1351:
    #####: 1352:    item_remove(c->item);       /* release the c->item reference */
    #####: 1353:    c->item = 0;
    #####: 1354:}
------------------
complete_nread_ascii:
    #####: 1258:static void complete_nread_ascii(conn *c) {
    #####: 1259:    assert(c != NULL);
        -: 1260:
    #####: 1261:    item *it = c->item;
    #####: 1262:    int comm = c->cmd;
    #####: 1263:    enum store_item_type ret;
    #####: 1264:    bool is_valid = false;
        -: 1265:
    #####: 1266:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1267:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    #####: 1268:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1269:
    #####: 1270:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1271:        if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
        -: 1272:            is_valid = true;
        -: 1273:        }
        -: 1274:    } else {
    #####: 1275:        char buf[2];
        -: 1276:        /* should point to the final item chunk */
    #####: 1277:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1278:        assert(ch->used != 0);
        -: 1279:        /* :( We need to look at the last two bytes. This could span two
        -: 1280:         * chunks.
        -: 1281:         */
    #####: 1282:        if (ch->used > 1) {
    #####: 1283:            buf[0] = ch->data[ch->used - 2];
    #####: 1284:            buf[1] = ch->data[ch->used - 1];
        -: 1285:        } else {
    #####: 1286:            assert(ch->prev);
    #####: 1287:            assert(ch->used == 1);
    #####: 1288:            buf[0] = ch->prev->data[ch->prev->used - 1];
    #####: 1289:            buf[1] = ch->data[ch->used - 1];
        -: 1290:        }
    #####: 1291:        if (strncmp(buf, "\r\n", 2) == 0) {
    #####: 1292:            is_valid = true;
        -: 1293:        } else {
    #####: 1294:            assert(1 == 0);
        -: 1295:        }
        -: 1296:    }
        -: 1297:
    #####: 1298:    if (!is_valid) {
    #####: 1299:        out_string(c, "CLIENT_ERROR bad data chunk");
        -: 1300:    } else {
    #####: 1301:      ret = store_item(it, comm, c);
        -: 1302:
        -: 1303:#ifdef ENABLE_DTRACE
        -: 1304:      uint64_t cas = ITEM_get_cas(it);
        -: 1305:      switch (c->cmd) {
        -: 1306:      case NREAD_ADD:
        -: 1307:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1308:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1309:          break;
        -: 1310:      case NREAD_REPLACE:
        -: 1311:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1312:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1313:          break;
        -: 1314:      case NREAD_APPEND:
        -: 1315:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1316:                                   (ret == 1) ? it->nbytes : -1, cas);
        -: 1317:          break;
        -: 1318:      case NREAD_PREPEND:
        -: 1319:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1320:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1321:          break;
        -: 1322:      case NREAD_SET:
        -: 1323:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1324:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1325:          break;
        -: 1326:      case NREAD_CAS:
        -: 1327:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -: 1328:                                cas);
        -: 1329:          break;
        -: 1330:      }
        -: 1331:#endif
        -: 1332:
    #####: 1333:      switch (ret) {
    #####: 1334:      case STORED:
    #####: 1335:          out_string(c, "STORED");
    #####: 1336:          break;
    #####: 1337:      case EXISTS:
    #####: 1338:          out_string(c, "EXISTS");
    #####: 1339:          break;
    #####: 1340:      case NOT_FOUND:
    #####: 1341:          out_string(c, "NOT_FOUND");
    #####: 1342:          break;
    #####: 1343:      case NOT_STORED:
    #####: 1344:          out_string(c, "NOT_STORED");
    #####: 1345:          break;
    #####: 1346:      default:
    #####: 1347:          out_string(c, "SERVER_ERROR Unhandled storage type.");
        -: 1348:      }
        -: 1349:
        -: 1350:    }
        -: 1351:
    #####: 1352:    item_remove(c->item);       /* release the c->item reference */
    #####: 1353:    c->item = 0;
    #####: 1354:}
------------------
complete_nread_ascii:
    #####: 1258:static void complete_nread_ascii(conn *c) {
    #####: 1259:    assert(c != NULL);
        -: 1260:
    #####: 1261:    item *it = c->item;
    #####: 1262:    int comm = c->cmd;
    #####: 1263:    enum store_item_type ret;
    #####: 1264:    bool is_valid = false;
        -: 1265:
    #####: 1266:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1267:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    #####: 1268:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1269:
    #####: 1270:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1271:        if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
        -: 1272:            is_valid = true;
        -: 1273:        }
        -: 1274:    } else {
    #####: 1275:        char buf[2];
        -: 1276:        /* should point to the final item chunk */
    #####: 1277:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1278:        assert(ch->used != 0);
        -: 1279:        /* :( We need to look at the last two bytes. This could span two
        -: 1280:         * chunks.
        -: 1281:         */
    #####: 1282:        if (ch->used > 1) {
    #####: 1283:            buf[0] = ch->data[ch->used - 2];
    #####: 1284:            buf[1] = ch->data[ch->used - 1];
        -: 1285:        } else {
    #####: 1286:            assert(ch->prev);
    #####: 1287:            assert(ch->used == 1);
    #####: 1288:            buf[0] = ch->prev->data[ch->prev->used - 1];
    #####: 1289:            buf[1] = ch->data[ch->used - 1];
        -: 1290:        }
    #####: 1291:        if (strncmp(buf, "\r\n", 2) == 0) {
    #####: 1292:            is_valid = true;
        -: 1293:        } else {
    #####: 1294:            assert(1 == 0);
        -: 1295:        }
        -: 1296:    }
        -: 1297:
    #####: 1298:    if (!is_valid) {
    #####: 1299:        out_string(c, "CLIENT_ERROR bad data chunk");
        -: 1300:    } else {
    #####: 1301:      ret = store_item(it, comm, c);
        -: 1302:
        -: 1303:#ifdef ENABLE_DTRACE
        -: 1304:      uint64_t cas = ITEM_get_cas(it);
        -: 1305:      switch (c->cmd) {
        -: 1306:      case NREAD_ADD:
        -: 1307:          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1308:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1309:          break;
        -: 1310:      case NREAD_REPLACE:
        -: 1311:          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1312:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1313:          break;
        -: 1314:      case NREAD_APPEND:
        -: 1315:          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1316:                                   (ret == 1) ? it->nbytes : -1, cas);
        -: 1317:          break;
        -: 1318:      case NREAD_PREPEND:
        -: 1319:          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1320:                                    (ret == 1) ? it->nbytes : -1, cas);
        -: 1321:          break;
        -: 1322:      case NREAD_SET:
        -: 1323:          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1324:                                (ret == 1) ? it->nbytes : -1, cas);
        -: 1325:          break;
        -: 1326:      case NREAD_CAS:
        -: 1327:          MEMCACHED_COMMAND_CAS(c->sfd, ITEM_key(it), it->nkey, it->nbytes,
        -: 1328:                                cas);
        -: 1329:          break;
        -: 1330:      }
        -: 1331:#endif
        -: 1332:
    #####: 1333:      switch (ret) {
    #####: 1334:      case STORED:
    #####: 1335:          out_string(c, "STORED");
    #####: 1336:          break;
    #####: 1337:      case EXISTS:
    #####: 1338:          out_string(c, "EXISTS");
    #####: 1339:          break;
    #####: 1340:      case NOT_FOUND:
    #####: 1341:          out_string(c, "NOT_FOUND");
    #####: 1342:          break;
    #####: 1343:      case NOT_STORED:
    #####: 1344:          out_string(c, "NOT_STORED");
    #####: 1345:          break;
    #####: 1346:      default:
    #####: 1347:          out_string(c, "SERVER_ERROR Unhandled storage type.");
        -: 1348:      }
        -: 1349:
        -: 1350:    }
        -: 1351:
    #####: 1352:    item_remove(c->item);       /* release the c->item reference */
    #####: 1353:    c->item = 0;
    #####: 1354:}
------------------
        -: 1355:
        -: 1356:/**
        -: 1357: * get a pointer to the start of the request struct for the current command
        -: 1358: */
    27600: 1359:static void* binary_get_request(conn *c) {
    27600: 1360:    char *ret = c->rcurr;
    55200: 1361:    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
    27600: 1362:            c->binary_header.request.extlen);
        -: 1363:
   27600*: 1364:    assert(ret >= c->rbuf);
    27600: 1365:    return ret;
        -: 1366:}
------------------
binary_get_request:
     9200: 1359:static void* binary_get_request(conn *c) {
     9200: 1360:    char *ret = c->rcurr;
    18400: 1361:    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
     9200: 1362:            c->binary_header.request.extlen);
        -: 1363:
    9200*: 1364:    assert(ret >= c->rbuf);
     9200: 1365:    return ret;
        -: 1366:}
------------------
binary_get_request:
     9200: 1359:static void* binary_get_request(conn *c) {
     9200: 1360:    char *ret = c->rcurr;
    18400: 1361:    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
     9200: 1362:            c->binary_header.request.extlen);
        -: 1363:
    9200*: 1364:    assert(ret >= c->rbuf);
     9200: 1365:    return ret;
        -: 1366:}
------------------
binary_get_request:
     9200: 1359:static void* binary_get_request(conn *c) {
     9200: 1360:    char *ret = c->rcurr;
    18400: 1361:    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +
     9200: 1362:            c->binary_header.request.extlen);
        -: 1363:
    9200*: 1364:    assert(ret >= c->rbuf);
     9200: 1365:    return ret;
        -: 1366:}
------------------
        -: 1367:
        -: 1368:/**
        -: 1369: * get a pointer to the key in this request
        -: 1370: */
    #####: 1371:static char* binary_get_key(conn *c) {
  300000*: 1372:    return c->rcurr - (c->binary_header.request.keylen);
        -: 1373:}
------------------
binary_get_key:
    #####: 1371:static char* binary_get_key(conn *c) {
    #####: 1372:    return c->rcurr - (c->binary_header.request.keylen);
        -: 1373:}
------------------
binary_get_key:
    #####: 1371:static char* binary_get_key(conn *c) {
    #####: 1372:    return c->rcurr - (c->binary_header.request.keylen);
        -: 1373:}
------------------
binary_get_key:
    #####: 1371:static char* binary_get_key(conn *c) {
    #####: 1372:    return c->rcurr - (c->binary_header.request.keylen);
        -: 1373:}
------------------
        -: 1374:
   300000: 1375:static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
   300000: 1376:    protocol_binary_response_header* header;
        -: 1377:
  300000*: 1378:    assert(c);
        -: 1379:
   300000: 1380:    c->msgcurr = 0;
   300000: 1381:    c->msgused = 0;
   300000: 1382:    c->iovused = 0;
   300000: 1383:    if (add_msghdr(c) != 0) {
        -: 1384:        /* This should never run out of memory because iov and msg lists
        -: 1385:         * have minimum sizes big enough to hold an error response.
        -: 1386:         */
    #####: 1387:        out_of_memory(c, "SERVER_ERROR out of memory adding binary header");
    #####: 1388:        return;
        -: 1389:    }
        -: 1390:
   300000: 1391:    header = (protocol_binary_response_header *)c->wbuf;
        -: 1392:
   300000: 1393:    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
   300000: 1394:    header->response.opcode = c->binary_header.request.opcode;
   300000: 1395:    header->response.keylen = (uint16_t)htons(key_len);
        -: 1396:
   300000: 1397:    header->response.extlen = (uint8_t)hdr_len;
   300000: 1398:    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
   300000: 1399:    header->response.status = (uint16_t)htons(err);
        -: 1400:
   300000: 1401:    header->response.bodylen = htonl(body_len);
   300000: 1402:    header->response.opaque = c->opaque;
   300000: 1403:    header->response.cas = htonll(c->cas);
        -: 1404:
   300000: 1405:    if (settings.verbose > 1) {
    #####: 1406:        int ii;
    #####: 1407:        fprintf(stderr, ">%d Writing bin response:", c->sfd);
    #####: 1408:        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
    #####: 1409:            if (ii % 4 == 0) {
    #####: 1410:                fprintf(stderr, "\n>%d  ", c->sfd);
        -: 1411:            }
    #####: 1412:            fprintf(stderr, " 0x%02x", header->bytes[ii]);
        -: 1413:        }
    #####: 1414:        fprintf(stderr, "\n");
        -: 1415:    }
        -: 1416:
   300000: 1417:    add_iov(c, c->wbuf, sizeof(header->response));
        -: 1418:}
------------------
add_bin_header:
   100000: 1375:static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
   100000: 1376:    protocol_binary_response_header* header;
        -: 1377:
  100000*: 1378:    assert(c);
        -: 1379:
   100000: 1380:    c->msgcurr = 0;
   100000: 1381:    c->msgused = 0;
   100000: 1382:    c->iovused = 0;
   100000: 1383:    if (add_msghdr(c) != 0) {
        -: 1384:        /* This should never run out of memory because iov and msg lists
        -: 1385:         * have minimum sizes big enough to hold an error response.
        -: 1386:         */
    #####: 1387:        out_of_memory(c, "SERVER_ERROR out of memory adding binary header");
    #####: 1388:        return;
        -: 1389:    }
        -: 1390:
   100000: 1391:    header = (protocol_binary_response_header *)c->wbuf;
        -: 1392:
   100000: 1393:    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
   100000: 1394:    header->response.opcode = c->binary_header.request.opcode;
   100000: 1395:    header->response.keylen = (uint16_t)htons(key_len);
        -: 1396:
   100000: 1397:    header->response.extlen = (uint8_t)hdr_len;
   100000: 1398:    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
   100000: 1399:    header->response.status = (uint16_t)htons(err);
        -: 1400:
   100000: 1401:    header->response.bodylen = htonl(body_len);
   100000: 1402:    header->response.opaque = c->opaque;
   100000: 1403:    header->response.cas = htonll(c->cas);
        -: 1404:
   100000: 1405:    if (settings.verbose > 1) {
    #####: 1406:        int ii;
    #####: 1407:        fprintf(stderr, ">%d Writing bin response:", c->sfd);
    #####: 1408:        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
    #####: 1409:            if (ii % 4 == 0) {
    #####: 1410:                fprintf(stderr, "\n>%d  ", c->sfd);
        -: 1411:            }
    #####: 1412:            fprintf(stderr, " 0x%02x", header->bytes[ii]);
        -: 1413:        }
    #####: 1414:        fprintf(stderr, "\n");
        -: 1415:    }
        -: 1416:
   100000: 1417:    add_iov(c, c->wbuf, sizeof(header->response));
        -: 1418:}
------------------
add_bin_header:
   100000: 1375:static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
   100000: 1376:    protocol_binary_response_header* header;
        -: 1377:
  100000*: 1378:    assert(c);
        -: 1379:
   100000: 1380:    c->msgcurr = 0;
   100000: 1381:    c->msgused = 0;
   100000: 1382:    c->iovused = 0;
   100000: 1383:    if (add_msghdr(c) != 0) {
        -: 1384:        /* This should never run out of memory because iov and msg lists
        -: 1385:         * have minimum sizes big enough to hold an error response.
        -: 1386:         */
    #####: 1387:        out_of_memory(c, "SERVER_ERROR out of memory adding binary header");
    #####: 1388:        return;
        -: 1389:    }
        -: 1390:
   100000: 1391:    header = (protocol_binary_response_header *)c->wbuf;
        -: 1392:
   100000: 1393:    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
   100000: 1394:    header->response.opcode = c->binary_header.request.opcode;
   100000: 1395:    header->response.keylen = (uint16_t)htons(key_len);
        -: 1396:
   100000: 1397:    header->response.extlen = (uint8_t)hdr_len;
   100000: 1398:    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
   100000: 1399:    header->response.status = (uint16_t)htons(err);
        -: 1400:
   100000: 1401:    header->response.bodylen = htonl(body_len);
   100000: 1402:    header->response.opaque = c->opaque;
   100000: 1403:    header->response.cas = htonll(c->cas);
        -: 1404:
   100000: 1405:    if (settings.verbose > 1) {
    #####: 1406:        int ii;
    #####: 1407:        fprintf(stderr, ">%d Writing bin response:", c->sfd);
    #####: 1408:        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
    #####: 1409:            if (ii % 4 == 0) {
    #####: 1410:                fprintf(stderr, "\n>%d  ", c->sfd);
        -: 1411:            }
    #####: 1412:            fprintf(stderr, " 0x%02x", header->bytes[ii]);
        -: 1413:        }
    #####: 1414:        fprintf(stderr, "\n");
        -: 1415:    }
        -: 1416:
   100000: 1417:    add_iov(c, c->wbuf, sizeof(header->response));
        -: 1418:}
------------------
add_bin_header:
   100000: 1375:static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
   100000: 1376:    protocol_binary_response_header* header;
        -: 1377:
  100000*: 1378:    assert(c);
        -: 1379:
   100000: 1380:    c->msgcurr = 0;
   100000: 1381:    c->msgused = 0;
   100000: 1382:    c->iovused = 0;
   100000: 1383:    if (add_msghdr(c) != 0) {
        -: 1384:        /* This should never run out of memory because iov and msg lists
        -: 1385:         * have minimum sizes big enough to hold an error response.
        -: 1386:         */
    #####: 1387:        out_of_memory(c, "SERVER_ERROR out of memory adding binary header");
    #####: 1388:        return;
        -: 1389:    }
        -: 1390:
   100000: 1391:    header = (protocol_binary_response_header *)c->wbuf;
        -: 1392:
   100000: 1393:    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
   100000: 1394:    header->response.opcode = c->binary_header.request.opcode;
   100000: 1395:    header->response.keylen = (uint16_t)htons(key_len);
        -: 1396:
   100000: 1397:    header->response.extlen = (uint8_t)hdr_len;
   100000: 1398:    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
   100000: 1399:    header->response.status = (uint16_t)htons(err);
        -: 1400:
   100000: 1401:    header->response.bodylen = htonl(body_len);
   100000: 1402:    header->response.opaque = c->opaque;
   100000: 1403:    header->response.cas = htonll(c->cas);
        -: 1404:
   100000: 1405:    if (settings.verbose > 1) {
    #####: 1406:        int ii;
    #####: 1407:        fprintf(stderr, ">%d Writing bin response:", c->sfd);
    #####: 1408:        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
    #####: 1409:            if (ii % 4 == 0) {
    #####: 1410:                fprintf(stderr, "\n>%d  ", c->sfd);
        -: 1411:            }
    #####: 1412:            fprintf(stderr, " 0x%02x", header->bytes[ii]);
        -: 1413:        }
    #####: 1414:        fprintf(stderr, "\n");
        -: 1415:    }
        -: 1416:
   100000: 1417:    add_iov(c, c->wbuf, sizeof(header->response));
        -: 1418:}
------------------
        -: 1419:
        -: 1420:/**
        -: 1421: * Writes a binary error response. If errstr is supplied, it is used as the
        -: 1422: * error text; otherwise a generic description of the error status code is
        -: 1423: * included.
        -: 1424: */
   272400: 1425:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -: 1426:                            const char *errstr, int swallow) {
   272400: 1427:    size_t len;
        -: 1428:
   272400: 1429:    if (!errstr) {
   272400: 1430:        switch (err) {
        -: 1431:        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
        -: 1432:            errstr = "Out of memory";
        -: 1433:            break;
    #####: 1434:        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
    #####: 1435:            errstr = "Unknown command";
    #####: 1436:            break;
   272400: 1437:        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
   272400: 1438:            errstr = "Not found";
   272400: 1439:            break;
    #####: 1440:        case PROTOCOL_BINARY_RESPONSE_EINVAL:
    #####: 1441:            errstr = "Invalid arguments";
    #####: 1442:            break;
    #####: 1443:        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
    #####: 1444:            errstr = "Data exists for key.";
    #####: 1445:            break;
    #####: 1446:        case PROTOCOL_BINARY_RESPONSE_E2BIG:
    #####: 1447:            errstr = "Too large.";
    #####: 1448:            break;
    #####: 1449:        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
    #####: 1450:            errstr = "Non-numeric server-side value for incr or decr";
    #####: 1451:            break;
    #####: 1452:        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
    #####: 1453:            errstr = "Not stored.";
    #####: 1454:            break;
    #####: 1455:        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
    #####: 1456:            errstr = "Auth failure.";
    #####: 1457:            break;
        -: 1458:        default:
    #####: 1459:            assert(false);
        -: 1460:            errstr = "UNHANDLED ERROR";
        -: 1461:            fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
        -: 1462:        }
    #####: 1463:    }
        -: 1464:
   272400: 1465:    if (settings.verbose > 1) {
    #####: 1466:        fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
        -: 1467:    }
        -: 1468:
   272400: 1469:    len = strlen(errstr);
   272400: 1470:    add_bin_header(c, err, 0, 0, len);
   272400: 1471:    if (len > 0) {
   272400: 1472:        add_iov(c, errstr, len);
        -: 1473:    }
   272400: 1474:    conn_set_state(c, conn_mwrite);
   272400: 1475:    if(swallow > 0) {
    #####: 1476:        c->sbytes = swallow;
    #####: 1477:        c->write_and_go = conn_swallow;
        -: 1478:    } else {
   272400: 1479:        c->write_and_go = conn_new_cmd;
        -: 1480:    }
   272400: 1481:}
------------------
write_bin_error:
    90800: 1425:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -: 1426:                            const char *errstr, int swallow) {
    90800: 1427:    size_t len;
        -: 1428:
    90800: 1429:    if (!errstr) {
    90800: 1430:        switch (err) {
        -: 1431:        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
        -: 1432:            errstr = "Out of memory";
        -: 1433:            break;
    #####: 1434:        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
    #####: 1435:            errstr = "Unknown command";
    #####: 1436:            break;
    90800: 1437:        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
    90800: 1438:            errstr = "Not found";
    90800: 1439:            break;
    #####: 1440:        case PROTOCOL_BINARY_RESPONSE_EINVAL:
    #####: 1441:            errstr = "Invalid arguments";
    #####: 1442:            break;
    #####: 1443:        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
    #####: 1444:            errstr = "Data exists for key.";
    #####: 1445:            break;
    #####: 1446:        case PROTOCOL_BINARY_RESPONSE_E2BIG:
    #####: 1447:            errstr = "Too large.";
    #####: 1448:            break;
    #####: 1449:        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
    #####: 1450:            errstr = "Non-numeric server-side value for incr or decr";
    #####: 1451:            break;
    #####: 1452:        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
    #####: 1453:            errstr = "Not stored.";
    #####: 1454:            break;
    #####: 1455:        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
    #####: 1456:            errstr = "Auth failure.";
    #####: 1457:            break;
        -: 1458:        default:
    #####: 1459:            assert(false);
        -: 1460:            errstr = "UNHANDLED ERROR";
        -: 1461:            fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
        -: 1462:        }
    #####: 1463:    }
        -: 1464:
    90800: 1465:    if (settings.verbose > 1) {
    #####: 1466:        fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
        -: 1467:    }
        -: 1468:
    90800: 1469:    len = strlen(errstr);
    90800: 1470:    add_bin_header(c, err, 0, 0, len);
    90800: 1471:    if (len > 0) {
    90800: 1472:        add_iov(c, errstr, len);
        -: 1473:    }
    90800: 1474:    conn_set_state(c, conn_mwrite);
    90800: 1475:    if(swallow > 0) {
    #####: 1476:        c->sbytes = swallow;
    #####: 1477:        c->write_and_go = conn_swallow;
        -: 1478:    } else {
    90800: 1479:        c->write_and_go = conn_new_cmd;
        -: 1480:    }
    90800: 1481:}
------------------
write_bin_error:
    90800: 1425:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -: 1426:                            const char *errstr, int swallow) {
    90800: 1427:    size_t len;
        -: 1428:
    90800: 1429:    if (!errstr) {
    90800: 1430:        switch (err) {
        -: 1431:        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
        -: 1432:            errstr = "Out of memory";
        -: 1433:            break;
    #####: 1434:        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
    #####: 1435:            errstr = "Unknown command";
    #####: 1436:            break;
    90800: 1437:        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
    90800: 1438:            errstr = "Not found";
    90800: 1439:            break;
    #####: 1440:        case PROTOCOL_BINARY_RESPONSE_EINVAL:
    #####: 1441:            errstr = "Invalid arguments";
    #####: 1442:            break;
    #####: 1443:        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
    #####: 1444:            errstr = "Data exists for key.";
    #####: 1445:            break;
    #####: 1446:        case PROTOCOL_BINARY_RESPONSE_E2BIG:
    #####: 1447:            errstr = "Too large.";
    #####: 1448:            break;
    #####: 1449:        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
    #####: 1450:            errstr = "Non-numeric server-side value for incr or decr";
    #####: 1451:            break;
    #####: 1452:        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
    #####: 1453:            errstr = "Not stored.";
    #####: 1454:            break;
    #####: 1455:        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
    #####: 1456:            errstr = "Auth failure.";
    #####: 1457:            break;
        -: 1458:        default:
    #####: 1459:            assert(false);
        -: 1460:            errstr = "UNHANDLED ERROR";
        -: 1461:            fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
        -: 1462:        }
    #####: 1463:    }
        -: 1464:
    90800: 1465:    if (settings.verbose > 1) {
    #####: 1466:        fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
        -: 1467:    }
        -: 1468:
    90800: 1469:    len = strlen(errstr);
    90800: 1470:    add_bin_header(c, err, 0, 0, len);
    90800: 1471:    if (len > 0) {
    90800: 1472:        add_iov(c, errstr, len);
        -: 1473:    }
    90800: 1474:    conn_set_state(c, conn_mwrite);
    90800: 1475:    if(swallow > 0) {
    #####: 1476:        c->sbytes = swallow;
    #####: 1477:        c->write_and_go = conn_swallow;
        -: 1478:    } else {
    90800: 1479:        c->write_and_go = conn_new_cmd;
        -: 1480:    }
    90800: 1481:}
------------------
write_bin_error:
    90800: 1425:static void write_bin_error(conn *c, protocol_binary_response_status err,
        -: 1426:                            const char *errstr, int swallow) {
    90800: 1427:    size_t len;
        -: 1428:
    90800: 1429:    if (!errstr) {
    90800: 1430:        switch (err) {
        -: 1431:        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
        -: 1432:            errstr = "Out of memory";
        -: 1433:            break;
    #####: 1434:        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
    #####: 1435:            errstr = "Unknown command";
    #####: 1436:            break;
    90800: 1437:        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
    90800: 1438:            errstr = "Not found";
    90800: 1439:            break;
    #####: 1440:        case PROTOCOL_BINARY_RESPONSE_EINVAL:
    #####: 1441:            errstr = "Invalid arguments";
    #####: 1442:            break;
    #####: 1443:        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
    #####: 1444:            errstr = "Data exists for key.";
    #####: 1445:            break;
    #####: 1446:        case PROTOCOL_BINARY_RESPONSE_E2BIG:
    #####: 1447:            errstr = "Too large.";
    #####: 1448:            break;
    #####: 1449:        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
    #####: 1450:            errstr = "Non-numeric server-side value for incr or decr";
    #####: 1451:            break;
    #####: 1452:        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
    #####: 1453:            errstr = "Not stored.";
    #####: 1454:            break;
    #####: 1455:        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
    #####: 1456:            errstr = "Auth failure.";
    #####: 1457:            break;
        -: 1458:        default:
    #####: 1459:            assert(false);
        -: 1460:            errstr = "UNHANDLED ERROR";
        -: 1461:            fprintf(stderr, ">%d UNHANDLED ERROR: %d\n", c->sfd, err);
        -: 1462:        }
    #####: 1463:    }
        -: 1464:
    90800: 1465:    if (settings.verbose > 1) {
    #####: 1466:        fprintf(stderr, ">%d Writing an error: %s\n", c->sfd, errstr);
        -: 1467:    }
        -: 1468:
    90800: 1469:    len = strlen(errstr);
    90800: 1470:    add_bin_header(c, err, 0, 0, len);
    90800: 1471:    if (len > 0) {
    90800: 1472:        add_iov(c, errstr, len);
        -: 1473:    }
    90800: 1474:    conn_set_state(c, conn_mwrite);
    90800: 1475:    if(swallow > 0) {
    #####: 1476:        c->sbytes = swallow;
    #####: 1477:        c->write_and_go = conn_swallow;
        -: 1478:    } else {
    90800: 1479:        c->write_and_go = conn_new_cmd;
        -: 1480:    }
    90800: 1481:}
------------------
        -: 1482:
        -: 1483:/* Form and send a response to a command over the binary protocol */
    27600: 1484:static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
   27600*: 1485:    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        -: 1486:        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
    27600: 1487:        add_bin_header(c, 0, hlen, keylen, dlen);
    27600: 1488:        if(dlen > 0) {
    #####: 1489:            add_iov(c, d, dlen);
        -: 1490:        }
    27600: 1491:        conn_set_state(c, conn_mwrite);
    27600: 1492:        c->write_and_go = conn_new_cmd;
        -: 1493:    } else {
    #####: 1494:        conn_set_state(c, conn_new_cmd);
        -: 1495:    }
    27600: 1496:}
------------------
write_bin_response:
     9200: 1484:static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    9200*: 1485:    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        -: 1486:        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
     9200: 1487:        add_bin_header(c, 0, hlen, keylen, dlen);
     9200: 1488:        if(dlen > 0) {
    #####: 1489:            add_iov(c, d, dlen);
        -: 1490:        }
     9200: 1491:        conn_set_state(c, conn_mwrite);
     9200: 1492:        c->write_and_go = conn_new_cmd;
        -: 1493:    } else {
    #####: 1494:        conn_set_state(c, conn_new_cmd);
        -: 1495:    }
     9200: 1496:}
------------------
write_bin_response:
     9200: 1484:static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    9200*: 1485:    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        -: 1486:        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
     9200: 1487:        add_bin_header(c, 0, hlen, keylen, dlen);
     9200: 1488:        if(dlen > 0) {
    #####: 1489:            add_iov(c, d, dlen);
        -: 1490:        }
     9200: 1491:        conn_set_state(c, conn_mwrite);
     9200: 1492:        c->write_and_go = conn_new_cmd;
        -: 1493:    } else {
    #####: 1494:        conn_set_state(c, conn_new_cmd);
        -: 1495:    }
     9200: 1496:}
------------------
write_bin_response:
     9200: 1484:static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    9200*: 1485:    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        -: 1486:        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
     9200: 1487:        add_bin_header(c, 0, hlen, keylen, dlen);
     9200: 1488:        if(dlen > 0) {
    #####: 1489:            add_iov(c, d, dlen);
        -: 1490:        }
     9200: 1491:        conn_set_state(c, conn_mwrite);
     9200: 1492:        c->write_and_go = conn_new_cmd;
        -: 1493:    } else {
    #####: 1494:        conn_set_state(c, conn_new_cmd);
        -: 1495:    }
     9200: 1496:}
------------------
        -: 1497:
    #####: 1498:static void complete_incr_bin(conn *c) {
    #####: 1499:    item *it;
    #####: 1500:    char *key;
    #####: 1501:    size_t nkey;
        -: 1502:    /* Weird magic in add_delta forces me to pad here */
    #####: 1503:    char tmpbuf[INCR_MAX_STORAGE_LEN];
    #####: 1504:    uint64_t cas = 0;
        -: 1505:
    #####: 1506:    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
    #####: 1507:    protocol_binary_request_incr* req = binary_get_request(c);
        -: 1508:
    #####: 1509:    assert(c != NULL);
    #####: 1510:    assert(c->wsize >= sizeof(*rsp));
        -: 1511:
        -: 1512:    /* fix byteorder in the request */
    #####: 1513:    req->message.body.delta = ntohll(req->message.body.delta);
    #####: 1514:    req->message.body.initial = ntohll(req->message.body.initial);
    #####: 1515:    req->message.body.expiration = ntohl(req->message.body.expiration);
    #####: 1516:    key = binary_get_key(c);
    #####: 1517:    nkey = c->binary_header.request.keylen;
        -: 1518:
    #####: 1519:    if (settings.verbose > 1) {
    #####: 1520:        int i;
    #####: 1521:        fprintf(stderr, "incr ");
        -: 1522:
    #####: 1523:        for (i = 0; i < nkey; i++) {
    #####: 1524:            fprintf(stderr, "%c", key[i]);
        -: 1525:        }
    #####: 1526:        fprintf(stderr, " %lld, %llu, %d\n",
    #####: 1527:                (long long)req->message.body.delta,
    #####: 1528:                (long long)req->message.body.initial,
        -: 1529:                req->message.body.expiration);
        -: 1530:    }
        -: 1531:
    #####: 1532:    if (c->binary_header.request.cas != 0) {
    #####: 1533:        cas = c->binary_header.request.cas;
        -: 1534:    }
    #####: 1535:    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
    #####: 1536:                     req->message.body.delta, tmpbuf,
        -: 1537:                     &cas)) {
    #####: 1538:    case OK:
    #####: 1539:        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
    #####: 1540:        if (cas) {
    #####: 1541:            c->cas = cas;
        -: 1542:        }
    #####: 1543:        write_bin_response(c, &rsp->message.body, 0, 0,
        -: 1544:                           sizeof(rsp->message.body.value));
    #####: 1545:        break;
    #####: 1546:    case NON_NUMERIC:
    #####: 1547:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
    #####: 1548:        break;
    #####: 1549:    case EOM:
    #####: 1550:        out_of_memory(c, "SERVER_ERROR Out of memory incrementing value");
    #####: 1551:        break;
    #####: 1552:    case DELTA_ITEM_NOT_FOUND:
    #####: 1553:        if (req->message.body.expiration != 0xffffffff) {
        -: 1554:            /* Save some room for the response */
    #####: 1555:            rsp->message.body.value = htonll(req->message.body.initial);
        -: 1556:
    #####: 1557:            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, "%llu",
    #####: 1558:                (unsigned long long)req->message.body.initial);
    #####: 1559:            int res = strlen(tmpbuf);
    #####: 1560:            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
        -: 1561:                            res + 2);
        -: 1562:
    #####: 1563:            if (it != NULL) {
    #####: 1564:                memcpy(ITEM_data(it), tmpbuf, res);
    #####: 1565:                memcpy(ITEM_data(it) + res, "\r\n", 2);
        -: 1566:
    #####: 1567:                if (store_item(it, NREAD_ADD, c)) {
    #####: 1568:                    c->cas = ITEM_get_cas(it);
    #####: 1569:                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
        -: 1570:                } else {
    #####: 1571:                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
        -: 1572:                                    NULL, 0);
        -: 1573:                }
    #####: 1574:                item_remove(it);         /* release our reference */
        -: 1575:            } else {
    #####: 1576:                out_of_memory(c,
        -: 1577:                        "SERVER_ERROR Out of memory allocating new item");
        -: 1578:            }
        -: 1579:        } else {
    #####: 1580:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1581:            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
    #####: 1582:                c->thread->stats.incr_misses++;
        -: 1583:            } else {
    #####: 1584:                c->thread->stats.decr_misses++;
        -: 1585:            }
    #####: 1586:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1587:
    #####: 1588:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1589:        }
        -: 1590:        break;
    #####: 1591:    case DELTA_ITEM_CAS_MISMATCH:
    #####: 1592:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1593:        break;
        -: 1594:    }
    #####: 1595:}
------------------
complete_incr_bin:
    #####: 1498:static void complete_incr_bin(conn *c) {
    #####: 1499:    item *it;
    #####: 1500:    char *key;
    #####: 1501:    size_t nkey;
        -: 1502:    /* Weird magic in add_delta forces me to pad here */
    #####: 1503:    char tmpbuf[INCR_MAX_STORAGE_LEN];
    #####: 1504:    uint64_t cas = 0;
        -: 1505:
    #####: 1506:    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
    #####: 1507:    protocol_binary_request_incr* req = binary_get_request(c);
        -: 1508:
    #####: 1509:    assert(c != NULL);
    #####: 1510:    assert(c->wsize >= sizeof(*rsp));
        -: 1511:
        -: 1512:    /* fix byteorder in the request */
    #####: 1513:    req->message.body.delta = ntohll(req->message.body.delta);
    #####: 1514:    req->message.body.initial = ntohll(req->message.body.initial);
    #####: 1515:    req->message.body.expiration = ntohl(req->message.body.expiration);
    #####: 1516:    key = binary_get_key(c);
    #####: 1517:    nkey = c->binary_header.request.keylen;
        -: 1518:
    #####: 1519:    if (settings.verbose > 1) {
    #####: 1520:        int i;
    #####: 1521:        fprintf(stderr, "incr ");
        -: 1522:
    #####: 1523:        for (i = 0; i < nkey; i++) {
    #####: 1524:            fprintf(stderr, "%c", key[i]);
        -: 1525:        }
    #####: 1526:        fprintf(stderr, " %lld, %llu, %d\n",
    #####: 1527:                (long long)req->message.body.delta,
    #####: 1528:                (long long)req->message.body.initial,
        -: 1529:                req->message.body.expiration);
        -: 1530:    }
        -: 1531:
    #####: 1532:    if (c->binary_header.request.cas != 0) {
    #####: 1533:        cas = c->binary_header.request.cas;
        -: 1534:    }
    #####: 1535:    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
    #####: 1536:                     req->message.body.delta, tmpbuf,
        -: 1537:                     &cas)) {
    #####: 1538:    case OK:
    #####: 1539:        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
    #####: 1540:        if (cas) {
    #####: 1541:            c->cas = cas;
        -: 1542:        }
    #####: 1543:        write_bin_response(c, &rsp->message.body, 0, 0,
        -: 1544:                           sizeof(rsp->message.body.value));
    #####: 1545:        break;
    #####: 1546:    case NON_NUMERIC:
    #####: 1547:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
    #####: 1548:        break;
    #####: 1549:    case EOM:
    #####: 1550:        out_of_memory(c, "SERVER_ERROR Out of memory incrementing value");
    #####: 1551:        break;
    #####: 1552:    case DELTA_ITEM_NOT_FOUND:
    #####: 1553:        if (req->message.body.expiration != 0xffffffff) {
        -: 1554:            /* Save some room for the response */
    #####: 1555:            rsp->message.body.value = htonll(req->message.body.initial);
        -: 1556:
    #####: 1557:            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, "%llu",
    #####: 1558:                (unsigned long long)req->message.body.initial);
    #####: 1559:            int res = strlen(tmpbuf);
    #####: 1560:            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
        -: 1561:                            res + 2);
        -: 1562:
    #####: 1563:            if (it != NULL) {
    #####: 1564:                memcpy(ITEM_data(it), tmpbuf, res);
    #####: 1565:                memcpy(ITEM_data(it) + res, "\r\n", 2);
        -: 1566:
    #####: 1567:                if (store_item(it, NREAD_ADD, c)) {
    #####: 1568:                    c->cas = ITEM_get_cas(it);
    #####: 1569:                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
        -: 1570:                } else {
    #####: 1571:                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
        -: 1572:                                    NULL, 0);
        -: 1573:                }
    #####: 1574:                item_remove(it);         /* release our reference */
        -: 1575:            } else {
    #####: 1576:                out_of_memory(c,
        -: 1577:                        "SERVER_ERROR Out of memory allocating new item");
        -: 1578:            }
        -: 1579:        } else {
    #####: 1580:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1581:            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
    #####: 1582:                c->thread->stats.incr_misses++;
        -: 1583:            } else {
    #####: 1584:                c->thread->stats.decr_misses++;
        -: 1585:            }
    #####: 1586:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1587:
    #####: 1588:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1589:        }
        -: 1590:        break;
    #####: 1591:    case DELTA_ITEM_CAS_MISMATCH:
    #####: 1592:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1593:        break;
        -: 1594:    }
    #####: 1595:}
------------------
complete_incr_bin:
    #####: 1498:static void complete_incr_bin(conn *c) {
    #####: 1499:    item *it;
    #####: 1500:    char *key;
    #####: 1501:    size_t nkey;
        -: 1502:    /* Weird magic in add_delta forces me to pad here */
    #####: 1503:    char tmpbuf[INCR_MAX_STORAGE_LEN];
    #####: 1504:    uint64_t cas = 0;
        -: 1505:
    #####: 1506:    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
    #####: 1507:    protocol_binary_request_incr* req = binary_get_request(c);
        -: 1508:
    #####: 1509:    assert(c != NULL);
    #####: 1510:    assert(c->wsize >= sizeof(*rsp));
        -: 1511:
        -: 1512:    /* fix byteorder in the request */
    #####: 1513:    req->message.body.delta = ntohll(req->message.body.delta);
    #####: 1514:    req->message.body.initial = ntohll(req->message.body.initial);
    #####: 1515:    req->message.body.expiration = ntohl(req->message.body.expiration);
    #####: 1516:    key = binary_get_key(c);
    #####: 1517:    nkey = c->binary_header.request.keylen;
        -: 1518:
    #####: 1519:    if (settings.verbose > 1) {
    #####: 1520:        int i;
    #####: 1521:        fprintf(stderr, "incr ");
        -: 1522:
    #####: 1523:        for (i = 0; i < nkey; i++) {
    #####: 1524:            fprintf(stderr, "%c", key[i]);
        -: 1525:        }
    #####: 1526:        fprintf(stderr, " %lld, %llu, %d\n",
    #####: 1527:                (long long)req->message.body.delta,
    #####: 1528:                (long long)req->message.body.initial,
        -: 1529:                req->message.body.expiration);
        -: 1530:    }
        -: 1531:
    #####: 1532:    if (c->binary_header.request.cas != 0) {
    #####: 1533:        cas = c->binary_header.request.cas;
        -: 1534:    }
    #####: 1535:    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
    #####: 1536:                     req->message.body.delta, tmpbuf,
        -: 1537:                     &cas)) {
    #####: 1538:    case OK:
    #####: 1539:        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
    #####: 1540:        if (cas) {
    #####: 1541:            c->cas = cas;
        -: 1542:        }
    #####: 1543:        write_bin_response(c, &rsp->message.body, 0, 0,
        -: 1544:                           sizeof(rsp->message.body.value));
    #####: 1545:        break;
    #####: 1546:    case NON_NUMERIC:
    #####: 1547:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
    #####: 1548:        break;
    #####: 1549:    case EOM:
    #####: 1550:        out_of_memory(c, "SERVER_ERROR Out of memory incrementing value");
    #####: 1551:        break;
    #####: 1552:    case DELTA_ITEM_NOT_FOUND:
    #####: 1553:        if (req->message.body.expiration != 0xffffffff) {
        -: 1554:            /* Save some room for the response */
    #####: 1555:            rsp->message.body.value = htonll(req->message.body.initial);
        -: 1556:
    #####: 1557:            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, "%llu",
    #####: 1558:                (unsigned long long)req->message.body.initial);
    #####: 1559:            int res = strlen(tmpbuf);
    #####: 1560:            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
        -: 1561:                            res + 2);
        -: 1562:
    #####: 1563:            if (it != NULL) {
    #####: 1564:                memcpy(ITEM_data(it), tmpbuf, res);
    #####: 1565:                memcpy(ITEM_data(it) + res, "\r\n", 2);
        -: 1566:
    #####: 1567:                if (store_item(it, NREAD_ADD, c)) {
    #####: 1568:                    c->cas = ITEM_get_cas(it);
    #####: 1569:                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
        -: 1570:                } else {
    #####: 1571:                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
        -: 1572:                                    NULL, 0);
        -: 1573:                }
    #####: 1574:                item_remove(it);         /* release our reference */
        -: 1575:            } else {
    #####: 1576:                out_of_memory(c,
        -: 1577:                        "SERVER_ERROR Out of memory allocating new item");
        -: 1578:            }
        -: 1579:        } else {
    #####: 1580:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1581:            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
    #####: 1582:                c->thread->stats.incr_misses++;
        -: 1583:            } else {
    #####: 1584:                c->thread->stats.decr_misses++;
        -: 1585:            }
    #####: 1586:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1587:
    #####: 1588:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1589:        }
        -: 1590:        break;
    #####: 1591:    case DELTA_ITEM_CAS_MISMATCH:
    #####: 1592:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1593:        break;
        -: 1594:    }
    #####: 1595:}
------------------
complete_incr_bin:
    #####: 1498:static void complete_incr_bin(conn *c) {
    #####: 1499:    item *it;
    #####: 1500:    char *key;
    #####: 1501:    size_t nkey;
        -: 1502:    /* Weird magic in add_delta forces me to pad here */
    #####: 1503:    char tmpbuf[INCR_MAX_STORAGE_LEN];
    #####: 1504:    uint64_t cas = 0;
        -: 1505:
    #####: 1506:    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;
    #####: 1507:    protocol_binary_request_incr* req = binary_get_request(c);
        -: 1508:
    #####: 1509:    assert(c != NULL);
    #####: 1510:    assert(c->wsize >= sizeof(*rsp));
        -: 1511:
        -: 1512:    /* fix byteorder in the request */
    #####: 1513:    req->message.body.delta = ntohll(req->message.body.delta);
    #####: 1514:    req->message.body.initial = ntohll(req->message.body.initial);
    #####: 1515:    req->message.body.expiration = ntohl(req->message.body.expiration);
    #####: 1516:    key = binary_get_key(c);
    #####: 1517:    nkey = c->binary_header.request.keylen;
        -: 1518:
    #####: 1519:    if (settings.verbose > 1) {
    #####: 1520:        int i;
    #####: 1521:        fprintf(stderr, "incr ");
        -: 1522:
    #####: 1523:        for (i = 0; i < nkey; i++) {
    #####: 1524:            fprintf(stderr, "%c", key[i]);
        -: 1525:        }
    #####: 1526:        fprintf(stderr, " %lld, %llu, %d\n",
    #####: 1527:                (long long)req->message.body.delta,
    #####: 1528:                (long long)req->message.body.initial,
        -: 1529:                req->message.body.expiration);
        -: 1530:    }
        -: 1531:
    #####: 1532:    if (c->binary_header.request.cas != 0) {
    #####: 1533:        cas = c->binary_header.request.cas;
        -: 1534:    }
    #####: 1535:    switch(add_delta(c, key, nkey, c->cmd == PROTOCOL_BINARY_CMD_INCREMENT,
    #####: 1536:                     req->message.body.delta, tmpbuf,
        -: 1537:                     &cas)) {
    #####: 1538:    case OK:
    #####: 1539:        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
    #####: 1540:        if (cas) {
    #####: 1541:            c->cas = cas;
        -: 1542:        }
    #####: 1543:        write_bin_response(c, &rsp->message.body, 0, 0,
        -: 1544:                           sizeof(rsp->message.body.value));
    #####: 1545:        break;
    #####: 1546:    case NON_NUMERIC:
    #####: 1547:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
    #####: 1548:        break;
    #####: 1549:    case EOM:
    #####: 1550:        out_of_memory(c, "SERVER_ERROR Out of memory incrementing value");
    #####: 1551:        break;
    #####: 1552:    case DELTA_ITEM_NOT_FOUND:
    #####: 1553:        if (req->message.body.expiration != 0xffffffff) {
        -: 1554:            /* Save some room for the response */
    #####: 1555:            rsp->message.body.value = htonll(req->message.body.initial);
        -: 1556:
    #####: 1557:            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, "%llu",
    #####: 1558:                (unsigned long long)req->message.body.initial);
    #####: 1559:            int res = strlen(tmpbuf);
    #####: 1560:            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
        -: 1561:                            res + 2);
        -: 1562:
    #####: 1563:            if (it != NULL) {
    #####: 1564:                memcpy(ITEM_data(it), tmpbuf, res);
    #####: 1565:                memcpy(ITEM_data(it) + res, "\r\n", 2);
        -: 1566:
    #####: 1567:                if (store_item(it, NREAD_ADD, c)) {
    #####: 1568:                    c->cas = ITEM_get_cas(it);
    #####: 1569:                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
        -: 1570:                } else {
    #####: 1571:                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
        -: 1572:                                    NULL, 0);
        -: 1573:                }
    #####: 1574:                item_remove(it);         /* release our reference */
        -: 1575:            } else {
    #####: 1576:                out_of_memory(c,
        -: 1577:                        "SERVER_ERROR Out of memory allocating new item");
        -: 1578:            }
        -: 1579:        } else {
    #####: 1580:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1581:            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
    #####: 1582:                c->thread->stats.incr_misses++;
        -: 1583:            } else {
    #####: 1584:                c->thread->stats.decr_misses++;
        -: 1585:            }
    #####: 1586:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1587:
    #####: 1588:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 1589:        }
        -: 1590:        break;
    #####: 1591:    case DELTA_ITEM_CAS_MISMATCH:
    #####: 1592:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1593:        break;
        -: 1594:    }
    #####: 1595:}
------------------
        -: 1596:
    27600: 1597:static void complete_update_bin(conn *c) {
    27600: 1598:    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    27600: 1599:    enum store_item_type ret = NOT_STORED;
   27600*: 1600:    assert(c != NULL);
        -: 1601:
    27600: 1602:    item *it = c->item;
        -: 1603:
    27600: 1604:    pthread_mutex_lock(&c->thread->stats.mutex);
    27600: 1605:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    27600: 1606:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1607:
        -: 1608:    /* We don't actually receive the trailing two characters in the bin
        -: 1609:     * protocol, so we're going to just set them here */
    27600: 1610:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
    27600: 1611:        *(ITEM_data(it) + it->nbytes - 2) = '\r';
    27600: 1612:        *(ITEM_data(it) + it->nbytes - 1) = '\n';
        -: 1613:    } else {
    #####: 1614:        assert(c->ritem);
    #####: 1615:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1616:        if (ch->size == ch->used)
    #####: 1617:            ch = ch->next;
    #####: 1618:        assert(ch->size - ch->used >= 2);
    #####: 1619:        ch->data[ch->used] = '\r';
    #####: 1620:        ch->data[ch->used + 1] = '\n';
    #####: 1621:        ch->used += 2;
        -: 1622:    }
        -: 1623:
    27600: 1624:    ret = store_item(it, c->cmd, c);
        -: 1625:
        -: 1626:#ifdef ENABLE_DTRACE
        -: 1627:    uint64_t cas = ITEM_get_cas(it);
        -: 1628:    switch (c->cmd) {
        -: 1629:    case NREAD_ADD:
        -: 1630:        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1631:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1632:        break;
        -: 1633:    case NREAD_REPLACE:
        -: 1634:        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1635:                                  (ret == STORED) ? it->nbytes : -1, cas);
        -: 1636:        break;
        -: 1637:    case NREAD_APPEND:
        -: 1638:        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1639:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1640:        break;
        -: 1641:    case NREAD_PREPEND:
        -: 1642:        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1643:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1644:        break;
        -: 1645:    case NREAD_SET:
        -: 1646:        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1647:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1648:        break;
        -: 1649:    }
        -: 1650:#endif
        -: 1651:
    27600: 1652:    switch (ret) {
    27600: 1653:    case STORED:
        -: 1654:        /* Stored */
    27600: 1655:        write_bin_response(c, NULL, 0, 0, 0);
    27600: 1656:        break;
    #####: 1657:    case EXISTS:
    #####: 1658:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1659:        break;
    #####: 1660:    case NOT_FOUND:
    #####: 1661:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 1662:        break;
    #####: 1663:    case NOT_STORED:
        -: 1664:    case TOO_LARGE:
        -: 1665:    case NO_MEMORY:
    #####: 1666:        if (c->cmd == NREAD_ADD) {
        -: 1667:            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
    #####: 1668:        } else if(c->cmd == NREAD_REPLACE) {
        -: 1669:            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        -: 1670:        } else {
    #####: 1671:            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        -: 1672:        }
    #####: 1673:        write_bin_error(c, eno, NULL, 0);
        -: 1674:    }
        -: 1675:
    27600: 1676:    item_remove(c->item);       /* release the c->item reference */
    27600: 1677:    c->item = 0;
    27600: 1678:}
------------------
complete_update_bin:
     9200: 1597:static void complete_update_bin(conn *c) {
     9200: 1598:    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
     9200: 1599:    enum store_item_type ret = NOT_STORED;
    9200*: 1600:    assert(c != NULL);
        -: 1601:
     9200: 1602:    item *it = c->item;
        -: 1603:
     9200: 1604:    pthread_mutex_lock(&c->thread->stats.mutex);
     9200: 1605:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
     9200: 1606:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1607:
        -: 1608:    /* We don't actually receive the trailing two characters in the bin
        -: 1609:     * protocol, so we're going to just set them here */
     9200: 1610:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
     9200: 1611:        *(ITEM_data(it) + it->nbytes - 2) = '\r';
     9200: 1612:        *(ITEM_data(it) + it->nbytes - 1) = '\n';
        -: 1613:    } else {
    #####: 1614:        assert(c->ritem);
    #####: 1615:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1616:        if (ch->size == ch->used)
    #####: 1617:            ch = ch->next;
    #####: 1618:        assert(ch->size - ch->used >= 2);
    #####: 1619:        ch->data[ch->used] = '\r';
    #####: 1620:        ch->data[ch->used + 1] = '\n';
    #####: 1621:        ch->used += 2;
        -: 1622:    }
        -: 1623:
     9200: 1624:    ret = store_item(it, c->cmd, c);
        -: 1625:
        -: 1626:#ifdef ENABLE_DTRACE
        -: 1627:    uint64_t cas = ITEM_get_cas(it);
        -: 1628:    switch (c->cmd) {
        -: 1629:    case NREAD_ADD:
        -: 1630:        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1631:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1632:        break;
        -: 1633:    case NREAD_REPLACE:
        -: 1634:        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1635:                                  (ret == STORED) ? it->nbytes : -1, cas);
        -: 1636:        break;
        -: 1637:    case NREAD_APPEND:
        -: 1638:        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1639:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1640:        break;
        -: 1641:    case NREAD_PREPEND:
        -: 1642:        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1643:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1644:        break;
        -: 1645:    case NREAD_SET:
        -: 1646:        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1647:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1648:        break;
        -: 1649:    }
        -: 1650:#endif
        -: 1651:
     9200: 1652:    switch (ret) {
     9200: 1653:    case STORED:
        -: 1654:        /* Stored */
     9200: 1655:        write_bin_response(c, NULL, 0, 0, 0);
     9200: 1656:        break;
    #####: 1657:    case EXISTS:
    #####: 1658:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1659:        break;
    #####: 1660:    case NOT_FOUND:
    #####: 1661:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 1662:        break;
    #####: 1663:    case NOT_STORED:
        -: 1664:    case TOO_LARGE:
        -: 1665:    case NO_MEMORY:
    #####: 1666:        if (c->cmd == NREAD_ADD) {
        -: 1667:            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
    #####: 1668:        } else if(c->cmd == NREAD_REPLACE) {
        -: 1669:            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        -: 1670:        } else {
    #####: 1671:            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        -: 1672:        }
    #####: 1673:        write_bin_error(c, eno, NULL, 0);
        -: 1674:    }
        -: 1675:
     9200: 1676:    item_remove(c->item);       /* release the c->item reference */
     9200: 1677:    c->item = 0;
     9200: 1678:}
------------------
complete_update_bin:
     9200: 1597:static void complete_update_bin(conn *c) {
     9200: 1598:    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
     9200: 1599:    enum store_item_type ret = NOT_STORED;
    9200*: 1600:    assert(c != NULL);
        -: 1601:
     9200: 1602:    item *it = c->item;
        -: 1603:
     9200: 1604:    pthread_mutex_lock(&c->thread->stats.mutex);
     9200: 1605:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
     9200: 1606:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1607:
        -: 1608:    /* We don't actually receive the trailing two characters in the bin
        -: 1609:     * protocol, so we're going to just set them here */
     9200: 1610:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
     9200: 1611:        *(ITEM_data(it) + it->nbytes - 2) = '\r';
     9200: 1612:        *(ITEM_data(it) + it->nbytes - 1) = '\n';
        -: 1613:    } else {
    #####: 1614:        assert(c->ritem);
    #####: 1615:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1616:        if (ch->size == ch->used)
    #####: 1617:            ch = ch->next;
    #####: 1618:        assert(ch->size - ch->used >= 2);
    #####: 1619:        ch->data[ch->used] = '\r';
    #####: 1620:        ch->data[ch->used + 1] = '\n';
    #####: 1621:        ch->used += 2;
        -: 1622:    }
        -: 1623:
     9200: 1624:    ret = store_item(it, c->cmd, c);
        -: 1625:
        -: 1626:#ifdef ENABLE_DTRACE
        -: 1627:    uint64_t cas = ITEM_get_cas(it);
        -: 1628:    switch (c->cmd) {
        -: 1629:    case NREAD_ADD:
        -: 1630:        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1631:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1632:        break;
        -: 1633:    case NREAD_REPLACE:
        -: 1634:        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1635:                                  (ret == STORED) ? it->nbytes : -1, cas);
        -: 1636:        break;
        -: 1637:    case NREAD_APPEND:
        -: 1638:        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1639:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1640:        break;
        -: 1641:    case NREAD_PREPEND:
        -: 1642:        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1643:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1644:        break;
        -: 1645:    case NREAD_SET:
        -: 1646:        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1647:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1648:        break;
        -: 1649:    }
        -: 1650:#endif
        -: 1651:
     9200: 1652:    switch (ret) {
     9200: 1653:    case STORED:
        -: 1654:        /* Stored */
     9200: 1655:        write_bin_response(c, NULL, 0, 0, 0);
     9200: 1656:        break;
    #####: 1657:    case EXISTS:
    #####: 1658:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1659:        break;
    #####: 1660:    case NOT_FOUND:
    #####: 1661:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 1662:        break;
    #####: 1663:    case NOT_STORED:
        -: 1664:    case TOO_LARGE:
        -: 1665:    case NO_MEMORY:
    #####: 1666:        if (c->cmd == NREAD_ADD) {
        -: 1667:            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
    #####: 1668:        } else if(c->cmd == NREAD_REPLACE) {
        -: 1669:            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        -: 1670:        } else {
    #####: 1671:            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        -: 1672:        }
    #####: 1673:        write_bin_error(c, eno, NULL, 0);
        -: 1674:    }
        -: 1675:
     9200: 1676:    item_remove(c->item);       /* release the c->item reference */
     9200: 1677:    c->item = 0;
     9200: 1678:}
------------------
complete_update_bin:
     9200: 1597:static void complete_update_bin(conn *c) {
     9200: 1598:    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
     9200: 1599:    enum store_item_type ret = NOT_STORED;
    9200*: 1600:    assert(c != NULL);
        -: 1601:
     9200: 1602:    item *it = c->item;
        -: 1603:
     9200: 1604:    pthread_mutex_lock(&c->thread->stats.mutex);
     9200: 1605:    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
     9200: 1606:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1607:
        -: 1608:    /* We don't actually receive the trailing two characters in the bin
        -: 1609:     * protocol, so we're going to just set them here */
     9200: 1610:    if ((it->it_flags & ITEM_CHUNKED) == 0) {
     9200: 1611:        *(ITEM_data(it) + it->nbytes - 2) = '\r';
     9200: 1612:        *(ITEM_data(it) + it->nbytes - 1) = '\n';
        -: 1613:    } else {
    #####: 1614:        assert(c->ritem);
    #####: 1615:        item_chunk *ch = (item_chunk *) c->ritem;
    #####: 1616:        if (ch->size == ch->used)
    #####: 1617:            ch = ch->next;
    #####: 1618:        assert(ch->size - ch->used >= 2);
    #####: 1619:        ch->data[ch->used] = '\r';
    #####: 1620:        ch->data[ch->used + 1] = '\n';
    #####: 1621:        ch->used += 2;
        -: 1622:    }
        -: 1623:
     9200: 1624:    ret = store_item(it, c->cmd, c);
        -: 1625:
        -: 1626:#ifdef ENABLE_DTRACE
        -: 1627:    uint64_t cas = ITEM_get_cas(it);
        -: 1628:    switch (c->cmd) {
        -: 1629:    case NREAD_ADD:
        -: 1630:        MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
        -: 1631:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1632:        break;
        -: 1633:    case NREAD_REPLACE:
        -: 1634:        MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
        -: 1635:                                  (ret == STORED) ? it->nbytes : -1, cas);
        -: 1636:        break;
        -: 1637:    case NREAD_APPEND:
        -: 1638:        MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1639:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1640:        break;
        -: 1641:    case NREAD_PREPEND:
        -: 1642:        MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
        -: 1643:                                 (ret == STORED) ? it->nbytes : -1, cas);
        -: 1644:        break;
        -: 1645:    case NREAD_SET:
        -: 1646:        MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
        -: 1647:                              (ret == STORED) ? it->nbytes : -1, cas);
        -: 1648:        break;
        -: 1649:    }
        -: 1650:#endif
        -: 1651:
     9200: 1652:    switch (ret) {
     9200: 1653:    case STORED:
        -: 1654:        /* Stored */
     9200: 1655:        write_bin_response(c, NULL, 0, 0, 0);
     9200: 1656:        break;
    #####: 1657:    case EXISTS:
    #####: 1658:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
    #####: 1659:        break;
    #####: 1660:    case NOT_FOUND:
    #####: 1661:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 1662:        break;
    #####: 1663:    case NOT_STORED:
        -: 1664:    case TOO_LARGE:
        -: 1665:    case NO_MEMORY:
    #####: 1666:        if (c->cmd == NREAD_ADD) {
        -: 1667:            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
    #####: 1668:        } else if(c->cmd == NREAD_REPLACE) {
        -: 1669:            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        -: 1670:        } else {
    #####: 1671:            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        -: 1672:        }
    #####: 1673:        write_bin_error(c, eno, NULL, 0);
        -: 1674:    }
        -: 1675:
     9200: 1676:    item_remove(c->item);       /* release the c->item reference */
     9200: 1677:    c->item = 0;
     9200: 1678:}
------------------
        -: 1679:
    #####: 1680:static void write_bin_miss_response(conn *c, char *key, size_t nkey) {
  272400*: 1681:    if (nkey) {
    #####: 1682:        char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
    #####: 1683:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1684:                0, nkey, nkey);
    #####: 1685:        memcpy(ofs, key, nkey);
    #####: 1686:        add_iov(c, ofs, nkey);
    #####: 1687:        conn_set_state(c, conn_mwrite);
    #####: 1688:        c->write_and_go = conn_new_cmd;
        -: 1689:    } else {
  272400*: 1690:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1691:                        NULL, 0);
        -: 1692:    }
    #####: 1693:}
------------------
write_bin_miss_response:
    #####: 1680:static void write_bin_miss_response(conn *c, char *key, size_t nkey) {
    #####: 1681:    if (nkey) {
    #####: 1682:        char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
    #####: 1683:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1684:                0, nkey, nkey);
    #####: 1685:        memcpy(ofs, key, nkey);
    #####: 1686:        add_iov(c, ofs, nkey);
    #####: 1687:        conn_set_state(c, conn_mwrite);
    #####: 1688:        c->write_and_go = conn_new_cmd;
        -: 1689:    } else {
    #####: 1690:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1691:                        NULL, 0);
        -: 1692:    }
    #####: 1693:}
------------------
write_bin_miss_response:
    #####: 1680:static void write_bin_miss_response(conn *c, char *key, size_t nkey) {
    #####: 1681:    if (nkey) {
    #####: 1682:        char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
    #####: 1683:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1684:                0, nkey, nkey);
    #####: 1685:        memcpy(ofs, key, nkey);
    #####: 1686:        add_iov(c, ofs, nkey);
    #####: 1687:        conn_set_state(c, conn_mwrite);
    #####: 1688:        c->write_and_go = conn_new_cmd;
        -: 1689:    } else {
    #####: 1690:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1691:                        NULL, 0);
        -: 1692:    }
    #####: 1693:}
------------------
write_bin_miss_response:
    #####: 1680:static void write_bin_miss_response(conn *c, char *key, size_t nkey) {
    #####: 1681:    if (nkey) {
    #####: 1682:        char *ofs = c->wbuf + sizeof(protocol_binary_response_header);
    #####: 1683:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1684:                0, nkey, nkey);
    #####: 1685:        memcpy(ofs, key, nkey);
    #####: 1686:        add_iov(c, ofs, nkey);
    #####: 1687:        conn_set_state(c, conn_mwrite);
    #####: 1688:        c->write_and_go = conn_new_cmd;
        -: 1689:    } else {
    #####: 1690:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
        -: 1691:                        NULL, 0);
        -: 1692:    }
    #####: 1693:}
------------------
        -: 1694:
   272400: 1695:static void process_bin_get_or_touch(conn *c) {
   272400: 1696:    item *it;
        -: 1697:
   272400: 1698:    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
   544800: 1699:    char* key = binary_get_key(c);
   272400: 1700:    size_t nkey = c->binary_header.request.keylen;
   544800: 1701:    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
   272400: 1702:                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
        -: 1703:                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
   272400: 1704:    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
        -: 1705:                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
   272400: 1706:    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
   272400: 1707:    bool failed = false;
        -: 1708:
   272400: 1709:    if (settings.verbose > 1) {
    #####: 1710:        fprintf(stderr, "<%d %s ", c->sfd, should_touch ? "TOUCH" : "GET");
    #####: 1711:        if (fwrite(key, 1, nkey, stderr)) {}
    #####: 1712:        fputc('\n', stderr);
        -: 1713:    }
        -: 1714:
   272400: 1715:    if (should_touch) {
    #####: 1716:        protocol_binary_request_touch *t = binary_get_request(c);
    #####: 1717:        time_t exptime = ntohl(t->message.body.expiration);
        -: 1718:
    #####: 1719:        it = item_touch(key, nkey, realtime(exptime), c);
        -: 1720:    } else {
   272400: 1721:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 1722:    }
        -: 1723:
   272400: 1724:    if (it) {
        -: 1725:        /* the length has two unnecessary bytes ("\r\n") */
    #####: 1726:        uint16_t keylen = 0;
    #####: 1727:        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);
        -: 1728:
    #####: 1729:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1730:        if (should_touch) {
    #####: 1731:            c->thread->stats.touch_cmds++;
    #####: 1732:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1733:        } else {
    #####: 1734:            c->thread->stats.get_cmds++;
    #####: 1735:            c->thread->stats.lru_hits[it->slabs_clsid]++;
        -: 1736:        }
    #####: 1737:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1738:
    #####: 1739:        if (should_touch) {
        -: 1740:            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
        -: 1741:                                    it->nbytes, ITEM_get_cas(it));
        -: 1742:        } else {
        -: 1743:            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 1744:                                  it->nbytes, ITEM_get_cas(it));
        -: 1745:        }
        -: 1746:
    #####: 1747:        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
    #####: 1748:            bodylen -= it->nbytes - 2;
    #####: 1749:        } else if (should_return_key) {
    #####: 1750:            bodylen += nkey;
    #####: 1751:            keylen = nkey;
        -: 1752:        }
        -: 1753:
    #####: 1754:        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
    #####: 1755:        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));
        -: 1756:
        -: 1757:        // add the flags
    #####: 1758:        FLAGS_CONV(it, rsp->message.body.flags);
    #####: 1759:        rsp->message.body.flags = htonl(rsp->message.body.flags);
    #####: 1760:        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));
        -: 1761:
    #####: 1762:        if (should_return_key) {
    #####: 1763:            add_iov(c, ITEM_key(it), nkey);
        -: 1764:        }
        -: 1765:
    #####: 1766:        if (should_return_value) {
        -: 1767:            /* Add the data minus the CRLF */
        -: 1768:#ifdef EXTSTORE
        -: 1769:            if (it->it_flags & ITEM_HDR) {
        -: 1770:                int iovcnt = 4;
        -: 1771:                int iovst = c->iovused - 3;
        -: 1772:                if (!should_return_key) {
        -: 1773:                    iovcnt = 3;
        -: 1774:                    iovst = c->iovused - 2;
        -: 1775:                }
        -: 1776:
        -: 1777:                if (_get_extstore(c, it, iovst, iovcnt) != 0) {
        -: 1778:                    pthread_mutex_lock(&c->thread->stats.mutex);
        -: 1779:                    c->thread->stats.get_oom_extstore++;
        -: 1780:                    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1781:
        -: 1782:                    failed = true;
        -: 1783:                }
        -: 1784:            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 1785:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1786:            } else {
        -: 1787:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1788:            }
        -: 1789:#else
    #####: 1790:            if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1791:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1792:            } else {
    #####: 1793:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1794:            }
        -: 1795:#endif
        -: 1796:        }
        -: 1797:
    #####: 1798:        if (!failed) {
    #####: 1799:            conn_set_state(c, conn_mwrite);
    #####: 1800:            c->write_and_go = conn_new_cmd;
        -: 1801:            /* Remember this command so we can garbage collect it later */
        -: 1802:#ifdef EXTSTORE
        -: 1803:            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {
        -: 1804:                // Only have extstore clean if header and returning value.
        -: 1805:                c->item = NULL;
        -: 1806:            } else {
        -: 1807:                c->item = it;
        -: 1808:            }
        -: 1809:#else
    #####: 1810:            c->item = it;
        -: 1811:#endif
        -: 1812:        } else {
        -: 1813:            item_remove(it);
        -: 1814:        }
        -: 1815:    } else {
        -: 1816:        failed = true;
        -: 1817:    }
        -: 1818:
    #####: 1819:    if (failed) {
   272400: 1820:        pthread_mutex_lock(&c->thread->stats.mutex);
   272400: 1821:        if (should_touch) {
    #####: 1822:            c->thread->stats.touch_cmds++;
    #####: 1823:            c->thread->stats.touch_misses++;
        -: 1824:        } else {
   272400: 1825:            c->thread->stats.get_cmds++;
   272400: 1826:            c->thread->stats.get_misses++;
        -: 1827:        }
   272400: 1828:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1829:
   272400: 1830:        if (should_touch) {
        -: 1831:            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        -: 1832:        } else {
   272400: 1833:            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 1834:        }
        -: 1835:
   272400: 1836:        if (c->noreply) {
    #####: 1837:            conn_set_state(c, conn_new_cmd);
        -: 1838:        } else {
   272400: 1839:            if (should_return_key) {
    #####: 1840:                write_bin_miss_response(c, key, nkey);
        -: 1841:            } else {
   272400: 1842:                write_bin_miss_response(c, NULL, 0);
        -: 1843:            }
        -: 1844:        }
        -: 1845:    }
        -: 1846:
   272400: 1847:    if (settings.detail_enabled) {
    #####: 1848:        stats_prefix_record_get(key, nkey, NULL != it);
        -: 1849:    }
   272400: 1850:}
------------------
process_bin_get_or_touch:
    90800: 1695:static void process_bin_get_or_touch(conn *c) {
    90800: 1696:    item *it;
        -: 1697:
    90800: 1698:    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
   181600: 1699:    char* key = binary_get_key(c);
    90800: 1700:    size_t nkey = c->binary_header.request.keylen;
   181600: 1701:    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
    90800: 1702:                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
        -: 1703:                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
    90800: 1704:    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
        -: 1705:                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
    90800: 1706:    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
    90800: 1707:    bool failed = false;
        -: 1708:
    90800: 1709:    if (settings.verbose > 1) {
    #####: 1710:        fprintf(stderr, "<%d %s ", c->sfd, should_touch ? "TOUCH" : "GET");
    #####: 1711:        if (fwrite(key, 1, nkey, stderr)) {}
    #####: 1712:        fputc('\n', stderr);
        -: 1713:    }
        -: 1714:
    90800: 1715:    if (should_touch) {
    #####: 1716:        protocol_binary_request_touch *t = binary_get_request(c);
    #####: 1717:        time_t exptime = ntohl(t->message.body.expiration);
        -: 1718:
    #####: 1719:        it = item_touch(key, nkey, realtime(exptime), c);
        -: 1720:    } else {
    90800: 1721:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 1722:    }
        -: 1723:
    90800: 1724:    if (it) {
        -: 1725:        /* the length has two unnecessary bytes ("\r\n") */
    #####: 1726:        uint16_t keylen = 0;
    #####: 1727:        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);
        -: 1728:
    #####: 1729:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1730:        if (should_touch) {
    #####: 1731:            c->thread->stats.touch_cmds++;
    #####: 1732:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1733:        } else {
    #####: 1734:            c->thread->stats.get_cmds++;
    #####: 1735:            c->thread->stats.lru_hits[it->slabs_clsid]++;
        -: 1736:        }
    #####: 1737:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1738:
    #####: 1739:        if (should_touch) {
        -: 1740:            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
        -: 1741:                                    it->nbytes, ITEM_get_cas(it));
        -: 1742:        } else {
        -: 1743:            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 1744:                                  it->nbytes, ITEM_get_cas(it));
        -: 1745:        }
        -: 1746:
    #####: 1747:        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
    #####: 1748:            bodylen -= it->nbytes - 2;
    #####: 1749:        } else if (should_return_key) {
    #####: 1750:            bodylen += nkey;
    #####: 1751:            keylen = nkey;
        -: 1752:        }
        -: 1753:
    #####: 1754:        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
    #####: 1755:        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));
        -: 1756:
        -: 1757:        // add the flags
    #####: 1758:        FLAGS_CONV(it, rsp->message.body.flags);
    #####: 1759:        rsp->message.body.flags = htonl(rsp->message.body.flags);
    #####: 1760:        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));
        -: 1761:
    #####: 1762:        if (should_return_key) {
    #####: 1763:            add_iov(c, ITEM_key(it), nkey);
        -: 1764:        }
        -: 1765:
    #####: 1766:        if (should_return_value) {
        -: 1767:            /* Add the data minus the CRLF */
        -: 1768:#ifdef EXTSTORE
        -: 1769:            if (it->it_flags & ITEM_HDR) {
        -: 1770:                int iovcnt = 4;
        -: 1771:                int iovst = c->iovused - 3;
        -: 1772:                if (!should_return_key) {
        -: 1773:                    iovcnt = 3;
        -: 1774:                    iovst = c->iovused - 2;
        -: 1775:                }
        -: 1776:
        -: 1777:                if (_get_extstore(c, it, iovst, iovcnt) != 0) {
        -: 1778:                    pthread_mutex_lock(&c->thread->stats.mutex);
        -: 1779:                    c->thread->stats.get_oom_extstore++;
        -: 1780:                    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1781:
        -: 1782:                    failed = true;
        -: 1783:                }
        -: 1784:            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 1785:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1786:            } else {
        -: 1787:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1788:            }
        -: 1789:#else
    #####: 1790:            if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1791:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1792:            } else {
    #####: 1793:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1794:            }
        -: 1795:#endif
        -: 1796:        }
        -: 1797:
    #####: 1798:        if (!failed) {
    #####: 1799:            conn_set_state(c, conn_mwrite);
    #####: 1800:            c->write_and_go = conn_new_cmd;
        -: 1801:            /* Remember this command so we can garbage collect it later */
        -: 1802:#ifdef EXTSTORE
        -: 1803:            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {
        -: 1804:                // Only have extstore clean if header and returning value.
        -: 1805:                c->item = NULL;
        -: 1806:            } else {
        -: 1807:                c->item = it;
        -: 1808:            }
        -: 1809:#else
    #####: 1810:            c->item = it;
        -: 1811:#endif
        -: 1812:        } else {
        -: 1813:            item_remove(it);
        -: 1814:        }
        -: 1815:    } else {
        -: 1816:        failed = true;
        -: 1817:    }
        -: 1818:
    #####: 1819:    if (failed) {
    90800: 1820:        pthread_mutex_lock(&c->thread->stats.mutex);
    90800: 1821:        if (should_touch) {
    #####: 1822:            c->thread->stats.touch_cmds++;
    #####: 1823:            c->thread->stats.touch_misses++;
        -: 1824:        } else {
    90800: 1825:            c->thread->stats.get_cmds++;
    90800: 1826:            c->thread->stats.get_misses++;
        -: 1827:        }
    90800: 1828:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1829:
    90800: 1830:        if (should_touch) {
        -: 1831:            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        -: 1832:        } else {
    90800: 1833:            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 1834:        }
        -: 1835:
    90800: 1836:        if (c->noreply) {
    #####: 1837:            conn_set_state(c, conn_new_cmd);
        -: 1838:        } else {
    90800: 1839:            if (should_return_key) {
    #####: 1840:                write_bin_miss_response(c, key, nkey);
        -: 1841:            } else {
    90800: 1842:                write_bin_miss_response(c, NULL, 0);
        -: 1843:            }
        -: 1844:        }
        -: 1845:    }
        -: 1846:
    90800: 1847:    if (settings.detail_enabled) {
    #####: 1848:        stats_prefix_record_get(key, nkey, NULL != it);
        -: 1849:    }
    90800: 1850:}
------------------
process_bin_get_or_touch:
    90800: 1695:static void process_bin_get_or_touch(conn *c) {
    90800: 1696:    item *it;
        -: 1697:
    90800: 1698:    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
   181600: 1699:    char* key = binary_get_key(c);
    90800: 1700:    size_t nkey = c->binary_header.request.keylen;
   181600: 1701:    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
    90800: 1702:                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
        -: 1703:                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
    90800: 1704:    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
        -: 1705:                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
    90800: 1706:    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
    90800: 1707:    bool failed = false;
        -: 1708:
    90800: 1709:    if (settings.verbose > 1) {
    #####: 1710:        fprintf(stderr, "<%d %s ", c->sfd, should_touch ? "TOUCH" : "GET");
    #####: 1711:        if (fwrite(key, 1, nkey, stderr)) {}
    #####: 1712:        fputc('\n', stderr);
        -: 1713:    }
        -: 1714:
    90800: 1715:    if (should_touch) {
    #####: 1716:        protocol_binary_request_touch *t = binary_get_request(c);
    #####: 1717:        time_t exptime = ntohl(t->message.body.expiration);
        -: 1718:
    #####: 1719:        it = item_touch(key, nkey, realtime(exptime), c);
        -: 1720:    } else {
    90800: 1721:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 1722:    }
        -: 1723:
    90800: 1724:    if (it) {
        -: 1725:        /* the length has two unnecessary bytes ("\r\n") */
    #####: 1726:        uint16_t keylen = 0;
    #####: 1727:        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);
        -: 1728:
    #####: 1729:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1730:        if (should_touch) {
    #####: 1731:            c->thread->stats.touch_cmds++;
    #####: 1732:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1733:        } else {
    #####: 1734:            c->thread->stats.get_cmds++;
    #####: 1735:            c->thread->stats.lru_hits[it->slabs_clsid]++;
        -: 1736:        }
    #####: 1737:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1738:
    #####: 1739:        if (should_touch) {
        -: 1740:            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
        -: 1741:                                    it->nbytes, ITEM_get_cas(it));
        -: 1742:        } else {
        -: 1743:            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 1744:                                  it->nbytes, ITEM_get_cas(it));
        -: 1745:        }
        -: 1746:
    #####: 1747:        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
    #####: 1748:            bodylen -= it->nbytes - 2;
    #####: 1749:        } else if (should_return_key) {
    #####: 1750:            bodylen += nkey;
    #####: 1751:            keylen = nkey;
        -: 1752:        }
        -: 1753:
    #####: 1754:        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
    #####: 1755:        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));
        -: 1756:
        -: 1757:        // add the flags
    #####: 1758:        FLAGS_CONV(it, rsp->message.body.flags);
    #####: 1759:        rsp->message.body.flags = htonl(rsp->message.body.flags);
    #####: 1760:        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));
        -: 1761:
    #####: 1762:        if (should_return_key) {
    #####: 1763:            add_iov(c, ITEM_key(it), nkey);
        -: 1764:        }
        -: 1765:
    #####: 1766:        if (should_return_value) {
        -: 1767:            /* Add the data minus the CRLF */
        -: 1768:#ifdef EXTSTORE
        -: 1769:            if (it->it_flags & ITEM_HDR) {
        -: 1770:                int iovcnt = 4;
        -: 1771:                int iovst = c->iovused - 3;
        -: 1772:                if (!should_return_key) {
        -: 1773:                    iovcnt = 3;
        -: 1774:                    iovst = c->iovused - 2;
        -: 1775:                }
        -: 1776:
        -: 1777:                if (_get_extstore(c, it, iovst, iovcnt) != 0) {
        -: 1778:                    pthread_mutex_lock(&c->thread->stats.mutex);
        -: 1779:                    c->thread->stats.get_oom_extstore++;
        -: 1780:                    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1781:
        -: 1782:                    failed = true;
        -: 1783:                }
        -: 1784:            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 1785:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1786:            } else {
        -: 1787:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1788:            }
        -: 1789:#else
    #####: 1790:            if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1791:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1792:            } else {
    #####: 1793:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1794:            }
        -: 1795:#endif
        -: 1796:        }
        -: 1797:
    #####: 1798:        if (!failed) {
    #####: 1799:            conn_set_state(c, conn_mwrite);
    #####: 1800:            c->write_and_go = conn_new_cmd;
        -: 1801:            /* Remember this command so we can garbage collect it later */
        -: 1802:#ifdef EXTSTORE
        -: 1803:            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {
        -: 1804:                // Only have extstore clean if header and returning value.
        -: 1805:                c->item = NULL;
        -: 1806:            } else {
        -: 1807:                c->item = it;
        -: 1808:            }
        -: 1809:#else
    #####: 1810:            c->item = it;
        -: 1811:#endif
        -: 1812:        } else {
        -: 1813:            item_remove(it);
        -: 1814:        }
        -: 1815:    } else {
        -: 1816:        failed = true;
        -: 1817:    }
        -: 1818:
    #####: 1819:    if (failed) {
    90800: 1820:        pthread_mutex_lock(&c->thread->stats.mutex);
    90800: 1821:        if (should_touch) {
    #####: 1822:            c->thread->stats.touch_cmds++;
    #####: 1823:            c->thread->stats.touch_misses++;
        -: 1824:        } else {
    90800: 1825:            c->thread->stats.get_cmds++;
    90800: 1826:            c->thread->stats.get_misses++;
        -: 1827:        }
    90800: 1828:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1829:
    90800: 1830:        if (should_touch) {
        -: 1831:            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        -: 1832:        } else {
    90800: 1833:            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 1834:        }
        -: 1835:
    90800: 1836:        if (c->noreply) {
    #####: 1837:            conn_set_state(c, conn_new_cmd);
        -: 1838:        } else {
    90800: 1839:            if (should_return_key) {
    #####: 1840:                write_bin_miss_response(c, key, nkey);
        -: 1841:            } else {
    90800: 1842:                write_bin_miss_response(c, NULL, 0);
        -: 1843:            }
        -: 1844:        }
        -: 1845:    }
        -: 1846:
    90800: 1847:    if (settings.detail_enabled) {
    #####: 1848:        stats_prefix_record_get(key, nkey, NULL != it);
        -: 1849:    }
    90800: 1850:}
------------------
process_bin_get_or_touch:
    90800: 1695:static void process_bin_get_or_touch(conn *c) {
    90800: 1696:    item *it;
        -: 1697:
    90800: 1698:    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;
   181600: 1699:    char* key = binary_get_key(c);
    90800: 1700:    size_t nkey = c->binary_header.request.keylen;
   181600: 1701:    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
    90800: 1702:                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
        -: 1703:                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
    90800: 1704:    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
        -: 1705:                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
    90800: 1706:    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
    90800: 1707:    bool failed = false;
        -: 1708:
    90800: 1709:    if (settings.verbose > 1) {
    #####: 1710:        fprintf(stderr, "<%d %s ", c->sfd, should_touch ? "TOUCH" : "GET");
    #####: 1711:        if (fwrite(key, 1, nkey, stderr)) {}
    #####: 1712:        fputc('\n', stderr);
        -: 1713:    }
        -: 1714:
    90800: 1715:    if (should_touch) {
    #####: 1716:        protocol_binary_request_touch *t = binary_get_request(c);
    #####: 1717:        time_t exptime = ntohl(t->message.body.expiration);
        -: 1718:
    #####: 1719:        it = item_touch(key, nkey, realtime(exptime), c);
        -: 1720:    } else {
    90800: 1721:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 1722:    }
        -: 1723:
    90800: 1724:    if (it) {
        -: 1725:        /* the length has two unnecessary bytes ("\r\n") */
    #####: 1726:        uint16_t keylen = 0;
    #####: 1727:        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);
        -: 1728:
    #####: 1729:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 1730:        if (should_touch) {
    #####: 1731:            c->thread->stats.touch_cmds++;
    #####: 1732:            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 1733:        } else {
    #####: 1734:            c->thread->stats.get_cmds++;
    #####: 1735:            c->thread->stats.lru_hits[it->slabs_clsid]++;
        -: 1736:        }
    #####: 1737:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1738:
    #####: 1739:        if (should_touch) {
        -: 1740:            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
        -: 1741:                                    it->nbytes, ITEM_get_cas(it));
        -: 1742:        } else {
        -: 1743:            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 1744:                                  it->nbytes, ITEM_get_cas(it));
        -: 1745:        }
        -: 1746:
    #####: 1747:        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
    #####: 1748:            bodylen -= it->nbytes - 2;
    #####: 1749:        } else if (should_return_key) {
    #####: 1750:            bodylen += nkey;
    #####: 1751:            keylen = nkey;
        -: 1752:        }
        -: 1753:
    #####: 1754:        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);
    #####: 1755:        rsp->message.header.response.cas = htonll(ITEM_get_cas(it));
        -: 1756:
        -: 1757:        // add the flags
    #####: 1758:        FLAGS_CONV(it, rsp->message.body.flags);
    #####: 1759:        rsp->message.body.flags = htonl(rsp->message.body.flags);
    #####: 1760:        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));
        -: 1761:
    #####: 1762:        if (should_return_key) {
    #####: 1763:            add_iov(c, ITEM_key(it), nkey);
        -: 1764:        }
        -: 1765:
    #####: 1766:        if (should_return_value) {
        -: 1767:            /* Add the data minus the CRLF */
        -: 1768:#ifdef EXTSTORE
        -: 1769:            if (it->it_flags & ITEM_HDR) {
        -: 1770:                int iovcnt = 4;
        -: 1771:                int iovst = c->iovused - 3;
        -: 1772:                if (!should_return_key) {
        -: 1773:                    iovcnt = 3;
        -: 1774:                    iovst = c->iovused - 2;
        -: 1775:                }
        -: 1776:
        -: 1777:                if (_get_extstore(c, it, iovst, iovcnt) != 0) {
        -: 1778:                    pthread_mutex_lock(&c->thread->stats.mutex);
        -: 1779:                    c->thread->stats.get_oom_extstore++;
        -: 1780:                    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1781:
        -: 1782:                    failed = true;
        -: 1783:                }
        -: 1784:            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 1785:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1786:            } else {
        -: 1787:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1788:            }
        -: 1789:#else
    #####: 1790:            if ((it->it_flags & ITEM_CHUNKED) == 0) {
    #####: 1791:                add_iov(c, ITEM_data(it), it->nbytes - 2);
        -: 1792:            } else {
    #####: 1793:                add_chunked_item_iovs(c, it, it->nbytes - 2);
        -: 1794:            }
        -: 1795:#endif
        -: 1796:        }
        -: 1797:
    #####: 1798:        if (!failed) {
    #####: 1799:            conn_set_state(c, conn_mwrite);
    #####: 1800:            c->write_and_go = conn_new_cmd;
        -: 1801:            /* Remember this command so we can garbage collect it later */
        -: 1802:#ifdef EXTSTORE
        -: 1803:            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {
        -: 1804:                // Only have extstore clean if header and returning value.
        -: 1805:                c->item = NULL;
        -: 1806:            } else {
        -: 1807:                c->item = it;
        -: 1808:            }
        -: 1809:#else
    #####: 1810:            c->item = it;
        -: 1811:#endif
        -: 1812:        } else {
        -: 1813:            item_remove(it);
        -: 1814:        }
        -: 1815:    } else {
        -: 1816:        failed = true;
        -: 1817:    }
        -: 1818:
    #####: 1819:    if (failed) {
    90800: 1820:        pthread_mutex_lock(&c->thread->stats.mutex);
    90800: 1821:        if (should_touch) {
    #####: 1822:            c->thread->stats.touch_cmds++;
    #####: 1823:            c->thread->stats.touch_misses++;
        -: 1824:        } else {
    90800: 1825:            c->thread->stats.get_cmds++;
    90800: 1826:            c->thread->stats.get_misses++;
        -: 1827:        }
    90800: 1828:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 1829:
    90800: 1830:        if (should_touch) {
        -: 1831:            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        -: 1832:        } else {
    90800: 1833:            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        -: 1834:        }
        -: 1835:
    90800: 1836:        if (c->noreply) {
    #####: 1837:            conn_set_state(c, conn_new_cmd);
        -: 1838:        } else {
    90800: 1839:            if (should_return_key) {
    #####: 1840:                write_bin_miss_response(c, key, nkey);
        -: 1841:            } else {
    90800: 1842:                write_bin_miss_response(c, NULL, 0);
        -: 1843:            }
        -: 1844:        }
        -: 1845:    }
        -: 1846:
    90800: 1847:    if (settings.detail_enabled) {
    #####: 1848:        stats_prefix_record_get(key, nkey, NULL != it);
        -: 1849:    }
    90800: 1850:}
------------------
        -: 1851:
    #####: 1852:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1853:                             const char *val, const uint32_t vlen,
        -: 1854:                             conn *c) {
    #####: 1855:    char *buf = c->stats.buffer + c->stats.offset;
    #####: 1856:    uint32_t bodylen = klen + vlen;
    #####: 1857:    protocol_binary_response_header header = {
        -: 1858:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1859:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
    #####: 1860:        .response.keylen = (uint16_t)htons(klen),
        -: 1861:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
    #####: 1862:        .response.bodylen = htonl(bodylen),
    #####: 1863:        .response.opaque = c->opaque
        -: 1864:    };
        -: 1865:
    #####: 1866:    memcpy(buf, header.bytes, sizeof(header.response));
    #####: 1867:    buf += sizeof(header.response);
        -: 1868:
    #####: 1869:    if (klen > 0) {
    #####: 1870:        memcpy(buf, key, klen);
    #####: 1871:        buf += klen;
        -: 1872:
    #####: 1873:        if (vlen > 0) {
    #####: 1874:            memcpy(buf, val, vlen);
        -: 1875:        }
        -: 1876:    }
        -: 1877:
    #####: 1878:    c->stats.offset += sizeof(header.response) + bodylen;
    #####: 1879:}
------------------
append_bin_stats:
    #####: 1852:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1853:                             const char *val, const uint32_t vlen,
        -: 1854:                             conn *c) {
    #####: 1855:    char *buf = c->stats.buffer + c->stats.offset;
    #####: 1856:    uint32_t bodylen = klen + vlen;
    #####: 1857:    protocol_binary_response_header header = {
        -: 1858:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1859:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
    #####: 1860:        .response.keylen = (uint16_t)htons(klen),
        -: 1861:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
    #####: 1862:        .response.bodylen = htonl(bodylen),
    #####: 1863:        .response.opaque = c->opaque
        -: 1864:    };
        -: 1865:
    #####: 1866:    memcpy(buf, header.bytes, sizeof(header.response));
    #####: 1867:    buf += sizeof(header.response);
        -: 1868:
    #####: 1869:    if (klen > 0) {
    #####: 1870:        memcpy(buf, key, klen);
    #####: 1871:        buf += klen;
        -: 1872:
    #####: 1873:        if (vlen > 0) {
    #####: 1874:            memcpy(buf, val, vlen);
        -: 1875:        }
        -: 1876:    }
        -: 1877:
    #####: 1878:    c->stats.offset += sizeof(header.response) + bodylen;
    #####: 1879:}
------------------
append_bin_stats:
    #####: 1852:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1853:                             const char *val, const uint32_t vlen,
        -: 1854:                             conn *c) {
    #####: 1855:    char *buf = c->stats.buffer + c->stats.offset;
    #####: 1856:    uint32_t bodylen = klen + vlen;
    #####: 1857:    protocol_binary_response_header header = {
        -: 1858:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1859:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
    #####: 1860:        .response.keylen = (uint16_t)htons(klen),
        -: 1861:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
    #####: 1862:        .response.bodylen = htonl(bodylen),
    #####: 1863:        .response.opaque = c->opaque
        -: 1864:    };
        -: 1865:
    #####: 1866:    memcpy(buf, header.bytes, sizeof(header.response));
    #####: 1867:    buf += sizeof(header.response);
        -: 1868:
    #####: 1869:    if (klen > 0) {
    #####: 1870:        memcpy(buf, key, klen);
    #####: 1871:        buf += klen;
        -: 1872:
    #####: 1873:        if (vlen > 0) {
    #####: 1874:            memcpy(buf, val, vlen);
        -: 1875:        }
        -: 1876:    }
        -: 1877:
    #####: 1878:    c->stats.offset += sizeof(header.response) + bodylen;
    #####: 1879:}
------------------
append_bin_stats:
    #####: 1852:static void append_bin_stats(const char *key, const uint16_t klen,
        -: 1853:                             const char *val, const uint32_t vlen,
        -: 1854:                             conn *c) {
    #####: 1855:    char *buf = c->stats.buffer + c->stats.offset;
    #####: 1856:    uint32_t bodylen = klen + vlen;
    #####: 1857:    protocol_binary_response_header header = {
        -: 1858:        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        -: 1859:        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
    #####: 1860:        .response.keylen = (uint16_t)htons(klen),
        -: 1861:        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
    #####: 1862:        .response.bodylen = htonl(bodylen),
    #####: 1863:        .response.opaque = c->opaque
        -: 1864:    };
        -: 1865:
    #####: 1866:    memcpy(buf, header.bytes, sizeof(header.response));
    #####: 1867:    buf += sizeof(header.response);
        -: 1868:
    #####: 1869:    if (klen > 0) {
    #####: 1870:        memcpy(buf, key, klen);
    #####: 1871:        buf += klen;
        -: 1872:
    #####: 1873:        if (vlen > 0) {
    #####: 1874:            memcpy(buf, val, vlen);
        -: 1875:        }
        -: 1876:    }
        -: 1877:
    #####: 1878:    c->stats.offset += sizeof(header.response) + bodylen;
    #####: 1879:}
------------------
        -: 1880:
    #####: 1881:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1882:                               const char *val, const uint32_t vlen,
        -: 1883:                               conn *c) {
    #####: 1884:    char *pos = c->stats.buffer + c->stats.offset;
    #####: 1885:    uint32_t nbytes = 0;
    #####: 1886:    int remaining = c->stats.size - c->stats.offset;
    #####: 1887:    int room = remaining - 1;
        -: 1888:
    #####: 1889:    if (klen == 0 && vlen == 0) {
    #####: 1890:        nbytes = snprintf(pos, room, "END\r\n");
    #####: 1891:    } else if (vlen == 0) {
    #####: 1892:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1893:    } else {
    #####: 1894:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1895:    }
        -: 1896:
    #####: 1897:    c->stats.offset += nbytes;
    #####: 1898:}
------------------
append_ascii_stats:
    #####: 1881:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1882:                               const char *val, const uint32_t vlen,
        -: 1883:                               conn *c) {
    #####: 1884:    char *pos = c->stats.buffer + c->stats.offset;
    #####: 1885:    uint32_t nbytes = 0;
    #####: 1886:    int remaining = c->stats.size - c->stats.offset;
    #####: 1887:    int room = remaining - 1;
        -: 1888:
    #####: 1889:    if (klen == 0 && vlen == 0) {
    #####: 1890:        nbytes = snprintf(pos, room, "END\r\n");
    #####: 1891:    } else if (vlen == 0) {
    #####: 1892:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1893:    } else {
    #####: 1894:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1895:    }
        -: 1896:
    #####: 1897:    c->stats.offset += nbytes;
    #####: 1898:}
------------------
append_ascii_stats:
    #####: 1881:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1882:                               const char *val, const uint32_t vlen,
        -: 1883:                               conn *c) {
    #####: 1884:    char *pos = c->stats.buffer + c->stats.offset;
    #####: 1885:    uint32_t nbytes = 0;
    #####: 1886:    int remaining = c->stats.size - c->stats.offset;
    #####: 1887:    int room = remaining - 1;
        -: 1888:
    #####: 1889:    if (klen == 0 && vlen == 0) {
    #####: 1890:        nbytes = snprintf(pos, room, "END\r\n");
    #####: 1891:    } else if (vlen == 0) {
    #####: 1892:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1893:    } else {
    #####: 1894:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1895:    }
        -: 1896:
    #####: 1897:    c->stats.offset += nbytes;
    #####: 1898:}
------------------
append_ascii_stats:
    #####: 1881:static void append_ascii_stats(const char *key, const uint16_t klen,
        -: 1882:                               const char *val, const uint32_t vlen,
        -: 1883:                               conn *c) {
    #####: 1884:    char *pos = c->stats.buffer + c->stats.offset;
    #####: 1885:    uint32_t nbytes = 0;
    #####: 1886:    int remaining = c->stats.size - c->stats.offset;
    #####: 1887:    int room = remaining - 1;
        -: 1888:
    #####: 1889:    if (klen == 0 && vlen == 0) {
    #####: 1890:        nbytes = snprintf(pos, room, "END\r\n");
    #####: 1891:    } else if (vlen == 0) {
    #####: 1892:        nbytes = snprintf(pos, room, "STAT %s\r\n", key);
        -: 1893:    } else {
    #####: 1894:        nbytes = snprintf(pos, room, "STAT %s %s\r\n", key, val);
        -: 1895:    }
        -: 1896:
    #####: 1897:    c->stats.offset += nbytes;
    #####: 1898:}
------------------
        -: 1899:
    #####: 1900:static bool grow_stats_buf(conn *c, size_t needed) {
    #####: 1901:    size_t nsize = c->stats.size;
    #####: 1902:    size_t available = nsize - c->stats.offset;
    #####: 1903:    bool rv = true;
        -: 1904:
        -: 1905:    /* Special case: No buffer -- need to allocate fresh */
    #####: 1906:    if (c->stats.buffer == NULL) {
    #####: 1907:        nsize = 1024;
    #####: 1908:        available = c->stats.size = c->stats.offset = 0;
        -: 1909:    }
        -: 1910:
    #####: 1911:    while (needed > available) {
    #####: 1912:        assert(nsize > 0);
    #####: 1913:        nsize = nsize << 1;
    #####: 1914:        available = nsize - c->stats.offset;
        -: 1915:    }
        -: 1916:
    #####: 1917:    if (nsize != c->stats.size) {
    #####: 1918:        char *ptr = realloc(c->stats.buffer, nsize);
    #####: 1919:        if (ptr) {
    #####: 1920:            c->stats.buffer = ptr;
    #####: 1921:            c->stats.size = nsize;
        -: 1922:        } else {
    #####: 1923:            STATS_LOCK();
    #####: 1924:            stats.malloc_fails++;
    #####: 1925:            STATS_UNLOCK();
    #####: 1926:            rv = false;
        -: 1927:        }
        -: 1928:    }
        -: 1929:
    #####: 1930:    return rv;
        -: 1931:}
------------------
grow_stats_buf:
    #####: 1900:static bool grow_stats_buf(conn *c, size_t needed) {
    #####: 1901:    size_t nsize = c->stats.size;
    #####: 1902:    size_t available = nsize - c->stats.offset;
    #####: 1903:    bool rv = true;
        -: 1904:
        -: 1905:    /* Special case: No buffer -- need to allocate fresh */
    #####: 1906:    if (c->stats.buffer == NULL) {
    #####: 1907:        nsize = 1024;
    #####: 1908:        available = c->stats.size = c->stats.offset = 0;
        -: 1909:    }
        -: 1910:
    #####: 1911:    while (needed > available) {
    #####: 1912:        assert(nsize > 0);
    #####: 1913:        nsize = nsize << 1;
    #####: 1914:        available = nsize - c->stats.offset;
        -: 1915:    }
        -: 1916:
    #####: 1917:    if (nsize != c->stats.size) {
    #####: 1918:        char *ptr = realloc(c->stats.buffer, nsize);
    #####: 1919:        if (ptr) {
    #####: 1920:            c->stats.buffer = ptr;
    #####: 1921:            c->stats.size = nsize;
        -: 1922:        } else {
    #####: 1923:            STATS_LOCK();
    #####: 1924:            stats.malloc_fails++;
    #####: 1925:            STATS_UNLOCK();
    #####: 1926:            rv = false;
        -: 1927:        }
        -: 1928:    }
        -: 1929:
    #####: 1930:    return rv;
        -: 1931:}
------------------
grow_stats_buf:
    #####: 1900:static bool grow_stats_buf(conn *c, size_t needed) {
    #####: 1901:    size_t nsize = c->stats.size;
    #####: 1902:    size_t available = nsize - c->stats.offset;
    #####: 1903:    bool rv = true;
        -: 1904:
        -: 1905:    /* Special case: No buffer -- need to allocate fresh */
    #####: 1906:    if (c->stats.buffer == NULL) {
    #####: 1907:        nsize = 1024;
    #####: 1908:        available = c->stats.size = c->stats.offset = 0;
        -: 1909:    }
        -: 1910:
    #####: 1911:    while (needed > available) {
    #####: 1912:        assert(nsize > 0);
    #####: 1913:        nsize = nsize << 1;
    #####: 1914:        available = nsize - c->stats.offset;
        -: 1915:    }
        -: 1916:
    #####: 1917:    if (nsize != c->stats.size) {
    #####: 1918:        char *ptr = realloc(c->stats.buffer, nsize);
    #####: 1919:        if (ptr) {
    #####: 1920:            c->stats.buffer = ptr;
    #####: 1921:            c->stats.size = nsize;
        -: 1922:        } else {
    #####: 1923:            STATS_LOCK();
    #####: 1924:            stats.malloc_fails++;
    #####: 1925:            STATS_UNLOCK();
    #####: 1926:            rv = false;
        -: 1927:        }
        -: 1928:    }
        -: 1929:
    #####: 1930:    return rv;
        -: 1931:}
------------------
grow_stats_buf:
    #####: 1900:static bool grow_stats_buf(conn *c, size_t needed) {
    #####: 1901:    size_t nsize = c->stats.size;
    #####: 1902:    size_t available = nsize - c->stats.offset;
    #####: 1903:    bool rv = true;
        -: 1904:
        -: 1905:    /* Special case: No buffer -- need to allocate fresh */
    #####: 1906:    if (c->stats.buffer == NULL) {
    #####: 1907:        nsize = 1024;
    #####: 1908:        available = c->stats.size = c->stats.offset = 0;
        -: 1909:    }
        -: 1910:
    #####: 1911:    while (needed > available) {
    #####: 1912:        assert(nsize > 0);
    #####: 1913:        nsize = nsize << 1;
    #####: 1914:        available = nsize - c->stats.offset;
        -: 1915:    }
        -: 1916:
    #####: 1917:    if (nsize != c->stats.size) {
    #####: 1918:        char *ptr = realloc(c->stats.buffer, nsize);
    #####: 1919:        if (ptr) {
    #####: 1920:            c->stats.buffer = ptr;
    #####: 1921:            c->stats.size = nsize;
        -: 1922:        } else {
    #####: 1923:            STATS_LOCK();
    #####: 1924:            stats.malloc_fails++;
    #####: 1925:            STATS_UNLOCK();
    #####: 1926:            rv = false;
        -: 1927:        }
        -: 1928:    }
        -: 1929:
    #####: 1930:    return rv;
        -: 1931:}
------------------
        -: 1932:
    #####: 1933:static void append_stats(const char *key, const uint16_t klen,
        -: 1934:                  const char *val, const uint32_t vlen,
        -: 1935:                  const void *cookie)
        -: 1936:{
        -: 1937:    /* value without a key is invalid */
    #####: 1938:    if (klen == 0 && vlen > 0) {
        -: 1939:        return ;
        -: 1940:    }
        -: 1941:
    #####: 1942:    conn *c = (conn*)cookie;
        -: 1943:
    #####: 1944:    if (c->protocol == binary_prot) {
    #####: 1945:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
    #####: 1946:        if (!grow_stats_buf(c, needed)) {
        -: 1947:            return ;
        -: 1948:        }
    #####: 1949:        append_bin_stats(key, klen, val, vlen, c);
        -: 1950:    } else {
    #####: 1951:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
    #####: 1952:        if (!grow_stats_buf(c, needed)) {
        -: 1953:            return ;
        -: 1954:        }
    #####: 1955:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1956:    }
        -: 1957:
    #####: 1958:    assert(c->stats.offset <= c->stats.size);
        -: 1959:}
------------------
append_stats:
    #####: 1933:static void append_stats(const char *key, const uint16_t klen,
        -: 1934:                  const char *val, const uint32_t vlen,
        -: 1935:                  const void *cookie)
        -: 1936:{
        -: 1937:    /* value without a key is invalid */
    #####: 1938:    if (klen == 0 && vlen > 0) {
        -: 1939:        return ;
        -: 1940:    }
        -: 1941:
    #####: 1942:    conn *c = (conn*)cookie;
        -: 1943:
    #####: 1944:    if (c->protocol == binary_prot) {
    #####: 1945:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
    #####: 1946:        if (!grow_stats_buf(c, needed)) {
        -: 1947:            return ;
        -: 1948:        }
    #####: 1949:        append_bin_stats(key, klen, val, vlen, c);
        -: 1950:    } else {
    #####: 1951:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
    #####: 1952:        if (!grow_stats_buf(c, needed)) {
        -: 1953:            return ;
        -: 1954:        }
    #####: 1955:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1956:    }
        -: 1957:
    #####: 1958:    assert(c->stats.offset <= c->stats.size);
        -: 1959:}
------------------
append_stats:
    #####: 1933:static void append_stats(const char *key, const uint16_t klen,
        -: 1934:                  const char *val, const uint32_t vlen,
        -: 1935:                  const void *cookie)
        -: 1936:{
        -: 1937:    /* value without a key is invalid */
    #####: 1938:    if (klen == 0 && vlen > 0) {
        -: 1939:        return ;
        -: 1940:    }
        -: 1941:
    #####: 1942:    conn *c = (conn*)cookie;
        -: 1943:
    #####: 1944:    if (c->protocol == binary_prot) {
    #####: 1945:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
    #####: 1946:        if (!grow_stats_buf(c, needed)) {
        -: 1947:            return ;
        -: 1948:        }
    #####: 1949:        append_bin_stats(key, klen, val, vlen, c);
        -: 1950:    } else {
    #####: 1951:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
    #####: 1952:        if (!grow_stats_buf(c, needed)) {
        -: 1953:            return ;
        -: 1954:        }
    #####: 1955:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1956:    }
        -: 1957:
    #####: 1958:    assert(c->stats.offset <= c->stats.size);
        -: 1959:}
------------------
append_stats:
    #####: 1933:static void append_stats(const char *key, const uint16_t klen,
        -: 1934:                  const char *val, const uint32_t vlen,
        -: 1935:                  const void *cookie)
        -: 1936:{
        -: 1937:    /* value without a key is invalid */
    #####: 1938:    if (klen == 0 && vlen > 0) {
        -: 1939:        return ;
        -: 1940:    }
        -: 1941:
    #####: 1942:    conn *c = (conn*)cookie;
        -: 1943:
    #####: 1944:    if (c->protocol == binary_prot) {
    #####: 1945:        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
    #####: 1946:        if (!grow_stats_buf(c, needed)) {
        -: 1947:            return ;
        -: 1948:        }
    #####: 1949:        append_bin_stats(key, klen, val, vlen, c);
        -: 1950:    } else {
    #####: 1951:        size_t needed = vlen + klen + 10; // 10 == "STAT = \r\n"
    #####: 1952:        if (!grow_stats_buf(c, needed)) {
        -: 1953:            return ;
        -: 1954:        }
    #####: 1955:        append_ascii_stats(key, klen, val, vlen, c);
        -: 1956:    }
        -: 1957:
    #####: 1958:    assert(c->stats.offset <= c->stats.size);
        -: 1959:}
------------------
        -: 1960:
    #####: 1961:static void process_bin_stat(conn *c) {
    #####: 1962:    char *subcommand = binary_get_key(c);
    #####: 1963:    size_t nkey = c->binary_header.request.keylen;
        -: 1964:
    #####: 1965:    if (settings.verbose > 1) {
    #####: 1966:        int ii;
    #####: 1967:        fprintf(stderr, "<%d STATS ", c->sfd);
    #####: 1968:        for (ii = 0; ii < nkey; ++ii) {
    #####: 1969:            fprintf(stderr, "%c", subcommand[ii]);
        -: 1970:        }
    #####: 1971:        fprintf(stderr, "\n");
        -: 1972:    }
        -: 1973:
    #####: 1974:    if (nkey == 0) {
        -: 1975:        /* request all statistics */
    #####: 1976:        server_stats(&append_stats, c);
    #####: 1977:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 1978:    } else if (strncmp(subcommand, "reset", 5) == 0) {
    #####: 1979:        stats_reset();
    #####: 1980:    } else if (strncmp(subcommand, "settings", 8) == 0) {
    #####: 1981:        process_stat_settings(&append_stats, c);
    #####: 1982:    } else if (strncmp(subcommand, "detail", 6) == 0) {
    #####: 1983:        char *subcmd_pos = subcommand + 6;
    #####: 1984:        if (strncmp(subcmd_pos, " dump", 5) == 0) {
    #####: 1985:            int len;
    #####: 1986:            char *dump_buf = stats_prefix_dump(&len);
    #####: 1987:            if (dump_buf == NULL || len <= 0) {
    #####: 1988:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
    #####: 1989:                if (dump_buf != NULL)
    #####: 1990:                    free(dump_buf);
    #####: 1991:                return;
        -: 1992:            } else {
    #####: 1993:                append_stats("detailed", strlen("detailed"), dump_buf, len, c);
    #####: 1994:                free(dump_buf);
        -: 1995:            }
    #####: 1996:        } else if (strncmp(subcmd_pos, " on", 3) == 0) {
    #####: 1997:            settings.detail_enabled = 1;
    #####: 1998:        } else if (strncmp(subcmd_pos, " off", 4) == 0) {
    #####: 1999:            settings.detail_enabled = 0;
        -: 2000:        } else {
    #####: 2001:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2002:            return;
        -: 2003:        }
        -: 2004:    } else {
    #####: 2005:        if (get_stats(subcommand, nkey, &append_stats, c)) {
    #####: 2006:            if (c->stats.buffer == NULL) {
    #####: 2007:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
        -: 2008:            } else {
    #####: 2009:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2010:                c->stats.buffer = NULL;
        -: 2011:            }
        -: 2012:        } else {
    #####: 2013:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 2014:        }
        -: 2015:
    #####: 2016:        return;
        -: 2017:    }
        -: 2018:
        -: 2019:    /* Append termination package and start the transfer */
    #####: 2020:    append_stats(NULL, 0, NULL, 0, c);
    #####: 2021:    if (c->stats.buffer == NULL) {
    #####: 2022:        out_of_memory(c, "SERVER_ERROR Out of memory preparing to send stats");
        -: 2023:    } else {
    #####: 2024:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2025:        c->stats.buffer = NULL;
        -: 2026:    }
        -: 2027:}
------------------
process_bin_stat:
    #####: 1961:static void process_bin_stat(conn *c) {
    #####: 1962:    char *subcommand = binary_get_key(c);
    #####: 1963:    size_t nkey = c->binary_header.request.keylen;
        -: 1964:
    #####: 1965:    if (settings.verbose > 1) {
    #####: 1966:        int ii;
    #####: 1967:        fprintf(stderr, "<%d STATS ", c->sfd);
    #####: 1968:        for (ii = 0; ii < nkey; ++ii) {
    #####: 1969:            fprintf(stderr, "%c", subcommand[ii]);
        -: 1970:        }
    #####: 1971:        fprintf(stderr, "\n");
        -: 1972:    }
        -: 1973:
    #####: 1974:    if (nkey == 0) {
        -: 1975:        /* request all statistics */
    #####: 1976:        server_stats(&append_stats, c);
    #####: 1977:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 1978:    } else if (strncmp(subcommand, "reset", 5) == 0) {
    #####: 1979:        stats_reset();
    #####: 1980:    } else if (strncmp(subcommand, "settings", 8) == 0) {
    #####: 1981:        process_stat_settings(&append_stats, c);
    #####: 1982:    } else if (strncmp(subcommand, "detail", 6) == 0) {
    #####: 1983:        char *subcmd_pos = subcommand + 6;
    #####: 1984:        if (strncmp(subcmd_pos, " dump", 5) == 0) {
    #####: 1985:            int len;
    #####: 1986:            char *dump_buf = stats_prefix_dump(&len);
    #####: 1987:            if (dump_buf == NULL || len <= 0) {
    #####: 1988:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
    #####: 1989:                if (dump_buf != NULL)
    #####: 1990:                    free(dump_buf);
    #####: 1991:                return;
        -: 1992:            } else {
    #####: 1993:                append_stats("detailed", strlen("detailed"), dump_buf, len, c);
    #####: 1994:                free(dump_buf);
        -: 1995:            }
    #####: 1996:        } else if (strncmp(subcmd_pos, " on", 3) == 0) {
    #####: 1997:            settings.detail_enabled = 1;
    #####: 1998:        } else if (strncmp(subcmd_pos, " off", 4) == 0) {
    #####: 1999:            settings.detail_enabled = 0;
        -: 2000:        } else {
    #####: 2001:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2002:            return;
        -: 2003:        }
        -: 2004:    } else {
    #####: 2005:        if (get_stats(subcommand, nkey, &append_stats, c)) {
    #####: 2006:            if (c->stats.buffer == NULL) {
    #####: 2007:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
        -: 2008:            } else {
    #####: 2009:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2010:                c->stats.buffer = NULL;
        -: 2011:            }
        -: 2012:        } else {
    #####: 2013:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 2014:        }
        -: 2015:
    #####: 2016:        return;
        -: 2017:    }
        -: 2018:
        -: 2019:    /* Append termination package and start the transfer */
    #####: 2020:    append_stats(NULL, 0, NULL, 0, c);
    #####: 2021:    if (c->stats.buffer == NULL) {
    #####: 2022:        out_of_memory(c, "SERVER_ERROR Out of memory preparing to send stats");
        -: 2023:    } else {
    #####: 2024:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2025:        c->stats.buffer = NULL;
        -: 2026:    }
        -: 2027:}
------------------
process_bin_stat:
    #####: 1961:static void process_bin_stat(conn *c) {
    #####: 1962:    char *subcommand = binary_get_key(c);
    #####: 1963:    size_t nkey = c->binary_header.request.keylen;
        -: 1964:
    #####: 1965:    if (settings.verbose > 1) {
    #####: 1966:        int ii;
    #####: 1967:        fprintf(stderr, "<%d STATS ", c->sfd);
    #####: 1968:        for (ii = 0; ii < nkey; ++ii) {
    #####: 1969:            fprintf(stderr, "%c", subcommand[ii]);
        -: 1970:        }
    #####: 1971:        fprintf(stderr, "\n");
        -: 1972:    }
        -: 1973:
    #####: 1974:    if (nkey == 0) {
        -: 1975:        /* request all statistics */
    #####: 1976:        server_stats(&append_stats, c);
    #####: 1977:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 1978:    } else if (strncmp(subcommand, "reset", 5) == 0) {
    #####: 1979:        stats_reset();
    #####: 1980:    } else if (strncmp(subcommand, "settings", 8) == 0) {
    #####: 1981:        process_stat_settings(&append_stats, c);
    #####: 1982:    } else if (strncmp(subcommand, "detail", 6) == 0) {
    #####: 1983:        char *subcmd_pos = subcommand + 6;
    #####: 1984:        if (strncmp(subcmd_pos, " dump", 5) == 0) {
    #####: 1985:            int len;
    #####: 1986:            char *dump_buf = stats_prefix_dump(&len);
    #####: 1987:            if (dump_buf == NULL || len <= 0) {
    #####: 1988:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
    #####: 1989:                if (dump_buf != NULL)
    #####: 1990:                    free(dump_buf);
    #####: 1991:                return;
        -: 1992:            } else {
    #####: 1993:                append_stats("detailed", strlen("detailed"), dump_buf, len, c);
    #####: 1994:                free(dump_buf);
        -: 1995:            }
    #####: 1996:        } else if (strncmp(subcmd_pos, " on", 3) == 0) {
    #####: 1997:            settings.detail_enabled = 1;
    #####: 1998:        } else if (strncmp(subcmd_pos, " off", 4) == 0) {
    #####: 1999:            settings.detail_enabled = 0;
        -: 2000:        } else {
    #####: 2001:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2002:            return;
        -: 2003:        }
        -: 2004:    } else {
    #####: 2005:        if (get_stats(subcommand, nkey, &append_stats, c)) {
    #####: 2006:            if (c->stats.buffer == NULL) {
    #####: 2007:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
        -: 2008:            } else {
    #####: 2009:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2010:                c->stats.buffer = NULL;
        -: 2011:            }
        -: 2012:        } else {
    #####: 2013:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 2014:        }
        -: 2015:
    #####: 2016:        return;
        -: 2017:    }
        -: 2018:
        -: 2019:    /* Append termination package and start the transfer */
    #####: 2020:    append_stats(NULL, 0, NULL, 0, c);
    #####: 2021:    if (c->stats.buffer == NULL) {
    #####: 2022:        out_of_memory(c, "SERVER_ERROR Out of memory preparing to send stats");
        -: 2023:    } else {
    #####: 2024:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2025:        c->stats.buffer = NULL;
        -: 2026:    }
        -: 2027:}
------------------
process_bin_stat:
    #####: 1961:static void process_bin_stat(conn *c) {
    #####: 1962:    char *subcommand = binary_get_key(c);
    #####: 1963:    size_t nkey = c->binary_header.request.keylen;
        -: 1964:
    #####: 1965:    if (settings.verbose > 1) {
    #####: 1966:        int ii;
    #####: 1967:        fprintf(stderr, "<%d STATS ", c->sfd);
    #####: 1968:        for (ii = 0; ii < nkey; ++ii) {
    #####: 1969:            fprintf(stderr, "%c", subcommand[ii]);
        -: 1970:        }
    #####: 1971:        fprintf(stderr, "\n");
        -: 1972:    }
        -: 1973:
    #####: 1974:    if (nkey == 0) {
        -: 1975:        /* request all statistics */
    #####: 1976:        server_stats(&append_stats, c);
    #####: 1977:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 1978:    } else if (strncmp(subcommand, "reset", 5) == 0) {
    #####: 1979:        stats_reset();
    #####: 1980:    } else if (strncmp(subcommand, "settings", 8) == 0) {
    #####: 1981:        process_stat_settings(&append_stats, c);
    #####: 1982:    } else if (strncmp(subcommand, "detail", 6) == 0) {
    #####: 1983:        char *subcmd_pos = subcommand + 6;
    #####: 1984:        if (strncmp(subcmd_pos, " dump", 5) == 0) {
    #####: 1985:            int len;
    #####: 1986:            char *dump_buf = stats_prefix_dump(&len);
    #####: 1987:            if (dump_buf == NULL || len <= 0) {
    #####: 1988:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
    #####: 1989:                if (dump_buf != NULL)
    #####: 1990:                    free(dump_buf);
    #####: 1991:                return;
        -: 1992:            } else {
    #####: 1993:                append_stats("detailed", strlen("detailed"), dump_buf, len, c);
    #####: 1994:                free(dump_buf);
        -: 1995:            }
    #####: 1996:        } else if (strncmp(subcmd_pos, " on", 3) == 0) {
    #####: 1997:            settings.detail_enabled = 1;
    #####: 1998:        } else if (strncmp(subcmd_pos, " off", 4) == 0) {
    #####: 1999:            settings.detail_enabled = 0;
        -: 2000:        } else {
    #####: 2001:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2002:            return;
        -: 2003:        }
        -: 2004:    } else {
    #####: 2005:        if (get_stats(subcommand, nkey, &append_stats, c)) {
    #####: 2006:            if (c->stats.buffer == NULL) {
    #####: 2007:                out_of_memory(c, "SERVER_ERROR Out of memory generating stats");
        -: 2008:            } else {
    #####: 2009:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2010:                c->stats.buffer = NULL;
        -: 2011:            }
        -: 2012:        } else {
    #####: 2013:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        -: 2014:        }
        -: 2015:
    #####: 2016:        return;
        -: 2017:    }
        -: 2018:
        -: 2019:    /* Append termination package and start the transfer */
    #####: 2020:    append_stats(NULL, 0, NULL, 0, c);
    #####: 2021:    if (c->stats.buffer == NULL) {
    #####: 2022:        out_of_memory(c, "SERVER_ERROR Out of memory preparing to send stats");
        -: 2023:    } else {
    #####: 2024:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 2025:        c->stats.buffer = NULL;
        -: 2026:    }
        -: 2027:}
------------------
        -: 2028:
   300000: 2029:static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {
  300000*: 2030:    assert(c);
   300000: 2031:    c->substate = next_substate;
   300000: 2032:    c->rlbytes = c->keylen + extra;
        -: 2033:
        -: 2034:    /* Ok... do we have room for the extras and the key in the input buffer? */
   300000: 2035:    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;
   300000: 2036:    if (c->rlbytes > c->rsize - offset) {
    #####: 2037:        size_t nsize = c->rsize;
    #####: 2038:        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);
        -: 2039:
    #####: 2040:        while (size > nsize) {
    #####: 2041:            nsize *= 2;
        -: 2042:        }
        -: 2043:
    #####: 2044:        if (nsize != c->rsize) {
    #####: 2045:            if (settings.verbose > 1) {
    #####: 2046:                fprintf(stderr, "%d: Need to grow buffer from %lu to %lu\n",
        -: 2047:                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);
        -: 2048:            }
    #####: 2049:            char *newm = realloc(c->rbuf, nsize);
    #####: 2050:            if (newm == NULL) {
    #####: 2051:                STATS_LOCK();
    #####: 2052:                stats.malloc_fails++;
    #####: 2053:                STATS_UNLOCK();
    #####: 2054:                if (settings.verbose) {
    #####: 2055:                    fprintf(stderr, "%d: Failed to grow buffer.. closing connection\n",
        -: 2056:                            c->sfd);
        -: 2057:                }
    #####: 2058:                conn_set_state(c, conn_closing);
    #####: 2059:                return;
        -: 2060:            }
        -: 2061:
    #####: 2062:            c->rbuf= newm;
        -: 2063:            /* rcurr should point to the same offset in the packet */
    #####: 2064:            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);
    #####: 2065:            c->rsize = nsize;
        -: 2066:        }
    #####: 2067:        if (c->rbuf != c->rcurr) {
    #####: 2068:            memmove(c->rbuf, c->rcurr, c->rbytes);
    #####: 2069:            c->rcurr = c->rbuf;
    #####: 2070:            if (settings.verbose > 1) {
    #####: 2071:                fprintf(stderr, "%d: Repack input buffer\n", c->sfd);
        -: 2072:            }
        -: 2073:        }
        -: 2074:    }
        -: 2075:
        -: 2076:    /* preserve the header in the buffer.. */
   300000: 2077:    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);
   300000: 2078:    conn_set_state(c, conn_nread);
        -: 2079:}
------------------
bin_read_key:
   100000: 2029:static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {
  100000*: 2030:    assert(c);
   100000: 2031:    c->substate = next_substate;
   100000: 2032:    c->rlbytes = c->keylen + extra;
        -: 2033:
        -: 2034:    /* Ok... do we have room for the extras and the key in the input buffer? */
   100000: 2035:    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;
   100000: 2036:    if (c->rlbytes > c->rsize - offset) {
    #####: 2037:        size_t nsize = c->rsize;
    #####: 2038:        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);
        -: 2039:
    #####: 2040:        while (size > nsize) {
    #####: 2041:            nsize *= 2;
        -: 2042:        }
        -: 2043:
    #####: 2044:        if (nsize != c->rsize) {
    #####: 2045:            if (settings.verbose > 1) {
    #####: 2046:                fprintf(stderr, "%d: Need to grow buffer from %lu to %lu\n",
        -: 2047:                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);
        -: 2048:            }
    #####: 2049:            char *newm = realloc(c->rbuf, nsize);
    #####: 2050:            if (newm == NULL) {
    #####: 2051:                STATS_LOCK();
    #####: 2052:                stats.malloc_fails++;
    #####: 2053:                STATS_UNLOCK();
    #####: 2054:                if (settings.verbose) {
    #####: 2055:                    fprintf(stderr, "%d: Failed to grow buffer.. closing connection\n",
        -: 2056:                            c->sfd);
        -: 2057:                }
    #####: 2058:                conn_set_state(c, conn_closing);
    #####: 2059:                return;
        -: 2060:            }
        -: 2061:
    #####: 2062:            c->rbuf= newm;
        -: 2063:            /* rcurr should point to the same offset in the packet */
    #####: 2064:            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);
    #####: 2065:            c->rsize = nsize;
        -: 2066:        }
    #####: 2067:        if (c->rbuf != c->rcurr) {
    #####: 2068:            memmove(c->rbuf, c->rcurr, c->rbytes);
    #####: 2069:            c->rcurr = c->rbuf;
    #####: 2070:            if (settings.verbose > 1) {
    #####: 2071:                fprintf(stderr, "%d: Repack input buffer\n", c->sfd);
        -: 2072:            }
        -: 2073:        }
        -: 2074:    }
        -: 2075:
        -: 2076:    /* preserve the header in the buffer.. */
   100000: 2077:    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);
   100000: 2078:    conn_set_state(c, conn_nread);
        -: 2079:}
------------------
bin_read_key:
   100000: 2029:static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {
  100000*: 2030:    assert(c);
   100000: 2031:    c->substate = next_substate;
   100000: 2032:    c->rlbytes = c->keylen + extra;
        -: 2033:
        -: 2034:    /* Ok... do we have room for the extras and the key in the input buffer? */
   100000: 2035:    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;
   100000: 2036:    if (c->rlbytes > c->rsize - offset) {
    #####: 2037:        size_t nsize = c->rsize;
    #####: 2038:        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);
        -: 2039:
    #####: 2040:        while (size > nsize) {
    #####: 2041:            nsize *= 2;
        -: 2042:        }
        -: 2043:
    #####: 2044:        if (nsize != c->rsize) {
    #####: 2045:            if (settings.verbose > 1) {
    #####: 2046:                fprintf(stderr, "%d: Need to grow buffer from %lu to %lu\n",
        -: 2047:                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);
        -: 2048:            }
    #####: 2049:            char *newm = realloc(c->rbuf, nsize);
    #####: 2050:            if (newm == NULL) {
    #####: 2051:                STATS_LOCK();
    #####: 2052:                stats.malloc_fails++;
    #####: 2053:                STATS_UNLOCK();
    #####: 2054:                if (settings.verbose) {
    #####: 2055:                    fprintf(stderr, "%d: Failed to grow buffer.. closing connection\n",
        -: 2056:                            c->sfd);
        -: 2057:                }
    #####: 2058:                conn_set_state(c, conn_closing);
    #####: 2059:                return;
        -: 2060:            }
        -: 2061:
    #####: 2062:            c->rbuf= newm;
        -: 2063:            /* rcurr should point to the same offset in the packet */
    #####: 2064:            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);
    #####: 2065:            c->rsize = nsize;
        -: 2066:        }
    #####: 2067:        if (c->rbuf != c->rcurr) {
    #####: 2068:            memmove(c->rbuf, c->rcurr, c->rbytes);
    #####: 2069:            c->rcurr = c->rbuf;
    #####: 2070:            if (settings.verbose > 1) {
    #####: 2071:                fprintf(stderr, "%d: Repack input buffer\n", c->sfd);
        -: 2072:            }
        -: 2073:        }
        -: 2074:    }
        -: 2075:
        -: 2076:    /* preserve the header in the buffer.. */
   100000: 2077:    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);
   100000: 2078:    conn_set_state(c, conn_nread);
        -: 2079:}
------------------
bin_read_key:
   100000: 2029:static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {
  100000*: 2030:    assert(c);
   100000: 2031:    c->substate = next_substate;
   100000: 2032:    c->rlbytes = c->keylen + extra;
        -: 2033:
        -: 2034:    /* Ok... do we have room for the extras and the key in the input buffer? */
   100000: 2035:    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;
   100000: 2036:    if (c->rlbytes > c->rsize - offset) {
    #####: 2037:        size_t nsize = c->rsize;
    #####: 2038:        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);
        -: 2039:
    #####: 2040:        while (size > nsize) {
    #####: 2041:            nsize *= 2;
        -: 2042:        }
        -: 2043:
    #####: 2044:        if (nsize != c->rsize) {
    #####: 2045:            if (settings.verbose > 1) {
    #####: 2046:                fprintf(stderr, "%d: Need to grow buffer from %lu to %lu\n",
        -: 2047:                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);
        -: 2048:            }
    #####: 2049:            char *newm = realloc(c->rbuf, nsize);
    #####: 2050:            if (newm == NULL) {
    #####: 2051:                STATS_LOCK();
    #####: 2052:                stats.malloc_fails++;
    #####: 2053:                STATS_UNLOCK();
    #####: 2054:                if (settings.verbose) {
    #####: 2055:                    fprintf(stderr, "%d: Failed to grow buffer.. closing connection\n",
        -: 2056:                            c->sfd);
        -: 2057:                }
    #####: 2058:                conn_set_state(c, conn_closing);
    #####: 2059:                return;
        -: 2060:            }
        -: 2061:
    #####: 2062:            c->rbuf= newm;
        -: 2063:            /* rcurr should point to the same offset in the packet */
    #####: 2064:            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);
    #####: 2065:            c->rsize = nsize;
        -: 2066:        }
    #####: 2067:        if (c->rbuf != c->rcurr) {
    #####: 2068:            memmove(c->rbuf, c->rcurr, c->rbytes);
    #####: 2069:            c->rcurr = c->rbuf;
    #####: 2070:            if (settings.verbose > 1) {
    #####: 2071:                fprintf(stderr, "%d: Repack input buffer\n", c->sfd);
        -: 2072:            }
        -: 2073:        }
        -: 2074:    }
        -: 2075:
        -: 2076:    /* preserve the header in the buffer.. */
   100000: 2077:    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);
   100000: 2078:    conn_set_state(c, conn_nread);
        -: 2079:}
------------------
        -: 2080:
        -: 2081:/* Just write an error message and disconnect the client */
    #####: 2082:static void handle_binary_protocol_error(conn *c) {
    #####: 2083:    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    #####: 2084:    if (settings.verbose) {
    #####: 2085:        fprintf(stderr, "Protocol error (opcode %02x), close connection %d\n",
    #####: 2086:                c->binary_header.request.opcode, c->sfd);
        -: 2087:    }
    #####: 2088:    c->write_and_go = conn_closing;
    #####: 2089:}
------------------
handle_binary_protocol_error:
    #####: 2082:static void handle_binary_protocol_error(conn *c) {
    #####: 2083:    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    #####: 2084:    if (settings.verbose) {
    #####: 2085:        fprintf(stderr, "Protocol error (opcode %02x), close connection %d\n",
    #####: 2086:                c->binary_header.request.opcode, c->sfd);
        -: 2087:    }
    #####: 2088:    c->write_and_go = conn_closing;
    #####: 2089:}
------------------
handle_binary_protocol_error:
    #####: 2082:static void handle_binary_protocol_error(conn *c) {
    #####: 2083:    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    #####: 2084:    if (settings.verbose) {
    #####: 2085:        fprintf(stderr, "Protocol error (opcode %02x), close connection %d\n",
    #####: 2086:                c->binary_header.request.opcode, c->sfd);
        -: 2087:    }
    #####: 2088:    c->write_and_go = conn_closing;
    #####: 2089:}
------------------
handle_binary_protocol_error:
    #####: 2082:static void handle_binary_protocol_error(conn *c) {
    #####: 2083:    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    #####: 2084:    if (settings.verbose) {
    #####: 2085:        fprintf(stderr, "Protocol error (opcode %02x), close connection %d\n",
    #####: 2086:                c->binary_header.request.opcode, c->sfd);
        -: 2087:    }
    #####: 2088:    c->write_and_go = conn_closing;
    #####: 2089:}
------------------
        -: 2090:
    #####: 2091:static void init_sasl_conn(conn *c) {
    #####: 2092:    assert(c);
        -: 2093:    /* should something else be returned? */
    #####: 2094:    if (!settings.sasl)
        -: 2095:        return;
        -: 2096:
    #####: 2097:    c->authenticated = false;
        -: 2098:
    #####: 2099:    if (!c->sasl_conn) {
    #####: 2100:        int result=sasl_server_new("memcached",
        -: 2101:                                   NULL,
        -: 2102:                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
        -: 2103:                                   NULL, NULL,
        -: 2104:                                   NULL, 0, &c->sasl_conn);
    #####: 2105:        if (result != SASL_OK) {
    #####: 2106:            if (settings.verbose) {
    #####: 2107:                fprintf(stderr, "Failed to initialize SASL conn.\n");
        -: 2108:            }
    #####: 2109:            c->sasl_conn = NULL;
        -: 2110:        }
        -: 2111:    }
        -: 2112:}
------------------
init_sasl_conn:
    #####: 2091:static void init_sasl_conn(conn *c) {
    #####: 2092:    assert(c);
        -: 2093:    /* should something else be returned? */
    #####: 2094:    if (!settings.sasl)
        -: 2095:        return;
        -: 2096:
    #####: 2097:    c->authenticated = false;
        -: 2098:
    #####: 2099:    if (!c->sasl_conn) {
    #####: 2100:        int result=sasl_server_new("memcached",
        -: 2101:                                   NULL,
        -: 2102:                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
        -: 2103:                                   NULL, NULL,
        -: 2104:                                   NULL, 0, &c->sasl_conn);
    #####: 2105:        if (result != SASL_OK) {
    #####: 2106:            if (settings.verbose) {
    #####: 2107:                fprintf(stderr, "Failed to initialize SASL conn.\n");
        -: 2108:            }
    #####: 2109:            c->sasl_conn = NULL;
        -: 2110:        }
        -: 2111:    }
        -: 2112:}
------------------
init_sasl_conn:
    #####: 2091:static void init_sasl_conn(conn *c) {
    #####: 2092:    assert(c);
        -: 2093:    /* should something else be returned? */
    #####: 2094:    if (!settings.sasl)
        -: 2095:        return;
        -: 2096:
    #####: 2097:    c->authenticated = false;
        -: 2098:
    #####: 2099:    if (!c->sasl_conn) {
    #####: 2100:        int result=sasl_server_new("memcached",
        -: 2101:                                   NULL,
        -: 2102:                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
        -: 2103:                                   NULL, NULL,
        -: 2104:                                   NULL, 0, &c->sasl_conn);
    #####: 2105:        if (result != SASL_OK) {
    #####: 2106:            if (settings.verbose) {
    #####: 2107:                fprintf(stderr, "Failed to initialize SASL conn.\n");
        -: 2108:            }
    #####: 2109:            c->sasl_conn = NULL;
        -: 2110:        }
        -: 2111:    }
        -: 2112:}
------------------
init_sasl_conn:
    #####: 2091:static void init_sasl_conn(conn *c) {
    #####: 2092:    assert(c);
        -: 2093:    /* should something else be returned? */
    #####: 2094:    if (!settings.sasl)
        -: 2095:        return;
        -: 2096:
    #####: 2097:    c->authenticated = false;
        -: 2098:
    #####: 2099:    if (!c->sasl_conn) {
    #####: 2100:        int result=sasl_server_new("memcached",
        -: 2101:                                   NULL,
        -: 2102:                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
        -: 2103:                                   NULL, NULL,
        -: 2104:                                   NULL, 0, &c->sasl_conn);
    #####: 2105:        if (result != SASL_OK) {
    #####: 2106:            if (settings.verbose) {
    #####: 2107:                fprintf(stderr, "Failed to initialize SASL conn.\n");
        -: 2108:            }
    #####: 2109:            c->sasl_conn = NULL;
        -: 2110:        }
        -: 2111:    }
        -: 2112:}
------------------
        -: 2113:
    #####: 2114:static void bin_list_sasl_mechs(conn *c) {
        -: 2115:    // Guard against a disabled SASL.
    #####: 2116:    if (!settings.sasl) {
    #####: 2117:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2118:                        c->binary_header.request.bodylen
    #####: 2119:                        - c->binary_header.request.keylen);
    #####: 2120:        return;
        -: 2121:    }
        -: 2122:
    #####: 2123:    init_sasl_conn(c);
    #####: 2124:    const char *result_string = NULL;
    #####: 2125:    unsigned int string_length = 0;
    #####: 2126:    int result=sasl_listmech(c->sasl_conn, NULL,
        -: 2127:                             "",   /* What to prepend the string with */
        -: 2128:                             " ",  /* What to separate mechanisms with */
        -: 2129:                             "",   /* What to append to the string */
        -: 2130:                             &result_string, &string_length,
        -: 2131:                             NULL);
    #####: 2132:    if (result != SASL_OK) {
        -: 2133:        /* Perhaps there's a better error for this... */
    #####: 2134:        if (settings.verbose) {
    #####: 2135:            fprintf(stderr, "Failed to list SASL mechanisms.\n");
        -: 2136:        }
    #####: 2137:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2138:        return;
        -: 2139:    }
        -: 2140:    write_bin_response(c, (char*)result_string, 0, 0, string_length);
        -: 2141:}
------------------
bin_list_sasl_mechs:
    #####: 2114:static void bin_list_sasl_mechs(conn *c) {
        -: 2115:    // Guard against a disabled SASL.
    #####: 2116:    if (!settings.sasl) {
    #####: 2117:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2118:                        c->binary_header.request.bodylen
    #####: 2119:                        - c->binary_header.request.keylen);
    #####: 2120:        return;
        -: 2121:    }
        -: 2122:
    #####: 2123:    init_sasl_conn(c);
    #####: 2124:    const char *result_string = NULL;
    #####: 2125:    unsigned int string_length = 0;
    #####: 2126:    int result=sasl_listmech(c->sasl_conn, NULL,
        -: 2127:                             "",   /* What to prepend the string with */
        -: 2128:                             " ",  /* What to separate mechanisms with */
        -: 2129:                             "",   /* What to append to the string */
        -: 2130:                             &result_string, &string_length,
        -: 2131:                             NULL);
    #####: 2132:    if (result != SASL_OK) {
        -: 2133:        /* Perhaps there's a better error for this... */
    #####: 2134:        if (settings.verbose) {
    #####: 2135:            fprintf(stderr, "Failed to list SASL mechanisms.\n");
        -: 2136:        }
    #####: 2137:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2138:        return;
        -: 2139:    }
        -: 2140:    write_bin_response(c, (char*)result_string, 0, 0, string_length);
        -: 2141:}
------------------
bin_list_sasl_mechs:
    #####: 2114:static void bin_list_sasl_mechs(conn *c) {
        -: 2115:    // Guard against a disabled SASL.
    #####: 2116:    if (!settings.sasl) {
    #####: 2117:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2118:                        c->binary_header.request.bodylen
    #####: 2119:                        - c->binary_header.request.keylen);
    #####: 2120:        return;
        -: 2121:    }
        -: 2122:
    #####: 2123:    init_sasl_conn(c);
    #####: 2124:    const char *result_string = NULL;
    #####: 2125:    unsigned int string_length = 0;
    #####: 2126:    int result=sasl_listmech(c->sasl_conn, NULL,
        -: 2127:                             "",   /* What to prepend the string with */
        -: 2128:                             " ",  /* What to separate mechanisms with */
        -: 2129:                             "",   /* What to append to the string */
        -: 2130:                             &result_string, &string_length,
        -: 2131:                             NULL);
    #####: 2132:    if (result != SASL_OK) {
        -: 2133:        /* Perhaps there's a better error for this... */
    #####: 2134:        if (settings.verbose) {
    #####: 2135:            fprintf(stderr, "Failed to list SASL mechanisms.\n");
        -: 2136:        }
    #####: 2137:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2138:        return;
        -: 2139:    }
        -: 2140:    write_bin_response(c, (char*)result_string, 0, 0, string_length);
        -: 2141:}
------------------
bin_list_sasl_mechs:
    #####: 2114:static void bin_list_sasl_mechs(conn *c) {
        -: 2115:    // Guard against a disabled SASL.
    #####: 2116:    if (!settings.sasl) {
    #####: 2117:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2118:                        c->binary_header.request.bodylen
    #####: 2119:                        - c->binary_header.request.keylen);
    #####: 2120:        return;
        -: 2121:    }
        -: 2122:
    #####: 2123:    init_sasl_conn(c);
    #####: 2124:    const char *result_string = NULL;
    #####: 2125:    unsigned int string_length = 0;
    #####: 2126:    int result=sasl_listmech(c->sasl_conn, NULL,
        -: 2127:                             "",   /* What to prepend the string with */
        -: 2128:                             " ",  /* What to separate mechanisms with */
        -: 2129:                             "",   /* What to append to the string */
        -: 2130:                             &result_string, &string_length,
        -: 2131:                             NULL);
    #####: 2132:    if (result != SASL_OK) {
        -: 2133:        /* Perhaps there's a better error for this... */
    #####: 2134:        if (settings.verbose) {
    #####: 2135:            fprintf(stderr, "Failed to list SASL mechanisms.\n");
        -: 2136:        }
    #####: 2137:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2138:        return;
        -: 2139:    }
        -: 2140:    write_bin_response(c, (char*)result_string, 0, 0, string_length);
        -: 2141:}
------------------
        -: 2142:
    #####: 2143:static void process_bin_sasl_auth(conn *c) {
        -: 2144:    // Guard for handling disabled SASL on the server.
    #####: 2145:    if (!settings.sasl) {
    #####: 2146:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2147:                        c->binary_header.request.bodylen
    #####: 2148:                        - c->binary_header.request.keylen);
    #####: 2149:        return;
        -: 2150:    }
        -: 2151:
    #####: 2152:    assert(c->binary_header.request.extlen == 0);
        -: 2153:
    #####: 2154:    int nkey = c->binary_header.request.keylen;
    #####: 2155:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2156:
    #####: 2157:    if (nkey > MAX_SASL_MECH_LEN) {
    #####: 2158:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2159:        c->write_and_go = conn_swallow;
    #####: 2160:        return;
        -: 2161:    }
        -: 2162:
    #####: 2163:    char *key = binary_get_key(c);
    #####: 2164:    assert(key);
        -: 2165:
    #####: 2166:    item *it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2167:
        -: 2168:    /* Can't use a chunked item for SASL authentication. */
    #####: 2169:    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
    #####: 2170:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
    #####: 2171:        c->write_and_go = conn_swallow;
    #####: 2172:        return;
        -: 2173:    }
        -: 2174:
    #####: 2175:    c->item = it;
    #####: 2176:    c->ritem = ITEM_data(it);
    #####: 2177:    c->rlbytes = vlen;
    #####: 2178:    conn_set_state(c, conn_nread);
    #####: 2179:    c->substate = bin_reading_sasl_auth_data;
        -: 2180:}
------------------
process_bin_sasl_auth:
    #####: 2143:static void process_bin_sasl_auth(conn *c) {
        -: 2144:    // Guard for handling disabled SASL on the server.
    #####: 2145:    if (!settings.sasl) {
    #####: 2146:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2147:                        c->binary_header.request.bodylen
    #####: 2148:                        - c->binary_header.request.keylen);
    #####: 2149:        return;
        -: 2150:    }
        -: 2151:
    #####: 2152:    assert(c->binary_header.request.extlen == 0);
        -: 2153:
    #####: 2154:    int nkey = c->binary_header.request.keylen;
    #####: 2155:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2156:
    #####: 2157:    if (nkey > MAX_SASL_MECH_LEN) {
    #####: 2158:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2159:        c->write_and_go = conn_swallow;
    #####: 2160:        return;
        -: 2161:    }
        -: 2162:
    #####: 2163:    char *key = binary_get_key(c);
    #####: 2164:    assert(key);
        -: 2165:
    #####: 2166:    item *it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2167:
        -: 2168:    /* Can't use a chunked item for SASL authentication. */
    #####: 2169:    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
    #####: 2170:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
    #####: 2171:        c->write_and_go = conn_swallow;
    #####: 2172:        return;
        -: 2173:    }
        -: 2174:
    #####: 2175:    c->item = it;
    #####: 2176:    c->ritem = ITEM_data(it);
    #####: 2177:    c->rlbytes = vlen;
    #####: 2178:    conn_set_state(c, conn_nread);
    #####: 2179:    c->substate = bin_reading_sasl_auth_data;
        -: 2180:}
------------------
process_bin_sasl_auth:
    #####: 2143:static void process_bin_sasl_auth(conn *c) {
        -: 2144:    // Guard for handling disabled SASL on the server.
    #####: 2145:    if (!settings.sasl) {
    #####: 2146:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2147:                        c->binary_header.request.bodylen
    #####: 2148:                        - c->binary_header.request.keylen);
    #####: 2149:        return;
        -: 2150:    }
        -: 2151:
    #####: 2152:    assert(c->binary_header.request.extlen == 0);
        -: 2153:
    #####: 2154:    int nkey = c->binary_header.request.keylen;
    #####: 2155:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2156:
    #####: 2157:    if (nkey > MAX_SASL_MECH_LEN) {
    #####: 2158:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2159:        c->write_and_go = conn_swallow;
    #####: 2160:        return;
        -: 2161:    }
        -: 2162:
    #####: 2163:    char *key = binary_get_key(c);
    #####: 2164:    assert(key);
        -: 2165:
    #####: 2166:    item *it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2167:
        -: 2168:    /* Can't use a chunked item for SASL authentication. */
    #####: 2169:    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
    #####: 2170:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
    #####: 2171:        c->write_and_go = conn_swallow;
    #####: 2172:        return;
        -: 2173:    }
        -: 2174:
    #####: 2175:    c->item = it;
    #####: 2176:    c->ritem = ITEM_data(it);
    #####: 2177:    c->rlbytes = vlen;
    #####: 2178:    conn_set_state(c, conn_nread);
    #####: 2179:    c->substate = bin_reading_sasl_auth_data;
        -: 2180:}
------------------
process_bin_sasl_auth:
    #####: 2143:static void process_bin_sasl_auth(conn *c) {
        -: 2144:    // Guard for handling disabled SASL on the server.
    #####: 2145:    if (!settings.sasl) {
    #####: 2146:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
    #####: 2147:                        c->binary_header.request.bodylen
    #####: 2148:                        - c->binary_header.request.keylen);
    #####: 2149:        return;
        -: 2150:    }
        -: 2151:
    #####: 2152:    assert(c->binary_header.request.extlen == 0);
        -: 2153:
    #####: 2154:    int nkey = c->binary_header.request.keylen;
    #####: 2155:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2156:
    #####: 2157:    if (nkey > MAX_SASL_MECH_LEN) {
    #####: 2158:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2159:        c->write_and_go = conn_swallow;
    #####: 2160:        return;
        -: 2161:    }
        -: 2162:
    #####: 2163:    char *key = binary_get_key(c);
    #####: 2164:    assert(key);
        -: 2165:
    #####: 2166:    item *it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2167:
        -: 2168:    /* Can't use a chunked item for SASL authentication. */
    #####: 2169:    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
    #####: 2170:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
    #####: 2171:        c->write_and_go = conn_swallow;
    #####: 2172:        return;
        -: 2173:    }
        -: 2174:
    #####: 2175:    c->item = it;
    #####: 2176:    c->ritem = ITEM_data(it);
    #####: 2177:    c->rlbytes = vlen;
    #####: 2178:    conn_set_state(c, conn_nread);
    #####: 2179:    c->substate = bin_reading_sasl_auth_data;
        -: 2180:}
------------------
        -: 2181:
    #####: 2182:static void process_bin_complete_sasl_auth(conn *c) {
    #####: 2183:    assert(settings.sasl);
    #####: 2184:    const char *out = NULL;
    #####: 2185:    unsigned int outlen = 0;
        -: 2186:
    #####: 2187:    assert(c->item);
    #####: 2188:    init_sasl_conn(c);
        -: 2189:
    #####: 2190:    int nkey = c->binary_header.request.keylen;
    #####: 2191:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2192:
    #####: 2193:    if (nkey > ((item*) c->item)->nkey) {
    #####: 2194:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2195:        c->write_and_go = conn_swallow;
    #####: 2196:        item_unlink(c->item);
    #####: 2197:        return;
        -: 2198:    }
        -: 2199:
    #####: 2200:    char mech[nkey+1];
    #####: 2201:    memcpy(mech, ITEM_key((item*)c->item), nkey);
    #####: 2202:    mech[nkey] = 0x00;
        -: 2203:
    #####: 2204:    if (settings.verbose)
    #####: 2205:        fprintf(stderr, "mech:  ``%s'' with %d bytes of data\n", mech, vlen);
        -: 2206:
    #####: 2207:    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);
        -: 2208:
    #####: 2209:    if (vlen > ((item*) c->item)->nbytes) {
    #####: 2210:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2211:        c->write_and_go = conn_swallow;
    #####: 2212:        item_unlink(c->item);
    #####: 2213:        return;
        -: 2214:    }
        -: 2215:
    #####: 2216:    int result=-1;
        -: 2217:
    #####: 2218:    switch (c->cmd) {
    #####: 2219:    case PROTOCOL_BINARY_CMD_SASL_AUTH:
    #####: 2220:        result = sasl_server_start(c->sasl_conn, mech,
        -: 2221:                                   challenge, vlen,
        -: 2222:                                   &out, &outlen);
    #####: 2223:        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);
    #####: 2224:        break;
    #####: 2225:    case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2226:        if (!c->sasl_started) {
    #####: 2227:            if (settings.verbose) {
    #####: 2228:                fprintf(stderr, "%d: SASL_STEP called but sasl_server_start "
        -: 2229:                        "not called for this connection!\n", c->sfd);
        -: 2230:            }
        -: 2231:            break;
        -: 2232:        }
        -: 2233:        result = sasl_server_step(c->sasl_conn,
        -: 2234:                                  challenge, vlen,
        -: 2235:                                  &out, &outlen);
        -: 2236:        break;
        -: 2237:    default:
    #####: 2238:        assert(false); /* CMD should be one of the above */
        -: 2239:        /* This code is pretty much impossible, but makes the compiler
        -: 2240:           happier */
        -: 2241:        if (settings.verbose) {
        -: 2242:            fprintf(stderr, "Unhandled command %d with challenge %s\n",
        -: 2243:                    c->cmd, challenge);
        -: 2244:        }
        -: 2245:        break;
        -: 2246:    }
        -: 2247:
    #####: 2248:    item_unlink(c->item);
        -: 2249:
    #####: 2250:    if (settings.verbose) {
    #####: 2251:        fprintf(stderr, "sasl result code:  %d\n", result);
        -: 2252:    }
        -: 2253:
    #####: 2254:    switch(result) {
    #####: 2255:    case SASL_OK:
    #####: 2256:        c->authenticated = true;
    #####: 2257:        write_bin_response(c, "Authenticated", 0, 0, strlen("Authenticated"));
    #####: 2258:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2259:        c->thread->stats.auth_cmds++;
    #####: 2260:        pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2261:        break;
    #####: 2262:    case SASL_CONTINUE:
    #####: 2263:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
    #####: 2264:        if(outlen > 0) {
        -: 2265:            add_iov(c, out, outlen);
        -: 2266:        }
    #####: 2267:        conn_set_state(c, conn_mwrite);
    #####: 2268:        c->write_and_go = conn_new_cmd;
    #####: 2269:        break;
    #####: 2270:    default:
    #####: 2271:        if (settings.verbose)
    #####: 2272:            fprintf(stderr, "Unknown sasl response:  %d\n", result);
    #####: 2273:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2274:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2275:        c->thread->stats.auth_cmds++;
    #####: 2276:        c->thread->stats.auth_errors++;
    #####: 2277:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2278:    }
        -: 2279:}
------------------
process_bin_complete_sasl_auth:
    #####: 2182:static void process_bin_complete_sasl_auth(conn *c) {
    #####: 2183:    assert(settings.sasl);
    #####: 2184:    const char *out = NULL;
    #####: 2185:    unsigned int outlen = 0;
        -: 2186:
    #####: 2187:    assert(c->item);
    #####: 2188:    init_sasl_conn(c);
        -: 2189:
    #####: 2190:    int nkey = c->binary_header.request.keylen;
    #####: 2191:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2192:
    #####: 2193:    if (nkey > ((item*) c->item)->nkey) {
    #####: 2194:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2195:        c->write_and_go = conn_swallow;
    #####: 2196:        item_unlink(c->item);
    #####: 2197:        return;
        -: 2198:    }
        -: 2199:
    #####: 2200:    char mech[nkey+1];
    #####: 2201:    memcpy(mech, ITEM_key((item*)c->item), nkey);
    #####: 2202:    mech[nkey] = 0x00;
        -: 2203:
    #####: 2204:    if (settings.verbose)
    #####: 2205:        fprintf(stderr, "mech:  ``%s'' with %d bytes of data\n", mech, vlen);
        -: 2206:
    #####: 2207:    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);
        -: 2208:
    #####: 2209:    if (vlen > ((item*) c->item)->nbytes) {
    #####: 2210:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2211:        c->write_and_go = conn_swallow;
    #####: 2212:        item_unlink(c->item);
    #####: 2213:        return;
        -: 2214:    }
        -: 2215:
    #####: 2216:    int result=-1;
        -: 2217:
    #####: 2218:    switch (c->cmd) {
    #####: 2219:    case PROTOCOL_BINARY_CMD_SASL_AUTH:
    #####: 2220:        result = sasl_server_start(c->sasl_conn, mech,
        -: 2221:                                   challenge, vlen,
        -: 2222:                                   &out, &outlen);
    #####: 2223:        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);
    #####: 2224:        break;
    #####: 2225:    case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2226:        if (!c->sasl_started) {
    #####: 2227:            if (settings.verbose) {
    #####: 2228:                fprintf(stderr, "%d: SASL_STEP called but sasl_server_start "
        -: 2229:                        "not called for this connection!\n", c->sfd);
        -: 2230:            }
        -: 2231:            break;
        -: 2232:        }
        -: 2233:        result = sasl_server_step(c->sasl_conn,
        -: 2234:                                  challenge, vlen,
        -: 2235:                                  &out, &outlen);
        -: 2236:        break;
        -: 2237:    default:
    #####: 2238:        assert(false); /* CMD should be one of the above */
        -: 2239:        /* This code is pretty much impossible, but makes the compiler
        -: 2240:           happier */
        -: 2241:        if (settings.verbose) {
        -: 2242:            fprintf(stderr, "Unhandled command %d with challenge %s\n",
        -: 2243:                    c->cmd, challenge);
        -: 2244:        }
        -: 2245:        break;
        -: 2246:    }
        -: 2247:
    #####: 2248:    item_unlink(c->item);
        -: 2249:
    #####: 2250:    if (settings.verbose) {
    #####: 2251:        fprintf(stderr, "sasl result code:  %d\n", result);
        -: 2252:    }
        -: 2253:
    #####: 2254:    switch(result) {
    #####: 2255:    case SASL_OK:
    #####: 2256:        c->authenticated = true;
    #####: 2257:        write_bin_response(c, "Authenticated", 0, 0, strlen("Authenticated"));
    #####: 2258:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2259:        c->thread->stats.auth_cmds++;
    #####: 2260:        pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2261:        break;
    #####: 2262:    case SASL_CONTINUE:
    #####: 2263:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
    #####: 2264:        if(outlen > 0) {
        -: 2265:            add_iov(c, out, outlen);
        -: 2266:        }
    #####: 2267:        conn_set_state(c, conn_mwrite);
    #####: 2268:        c->write_and_go = conn_new_cmd;
    #####: 2269:        break;
    #####: 2270:    default:
    #####: 2271:        if (settings.verbose)
    #####: 2272:            fprintf(stderr, "Unknown sasl response:  %d\n", result);
    #####: 2273:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2274:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2275:        c->thread->stats.auth_cmds++;
    #####: 2276:        c->thread->stats.auth_errors++;
    #####: 2277:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2278:    }
        -: 2279:}
------------------
process_bin_complete_sasl_auth:
    #####: 2182:static void process_bin_complete_sasl_auth(conn *c) {
    #####: 2183:    assert(settings.sasl);
    #####: 2184:    const char *out = NULL;
    #####: 2185:    unsigned int outlen = 0;
        -: 2186:
    #####: 2187:    assert(c->item);
    #####: 2188:    init_sasl_conn(c);
        -: 2189:
    #####: 2190:    int nkey = c->binary_header.request.keylen;
    #####: 2191:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2192:
    #####: 2193:    if (nkey > ((item*) c->item)->nkey) {
    #####: 2194:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2195:        c->write_and_go = conn_swallow;
    #####: 2196:        item_unlink(c->item);
    #####: 2197:        return;
        -: 2198:    }
        -: 2199:
    #####: 2200:    char mech[nkey+1];
    #####: 2201:    memcpy(mech, ITEM_key((item*)c->item), nkey);
    #####: 2202:    mech[nkey] = 0x00;
        -: 2203:
    #####: 2204:    if (settings.verbose)
    #####: 2205:        fprintf(stderr, "mech:  ``%s'' with %d bytes of data\n", mech, vlen);
        -: 2206:
    #####: 2207:    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);
        -: 2208:
    #####: 2209:    if (vlen > ((item*) c->item)->nbytes) {
    #####: 2210:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2211:        c->write_and_go = conn_swallow;
    #####: 2212:        item_unlink(c->item);
    #####: 2213:        return;
        -: 2214:    }
        -: 2215:
    #####: 2216:    int result=-1;
        -: 2217:
    #####: 2218:    switch (c->cmd) {
    #####: 2219:    case PROTOCOL_BINARY_CMD_SASL_AUTH:
    #####: 2220:        result = sasl_server_start(c->sasl_conn, mech,
        -: 2221:                                   challenge, vlen,
        -: 2222:                                   &out, &outlen);
    #####: 2223:        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);
    #####: 2224:        break;
    #####: 2225:    case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2226:        if (!c->sasl_started) {
    #####: 2227:            if (settings.verbose) {
    #####: 2228:                fprintf(stderr, "%d: SASL_STEP called but sasl_server_start "
        -: 2229:                        "not called for this connection!\n", c->sfd);
        -: 2230:            }
        -: 2231:            break;
        -: 2232:        }
        -: 2233:        result = sasl_server_step(c->sasl_conn,
        -: 2234:                                  challenge, vlen,
        -: 2235:                                  &out, &outlen);
        -: 2236:        break;
        -: 2237:    default:
    #####: 2238:        assert(false); /* CMD should be one of the above */
        -: 2239:        /* This code is pretty much impossible, but makes the compiler
        -: 2240:           happier */
        -: 2241:        if (settings.verbose) {
        -: 2242:            fprintf(stderr, "Unhandled command %d with challenge %s\n",
        -: 2243:                    c->cmd, challenge);
        -: 2244:        }
        -: 2245:        break;
        -: 2246:    }
        -: 2247:
    #####: 2248:    item_unlink(c->item);
        -: 2249:
    #####: 2250:    if (settings.verbose) {
    #####: 2251:        fprintf(stderr, "sasl result code:  %d\n", result);
        -: 2252:    }
        -: 2253:
    #####: 2254:    switch(result) {
    #####: 2255:    case SASL_OK:
    #####: 2256:        c->authenticated = true;
    #####: 2257:        write_bin_response(c, "Authenticated", 0, 0, strlen("Authenticated"));
    #####: 2258:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2259:        c->thread->stats.auth_cmds++;
    #####: 2260:        pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2261:        break;
    #####: 2262:    case SASL_CONTINUE:
    #####: 2263:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
    #####: 2264:        if(outlen > 0) {
        -: 2265:            add_iov(c, out, outlen);
        -: 2266:        }
    #####: 2267:        conn_set_state(c, conn_mwrite);
    #####: 2268:        c->write_and_go = conn_new_cmd;
    #####: 2269:        break;
    #####: 2270:    default:
    #####: 2271:        if (settings.verbose)
    #####: 2272:            fprintf(stderr, "Unknown sasl response:  %d\n", result);
    #####: 2273:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2274:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2275:        c->thread->stats.auth_cmds++;
    #####: 2276:        c->thread->stats.auth_errors++;
    #####: 2277:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2278:    }
        -: 2279:}
------------------
process_bin_complete_sasl_auth:
    #####: 2182:static void process_bin_complete_sasl_auth(conn *c) {
    #####: 2183:    assert(settings.sasl);
    #####: 2184:    const char *out = NULL;
    #####: 2185:    unsigned int outlen = 0;
        -: 2186:
    #####: 2187:    assert(c->item);
    #####: 2188:    init_sasl_conn(c);
        -: 2189:
    #####: 2190:    int nkey = c->binary_header.request.keylen;
    #####: 2191:    int vlen = c->binary_header.request.bodylen - nkey;
        -: 2192:
    #####: 2193:    if (nkey > ((item*) c->item)->nkey) {
    #####: 2194:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2195:        c->write_and_go = conn_swallow;
    #####: 2196:        item_unlink(c->item);
    #####: 2197:        return;
        -: 2198:    }
        -: 2199:
    #####: 2200:    char mech[nkey+1];
    #####: 2201:    memcpy(mech, ITEM_key((item*)c->item), nkey);
    #####: 2202:    mech[nkey] = 0x00;
        -: 2203:
    #####: 2204:    if (settings.verbose)
    #####: 2205:        fprintf(stderr, "mech:  ``%s'' with %d bytes of data\n", mech, vlen);
        -: 2206:
    #####: 2207:    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);
        -: 2208:
    #####: 2209:    if (vlen > ((item*) c->item)->nbytes) {
    #####: 2210:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
    #####: 2211:        c->write_and_go = conn_swallow;
    #####: 2212:        item_unlink(c->item);
    #####: 2213:        return;
        -: 2214:    }
        -: 2215:
    #####: 2216:    int result=-1;
        -: 2217:
    #####: 2218:    switch (c->cmd) {
    #####: 2219:    case PROTOCOL_BINARY_CMD_SASL_AUTH:
    #####: 2220:        result = sasl_server_start(c->sasl_conn, mech,
        -: 2221:                                   challenge, vlen,
        -: 2222:                                   &out, &outlen);
    #####: 2223:        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);
    #####: 2224:        break;
    #####: 2225:    case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2226:        if (!c->sasl_started) {
    #####: 2227:            if (settings.verbose) {
    #####: 2228:                fprintf(stderr, "%d: SASL_STEP called but sasl_server_start "
        -: 2229:                        "not called for this connection!\n", c->sfd);
        -: 2230:            }
        -: 2231:            break;
        -: 2232:        }
        -: 2233:        result = sasl_server_step(c->sasl_conn,
        -: 2234:                                  challenge, vlen,
        -: 2235:                                  &out, &outlen);
        -: 2236:        break;
        -: 2237:    default:
    #####: 2238:        assert(false); /* CMD should be one of the above */
        -: 2239:        /* This code is pretty much impossible, but makes the compiler
        -: 2240:           happier */
        -: 2241:        if (settings.verbose) {
        -: 2242:            fprintf(stderr, "Unhandled command %d with challenge %s\n",
        -: 2243:                    c->cmd, challenge);
        -: 2244:        }
        -: 2245:        break;
        -: 2246:    }
        -: 2247:
    #####: 2248:    item_unlink(c->item);
        -: 2249:
    #####: 2250:    if (settings.verbose) {
    #####: 2251:        fprintf(stderr, "sasl result code:  %d\n", result);
        -: 2252:    }
        -: 2253:
    #####: 2254:    switch(result) {
    #####: 2255:    case SASL_OK:
    #####: 2256:        c->authenticated = true;
    #####: 2257:        write_bin_response(c, "Authenticated", 0, 0, strlen("Authenticated"));
    #####: 2258:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2259:        c->thread->stats.auth_cmds++;
    #####: 2260:        pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2261:        break;
    #####: 2262:    case SASL_CONTINUE:
    #####: 2263:        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
    #####: 2264:        if(outlen > 0) {
        -: 2265:            add_iov(c, out, outlen);
        -: 2266:        }
    #####: 2267:        conn_set_state(c, conn_mwrite);
    #####: 2268:        c->write_and_go = conn_new_cmd;
    #####: 2269:        break;
    #####: 2270:    default:
    #####: 2271:        if (settings.verbose)
    #####: 2272:            fprintf(stderr, "Unknown sasl response:  %d\n", result);
    #####: 2273:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2274:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2275:        c->thread->stats.auth_cmds++;
    #####: 2276:        c->thread->stats.auth_errors++;
    #####: 2277:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2278:    }
        -: 2279:}
------------------
        -: 2280:
    #####: 2281:static bool authenticated(conn *c) {
    #####: 2282:    assert(settings.sasl);
    #####: 2283:    bool rv = false;
        -: 2284:
    #####: 2285:    switch (c->cmd) {
        -: 2286:    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
        -: 2287:    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
        -: 2288:    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
        -: 2289:    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        -: 2290:        rv = true;
        -: 2291:        break;
    #####: 2292:    default:
    #####: 2293:        rv = c->authenticated;
        -: 2294:    }
        -: 2295:
    #####: 2296:    if (settings.verbose > 1) {
    #####: 2297:        fprintf(stderr, "authenticated() in cmd 0x%02x is %s\n",
        -: 2298:                c->cmd, rv ? "true" : "false");
        -: 2299:    }
        -: 2300:
    #####: 2301:    return rv;
        -: 2302:}
------------------
authenticated:
    #####: 2281:static bool authenticated(conn *c) {
    #####: 2282:    assert(settings.sasl);
    #####: 2283:    bool rv = false;
        -: 2284:
    #####: 2285:    switch (c->cmd) {
        -: 2286:    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
        -: 2287:    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
        -: 2288:    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
        -: 2289:    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        -: 2290:        rv = true;
        -: 2291:        break;
    #####: 2292:    default:
    #####: 2293:        rv = c->authenticated;
        -: 2294:    }
        -: 2295:
    #####: 2296:    if (settings.verbose > 1) {
    #####: 2297:        fprintf(stderr, "authenticated() in cmd 0x%02x is %s\n",
        -: 2298:                c->cmd, rv ? "true" : "false");
        -: 2299:    }
        -: 2300:
    #####: 2301:    return rv;
        -: 2302:}
------------------
authenticated:
    #####: 2281:static bool authenticated(conn *c) {
    #####: 2282:    assert(settings.sasl);
    #####: 2283:    bool rv = false;
        -: 2284:
    #####: 2285:    switch (c->cmd) {
        -: 2286:    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
        -: 2287:    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
        -: 2288:    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
        -: 2289:    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        -: 2290:        rv = true;
        -: 2291:        break;
    #####: 2292:    default:
    #####: 2293:        rv = c->authenticated;
        -: 2294:    }
        -: 2295:
    #####: 2296:    if (settings.verbose > 1) {
    #####: 2297:        fprintf(stderr, "authenticated() in cmd 0x%02x is %s\n",
        -: 2298:                c->cmd, rv ? "true" : "false");
        -: 2299:    }
        -: 2300:
    #####: 2301:    return rv;
        -: 2302:}
------------------
authenticated:
    #####: 2281:static bool authenticated(conn *c) {
    #####: 2282:    assert(settings.sasl);
    #####: 2283:    bool rv = false;
        -: 2284:
    #####: 2285:    switch (c->cmd) {
        -: 2286:    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
        -: 2287:    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
        -: 2288:    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
        -: 2289:    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        -: 2290:        rv = true;
        -: 2291:        break;
    #####: 2292:    default:
    #####: 2293:        rv = c->authenticated;
        -: 2294:    }
        -: 2295:
    #####: 2296:    if (settings.verbose > 1) {
    #####: 2297:        fprintf(stderr, "authenticated() in cmd 0x%02x is %s\n",
        -: 2298:                c->cmd, rv ? "true" : "false");
        -: 2299:    }
        -: 2300:
    #####: 2301:    return rv;
        -: 2302:}
------------------
        -: 2303:
   300000: 2304:static void dispatch_bin_command(conn *c) {
   300000: 2305:    int protocol_error = 0;
        -: 2306:
   300000: 2307:    uint8_t extlen = c->binary_header.request.extlen;
   300000: 2308:    uint16_t keylen = c->binary_header.request.keylen;
   300000: 2309:    uint32_t bodylen = c->binary_header.request.bodylen;
        -: 2310:
   300000: 2311:    if (keylen > bodylen || keylen + extlen > bodylen) {
    #####: 2312:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
    #####: 2313:        c->write_and_go = conn_closing;
    #####: 2314:        return;
        -: 2315:    }
        -: 2316:
  300000*: 2317:    if (settings.sasl && !authenticated(c)) {
    #####: 2318:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2319:        c->write_and_go = conn_closing;
    #####: 2320:        return;
        -: 2321:    }
        -: 2322:
   300000: 2323:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
   300000: 2324:    c->noreply = true;
        -: 2325:
        -: 2326:    /* binprot supports 16bit keys, but internals are still 8bit */
   300000: 2327:    if (keylen > KEY_MAX_LENGTH) {
    #####: 2328:        handle_binary_protocol_error(c);
    #####: 2329:        return;
        -: 2330:    }
        -: 2331:
   300000: 2332:    switch (c->cmd) {
    #####: 2333:    case PROTOCOL_BINARY_CMD_SETQ:
    #####: 2334:        c->cmd = PROTOCOL_BINARY_CMD_SET;
    #####: 2335:        break;
    #####: 2336:    case PROTOCOL_BINARY_CMD_ADDQ:
    #####: 2337:        c->cmd = PROTOCOL_BINARY_CMD_ADD;
    #####: 2338:        break;
    #####: 2339:    case PROTOCOL_BINARY_CMD_REPLACEQ:
    #####: 2340:        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
    #####: 2341:        break;
    #####: 2342:    case PROTOCOL_BINARY_CMD_DELETEQ:
    #####: 2343:        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
    #####: 2344:        break;
    #####: 2345:    case PROTOCOL_BINARY_CMD_INCREMENTQ:
    #####: 2346:        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
    #####: 2347:        break;
    #####: 2348:    case PROTOCOL_BINARY_CMD_DECREMENTQ:
    #####: 2349:        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
    #####: 2350:        break;
    #####: 2351:    case PROTOCOL_BINARY_CMD_QUITQ:
    #####: 2352:        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
    #####: 2353:        break;
    #####: 2354:    case PROTOCOL_BINARY_CMD_FLUSHQ:
    #####: 2355:        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
    #####: 2356:        break;
    #####: 2357:    case PROTOCOL_BINARY_CMD_APPENDQ:
    #####: 2358:        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
    #####: 2359:        break;
    #####: 2360:    case PROTOCOL_BINARY_CMD_PREPENDQ:
    #####: 2361:        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
    #####: 2362:        break;
    #####: 2363:    case PROTOCOL_BINARY_CMD_GETQ:
    #####: 2364:        c->cmd = PROTOCOL_BINARY_CMD_GET;
    #####: 2365:        break;
    #####: 2366:    case PROTOCOL_BINARY_CMD_GETKQ:
    #####: 2367:        c->cmd = PROTOCOL_BINARY_CMD_GETK;
    #####: 2368:        break;
    #####: 2369:    case PROTOCOL_BINARY_CMD_GATQ:
    #####: 2370:        c->cmd = PROTOCOL_BINARY_CMD_GAT;
    #####: 2371:        break;
    #####: 2372:    case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2373:        c->cmd = PROTOCOL_BINARY_CMD_GATK;
    #####: 2374:        break;
   300000: 2375:    default:
   300000: 2376:        c->noreply = false;
        -: 2377:    }
        -: 2378:
   300000: 2379:    switch (c->cmd) {
    #####: 2380:        case PROTOCOL_BINARY_CMD_VERSION:
    #####: 2381:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2382:                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
        -: 2383:            } else {
        -: 2384:                protocol_error = 1;
        -: 2385:            }
        -: 2386:            break;
    #####: 2387:        case PROTOCOL_BINARY_CMD_FLUSH:
    #####: 2388:            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
    #####: 2389:                bin_read_key(c, bin_read_flush_exptime, extlen);
        -: 2390:            } else {
        -: 2391:                protocol_error = 1;
        -: 2392:            }
        -: 2393:            break;
    #####: 2394:        case PROTOCOL_BINARY_CMD_NOOP:
    #####: 2395:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2396:                write_bin_response(c, NULL, 0, 0, 0);
        -: 2397:            } else {
        -: 2398:                protocol_error = 1;
        -: 2399:            }
        -: 2400:            break;
    27600: 2401:        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        -: 2402:        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        -: 2403:        case PROTOCOL_BINARY_CMD_REPLACE:
    27600: 2404:            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {
    27600: 2405:                bin_read_key(c, bin_reading_set_header, 8);
        -: 2406:            } else {
        -: 2407:                protocol_error = 1;
        -: 2408:            }
        -: 2409:            break;
   272400: 2410:        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */
        -: 2411:        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */
        -: 2412:        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */
        -: 2413:        case PROTOCOL_BINARY_CMD_GETK:
   272400: 2414:            if (extlen == 0 && bodylen == keylen && keylen > 0) {
   272400: 2415:                bin_read_key(c, bin_reading_get_key, 0);
        -: 2416:            } else {
        -: 2417:                protocol_error = 1;
        -: 2418:            }
        -: 2419:            break;
    #####: 2420:        case PROTOCOL_BINARY_CMD_DELETE:
    #####: 2421:            if (keylen > 0 && extlen == 0 && bodylen == keylen) {
    #####: 2422:                bin_read_key(c, bin_reading_del_header, extlen);
        -: 2423:            } else {
        -: 2424:                protocol_error = 1;
        -: 2425:            }
        -: 2426:            break;
    #####: 2427:        case PROTOCOL_BINARY_CMD_INCREMENT:
        -: 2428:        case PROTOCOL_BINARY_CMD_DECREMENT:
    #####: 2429:            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {
    #####: 2430:                bin_read_key(c, bin_reading_incr_header, 20);
        -: 2431:            } else {
        -: 2432:                protocol_error = 1;
        -: 2433:            }
        -: 2434:            break;
    #####: 2435:        case PROTOCOL_BINARY_CMD_APPEND:
        -: 2436:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2437:            if (keylen > 0 && extlen == 0) {
    #####: 2438:                bin_read_key(c, bin_reading_set_header, 0);
        -: 2439:            } else {
        -: 2440:                protocol_error = 1;
        -: 2441:            }
        -: 2442:            break;
    #####: 2443:        case PROTOCOL_BINARY_CMD_STAT:
    #####: 2444:            if (extlen == 0) {
    #####: 2445:                bin_read_key(c, bin_reading_stat, 0);
        -: 2446:            } else {
        -: 2447:                protocol_error = 1;
        -: 2448:            }
        -: 2449:            break;
    #####: 2450:        case PROTOCOL_BINARY_CMD_QUIT:
    #####: 2451:            if (keylen == 0 && extlen == 0 && bodylen == 0) {
    #####: 2452:                write_bin_response(c, NULL, 0, 0, 0);
    #####: 2453:                c->write_and_go = conn_closing;
    #####: 2454:                if (c->noreply) {
    #####: 2455:                    conn_set_state(c, conn_closing);
        -: 2456:                }
        -: 2457:            } else {
        -: 2458:                protocol_error = 1;
        -: 2459:            }
        -: 2460:            break;
    #####: 2461:        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:
    #####: 2462:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2463:                bin_list_sasl_mechs(c);
        -: 2464:            } else {
        -: 2465:                protocol_error = 1;
        -: 2466:            }
        -: 2467:            break;
    #####: 2468:        case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 2469:        case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2470:            if (extlen == 0 && keylen != 0) {
    #####: 2471:                bin_read_key(c, bin_reading_sasl_auth, 0);
        -: 2472:            } else {
        -: 2473:                protocol_error = 1;
        -: 2474:            }
        -: 2475:            break;
    #####: 2476:        case PROTOCOL_BINARY_CMD_TOUCH:
        -: 2477:        case PROTOCOL_BINARY_CMD_GAT:
        -: 2478:        case PROTOCOL_BINARY_CMD_GATQ:
        -: 2479:        case PROTOCOL_BINARY_CMD_GATK:
        -: 2480:        case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2481:            if (extlen == 4 && keylen != 0) {
    #####: 2482:                bin_read_key(c, bin_reading_touch_key, 4);
        -: 2483:            } else {
        -: 2484:                protocol_error = 1;
        -: 2485:            }
        -: 2486:            break;
    #####: 2487:        default:
    #####: 2488:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
        -: 2489:                            bodylen);
        -: 2490:    }
        -: 2491:
  300000*: 2492:    if (protocol_error)
    #####: 2493:        handle_binary_protocol_error(c);
        -: 2494:}
------------------
dispatch_bin_command:
   100000: 2304:static void dispatch_bin_command(conn *c) {
   100000: 2305:    int protocol_error = 0;
        -: 2306:
   100000: 2307:    uint8_t extlen = c->binary_header.request.extlen;
   100000: 2308:    uint16_t keylen = c->binary_header.request.keylen;
   100000: 2309:    uint32_t bodylen = c->binary_header.request.bodylen;
        -: 2310:
   100000: 2311:    if (keylen > bodylen || keylen + extlen > bodylen) {
    #####: 2312:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
    #####: 2313:        c->write_and_go = conn_closing;
    #####: 2314:        return;
        -: 2315:    }
        -: 2316:
  100000*: 2317:    if (settings.sasl && !authenticated(c)) {
    #####: 2318:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2319:        c->write_and_go = conn_closing;
    #####: 2320:        return;
        -: 2321:    }
        -: 2322:
   100000: 2323:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
   100000: 2324:    c->noreply = true;
        -: 2325:
        -: 2326:    /* binprot supports 16bit keys, but internals are still 8bit */
   100000: 2327:    if (keylen > KEY_MAX_LENGTH) {
    #####: 2328:        handle_binary_protocol_error(c);
    #####: 2329:        return;
        -: 2330:    }
        -: 2331:
   100000: 2332:    switch (c->cmd) {
    #####: 2333:    case PROTOCOL_BINARY_CMD_SETQ:
    #####: 2334:        c->cmd = PROTOCOL_BINARY_CMD_SET;
    #####: 2335:        break;
    #####: 2336:    case PROTOCOL_BINARY_CMD_ADDQ:
    #####: 2337:        c->cmd = PROTOCOL_BINARY_CMD_ADD;
    #####: 2338:        break;
    #####: 2339:    case PROTOCOL_BINARY_CMD_REPLACEQ:
    #####: 2340:        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
    #####: 2341:        break;
    #####: 2342:    case PROTOCOL_BINARY_CMD_DELETEQ:
    #####: 2343:        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
    #####: 2344:        break;
    #####: 2345:    case PROTOCOL_BINARY_CMD_INCREMENTQ:
    #####: 2346:        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
    #####: 2347:        break;
    #####: 2348:    case PROTOCOL_BINARY_CMD_DECREMENTQ:
    #####: 2349:        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
    #####: 2350:        break;
    #####: 2351:    case PROTOCOL_BINARY_CMD_QUITQ:
    #####: 2352:        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
    #####: 2353:        break;
    #####: 2354:    case PROTOCOL_BINARY_CMD_FLUSHQ:
    #####: 2355:        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
    #####: 2356:        break;
    #####: 2357:    case PROTOCOL_BINARY_CMD_APPENDQ:
    #####: 2358:        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
    #####: 2359:        break;
    #####: 2360:    case PROTOCOL_BINARY_CMD_PREPENDQ:
    #####: 2361:        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
    #####: 2362:        break;
    #####: 2363:    case PROTOCOL_BINARY_CMD_GETQ:
    #####: 2364:        c->cmd = PROTOCOL_BINARY_CMD_GET;
    #####: 2365:        break;
    #####: 2366:    case PROTOCOL_BINARY_CMD_GETKQ:
    #####: 2367:        c->cmd = PROTOCOL_BINARY_CMD_GETK;
    #####: 2368:        break;
    #####: 2369:    case PROTOCOL_BINARY_CMD_GATQ:
    #####: 2370:        c->cmd = PROTOCOL_BINARY_CMD_GAT;
    #####: 2371:        break;
    #####: 2372:    case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2373:        c->cmd = PROTOCOL_BINARY_CMD_GATK;
    #####: 2374:        break;
   100000: 2375:    default:
   100000: 2376:        c->noreply = false;
        -: 2377:    }
        -: 2378:
   100000: 2379:    switch (c->cmd) {
    #####: 2380:        case PROTOCOL_BINARY_CMD_VERSION:
    #####: 2381:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2382:                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
        -: 2383:            } else {
        -: 2384:                protocol_error = 1;
        -: 2385:            }
        -: 2386:            break;
    #####: 2387:        case PROTOCOL_BINARY_CMD_FLUSH:
    #####: 2388:            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
    #####: 2389:                bin_read_key(c, bin_read_flush_exptime, extlen);
        -: 2390:            } else {
        -: 2391:                protocol_error = 1;
        -: 2392:            }
        -: 2393:            break;
    #####: 2394:        case PROTOCOL_BINARY_CMD_NOOP:
    #####: 2395:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2396:                write_bin_response(c, NULL, 0, 0, 0);
        -: 2397:            } else {
        -: 2398:                protocol_error = 1;
        -: 2399:            }
        -: 2400:            break;
     9200: 2401:        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        -: 2402:        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        -: 2403:        case PROTOCOL_BINARY_CMD_REPLACE:
     9200: 2404:            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {
     9200: 2405:                bin_read_key(c, bin_reading_set_header, 8);
        -: 2406:            } else {
        -: 2407:                protocol_error = 1;
        -: 2408:            }
        -: 2409:            break;
    90800: 2410:        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */
        -: 2411:        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */
        -: 2412:        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */
        -: 2413:        case PROTOCOL_BINARY_CMD_GETK:
    90800: 2414:            if (extlen == 0 && bodylen == keylen && keylen > 0) {
    90800: 2415:                bin_read_key(c, bin_reading_get_key, 0);
        -: 2416:            } else {
        -: 2417:                protocol_error = 1;
        -: 2418:            }
        -: 2419:            break;
    #####: 2420:        case PROTOCOL_BINARY_CMD_DELETE:
    #####: 2421:            if (keylen > 0 && extlen == 0 && bodylen == keylen) {
    #####: 2422:                bin_read_key(c, bin_reading_del_header, extlen);
        -: 2423:            } else {
        -: 2424:                protocol_error = 1;
        -: 2425:            }
        -: 2426:            break;
    #####: 2427:        case PROTOCOL_BINARY_CMD_INCREMENT:
        -: 2428:        case PROTOCOL_BINARY_CMD_DECREMENT:
    #####: 2429:            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {
    #####: 2430:                bin_read_key(c, bin_reading_incr_header, 20);
        -: 2431:            } else {
        -: 2432:                protocol_error = 1;
        -: 2433:            }
        -: 2434:            break;
    #####: 2435:        case PROTOCOL_BINARY_CMD_APPEND:
        -: 2436:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2437:            if (keylen > 0 && extlen == 0) {
    #####: 2438:                bin_read_key(c, bin_reading_set_header, 0);
        -: 2439:            } else {
        -: 2440:                protocol_error = 1;
        -: 2441:            }
        -: 2442:            break;
    #####: 2443:        case PROTOCOL_BINARY_CMD_STAT:
    #####: 2444:            if (extlen == 0) {
    #####: 2445:                bin_read_key(c, bin_reading_stat, 0);
        -: 2446:            } else {
        -: 2447:                protocol_error = 1;
        -: 2448:            }
        -: 2449:            break;
    #####: 2450:        case PROTOCOL_BINARY_CMD_QUIT:
    #####: 2451:            if (keylen == 0 && extlen == 0 && bodylen == 0) {
    #####: 2452:                write_bin_response(c, NULL, 0, 0, 0);
    #####: 2453:                c->write_and_go = conn_closing;
    #####: 2454:                if (c->noreply) {
    #####: 2455:                    conn_set_state(c, conn_closing);
        -: 2456:                }
        -: 2457:            } else {
        -: 2458:                protocol_error = 1;
        -: 2459:            }
        -: 2460:            break;
    #####: 2461:        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:
    #####: 2462:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2463:                bin_list_sasl_mechs(c);
        -: 2464:            } else {
        -: 2465:                protocol_error = 1;
        -: 2466:            }
        -: 2467:            break;
    #####: 2468:        case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 2469:        case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2470:            if (extlen == 0 && keylen != 0) {
    #####: 2471:                bin_read_key(c, bin_reading_sasl_auth, 0);
        -: 2472:            } else {
        -: 2473:                protocol_error = 1;
        -: 2474:            }
        -: 2475:            break;
    #####: 2476:        case PROTOCOL_BINARY_CMD_TOUCH:
        -: 2477:        case PROTOCOL_BINARY_CMD_GAT:
        -: 2478:        case PROTOCOL_BINARY_CMD_GATQ:
        -: 2479:        case PROTOCOL_BINARY_CMD_GATK:
        -: 2480:        case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2481:            if (extlen == 4 && keylen != 0) {
    #####: 2482:                bin_read_key(c, bin_reading_touch_key, 4);
        -: 2483:            } else {
        -: 2484:                protocol_error = 1;
        -: 2485:            }
        -: 2486:            break;
    #####: 2487:        default:
    #####: 2488:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
        -: 2489:                            bodylen);
        -: 2490:    }
        -: 2491:
  100000*: 2492:    if (protocol_error)
    #####: 2493:        handle_binary_protocol_error(c);
        -: 2494:}
------------------
dispatch_bin_command:
   100000: 2304:static void dispatch_bin_command(conn *c) {
   100000: 2305:    int protocol_error = 0;
        -: 2306:
   100000: 2307:    uint8_t extlen = c->binary_header.request.extlen;
   100000: 2308:    uint16_t keylen = c->binary_header.request.keylen;
   100000: 2309:    uint32_t bodylen = c->binary_header.request.bodylen;
        -: 2310:
   100000: 2311:    if (keylen > bodylen || keylen + extlen > bodylen) {
    #####: 2312:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
    #####: 2313:        c->write_and_go = conn_closing;
    #####: 2314:        return;
        -: 2315:    }
        -: 2316:
  100000*: 2317:    if (settings.sasl && !authenticated(c)) {
    #####: 2318:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2319:        c->write_and_go = conn_closing;
    #####: 2320:        return;
        -: 2321:    }
        -: 2322:
   100000: 2323:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
   100000: 2324:    c->noreply = true;
        -: 2325:
        -: 2326:    /* binprot supports 16bit keys, but internals are still 8bit */
   100000: 2327:    if (keylen > KEY_MAX_LENGTH) {
    #####: 2328:        handle_binary_protocol_error(c);
    #####: 2329:        return;
        -: 2330:    }
        -: 2331:
   100000: 2332:    switch (c->cmd) {
    #####: 2333:    case PROTOCOL_BINARY_CMD_SETQ:
    #####: 2334:        c->cmd = PROTOCOL_BINARY_CMD_SET;
    #####: 2335:        break;
    #####: 2336:    case PROTOCOL_BINARY_CMD_ADDQ:
    #####: 2337:        c->cmd = PROTOCOL_BINARY_CMD_ADD;
    #####: 2338:        break;
    #####: 2339:    case PROTOCOL_BINARY_CMD_REPLACEQ:
    #####: 2340:        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
    #####: 2341:        break;
    #####: 2342:    case PROTOCOL_BINARY_CMD_DELETEQ:
    #####: 2343:        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
    #####: 2344:        break;
    #####: 2345:    case PROTOCOL_BINARY_CMD_INCREMENTQ:
    #####: 2346:        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
    #####: 2347:        break;
    #####: 2348:    case PROTOCOL_BINARY_CMD_DECREMENTQ:
    #####: 2349:        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
    #####: 2350:        break;
    #####: 2351:    case PROTOCOL_BINARY_CMD_QUITQ:
    #####: 2352:        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
    #####: 2353:        break;
    #####: 2354:    case PROTOCOL_BINARY_CMD_FLUSHQ:
    #####: 2355:        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
    #####: 2356:        break;
    #####: 2357:    case PROTOCOL_BINARY_CMD_APPENDQ:
    #####: 2358:        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
    #####: 2359:        break;
    #####: 2360:    case PROTOCOL_BINARY_CMD_PREPENDQ:
    #####: 2361:        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
    #####: 2362:        break;
    #####: 2363:    case PROTOCOL_BINARY_CMD_GETQ:
    #####: 2364:        c->cmd = PROTOCOL_BINARY_CMD_GET;
    #####: 2365:        break;
    #####: 2366:    case PROTOCOL_BINARY_CMD_GETKQ:
    #####: 2367:        c->cmd = PROTOCOL_BINARY_CMD_GETK;
    #####: 2368:        break;
    #####: 2369:    case PROTOCOL_BINARY_CMD_GATQ:
    #####: 2370:        c->cmd = PROTOCOL_BINARY_CMD_GAT;
    #####: 2371:        break;
    #####: 2372:    case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2373:        c->cmd = PROTOCOL_BINARY_CMD_GATK;
    #####: 2374:        break;
   100000: 2375:    default:
   100000: 2376:        c->noreply = false;
        -: 2377:    }
        -: 2378:
   100000: 2379:    switch (c->cmd) {
    #####: 2380:        case PROTOCOL_BINARY_CMD_VERSION:
    #####: 2381:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2382:                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
        -: 2383:            } else {
        -: 2384:                protocol_error = 1;
        -: 2385:            }
        -: 2386:            break;
    #####: 2387:        case PROTOCOL_BINARY_CMD_FLUSH:
    #####: 2388:            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
    #####: 2389:                bin_read_key(c, bin_read_flush_exptime, extlen);
        -: 2390:            } else {
        -: 2391:                protocol_error = 1;
        -: 2392:            }
        -: 2393:            break;
    #####: 2394:        case PROTOCOL_BINARY_CMD_NOOP:
    #####: 2395:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2396:                write_bin_response(c, NULL, 0, 0, 0);
        -: 2397:            } else {
        -: 2398:                protocol_error = 1;
        -: 2399:            }
        -: 2400:            break;
     9200: 2401:        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        -: 2402:        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        -: 2403:        case PROTOCOL_BINARY_CMD_REPLACE:
     9200: 2404:            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {
     9200: 2405:                bin_read_key(c, bin_reading_set_header, 8);
        -: 2406:            } else {
        -: 2407:                protocol_error = 1;
        -: 2408:            }
        -: 2409:            break;
    90800: 2410:        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */
        -: 2411:        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */
        -: 2412:        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */
        -: 2413:        case PROTOCOL_BINARY_CMD_GETK:
    90800: 2414:            if (extlen == 0 && bodylen == keylen && keylen > 0) {
    90800: 2415:                bin_read_key(c, bin_reading_get_key, 0);
        -: 2416:            } else {
        -: 2417:                protocol_error = 1;
        -: 2418:            }
        -: 2419:            break;
    #####: 2420:        case PROTOCOL_BINARY_CMD_DELETE:
    #####: 2421:            if (keylen > 0 && extlen == 0 && bodylen == keylen) {
    #####: 2422:                bin_read_key(c, bin_reading_del_header, extlen);
        -: 2423:            } else {
        -: 2424:                protocol_error = 1;
        -: 2425:            }
        -: 2426:            break;
    #####: 2427:        case PROTOCOL_BINARY_CMD_INCREMENT:
        -: 2428:        case PROTOCOL_BINARY_CMD_DECREMENT:
    #####: 2429:            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {
    #####: 2430:                bin_read_key(c, bin_reading_incr_header, 20);
        -: 2431:            } else {
        -: 2432:                protocol_error = 1;
        -: 2433:            }
        -: 2434:            break;
    #####: 2435:        case PROTOCOL_BINARY_CMD_APPEND:
        -: 2436:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2437:            if (keylen > 0 && extlen == 0) {
    #####: 2438:                bin_read_key(c, bin_reading_set_header, 0);
        -: 2439:            } else {
        -: 2440:                protocol_error = 1;
        -: 2441:            }
        -: 2442:            break;
    #####: 2443:        case PROTOCOL_BINARY_CMD_STAT:
    #####: 2444:            if (extlen == 0) {
    #####: 2445:                bin_read_key(c, bin_reading_stat, 0);
        -: 2446:            } else {
        -: 2447:                protocol_error = 1;
        -: 2448:            }
        -: 2449:            break;
    #####: 2450:        case PROTOCOL_BINARY_CMD_QUIT:
    #####: 2451:            if (keylen == 0 && extlen == 0 && bodylen == 0) {
    #####: 2452:                write_bin_response(c, NULL, 0, 0, 0);
    #####: 2453:                c->write_and_go = conn_closing;
    #####: 2454:                if (c->noreply) {
    #####: 2455:                    conn_set_state(c, conn_closing);
        -: 2456:                }
        -: 2457:            } else {
        -: 2458:                protocol_error = 1;
        -: 2459:            }
        -: 2460:            break;
    #####: 2461:        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:
    #####: 2462:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2463:                bin_list_sasl_mechs(c);
        -: 2464:            } else {
        -: 2465:                protocol_error = 1;
        -: 2466:            }
        -: 2467:            break;
    #####: 2468:        case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 2469:        case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2470:            if (extlen == 0 && keylen != 0) {
    #####: 2471:                bin_read_key(c, bin_reading_sasl_auth, 0);
        -: 2472:            } else {
        -: 2473:                protocol_error = 1;
        -: 2474:            }
        -: 2475:            break;
    #####: 2476:        case PROTOCOL_BINARY_CMD_TOUCH:
        -: 2477:        case PROTOCOL_BINARY_CMD_GAT:
        -: 2478:        case PROTOCOL_BINARY_CMD_GATQ:
        -: 2479:        case PROTOCOL_BINARY_CMD_GATK:
        -: 2480:        case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2481:            if (extlen == 4 && keylen != 0) {
    #####: 2482:                bin_read_key(c, bin_reading_touch_key, 4);
        -: 2483:            } else {
        -: 2484:                protocol_error = 1;
        -: 2485:            }
        -: 2486:            break;
    #####: 2487:        default:
    #####: 2488:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
        -: 2489:                            bodylen);
        -: 2490:    }
        -: 2491:
  100000*: 2492:    if (protocol_error)
    #####: 2493:        handle_binary_protocol_error(c);
        -: 2494:}
------------------
dispatch_bin_command:
   100000: 2304:static void dispatch_bin_command(conn *c) {
   100000: 2305:    int protocol_error = 0;
        -: 2306:
   100000: 2307:    uint8_t extlen = c->binary_header.request.extlen;
   100000: 2308:    uint16_t keylen = c->binary_header.request.keylen;
   100000: 2309:    uint32_t bodylen = c->binary_header.request.bodylen;
        -: 2310:
   100000: 2311:    if (keylen > bodylen || keylen + extlen > bodylen) {
    #####: 2312:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
    #####: 2313:        c->write_and_go = conn_closing;
    #####: 2314:        return;
        -: 2315:    }
        -: 2316:
  100000*: 2317:    if (settings.sasl && !authenticated(c)) {
    #####: 2318:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2319:        c->write_and_go = conn_closing;
    #####: 2320:        return;
        -: 2321:    }
        -: 2322:
   100000: 2323:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
   100000: 2324:    c->noreply = true;
        -: 2325:
        -: 2326:    /* binprot supports 16bit keys, but internals are still 8bit */
   100000: 2327:    if (keylen > KEY_MAX_LENGTH) {
    #####: 2328:        handle_binary_protocol_error(c);
    #####: 2329:        return;
        -: 2330:    }
        -: 2331:
   100000: 2332:    switch (c->cmd) {
    #####: 2333:    case PROTOCOL_BINARY_CMD_SETQ:
    #####: 2334:        c->cmd = PROTOCOL_BINARY_CMD_SET;
    #####: 2335:        break;
    #####: 2336:    case PROTOCOL_BINARY_CMD_ADDQ:
    #####: 2337:        c->cmd = PROTOCOL_BINARY_CMD_ADD;
    #####: 2338:        break;
    #####: 2339:    case PROTOCOL_BINARY_CMD_REPLACEQ:
    #####: 2340:        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
    #####: 2341:        break;
    #####: 2342:    case PROTOCOL_BINARY_CMD_DELETEQ:
    #####: 2343:        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
    #####: 2344:        break;
    #####: 2345:    case PROTOCOL_BINARY_CMD_INCREMENTQ:
    #####: 2346:        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
    #####: 2347:        break;
    #####: 2348:    case PROTOCOL_BINARY_CMD_DECREMENTQ:
    #####: 2349:        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
    #####: 2350:        break;
    #####: 2351:    case PROTOCOL_BINARY_CMD_QUITQ:
    #####: 2352:        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
    #####: 2353:        break;
    #####: 2354:    case PROTOCOL_BINARY_CMD_FLUSHQ:
    #####: 2355:        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
    #####: 2356:        break;
    #####: 2357:    case PROTOCOL_BINARY_CMD_APPENDQ:
    #####: 2358:        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
    #####: 2359:        break;
    #####: 2360:    case PROTOCOL_BINARY_CMD_PREPENDQ:
    #####: 2361:        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
    #####: 2362:        break;
    #####: 2363:    case PROTOCOL_BINARY_CMD_GETQ:
    #####: 2364:        c->cmd = PROTOCOL_BINARY_CMD_GET;
    #####: 2365:        break;
    #####: 2366:    case PROTOCOL_BINARY_CMD_GETKQ:
    #####: 2367:        c->cmd = PROTOCOL_BINARY_CMD_GETK;
    #####: 2368:        break;
    #####: 2369:    case PROTOCOL_BINARY_CMD_GATQ:
    #####: 2370:        c->cmd = PROTOCOL_BINARY_CMD_GAT;
    #####: 2371:        break;
    #####: 2372:    case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2373:        c->cmd = PROTOCOL_BINARY_CMD_GATK;
    #####: 2374:        break;
   100000: 2375:    default:
   100000: 2376:        c->noreply = false;
        -: 2377:    }
        -: 2378:
   100000: 2379:    switch (c->cmd) {
    #####: 2380:        case PROTOCOL_BINARY_CMD_VERSION:
    #####: 2381:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2382:                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
        -: 2383:            } else {
        -: 2384:                protocol_error = 1;
        -: 2385:            }
        -: 2386:            break;
    #####: 2387:        case PROTOCOL_BINARY_CMD_FLUSH:
    #####: 2388:            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
    #####: 2389:                bin_read_key(c, bin_read_flush_exptime, extlen);
        -: 2390:            } else {
        -: 2391:                protocol_error = 1;
        -: 2392:            }
        -: 2393:            break;
    #####: 2394:        case PROTOCOL_BINARY_CMD_NOOP:
    #####: 2395:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2396:                write_bin_response(c, NULL, 0, 0, 0);
        -: 2397:            } else {
        -: 2398:                protocol_error = 1;
        -: 2399:            }
        -: 2400:            break;
     9200: 2401:        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        -: 2402:        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        -: 2403:        case PROTOCOL_BINARY_CMD_REPLACE:
     9200: 2404:            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {
     9200: 2405:                bin_read_key(c, bin_reading_set_header, 8);
        -: 2406:            } else {
        -: 2407:                protocol_error = 1;
        -: 2408:            }
        -: 2409:            break;
    90800: 2410:        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */
        -: 2411:        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */
        -: 2412:        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */
        -: 2413:        case PROTOCOL_BINARY_CMD_GETK:
    90800: 2414:            if (extlen == 0 && bodylen == keylen && keylen > 0) {
    90800: 2415:                bin_read_key(c, bin_reading_get_key, 0);
        -: 2416:            } else {
        -: 2417:                protocol_error = 1;
        -: 2418:            }
        -: 2419:            break;
    #####: 2420:        case PROTOCOL_BINARY_CMD_DELETE:
    #####: 2421:            if (keylen > 0 && extlen == 0 && bodylen == keylen) {
    #####: 2422:                bin_read_key(c, bin_reading_del_header, extlen);
        -: 2423:            } else {
        -: 2424:                protocol_error = 1;
        -: 2425:            }
        -: 2426:            break;
    #####: 2427:        case PROTOCOL_BINARY_CMD_INCREMENT:
        -: 2428:        case PROTOCOL_BINARY_CMD_DECREMENT:
    #####: 2429:            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {
    #####: 2430:                bin_read_key(c, bin_reading_incr_header, 20);
        -: 2431:            } else {
        -: 2432:                protocol_error = 1;
        -: 2433:            }
        -: 2434:            break;
    #####: 2435:        case PROTOCOL_BINARY_CMD_APPEND:
        -: 2436:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2437:            if (keylen > 0 && extlen == 0) {
    #####: 2438:                bin_read_key(c, bin_reading_set_header, 0);
        -: 2439:            } else {
        -: 2440:                protocol_error = 1;
        -: 2441:            }
        -: 2442:            break;
    #####: 2443:        case PROTOCOL_BINARY_CMD_STAT:
    #####: 2444:            if (extlen == 0) {
    #####: 2445:                bin_read_key(c, bin_reading_stat, 0);
        -: 2446:            } else {
        -: 2447:                protocol_error = 1;
        -: 2448:            }
        -: 2449:            break;
    #####: 2450:        case PROTOCOL_BINARY_CMD_QUIT:
    #####: 2451:            if (keylen == 0 && extlen == 0 && bodylen == 0) {
    #####: 2452:                write_bin_response(c, NULL, 0, 0, 0);
    #####: 2453:                c->write_and_go = conn_closing;
    #####: 2454:                if (c->noreply) {
    #####: 2455:                    conn_set_state(c, conn_closing);
        -: 2456:                }
        -: 2457:            } else {
        -: 2458:                protocol_error = 1;
        -: 2459:            }
        -: 2460:            break;
    #####: 2461:        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:
    #####: 2462:            if (extlen == 0 && keylen == 0 && bodylen == 0) {
    #####: 2463:                bin_list_sasl_mechs(c);
        -: 2464:            } else {
        -: 2465:                protocol_error = 1;
        -: 2466:            }
        -: 2467:            break;
    #####: 2468:        case PROTOCOL_BINARY_CMD_SASL_AUTH:
        -: 2469:        case PROTOCOL_BINARY_CMD_SASL_STEP:
    #####: 2470:            if (extlen == 0 && keylen != 0) {
    #####: 2471:                bin_read_key(c, bin_reading_sasl_auth, 0);
        -: 2472:            } else {
        -: 2473:                protocol_error = 1;
        -: 2474:            }
        -: 2475:            break;
    #####: 2476:        case PROTOCOL_BINARY_CMD_TOUCH:
        -: 2477:        case PROTOCOL_BINARY_CMD_GAT:
        -: 2478:        case PROTOCOL_BINARY_CMD_GATQ:
        -: 2479:        case PROTOCOL_BINARY_CMD_GATK:
        -: 2480:        case PROTOCOL_BINARY_CMD_GATKQ:
    #####: 2481:            if (extlen == 4 && keylen != 0) {
    #####: 2482:                bin_read_key(c, bin_reading_touch_key, 4);
        -: 2483:            } else {
        -: 2484:                protocol_error = 1;
        -: 2485:            }
        -: 2486:            break;
    #####: 2487:        default:
    #####: 2488:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
        -: 2489:                            bodylen);
        -: 2490:    }
        -: 2491:
  100000*: 2492:    if (protocol_error)
    #####: 2493:        handle_binary_protocol_error(c);
        -: 2494:}
------------------
        -: 2495:
    27600: 2496:static void process_bin_update(conn *c) {
    27600: 2497:    char *key;
    27600: 2498:    int nkey;
    27600: 2499:    int vlen;
    27600: 2500:    item *it;
    27600: 2501:    protocol_binary_request_set* req = binary_get_request(c);
        -: 2502:
   27600*: 2503:    assert(c != NULL);
        -: 2504:
    55200: 2505:    key = binary_get_key(c);
    27600: 2506:    nkey = c->binary_header.request.keylen;
        -: 2507:
        -: 2508:    /* fix byteorder in the request */
    27600: 2509:    req->message.body.flags = ntohl(req->message.body.flags);
    27600: 2510:    req->message.body.expiration = ntohl(req->message.body.expiration);
        -: 2511:
    27600: 2512:    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);
        -: 2513:
    27600: 2514:    if (settings.verbose > 1) {
    #####: 2515:        int ii;
    #####: 2516:        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
    #####: 2517:            fprintf(stderr, "<%d ADD ", c->sfd);
    #####: 2518:        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2519:            fprintf(stderr, "<%d SET ", c->sfd);
        -: 2520:        } else {
    #####: 2521:            fprintf(stderr, "<%d REPLACE ", c->sfd);
        -: 2522:        }
    #####: 2523:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2524:            fprintf(stderr, "%c", key[ii]);
        -: 2525:        }
        -: 2526:
    #####: 2527:        fprintf(stderr, " Value len is %d", vlen);
    #####: 2528:        fprintf(stderr, "\n");
        -: 2529:    }
        -: 2530:
    27600: 2531:    if (settings.detail_enabled) {
    #####: 2532:        stats_prefix_record_set(key, nkey);
        -: 2533:    }
        -: 2534:
    27600: 2535:    it = item_alloc(key, nkey, req->message.body.flags,
    27600: 2536:            realtime(req->message.body.expiration), vlen+2);
        -: 2537:
    27600: 2538:    if (it == 0) {
    #####: 2539:        enum store_item_type status;
    #####: 2540:        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
    #####: 2541:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
    #####: 2542:            status = TOO_LARGE;
        -: 2543:        } else {
    #####: 2544:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2545:            /* This error generating method eats the swallow value. Add here. */
    #####: 2546:            c->sbytes = vlen;
    #####: 2547:            status = NO_MEMORY;
        -: 2548:        }
        -: 2549:        /* FIXME: losing c->cmd since it's translated below. refactor? */
    #####: 2550:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 2551:                NULL, status, 0, key, nkey, req->message.body.expiration,
        -: 2552:                ITEM_clsid(it));
        -: 2553:
        -: 2554:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 2555:         * Unacceptable for SET. Anywhere else too? */
    #####: 2556:        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2557:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 2558:            if (it) {
    #####: 2559:                item_unlink(it);
    #####: 2560:                STORAGE_delete(c->thread->storage, it);
    #####: 2561:                item_remove(it);
        -: 2562:            }
        -: 2563:        }
        -: 2564:
        -: 2565:        /* swallow the data line */
    #####: 2566:        c->write_and_go = conn_swallow;
    #####: 2567:        return;
        -: 2568:    }
        -: 2569:
    27600: 2570:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2571:
    27600: 2572:    switch (c->cmd) {
    #####: 2573:        case PROTOCOL_BINARY_CMD_ADD:
    #####: 2574:            c->cmd = NREAD_ADD;
    #####: 2575:            break;
    27600: 2576:        case PROTOCOL_BINARY_CMD_SET:
    27600: 2577:            c->cmd = NREAD_SET;
    27600: 2578:            break;
    #####: 2579:        case PROTOCOL_BINARY_CMD_REPLACE:
    #####: 2580:            c->cmd = NREAD_REPLACE;
    #####: 2581:            break;
        -: 2582:        default:
    #####: 2583:            assert(0);
        -: 2584:    }
        -: 2585:
    27600: 2586:    if (ITEM_get_cas(it) != 0) {
    #####: 2587:        c->cmd = NREAD_CAS;
        -: 2588:    }
        -: 2589:
    27600: 2590:    c->item = it;
        -: 2591:#ifdef NEED_ALIGN
        -: 2592:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2593:        c->ritem = ITEM_schunk(it);
        -: 2594:    } else {
        -: 2595:        c->ritem = ITEM_data(it);
        -: 2596:    }
        -: 2597:#else
    27600: 2598:    c->ritem = ITEM_data(it);
        -: 2599:#endif
    27600: 2600:    c->rlbytes = vlen;
    27600: 2601:    conn_set_state(c, conn_nread);
    27600: 2602:    c->substate = bin_read_set_value;
        -: 2603:}
------------------
process_bin_update:
     9200: 2496:static void process_bin_update(conn *c) {
     9200: 2497:    char *key;
     9200: 2498:    int nkey;
     9200: 2499:    int vlen;
     9200: 2500:    item *it;
     9200: 2501:    protocol_binary_request_set* req = binary_get_request(c);
        -: 2502:
    9200*: 2503:    assert(c != NULL);
        -: 2504:
    18400: 2505:    key = binary_get_key(c);
     9200: 2506:    nkey = c->binary_header.request.keylen;
        -: 2507:
        -: 2508:    /* fix byteorder in the request */
     9200: 2509:    req->message.body.flags = ntohl(req->message.body.flags);
     9200: 2510:    req->message.body.expiration = ntohl(req->message.body.expiration);
        -: 2511:
     9200: 2512:    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);
        -: 2513:
     9200: 2514:    if (settings.verbose > 1) {
    #####: 2515:        int ii;
    #####: 2516:        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
    #####: 2517:            fprintf(stderr, "<%d ADD ", c->sfd);
    #####: 2518:        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2519:            fprintf(stderr, "<%d SET ", c->sfd);
        -: 2520:        } else {
    #####: 2521:            fprintf(stderr, "<%d REPLACE ", c->sfd);
        -: 2522:        }
    #####: 2523:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2524:            fprintf(stderr, "%c", key[ii]);
        -: 2525:        }
        -: 2526:
    #####: 2527:        fprintf(stderr, " Value len is %d", vlen);
    #####: 2528:        fprintf(stderr, "\n");
        -: 2529:    }
        -: 2530:
     9200: 2531:    if (settings.detail_enabled) {
    #####: 2532:        stats_prefix_record_set(key, nkey);
        -: 2533:    }
        -: 2534:
     9200: 2535:    it = item_alloc(key, nkey, req->message.body.flags,
     9200: 2536:            realtime(req->message.body.expiration), vlen+2);
        -: 2537:
     9200: 2538:    if (it == 0) {
    #####: 2539:        enum store_item_type status;
    #####: 2540:        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
    #####: 2541:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
    #####: 2542:            status = TOO_LARGE;
        -: 2543:        } else {
    #####: 2544:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2545:            /* This error generating method eats the swallow value. Add here. */
    #####: 2546:            c->sbytes = vlen;
    #####: 2547:            status = NO_MEMORY;
        -: 2548:        }
        -: 2549:        /* FIXME: losing c->cmd since it's translated below. refactor? */
    #####: 2550:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 2551:                NULL, status, 0, key, nkey, req->message.body.expiration,
        -: 2552:                ITEM_clsid(it));
        -: 2553:
        -: 2554:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 2555:         * Unacceptable for SET. Anywhere else too? */
    #####: 2556:        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2557:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 2558:            if (it) {
    #####: 2559:                item_unlink(it);
    #####: 2560:                STORAGE_delete(c->thread->storage, it);
    #####: 2561:                item_remove(it);
        -: 2562:            }
        -: 2563:        }
        -: 2564:
        -: 2565:        /* swallow the data line */
    #####: 2566:        c->write_and_go = conn_swallow;
    #####: 2567:        return;
        -: 2568:    }
        -: 2569:
     9200: 2570:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2571:
     9200: 2572:    switch (c->cmd) {
    #####: 2573:        case PROTOCOL_BINARY_CMD_ADD:
    #####: 2574:            c->cmd = NREAD_ADD;
    #####: 2575:            break;
     9200: 2576:        case PROTOCOL_BINARY_CMD_SET:
     9200: 2577:            c->cmd = NREAD_SET;
     9200: 2578:            break;
    #####: 2579:        case PROTOCOL_BINARY_CMD_REPLACE:
    #####: 2580:            c->cmd = NREAD_REPLACE;
    #####: 2581:            break;
        -: 2582:        default:
    #####: 2583:            assert(0);
        -: 2584:    }
        -: 2585:
     9200: 2586:    if (ITEM_get_cas(it) != 0) {
    #####: 2587:        c->cmd = NREAD_CAS;
        -: 2588:    }
        -: 2589:
     9200: 2590:    c->item = it;
        -: 2591:#ifdef NEED_ALIGN
        -: 2592:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2593:        c->ritem = ITEM_schunk(it);
        -: 2594:    } else {
        -: 2595:        c->ritem = ITEM_data(it);
        -: 2596:    }
        -: 2597:#else
     9200: 2598:    c->ritem = ITEM_data(it);
        -: 2599:#endif
     9200: 2600:    c->rlbytes = vlen;
     9200: 2601:    conn_set_state(c, conn_nread);
     9200: 2602:    c->substate = bin_read_set_value;
        -: 2603:}
------------------
process_bin_update:
     9200: 2496:static void process_bin_update(conn *c) {
     9200: 2497:    char *key;
     9200: 2498:    int nkey;
     9200: 2499:    int vlen;
     9200: 2500:    item *it;
     9200: 2501:    protocol_binary_request_set* req = binary_get_request(c);
        -: 2502:
    9200*: 2503:    assert(c != NULL);
        -: 2504:
    18400: 2505:    key = binary_get_key(c);
     9200: 2506:    nkey = c->binary_header.request.keylen;
        -: 2507:
        -: 2508:    /* fix byteorder in the request */
     9200: 2509:    req->message.body.flags = ntohl(req->message.body.flags);
     9200: 2510:    req->message.body.expiration = ntohl(req->message.body.expiration);
        -: 2511:
     9200: 2512:    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);
        -: 2513:
     9200: 2514:    if (settings.verbose > 1) {
    #####: 2515:        int ii;
    #####: 2516:        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
    #####: 2517:            fprintf(stderr, "<%d ADD ", c->sfd);
    #####: 2518:        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2519:            fprintf(stderr, "<%d SET ", c->sfd);
        -: 2520:        } else {
    #####: 2521:            fprintf(stderr, "<%d REPLACE ", c->sfd);
        -: 2522:        }
    #####: 2523:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2524:            fprintf(stderr, "%c", key[ii]);
        -: 2525:        }
        -: 2526:
    #####: 2527:        fprintf(stderr, " Value len is %d", vlen);
    #####: 2528:        fprintf(stderr, "\n");
        -: 2529:    }
        -: 2530:
     9200: 2531:    if (settings.detail_enabled) {
    #####: 2532:        stats_prefix_record_set(key, nkey);
        -: 2533:    }
        -: 2534:
     9200: 2535:    it = item_alloc(key, nkey, req->message.body.flags,
     9200: 2536:            realtime(req->message.body.expiration), vlen+2);
        -: 2537:
     9200: 2538:    if (it == 0) {
    #####: 2539:        enum store_item_type status;
    #####: 2540:        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
    #####: 2541:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
    #####: 2542:            status = TOO_LARGE;
        -: 2543:        } else {
    #####: 2544:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2545:            /* This error generating method eats the swallow value. Add here. */
    #####: 2546:            c->sbytes = vlen;
    #####: 2547:            status = NO_MEMORY;
        -: 2548:        }
        -: 2549:        /* FIXME: losing c->cmd since it's translated below. refactor? */
    #####: 2550:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 2551:                NULL, status, 0, key, nkey, req->message.body.expiration,
        -: 2552:                ITEM_clsid(it));
        -: 2553:
        -: 2554:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 2555:         * Unacceptable for SET. Anywhere else too? */
    #####: 2556:        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2557:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 2558:            if (it) {
    #####: 2559:                item_unlink(it);
    #####: 2560:                STORAGE_delete(c->thread->storage, it);
    #####: 2561:                item_remove(it);
        -: 2562:            }
        -: 2563:        }
        -: 2564:
        -: 2565:        /* swallow the data line */
    #####: 2566:        c->write_and_go = conn_swallow;
    #####: 2567:        return;
        -: 2568:    }
        -: 2569:
     9200: 2570:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2571:
     9200: 2572:    switch (c->cmd) {
    #####: 2573:        case PROTOCOL_BINARY_CMD_ADD:
    #####: 2574:            c->cmd = NREAD_ADD;
    #####: 2575:            break;
     9200: 2576:        case PROTOCOL_BINARY_CMD_SET:
     9200: 2577:            c->cmd = NREAD_SET;
     9200: 2578:            break;
    #####: 2579:        case PROTOCOL_BINARY_CMD_REPLACE:
    #####: 2580:            c->cmd = NREAD_REPLACE;
    #####: 2581:            break;
        -: 2582:        default:
    #####: 2583:            assert(0);
        -: 2584:    }
        -: 2585:
     9200: 2586:    if (ITEM_get_cas(it) != 0) {
    #####: 2587:        c->cmd = NREAD_CAS;
        -: 2588:    }
        -: 2589:
     9200: 2590:    c->item = it;
        -: 2591:#ifdef NEED_ALIGN
        -: 2592:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2593:        c->ritem = ITEM_schunk(it);
        -: 2594:    } else {
        -: 2595:        c->ritem = ITEM_data(it);
        -: 2596:    }
        -: 2597:#else
     9200: 2598:    c->ritem = ITEM_data(it);
        -: 2599:#endif
     9200: 2600:    c->rlbytes = vlen;
     9200: 2601:    conn_set_state(c, conn_nread);
     9200: 2602:    c->substate = bin_read_set_value;
        -: 2603:}
------------------
process_bin_update:
     9200: 2496:static void process_bin_update(conn *c) {
     9200: 2497:    char *key;
     9200: 2498:    int nkey;
     9200: 2499:    int vlen;
     9200: 2500:    item *it;
     9200: 2501:    protocol_binary_request_set* req = binary_get_request(c);
        -: 2502:
    9200*: 2503:    assert(c != NULL);
        -: 2504:
    18400: 2505:    key = binary_get_key(c);
     9200: 2506:    nkey = c->binary_header.request.keylen;
        -: 2507:
        -: 2508:    /* fix byteorder in the request */
     9200: 2509:    req->message.body.flags = ntohl(req->message.body.flags);
     9200: 2510:    req->message.body.expiration = ntohl(req->message.body.expiration);
        -: 2511:
     9200: 2512:    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);
        -: 2513:
     9200: 2514:    if (settings.verbose > 1) {
    #####: 2515:        int ii;
    #####: 2516:        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
    #####: 2517:            fprintf(stderr, "<%d ADD ", c->sfd);
    #####: 2518:        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2519:            fprintf(stderr, "<%d SET ", c->sfd);
        -: 2520:        } else {
    #####: 2521:            fprintf(stderr, "<%d REPLACE ", c->sfd);
        -: 2522:        }
    #####: 2523:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2524:            fprintf(stderr, "%c", key[ii]);
        -: 2525:        }
        -: 2526:
    #####: 2527:        fprintf(stderr, " Value len is %d", vlen);
    #####: 2528:        fprintf(stderr, "\n");
        -: 2529:    }
        -: 2530:
     9200: 2531:    if (settings.detail_enabled) {
    #####: 2532:        stats_prefix_record_set(key, nkey);
        -: 2533:    }
        -: 2534:
     9200: 2535:    it = item_alloc(key, nkey, req->message.body.flags,
     9200: 2536:            realtime(req->message.body.expiration), vlen+2);
        -: 2537:
     9200: 2538:    if (it == 0) {
    #####: 2539:        enum store_item_type status;
    #####: 2540:        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
    #####: 2541:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
    #####: 2542:            status = TOO_LARGE;
        -: 2543:        } else {
    #####: 2544:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2545:            /* This error generating method eats the swallow value. Add here. */
    #####: 2546:            c->sbytes = vlen;
    #####: 2547:            status = NO_MEMORY;
        -: 2548:        }
        -: 2549:        /* FIXME: losing c->cmd since it's translated below. refactor? */
    #####: 2550:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 2551:                NULL, status, 0, key, nkey, req->message.body.expiration,
        -: 2552:                ITEM_clsid(it));
        -: 2553:
        -: 2554:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 2555:         * Unacceptable for SET. Anywhere else too? */
    #####: 2556:        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
    #####: 2557:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 2558:            if (it) {
    #####: 2559:                item_unlink(it);
    #####: 2560:                STORAGE_delete(c->thread->storage, it);
    #####: 2561:                item_remove(it);
        -: 2562:            }
        -: 2563:        }
        -: 2564:
        -: 2565:        /* swallow the data line */
    #####: 2566:        c->write_and_go = conn_swallow;
    #####: 2567:        return;
        -: 2568:    }
        -: 2569:
     9200: 2570:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2571:
     9200: 2572:    switch (c->cmd) {
    #####: 2573:        case PROTOCOL_BINARY_CMD_ADD:
    #####: 2574:            c->cmd = NREAD_ADD;
    #####: 2575:            break;
     9200: 2576:        case PROTOCOL_BINARY_CMD_SET:
     9200: 2577:            c->cmd = NREAD_SET;
     9200: 2578:            break;
    #####: 2579:        case PROTOCOL_BINARY_CMD_REPLACE:
    #####: 2580:            c->cmd = NREAD_REPLACE;
    #####: 2581:            break;
        -: 2582:        default:
    #####: 2583:            assert(0);
        -: 2584:    }
        -: 2585:
     9200: 2586:    if (ITEM_get_cas(it) != 0) {
    #####: 2587:        c->cmd = NREAD_CAS;
        -: 2588:    }
        -: 2589:
     9200: 2590:    c->item = it;
        -: 2591:#ifdef NEED_ALIGN
        -: 2592:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2593:        c->ritem = ITEM_schunk(it);
        -: 2594:    } else {
        -: 2595:        c->ritem = ITEM_data(it);
        -: 2596:    }
        -: 2597:#else
     9200: 2598:    c->ritem = ITEM_data(it);
        -: 2599:#endif
     9200: 2600:    c->rlbytes = vlen;
     9200: 2601:    conn_set_state(c, conn_nread);
     9200: 2602:    c->substate = bin_read_set_value;
        -: 2603:}
------------------
        -: 2604:
    #####: 2605:static void process_bin_append_prepend(conn *c) {
    #####: 2606:    char *key;
    #####: 2607:    int nkey;
    #####: 2608:    int vlen;
    #####: 2609:    item *it;
        -: 2610:
    #####: 2611:    assert(c != NULL);
        -: 2612:
    #####: 2613:    key = binary_get_key(c);
    #####: 2614:    nkey = c->binary_header.request.keylen;
    #####: 2615:    vlen = c->binary_header.request.bodylen - nkey;
        -: 2616:
    #####: 2617:    if (settings.verbose > 1) {
    #####: 2618:        fprintf(stderr, "Value len is %d\n", vlen);
        -: 2619:    }
        -: 2620:
    #####: 2621:    if (settings.detail_enabled) {
    #####: 2622:        stats_prefix_record_set(key, nkey);
        -: 2623:    }
        -: 2624:
    #####: 2625:    it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2626:
    #####: 2627:    if (it == 0) {
    #####: 2628:        if (! item_size_ok(nkey, 0, vlen + 2)) {
    #####: 2629:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2630:        } else {
    #####: 2631:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2632:            /* OOM calls eat the swallow value. Add here. */
    #####: 2633:            c->sbytes = vlen;
        -: 2634:        }
        -: 2635:        /* swallow the data line */
    #####: 2636:        c->write_and_go = conn_swallow;
    #####: 2637:        return;
        -: 2638:    }
        -: 2639:
    #####: 2640:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2641:
    #####: 2642:    switch (c->cmd) {
    #####: 2643:        case PROTOCOL_BINARY_CMD_APPEND:
    #####: 2644:            c->cmd = NREAD_APPEND;
    #####: 2645:            break;
    #####: 2646:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2647:            c->cmd = NREAD_PREPEND;
    #####: 2648:            break;
        -: 2649:        default:
    #####: 2650:            assert(0);
        -: 2651:    }
        -: 2652:
    #####: 2653:    c->item = it;
        -: 2654:#ifdef NEED_ALIGN
        -: 2655:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2656:        c->ritem = ITEM_schunk(it);
        -: 2657:    } else {
        -: 2658:        c->ritem = ITEM_data(it);
        -: 2659:    }
        -: 2660:#else
    #####: 2661:    c->ritem = ITEM_data(it);
        -: 2662:#endif
    #####: 2663:    c->rlbytes = vlen;
    #####: 2664:    conn_set_state(c, conn_nread);
    #####: 2665:    c->substate = bin_read_set_value;
        -: 2666:}
------------------
process_bin_append_prepend:
    #####: 2605:static void process_bin_append_prepend(conn *c) {
    #####: 2606:    char *key;
    #####: 2607:    int nkey;
    #####: 2608:    int vlen;
    #####: 2609:    item *it;
        -: 2610:
    #####: 2611:    assert(c != NULL);
        -: 2612:
    #####: 2613:    key = binary_get_key(c);
    #####: 2614:    nkey = c->binary_header.request.keylen;
    #####: 2615:    vlen = c->binary_header.request.bodylen - nkey;
        -: 2616:
    #####: 2617:    if (settings.verbose > 1) {
    #####: 2618:        fprintf(stderr, "Value len is %d\n", vlen);
        -: 2619:    }
        -: 2620:
    #####: 2621:    if (settings.detail_enabled) {
    #####: 2622:        stats_prefix_record_set(key, nkey);
        -: 2623:    }
        -: 2624:
    #####: 2625:    it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2626:
    #####: 2627:    if (it == 0) {
    #####: 2628:        if (! item_size_ok(nkey, 0, vlen + 2)) {
    #####: 2629:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2630:        } else {
    #####: 2631:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2632:            /* OOM calls eat the swallow value. Add here. */
    #####: 2633:            c->sbytes = vlen;
        -: 2634:        }
        -: 2635:        /* swallow the data line */
    #####: 2636:        c->write_and_go = conn_swallow;
    #####: 2637:        return;
        -: 2638:    }
        -: 2639:
    #####: 2640:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2641:
    #####: 2642:    switch (c->cmd) {
    #####: 2643:        case PROTOCOL_BINARY_CMD_APPEND:
    #####: 2644:            c->cmd = NREAD_APPEND;
    #####: 2645:            break;
    #####: 2646:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2647:            c->cmd = NREAD_PREPEND;
    #####: 2648:            break;
        -: 2649:        default:
    #####: 2650:            assert(0);
        -: 2651:    }
        -: 2652:
    #####: 2653:    c->item = it;
        -: 2654:#ifdef NEED_ALIGN
        -: 2655:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2656:        c->ritem = ITEM_schunk(it);
        -: 2657:    } else {
        -: 2658:        c->ritem = ITEM_data(it);
        -: 2659:    }
        -: 2660:#else
    #####: 2661:    c->ritem = ITEM_data(it);
        -: 2662:#endif
    #####: 2663:    c->rlbytes = vlen;
    #####: 2664:    conn_set_state(c, conn_nread);
    #####: 2665:    c->substate = bin_read_set_value;
        -: 2666:}
------------------
process_bin_append_prepend:
    #####: 2605:static void process_bin_append_prepend(conn *c) {
    #####: 2606:    char *key;
    #####: 2607:    int nkey;
    #####: 2608:    int vlen;
    #####: 2609:    item *it;
        -: 2610:
    #####: 2611:    assert(c != NULL);
        -: 2612:
    #####: 2613:    key = binary_get_key(c);
    #####: 2614:    nkey = c->binary_header.request.keylen;
    #####: 2615:    vlen = c->binary_header.request.bodylen - nkey;
        -: 2616:
    #####: 2617:    if (settings.verbose > 1) {
    #####: 2618:        fprintf(stderr, "Value len is %d\n", vlen);
        -: 2619:    }
        -: 2620:
    #####: 2621:    if (settings.detail_enabled) {
    #####: 2622:        stats_prefix_record_set(key, nkey);
        -: 2623:    }
        -: 2624:
    #####: 2625:    it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2626:
    #####: 2627:    if (it == 0) {
    #####: 2628:        if (! item_size_ok(nkey, 0, vlen + 2)) {
    #####: 2629:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2630:        } else {
    #####: 2631:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2632:            /* OOM calls eat the swallow value. Add here. */
    #####: 2633:            c->sbytes = vlen;
        -: 2634:        }
        -: 2635:        /* swallow the data line */
    #####: 2636:        c->write_and_go = conn_swallow;
    #####: 2637:        return;
        -: 2638:    }
        -: 2639:
    #####: 2640:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2641:
    #####: 2642:    switch (c->cmd) {
    #####: 2643:        case PROTOCOL_BINARY_CMD_APPEND:
    #####: 2644:            c->cmd = NREAD_APPEND;
    #####: 2645:            break;
    #####: 2646:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2647:            c->cmd = NREAD_PREPEND;
    #####: 2648:            break;
        -: 2649:        default:
    #####: 2650:            assert(0);
        -: 2651:    }
        -: 2652:
    #####: 2653:    c->item = it;
        -: 2654:#ifdef NEED_ALIGN
        -: 2655:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2656:        c->ritem = ITEM_schunk(it);
        -: 2657:    } else {
        -: 2658:        c->ritem = ITEM_data(it);
        -: 2659:    }
        -: 2660:#else
    #####: 2661:    c->ritem = ITEM_data(it);
        -: 2662:#endif
    #####: 2663:    c->rlbytes = vlen;
    #####: 2664:    conn_set_state(c, conn_nread);
    #####: 2665:    c->substate = bin_read_set_value;
        -: 2666:}
------------------
process_bin_append_prepend:
    #####: 2605:static void process_bin_append_prepend(conn *c) {
    #####: 2606:    char *key;
    #####: 2607:    int nkey;
    #####: 2608:    int vlen;
    #####: 2609:    item *it;
        -: 2610:
    #####: 2611:    assert(c != NULL);
        -: 2612:
    #####: 2613:    key = binary_get_key(c);
    #####: 2614:    nkey = c->binary_header.request.keylen;
    #####: 2615:    vlen = c->binary_header.request.bodylen - nkey;
        -: 2616:
    #####: 2617:    if (settings.verbose > 1) {
    #####: 2618:        fprintf(stderr, "Value len is %d\n", vlen);
        -: 2619:    }
        -: 2620:
    #####: 2621:    if (settings.detail_enabled) {
    #####: 2622:        stats_prefix_record_set(key, nkey);
        -: 2623:    }
        -: 2624:
    #####: 2625:    it = item_alloc(key, nkey, 0, 0, vlen+2);
        -: 2626:
    #####: 2627:    if (it == 0) {
    #####: 2628:        if (! item_size_ok(nkey, 0, vlen + 2)) {
    #####: 2629:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        -: 2630:        } else {
    #####: 2631:            out_of_memory(c, "SERVER_ERROR Out of memory allocating item");
        -: 2632:            /* OOM calls eat the swallow value. Add here. */
    #####: 2633:            c->sbytes = vlen;
        -: 2634:        }
        -: 2635:        /* swallow the data line */
    #####: 2636:        c->write_and_go = conn_swallow;
    #####: 2637:        return;
        -: 2638:    }
        -: 2639:
    #####: 2640:    ITEM_set_cas(it, c->binary_header.request.cas);
        -: 2641:
    #####: 2642:    switch (c->cmd) {
    #####: 2643:        case PROTOCOL_BINARY_CMD_APPEND:
    #####: 2644:            c->cmd = NREAD_APPEND;
    #####: 2645:            break;
    #####: 2646:        case PROTOCOL_BINARY_CMD_PREPEND:
    #####: 2647:            c->cmd = NREAD_PREPEND;
    #####: 2648:            break;
        -: 2649:        default:
    #####: 2650:            assert(0);
        -: 2651:    }
        -: 2652:
    #####: 2653:    c->item = it;
        -: 2654:#ifdef NEED_ALIGN
        -: 2655:    if (it->it_flags & ITEM_CHUNKED) {
        -: 2656:        c->ritem = ITEM_schunk(it);
        -: 2657:    } else {
        -: 2658:        c->ritem = ITEM_data(it);
        -: 2659:    }
        -: 2660:#else
    #####: 2661:    c->ritem = ITEM_data(it);
        -: 2662:#endif
    #####: 2663:    c->rlbytes = vlen;
    #####: 2664:    conn_set_state(c, conn_nread);
    #####: 2665:    c->substate = bin_read_set_value;
        -: 2666:}
------------------
        -: 2667:
    #####: 2668:static void process_bin_flush(conn *c) {
    #####: 2669:    time_t exptime = 0;
    #####: 2670:    protocol_binary_request_flush* req = binary_get_request(c);
    #####: 2671:    rel_time_t new_oldest = 0;
        -: 2672:
    #####: 2673:    if (!settings.flush_enabled) {
        -: 2674:      // flush_all is not allowed but we log it on stats
    #####: 2675:      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2676:      return;
        -: 2677:    }
        -: 2678:
    #####: 2679:    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
    #####: 2680:        exptime = ntohl(req->message.body.expiration);
        -: 2681:    }
        -: 2682:
    #####: 2683:    if (exptime > 0) {
    #####: 2684:        new_oldest = realtime(exptime);
        -: 2685:    } else {
    #####: 2686:        new_oldest = current_time;
        -: 2687:    }
    #####: 2688:    if (settings.use_cas) {
    #####: 2689:        settings.oldest_live = new_oldest - 1;
    #####: 2690:        if (settings.oldest_live <= current_time)
    #####: 2691:            settings.oldest_cas = get_cas_id();
        -: 2692:    } else {
    #####: 2693:        settings.oldest_live = new_oldest;
        -: 2694:    }
        -: 2695:
    #####: 2696:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2697:    c->thread->stats.flush_cmds++;
    #####: 2698:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2699:
    #####: 2700:    write_bin_response(c, NULL, 0, 0, 0);
        -: 2701:}
------------------
process_bin_flush:
    #####: 2668:static void process_bin_flush(conn *c) {
    #####: 2669:    time_t exptime = 0;
    #####: 2670:    protocol_binary_request_flush* req = binary_get_request(c);
    #####: 2671:    rel_time_t new_oldest = 0;
        -: 2672:
    #####: 2673:    if (!settings.flush_enabled) {
        -: 2674:      // flush_all is not allowed but we log it on stats
    #####: 2675:      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2676:      return;
        -: 2677:    }
        -: 2678:
    #####: 2679:    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
    #####: 2680:        exptime = ntohl(req->message.body.expiration);
        -: 2681:    }
        -: 2682:
    #####: 2683:    if (exptime > 0) {
    #####: 2684:        new_oldest = realtime(exptime);
        -: 2685:    } else {
    #####: 2686:        new_oldest = current_time;
        -: 2687:    }
    #####: 2688:    if (settings.use_cas) {
    #####: 2689:        settings.oldest_live = new_oldest - 1;
    #####: 2690:        if (settings.oldest_live <= current_time)
    #####: 2691:            settings.oldest_cas = get_cas_id();
        -: 2692:    } else {
    #####: 2693:        settings.oldest_live = new_oldest;
        -: 2694:    }
        -: 2695:
    #####: 2696:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2697:    c->thread->stats.flush_cmds++;
    #####: 2698:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2699:
    #####: 2700:    write_bin_response(c, NULL, 0, 0, 0);
        -: 2701:}
------------------
process_bin_flush:
    #####: 2668:static void process_bin_flush(conn *c) {
    #####: 2669:    time_t exptime = 0;
    #####: 2670:    protocol_binary_request_flush* req = binary_get_request(c);
    #####: 2671:    rel_time_t new_oldest = 0;
        -: 2672:
    #####: 2673:    if (!settings.flush_enabled) {
        -: 2674:      // flush_all is not allowed but we log it on stats
    #####: 2675:      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2676:      return;
        -: 2677:    }
        -: 2678:
    #####: 2679:    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
    #####: 2680:        exptime = ntohl(req->message.body.expiration);
        -: 2681:    }
        -: 2682:
    #####: 2683:    if (exptime > 0) {
    #####: 2684:        new_oldest = realtime(exptime);
        -: 2685:    } else {
    #####: 2686:        new_oldest = current_time;
        -: 2687:    }
    #####: 2688:    if (settings.use_cas) {
    #####: 2689:        settings.oldest_live = new_oldest - 1;
    #####: 2690:        if (settings.oldest_live <= current_time)
    #####: 2691:            settings.oldest_cas = get_cas_id();
        -: 2692:    } else {
    #####: 2693:        settings.oldest_live = new_oldest;
        -: 2694:    }
        -: 2695:
    #####: 2696:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2697:    c->thread->stats.flush_cmds++;
    #####: 2698:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2699:
    #####: 2700:    write_bin_response(c, NULL, 0, 0, 0);
        -: 2701:}
------------------
process_bin_flush:
    #####: 2668:static void process_bin_flush(conn *c) {
    #####: 2669:    time_t exptime = 0;
    #####: 2670:    protocol_binary_request_flush* req = binary_get_request(c);
    #####: 2671:    rel_time_t new_oldest = 0;
        -: 2672:
    #####: 2673:    if (!settings.flush_enabled) {
        -: 2674:      // flush_all is not allowed but we log it on stats
    #####: 2675:      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
    #####: 2676:      return;
        -: 2677:    }
        -: 2678:
    #####: 2679:    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
    #####: 2680:        exptime = ntohl(req->message.body.expiration);
        -: 2681:    }
        -: 2682:
    #####: 2683:    if (exptime > 0) {
    #####: 2684:        new_oldest = realtime(exptime);
        -: 2685:    } else {
    #####: 2686:        new_oldest = current_time;
        -: 2687:    }
    #####: 2688:    if (settings.use_cas) {
    #####: 2689:        settings.oldest_live = new_oldest - 1;
    #####: 2690:        if (settings.oldest_live <= current_time)
    #####: 2691:            settings.oldest_cas = get_cas_id();
        -: 2692:    } else {
    #####: 2693:        settings.oldest_live = new_oldest;
        -: 2694:    }
        -: 2695:
    #####: 2696:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2697:    c->thread->stats.flush_cmds++;
    #####: 2698:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2699:
    #####: 2700:    write_bin_response(c, NULL, 0, 0, 0);
        -: 2701:}
------------------
        -: 2702:
    #####: 2703:static void process_bin_delete(conn *c) {
    #####: 2704:    item *it;
    #####: 2705:    uint32_t hv;
        -: 2706:
    #####: 2707:    protocol_binary_request_delete* req = binary_get_request(c);
        -: 2708:
    #####: 2709:    char* key = binary_get_key(c);
    #####: 2710:    size_t nkey = c->binary_header.request.keylen;
        -: 2711:
    #####: 2712:    assert(c != NULL);
        -: 2713:
    #####: 2714:    if (settings.verbose > 1) {
    #####: 2715:        int ii;
    #####: 2716:        fprintf(stderr, "Deleting ");
    #####: 2717:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2718:            fprintf(stderr, "%c", key[ii]);
        -: 2719:        }
    #####: 2720:        fprintf(stderr, "\n");
        -: 2721:    }
        -: 2722:
    #####: 2723:    if (settings.detail_enabled) {
    #####: 2724:        stats_prefix_record_delete(key, nkey);
        -: 2725:    }
        -: 2726:
    #####: 2727:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 2728:    if (it) {
    #####: 2729:        uint64_t cas = ntohll(req->message.header.request.cas);
    #####: 2730:        if (cas == 0 || cas == ITEM_get_cas(it)) {
    #####: 2731:            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
    #####: 2732:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2733:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 2734:            pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2735:            do_item_unlink(it, hv);
    #####: 2736:            STORAGE_delete(c->thread->storage, it);
    #####: 2737:            write_bin_response(c, NULL, 0, 0, 0);
        -: 2738:        } else {
    #####: 2739:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        -: 2740:        }
    #####: 2741:        do_item_remove(it);      /* release our reference */
        -: 2742:    } else {
    #####: 2743:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2744:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2745:        c->thread->stats.delete_misses++;
    #####: 2746:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2747:    }
    #####: 2748:    item_unlock(hv);
    #####: 2749:}
------------------
process_bin_delete:
    #####: 2703:static void process_bin_delete(conn *c) {
    #####: 2704:    item *it;
    #####: 2705:    uint32_t hv;
        -: 2706:
    #####: 2707:    protocol_binary_request_delete* req = binary_get_request(c);
        -: 2708:
    #####: 2709:    char* key = binary_get_key(c);
    #####: 2710:    size_t nkey = c->binary_header.request.keylen;
        -: 2711:
    #####: 2712:    assert(c != NULL);
        -: 2713:
    #####: 2714:    if (settings.verbose > 1) {
    #####: 2715:        int ii;
    #####: 2716:        fprintf(stderr, "Deleting ");
    #####: 2717:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2718:            fprintf(stderr, "%c", key[ii]);
        -: 2719:        }
    #####: 2720:        fprintf(stderr, "\n");
        -: 2721:    }
        -: 2722:
    #####: 2723:    if (settings.detail_enabled) {
    #####: 2724:        stats_prefix_record_delete(key, nkey);
        -: 2725:    }
        -: 2726:
    #####: 2727:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 2728:    if (it) {
    #####: 2729:        uint64_t cas = ntohll(req->message.header.request.cas);
    #####: 2730:        if (cas == 0 || cas == ITEM_get_cas(it)) {
    #####: 2731:            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
    #####: 2732:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2733:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 2734:            pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2735:            do_item_unlink(it, hv);
    #####: 2736:            STORAGE_delete(c->thread->storage, it);
    #####: 2737:            write_bin_response(c, NULL, 0, 0, 0);
        -: 2738:        } else {
    #####: 2739:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        -: 2740:        }
    #####: 2741:        do_item_remove(it);      /* release our reference */
        -: 2742:    } else {
    #####: 2743:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2744:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2745:        c->thread->stats.delete_misses++;
    #####: 2746:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2747:    }
    #####: 2748:    item_unlock(hv);
    #####: 2749:}
------------------
process_bin_delete:
    #####: 2703:static void process_bin_delete(conn *c) {
    #####: 2704:    item *it;
    #####: 2705:    uint32_t hv;
        -: 2706:
    #####: 2707:    protocol_binary_request_delete* req = binary_get_request(c);
        -: 2708:
    #####: 2709:    char* key = binary_get_key(c);
    #####: 2710:    size_t nkey = c->binary_header.request.keylen;
        -: 2711:
    #####: 2712:    assert(c != NULL);
        -: 2713:
    #####: 2714:    if (settings.verbose > 1) {
    #####: 2715:        int ii;
    #####: 2716:        fprintf(stderr, "Deleting ");
    #####: 2717:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2718:            fprintf(stderr, "%c", key[ii]);
        -: 2719:        }
    #####: 2720:        fprintf(stderr, "\n");
        -: 2721:    }
        -: 2722:
    #####: 2723:    if (settings.detail_enabled) {
    #####: 2724:        stats_prefix_record_delete(key, nkey);
        -: 2725:    }
        -: 2726:
    #####: 2727:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 2728:    if (it) {
    #####: 2729:        uint64_t cas = ntohll(req->message.header.request.cas);
    #####: 2730:        if (cas == 0 || cas == ITEM_get_cas(it)) {
    #####: 2731:            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
    #####: 2732:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2733:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 2734:            pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2735:            do_item_unlink(it, hv);
    #####: 2736:            STORAGE_delete(c->thread->storage, it);
    #####: 2737:            write_bin_response(c, NULL, 0, 0, 0);
        -: 2738:        } else {
    #####: 2739:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        -: 2740:        }
    #####: 2741:        do_item_remove(it);      /* release our reference */
        -: 2742:    } else {
    #####: 2743:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2744:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2745:        c->thread->stats.delete_misses++;
    #####: 2746:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2747:    }
    #####: 2748:    item_unlock(hv);
    #####: 2749:}
------------------
process_bin_delete:
    #####: 2703:static void process_bin_delete(conn *c) {
    #####: 2704:    item *it;
    #####: 2705:    uint32_t hv;
        -: 2706:
    #####: 2707:    protocol_binary_request_delete* req = binary_get_request(c);
        -: 2708:
    #####: 2709:    char* key = binary_get_key(c);
    #####: 2710:    size_t nkey = c->binary_header.request.keylen;
        -: 2711:
    #####: 2712:    assert(c != NULL);
        -: 2713:
    #####: 2714:    if (settings.verbose > 1) {
    #####: 2715:        int ii;
    #####: 2716:        fprintf(stderr, "Deleting ");
    #####: 2717:        for (ii = 0; ii < nkey; ++ii) {
    #####: 2718:            fprintf(stderr, "%c", key[ii]);
        -: 2719:        }
    #####: 2720:        fprintf(stderr, "\n");
        -: 2721:    }
        -: 2722:
    #####: 2723:    if (settings.detail_enabled) {
    #####: 2724:        stats_prefix_record_delete(key, nkey);
        -: 2725:    }
        -: 2726:
    #####: 2727:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 2728:    if (it) {
    #####: 2729:        uint64_t cas = ntohll(req->message.header.request.cas);
    #####: 2730:        if (cas == 0 || cas == ITEM_get_cas(it)) {
    #####: 2731:            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
    #####: 2732:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2733:            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 2734:            pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 2735:            do_item_unlink(it, hv);
    #####: 2736:            STORAGE_delete(c->thread->storage, it);
    #####: 2737:            write_bin_response(c, NULL, 0, 0, 0);
        -: 2738:        } else {
    #####: 2739:            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        -: 2740:        }
    #####: 2741:        do_item_remove(it);      /* release our reference */
        -: 2742:    } else {
    #####: 2743:        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
    #####: 2744:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2745:        c->thread->stats.delete_misses++;
    #####: 2746:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2747:    }
    #####: 2748:    item_unlock(hv);
    #####: 2749:}
------------------
        -: 2750:
   327600: 2751:static void complete_nread_binary(conn *c) {
  327600*: 2752:    assert(c != NULL);
  327600*: 2753:    assert(c->cmd >= 0);
        -: 2754:
   327600: 2755:    switch(c->substate) {
    27600: 2756:    case bin_reading_set_header:
    27600: 2757:        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||
        -: 2758:                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {
    #####: 2759:            process_bin_append_prepend(c);
        -: 2760:        } else {
    27600: 2761:            process_bin_update(c);
        -: 2762:        }
        -: 2763:        break;
    27600: 2764:    case bin_read_set_value:
    27600: 2765:        complete_update_bin(c);
    27600: 2766:        break;
   272400: 2767:    case bin_reading_get_key:
        -: 2768:    case bin_reading_touch_key:
   272400: 2769:        process_bin_get_or_touch(c);
   272400: 2770:        break;
    #####: 2771:    case bin_reading_stat:
    #####: 2772:        process_bin_stat(c);
    #####: 2773:        break;
    #####: 2774:    case bin_reading_del_header:
    #####: 2775:        process_bin_delete(c);
    #####: 2776:        break;
    #####: 2777:    case bin_reading_incr_header:
    #####: 2778:        complete_incr_bin(c);
    #####: 2779:        break;
    #####: 2780:    case bin_read_flush_exptime:
    #####: 2781:        process_bin_flush(c);
    #####: 2782:        break;
    #####: 2783:    case bin_reading_sasl_auth:
    #####: 2784:        process_bin_sasl_auth(c);
    #####: 2785:        break;
    #####: 2786:    case bin_reading_sasl_auth_data:
    #####: 2787:        process_bin_complete_sasl_auth(c);
    #####: 2788:        break;
    #####: 2789:    default:
    #####: 2790:        fprintf(stderr, "Not handling substate %d\n", c->substate);
    #####: 2791:        assert(0);
        -: 2792:    }
   327600: 2793:}
------------------
complete_nread_binary:
   109200: 2751:static void complete_nread_binary(conn *c) {
  109200*: 2752:    assert(c != NULL);
  109200*: 2753:    assert(c->cmd >= 0);
        -: 2754:
   109200: 2755:    switch(c->substate) {
     9200: 2756:    case bin_reading_set_header:
     9200: 2757:        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||
        -: 2758:                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {
    #####: 2759:            process_bin_append_prepend(c);
        -: 2760:        } else {
     9200: 2761:            process_bin_update(c);
        -: 2762:        }
        -: 2763:        break;
     9200: 2764:    case bin_read_set_value:
     9200: 2765:        complete_update_bin(c);
     9200: 2766:        break;
    90800: 2767:    case bin_reading_get_key:
        -: 2768:    case bin_reading_touch_key:
    90800: 2769:        process_bin_get_or_touch(c);
    90800: 2770:        break;
    #####: 2771:    case bin_reading_stat:
    #####: 2772:        process_bin_stat(c);
    #####: 2773:        break;
    #####: 2774:    case bin_reading_del_header:
    #####: 2775:        process_bin_delete(c);
    #####: 2776:        break;
    #####: 2777:    case bin_reading_incr_header:
    #####: 2778:        complete_incr_bin(c);
    #####: 2779:        break;
    #####: 2780:    case bin_read_flush_exptime:
    #####: 2781:        process_bin_flush(c);
    #####: 2782:        break;
    #####: 2783:    case bin_reading_sasl_auth:
    #####: 2784:        process_bin_sasl_auth(c);
    #####: 2785:        break;
    #####: 2786:    case bin_reading_sasl_auth_data:
    #####: 2787:        process_bin_complete_sasl_auth(c);
    #####: 2788:        break;
    #####: 2789:    default:
    #####: 2790:        fprintf(stderr, "Not handling substate %d\n", c->substate);
    #####: 2791:        assert(0);
        -: 2792:    }
   109200: 2793:}
------------------
complete_nread_binary:
   109200: 2751:static void complete_nread_binary(conn *c) {
  109200*: 2752:    assert(c != NULL);
  109200*: 2753:    assert(c->cmd >= 0);
        -: 2754:
   109200: 2755:    switch(c->substate) {
     9200: 2756:    case bin_reading_set_header:
     9200: 2757:        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||
        -: 2758:                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {
    #####: 2759:            process_bin_append_prepend(c);
        -: 2760:        } else {
     9200: 2761:            process_bin_update(c);
        -: 2762:        }
        -: 2763:        break;
     9200: 2764:    case bin_read_set_value:
     9200: 2765:        complete_update_bin(c);
     9200: 2766:        break;
    90800: 2767:    case bin_reading_get_key:
        -: 2768:    case bin_reading_touch_key:
    90800: 2769:        process_bin_get_or_touch(c);
    90800: 2770:        break;
    #####: 2771:    case bin_reading_stat:
    #####: 2772:        process_bin_stat(c);
    #####: 2773:        break;
    #####: 2774:    case bin_reading_del_header:
    #####: 2775:        process_bin_delete(c);
    #####: 2776:        break;
    #####: 2777:    case bin_reading_incr_header:
    #####: 2778:        complete_incr_bin(c);
    #####: 2779:        break;
    #####: 2780:    case bin_read_flush_exptime:
    #####: 2781:        process_bin_flush(c);
    #####: 2782:        break;
    #####: 2783:    case bin_reading_sasl_auth:
    #####: 2784:        process_bin_sasl_auth(c);
    #####: 2785:        break;
    #####: 2786:    case bin_reading_sasl_auth_data:
    #####: 2787:        process_bin_complete_sasl_auth(c);
    #####: 2788:        break;
    #####: 2789:    default:
    #####: 2790:        fprintf(stderr, "Not handling substate %d\n", c->substate);
    #####: 2791:        assert(0);
        -: 2792:    }
   109200: 2793:}
------------------
complete_nread_binary:
   109200: 2751:static void complete_nread_binary(conn *c) {
  109200*: 2752:    assert(c != NULL);
  109200*: 2753:    assert(c->cmd >= 0);
        -: 2754:
   109200: 2755:    switch(c->substate) {
     9200: 2756:    case bin_reading_set_header:
     9200: 2757:        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||
        -: 2758:                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {
    #####: 2759:            process_bin_append_prepend(c);
        -: 2760:        } else {
     9200: 2761:            process_bin_update(c);
        -: 2762:        }
        -: 2763:        break;
     9200: 2764:    case bin_read_set_value:
     9200: 2765:        complete_update_bin(c);
     9200: 2766:        break;
    90800: 2767:    case bin_reading_get_key:
        -: 2768:    case bin_reading_touch_key:
    90800: 2769:        process_bin_get_or_touch(c);
    90800: 2770:        break;
    #####: 2771:    case bin_reading_stat:
    #####: 2772:        process_bin_stat(c);
    #####: 2773:        break;
    #####: 2774:    case bin_reading_del_header:
    #####: 2775:        process_bin_delete(c);
    #####: 2776:        break;
    #####: 2777:    case bin_reading_incr_header:
    #####: 2778:        complete_incr_bin(c);
    #####: 2779:        break;
    #####: 2780:    case bin_read_flush_exptime:
    #####: 2781:        process_bin_flush(c);
    #####: 2782:        break;
    #####: 2783:    case bin_reading_sasl_auth:
    #####: 2784:        process_bin_sasl_auth(c);
    #####: 2785:        break;
    #####: 2786:    case bin_reading_sasl_auth_data:
    #####: 2787:        process_bin_complete_sasl_auth(c);
    #####: 2788:        break;
    #####: 2789:    default:
    #####: 2790:        fprintf(stderr, "Not handling substate %d\n", c->substate);
    #####: 2791:        assert(0);
        -: 2792:    }
   109200: 2793:}
------------------
        -: 2794:
   300600: 2795:static void reset_cmd_handler(conn *c) {
   300600: 2796:    c->cmd = -1;
   300600: 2797:    c->substate = bin_no_state;
   300600: 2798:    if(c->item != NULL) {
    #####: 2799:        item_remove(c->item);
    #####: 2800:        c->item = NULL;
        -: 2801:    }
   300600: 2802:    conn_shrink(c);
   300600: 2803:    if (c->rbytes > 0) {
    #####: 2804:        conn_set_state(c, conn_parse_cmd);
        -: 2805:    } else {
   300600: 2806:        conn_set_state(c, conn_waiting);
        -: 2807:    }
   300600: 2808:}
------------------
reset_cmd_handler:
   100200: 2795:static void reset_cmd_handler(conn *c) {
   100200: 2796:    c->cmd = -1;
   100200: 2797:    c->substate = bin_no_state;
   100200: 2798:    if(c->item != NULL) {
    #####: 2799:        item_remove(c->item);
    #####: 2800:        c->item = NULL;
        -: 2801:    }
   100200: 2802:    conn_shrink(c);
   100200: 2803:    if (c->rbytes > 0) {
    #####: 2804:        conn_set_state(c, conn_parse_cmd);
        -: 2805:    } else {
   100200: 2806:        conn_set_state(c, conn_waiting);
        -: 2807:    }
   100200: 2808:}
------------------
reset_cmd_handler:
   100200: 2795:static void reset_cmd_handler(conn *c) {
   100200: 2796:    c->cmd = -1;
   100200: 2797:    c->substate = bin_no_state;
   100200: 2798:    if(c->item != NULL) {
    #####: 2799:        item_remove(c->item);
    #####: 2800:        c->item = NULL;
        -: 2801:    }
   100200: 2802:    conn_shrink(c);
   100200: 2803:    if (c->rbytes > 0) {
    #####: 2804:        conn_set_state(c, conn_parse_cmd);
        -: 2805:    } else {
   100200: 2806:        conn_set_state(c, conn_waiting);
        -: 2807:    }
   100200: 2808:}
------------------
reset_cmd_handler:
   100200: 2795:static void reset_cmd_handler(conn *c) {
   100200: 2796:    c->cmd = -1;
   100200: 2797:    c->substate = bin_no_state;
   100200: 2798:    if(c->item != NULL) {
    #####: 2799:        item_remove(c->item);
    #####: 2800:        c->item = NULL;
        -: 2801:    }
   100200: 2802:    conn_shrink(c);
   100200: 2803:    if (c->rbytes > 0) {
    #####: 2804:        conn_set_state(c, conn_parse_cmd);
        -: 2805:    } else {
   100200: 2806:        conn_set_state(c, conn_waiting);
        -: 2807:    }
   100200: 2808:}
------------------
        -: 2809:
   327600: 2810:static void complete_nread(conn *c) {
  327600*: 2811:    assert(c != NULL);
  327600*: 2812:    assert(c->protocol == ascii_prot
        -: 2813:           || c->protocol == binary_prot);
        -: 2814:
   327600: 2815:    if (c->protocol == ascii_prot) {
    #####: 2816:        complete_nread_ascii(c);
   327600: 2817:    } else if (c->protocol == binary_prot) {
   327600: 2818:        complete_nread_binary(c);
        -: 2819:    }
   327600: 2820:}
------------------
complete_nread:
   109200: 2810:static void complete_nread(conn *c) {
  109200*: 2811:    assert(c != NULL);
  109200*: 2812:    assert(c->protocol == ascii_prot
        -: 2813:           || c->protocol == binary_prot);
        -: 2814:
   109200: 2815:    if (c->protocol == ascii_prot) {
    #####: 2816:        complete_nread_ascii(c);
   109200: 2817:    } else if (c->protocol == binary_prot) {
   109200: 2818:        complete_nread_binary(c);
        -: 2819:    }
   109200: 2820:}
------------------
complete_nread:
   109200: 2810:static void complete_nread(conn *c) {
  109200*: 2811:    assert(c != NULL);
  109200*: 2812:    assert(c->protocol == ascii_prot
        -: 2813:           || c->protocol == binary_prot);
        -: 2814:
   109200: 2815:    if (c->protocol == ascii_prot) {
    #####: 2816:        complete_nread_ascii(c);
   109200: 2817:    } else if (c->protocol == binary_prot) {
   109200: 2818:        complete_nread_binary(c);
        -: 2819:    }
   109200: 2820:}
------------------
complete_nread:
   109200: 2810:static void complete_nread(conn *c) {
  109200*: 2811:    assert(c != NULL);
  109200*: 2812:    assert(c->protocol == ascii_prot
        -: 2813:           || c->protocol == binary_prot);
        -: 2814:
   109200: 2815:    if (c->protocol == ascii_prot) {
    #####: 2816:        complete_nread_ascii(c);
   109200: 2817:    } else if (c->protocol == binary_prot) {
   109200: 2818:        complete_nread_binary(c);
        -: 2819:    }
   109200: 2820:}
------------------
        -: 2821:
        -: 2822:/* Destination must always be chunked */
        -: 2823:/* This should be part of item.c */
    #####: 2824:static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    #####: 2825:    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
        -: 2826:    /* Advance dch until we find free space */
    #####: 2827:    while (dch->size == dch->used) {
    #####: 2828:        if (dch->next) {
        -: 2829:            dch = dch->next;
        -: 2830:        } else {
        -: 2831:            break;
        -: 2832:        }
        -: 2833:    }
        -: 2834:
    #####: 2835:    if (s_it->it_flags & ITEM_CHUNKED) {
    #####: 2836:        int remain = len;
    #####: 2837:        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
    #####: 2838:        int copied = 0;
        -: 2839:        /* Fills dch's to capacity, not straight copy sch in case data is
        -: 2840:         * being added or removed (ie append/prepend)
        -: 2841:         */
    #####: 2842:        while (sch && dch && remain) {
    #####: 2843:            assert(dch->used <= dch->size);
    #####: 2844:            int todo = (dch->size - dch->used < sch->used - copied)
        -: 2845:                ? dch->size - dch->used : sch->used - copied;
    #####: 2846:            if (remain < todo)
    #####: 2847:                todo = remain;
    #####: 2848:            memcpy(dch->data + dch->used, sch->data + copied, todo);
    #####: 2849:            dch->used += todo;
    #####: 2850:            copied += todo;
    #####: 2851:            remain -= todo;
    #####: 2852:            assert(dch->used <= dch->size);
    #####: 2853:            if (dch->size == dch->used) {
    #####: 2854:                item_chunk *tch = do_item_alloc_chunk(dch, remain);
    #####: 2855:                if (tch) {
        -: 2856:                    dch = tch;
        -: 2857:                } else {
        -: 2858:                    return -1;
        -: 2859:                }
        -: 2860:            }
    #####: 2861:            assert(copied <= sch->used);
    #####: 2862:            if (copied == sch->used) {
    #####: 2863:                copied = 0;
    #####: 2864:                sch = sch->next;
        -: 2865:            }
        -: 2866:        }
        -: 2867:        /* assert that the destination had enough space for the source */
    #####: 2868:        assert(remain == 0);
        -: 2869:    } else {
        -: 2870:        int done = 0;
        -: 2871:        /* Fill dch's via a non-chunked item. */
    #####: 2872:        while (len > done && dch) {
    #####: 2873:            int todo = (dch->size - dch->used < len - done)
        -: 2874:                ? dch->size - dch->used : len - done;
        -: 2875:            //assert(dch->size - dch->used != 0);
    #####: 2876:            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
    #####: 2877:            done += todo;
    #####: 2878:            dch->used += todo;
    #####: 2879:            assert(dch->used <= dch->size);
    #####: 2880:            if (dch->size == dch->used) {
    #####: 2881:                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
    #####: 2882:                if (tch) {
        -: 2883:                    dch = tch;
        -: 2884:                } else {
        -: 2885:                    return -1;
        -: 2886:                }
        -: 2887:            }
        -: 2888:        }
    #####: 2889:        assert(len == done);
        -: 2890:    }
        -: 2891:    return 0;
        -: 2892:}
------------------
_store_item_copy_chunks:
    #####: 2824:static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    #####: 2825:    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
        -: 2826:    /* Advance dch until we find free space */
    #####: 2827:    while (dch->size == dch->used) {
    #####: 2828:        if (dch->next) {
        -: 2829:            dch = dch->next;
        -: 2830:        } else {
        -: 2831:            break;
        -: 2832:        }
        -: 2833:    }
        -: 2834:
    #####: 2835:    if (s_it->it_flags & ITEM_CHUNKED) {
    #####: 2836:        int remain = len;
    #####: 2837:        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
    #####: 2838:        int copied = 0;
        -: 2839:        /* Fills dch's to capacity, not straight copy sch in case data is
        -: 2840:         * being added or removed (ie append/prepend)
        -: 2841:         */
    #####: 2842:        while (sch && dch && remain) {
    #####: 2843:            assert(dch->used <= dch->size);
    #####: 2844:            int todo = (dch->size - dch->used < sch->used - copied)
        -: 2845:                ? dch->size - dch->used : sch->used - copied;
    #####: 2846:            if (remain < todo)
    #####: 2847:                todo = remain;
    #####: 2848:            memcpy(dch->data + dch->used, sch->data + copied, todo);
    #####: 2849:            dch->used += todo;
    #####: 2850:            copied += todo;
    #####: 2851:            remain -= todo;
    #####: 2852:            assert(dch->used <= dch->size);
    #####: 2853:            if (dch->size == dch->used) {
    #####: 2854:                item_chunk *tch = do_item_alloc_chunk(dch, remain);
    #####: 2855:                if (tch) {
        -: 2856:                    dch = tch;
        -: 2857:                } else {
        -: 2858:                    return -1;
        -: 2859:                }
        -: 2860:            }
    #####: 2861:            assert(copied <= sch->used);
    #####: 2862:            if (copied == sch->used) {
    #####: 2863:                copied = 0;
    #####: 2864:                sch = sch->next;
        -: 2865:            }
        -: 2866:        }
        -: 2867:        /* assert that the destination had enough space for the source */
    #####: 2868:        assert(remain == 0);
        -: 2869:    } else {
        -: 2870:        int done = 0;
        -: 2871:        /* Fill dch's via a non-chunked item. */
    #####: 2872:        while (len > done && dch) {
    #####: 2873:            int todo = (dch->size - dch->used < len - done)
        -: 2874:                ? dch->size - dch->used : len - done;
        -: 2875:            //assert(dch->size - dch->used != 0);
    #####: 2876:            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
    #####: 2877:            done += todo;
    #####: 2878:            dch->used += todo;
    #####: 2879:            assert(dch->used <= dch->size);
    #####: 2880:            if (dch->size == dch->used) {
    #####: 2881:                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
    #####: 2882:                if (tch) {
        -: 2883:                    dch = tch;
        -: 2884:                } else {
        -: 2885:                    return -1;
        -: 2886:                }
        -: 2887:            }
        -: 2888:        }
    #####: 2889:        assert(len == done);
        -: 2890:    }
        -: 2891:    return 0;
        -: 2892:}
------------------
_store_item_copy_chunks:
    #####: 2824:static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    #####: 2825:    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
        -: 2826:    /* Advance dch until we find free space */
    #####: 2827:    while (dch->size == dch->used) {
    #####: 2828:        if (dch->next) {
        -: 2829:            dch = dch->next;
        -: 2830:        } else {
        -: 2831:            break;
        -: 2832:        }
        -: 2833:    }
        -: 2834:
    #####: 2835:    if (s_it->it_flags & ITEM_CHUNKED) {
    #####: 2836:        int remain = len;
    #####: 2837:        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
    #####: 2838:        int copied = 0;
        -: 2839:        /* Fills dch's to capacity, not straight copy sch in case data is
        -: 2840:         * being added or removed (ie append/prepend)
        -: 2841:         */
    #####: 2842:        while (sch && dch && remain) {
    #####: 2843:            assert(dch->used <= dch->size);
    #####: 2844:            int todo = (dch->size - dch->used < sch->used - copied)
        -: 2845:                ? dch->size - dch->used : sch->used - copied;
    #####: 2846:            if (remain < todo)
    #####: 2847:                todo = remain;
    #####: 2848:            memcpy(dch->data + dch->used, sch->data + copied, todo);
    #####: 2849:            dch->used += todo;
    #####: 2850:            copied += todo;
    #####: 2851:            remain -= todo;
    #####: 2852:            assert(dch->used <= dch->size);
    #####: 2853:            if (dch->size == dch->used) {
    #####: 2854:                item_chunk *tch = do_item_alloc_chunk(dch, remain);
    #####: 2855:                if (tch) {
        -: 2856:                    dch = tch;
        -: 2857:                } else {
        -: 2858:                    return -1;
        -: 2859:                }
        -: 2860:            }
    #####: 2861:            assert(copied <= sch->used);
    #####: 2862:            if (copied == sch->used) {
    #####: 2863:                copied = 0;
    #####: 2864:                sch = sch->next;
        -: 2865:            }
        -: 2866:        }
        -: 2867:        /* assert that the destination had enough space for the source */
    #####: 2868:        assert(remain == 0);
        -: 2869:    } else {
        -: 2870:        int done = 0;
        -: 2871:        /* Fill dch's via a non-chunked item. */
    #####: 2872:        while (len > done && dch) {
    #####: 2873:            int todo = (dch->size - dch->used < len - done)
        -: 2874:                ? dch->size - dch->used : len - done;
        -: 2875:            //assert(dch->size - dch->used != 0);
    #####: 2876:            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
    #####: 2877:            done += todo;
    #####: 2878:            dch->used += todo;
    #####: 2879:            assert(dch->used <= dch->size);
    #####: 2880:            if (dch->size == dch->used) {
    #####: 2881:                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
    #####: 2882:                if (tch) {
        -: 2883:                    dch = tch;
        -: 2884:                } else {
        -: 2885:                    return -1;
        -: 2886:                }
        -: 2887:            }
        -: 2888:        }
    #####: 2889:        assert(len == done);
        -: 2890:    }
        -: 2891:    return 0;
        -: 2892:}
------------------
_store_item_copy_chunks:
    #####: 2824:static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    #####: 2825:    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
        -: 2826:    /* Advance dch until we find free space */
    #####: 2827:    while (dch->size == dch->used) {
    #####: 2828:        if (dch->next) {
        -: 2829:            dch = dch->next;
        -: 2830:        } else {
        -: 2831:            break;
        -: 2832:        }
        -: 2833:    }
        -: 2834:
    #####: 2835:    if (s_it->it_flags & ITEM_CHUNKED) {
    #####: 2836:        int remain = len;
    #####: 2837:        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
    #####: 2838:        int copied = 0;
        -: 2839:        /* Fills dch's to capacity, not straight copy sch in case data is
        -: 2840:         * being added or removed (ie append/prepend)
        -: 2841:         */
    #####: 2842:        while (sch && dch && remain) {
    #####: 2843:            assert(dch->used <= dch->size);
    #####: 2844:            int todo = (dch->size - dch->used < sch->used - copied)
        -: 2845:                ? dch->size - dch->used : sch->used - copied;
    #####: 2846:            if (remain < todo)
    #####: 2847:                todo = remain;
    #####: 2848:            memcpy(dch->data + dch->used, sch->data + copied, todo);
    #####: 2849:            dch->used += todo;
    #####: 2850:            copied += todo;
    #####: 2851:            remain -= todo;
    #####: 2852:            assert(dch->used <= dch->size);
    #####: 2853:            if (dch->size == dch->used) {
    #####: 2854:                item_chunk *tch = do_item_alloc_chunk(dch, remain);
    #####: 2855:                if (tch) {
        -: 2856:                    dch = tch;
        -: 2857:                } else {
        -: 2858:                    return -1;
        -: 2859:                }
        -: 2860:            }
    #####: 2861:            assert(copied <= sch->used);
    #####: 2862:            if (copied == sch->used) {
    #####: 2863:                copied = 0;
    #####: 2864:                sch = sch->next;
        -: 2865:            }
        -: 2866:        }
        -: 2867:        /* assert that the destination had enough space for the source */
    #####: 2868:        assert(remain == 0);
        -: 2869:    } else {
        -: 2870:        int done = 0;
        -: 2871:        /* Fill dch's via a non-chunked item. */
    #####: 2872:        while (len > done && dch) {
    #####: 2873:            int todo = (dch->size - dch->used < len - done)
        -: 2874:                ? dch->size - dch->used : len - done;
        -: 2875:            //assert(dch->size - dch->used != 0);
    #####: 2876:            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
    #####: 2877:            done += todo;
    #####: 2878:            dch->used += todo;
    #####: 2879:            assert(dch->used <= dch->size);
    #####: 2880:            if (dch->size == dch->used) {
    #####: 2881:                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
    #####: 2882:                if (tch) {
        -: 2883:                    dch = tch;
        -: 2884:                } else {
        -: 2885:                    return -1;
        -: 2886:                }
        -: 2887:            }
        -: 2888:        }
    #####: 2889:        assert(len == done);
        -: 2890:    }
        -: 2891:    return 0;
        -: 2892:}
------------------
        -: 2893:
    #####: 2894:static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    #####: 2895:    if (comm == NREAD_APPEND) {
    #####: 2896:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2897:            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
    #####: 2898:                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
    #####: 2899:                return -1;
        -: 2900:            }
        -: 2901:        } else {
    #####: 2902:            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
    #####: 2903:            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        -: 2904:        }
        -: 2905:    } else {
        -: 2906:        /* NREAD_PREPEND */
    #####: 2907:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2908:            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
    #####: 2909:                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
    #####: 2910:                return -1;
        -: 2911:            }
        -: 2912:        } else {
    #####: 2913:            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
    #####: 2914:            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 2915:        }
        -: 2916:    }
        -: 2917:    return 0;
        -: 2918:}
------------------
_store_item_copy_data:
    #####: 2894:static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    #####: 2895:    if (comm == NREAD_APPEND) {
    #####: 2896:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2897:            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
    #####: 2898:                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
    #####: 2899:                return -1;
        -: 2900:            }
        -: 2901:        } else {
    #####: 2902:            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
    #####: 2903:            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        -: 2904:        }
        -: 2905:    } else {
        -: 2906:        /* NREAD_PREPEND */
    #####: 2907:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2908:            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
    #####: 2909:                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
    #####: 2910:                return -1;
        -: 2911:            }
        -: 2912:        } else {
    #####: 2913:            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
    #####: 2914:            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 2915:        }
        -: 2916:    }
        -: 2917:    return 0;
        -: 2918:}
------------------
_store_item_copy_data:
    #####: 2894:static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    #####: 2895:    if (comm == NREAD_APPEND) {
    #####: 2896:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2897:            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
    #####: 2898:                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
    #####: 2899:                return -1;
        -: 2900:            }
        -: 2901:        } else {
    #####: 2902:            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
    #####: 2903:            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        -: 2904:        }
        -: 2905:    } else {
        -: 2906:        /* NREAD_PREPEND */
    #####: 2907:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2908:            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
    #####: 2909:                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
    #####: 2910:                return -1;
        -: 2911:            }
        -: 2912:        } else {
    #####: 2913:            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
    #####: 2914:            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 2915:        }
        -: 2916:    }
        -: 2917:    return 0;
        -: 2918:}
------------------
_store_item_copy_data:
    #####: 2894:static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    #####: 2895:    if (comm == NREAD_APPEND) {
    #####: 2896:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2897:            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
    #####: 2898:                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
    #####: 2899:                return -1;
        -: 2900:            }
        -: 2901:        } else {
    #####: 2902:            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
    #####: 2903:            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        -: 2904:        }
        -: 2905:    } else {
        -: 2906:        /* NREAD_PREPEND */
    #####: 2907:        if (new_it->it_flags & ITEM_CHUNKED) {
    #####: 2908:            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
    #####: 2909:                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
    #####: 2910:                return -1;
        -: 2911:            }
        -: 2912:        } else {
    #####: 2913:            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
    #####: 2914:            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        -: 2915:        }
        -: 2916:    }
        -: 2917:    return 0;
        -: 2918:}
------------------
        -: 2919:
        -: 2920:/*
        -: 2921: * Stores an item in the cache according to the semantics of one of the set
        -: 2922: * commands. In threaded mode, this is protected by the cache lock.
        -: 2923: *
        -: 2924: * Returns the state of storage.
        -: 2925: */
    27600: 2926:enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
    27600: 2927:    char *key = ITEM_key(it);
    27600: 2928:    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
    27600: 2929:    enum store_item_type stored = NOT_STORED;
        -: 2930:
    27600: 2931:    item *new_it = NULL;
    27600: 2932:    uint32_t flags;
        -: 2933:
    27600: 2934:    if (old_it != NULL && comm == NREAD_ADD) {
        -: 2935:        /* add only adds a nonexistent item, but promote to head of LRU */
    #####: 2936:        do_item_update(old_it);
    27600: 2937:    } else if (!old_it && (comm == NREAD_REPLACE
      138: 2938:        || comm == NREAD_APPEND || comm == NREAD_PREPEND))
        -: 2939:    {
        -: 2940:        /* replace only replaces an existing value; don't store */
    27600: 2941:    } else if (comm == NREAD_CAS) {
        -: 2942:        /* validate cas operation */
    #####: 2943:        if(old_it == NULL) {
        -: 2944:            // LRU expired
    #####: 2945:            stored = NOT_FOUND;
    #####: 2946:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2947:            c->thread->stats.cas_misses++;
    #####: 2948:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2949:        }
    #####: 2950:        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
        -: 2951:            // cas validates
        -: 2952:            // it and old_it may belong to different classes.
        -: 2953:            // I'm updating the stats for the one that's getting pushed out
    #####: 2954:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2955:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
    #####: 2956:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2957:
    #####: 2958:            STORAGE_delete(c->thread->storage, old_it);
    #####: 2959:            item_replace(old_it, it, hv);
    #####: 2960:            stored = STORED;
        -: 2961:        } else {
    #####: 2962:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2963:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
    #####: 2964:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2965:
    #####: 2966:            if(settings.verbose > 1) {
    #####: 2967:                fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 2968:                        (unsigned long long)ITEM_get_cas(old_it),
    #####: 2969:                        (unsigned long long)ITEM_get_cas(it));
        -: 2970:            }
        -: 2971:            stored = EXISTS;
        -: 2972:        }
        -: 2973:    } else {
    27600: 2974:        int failed_alloc = 0;
        -: 2975:        /*
        -: 2976:         * Append - combine new and old record into single one. Here it's
        -: 2977:         * atomic and thread-safe.
        -: 2978:         */
    27600: 2979:        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
        -: 2980:            /*
        -: 2981:             * Validate CAS
        -: 2982:             */
    #####: 2983:            if (ITEM_get_cas(it) != 0) {
        -: 2984:                // CAS much be equal
    #####: 2985:                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
        -: 2986:                    stored = EXISTS;
        -: 2987:                }
        -: 2988:            }
        -: 2989:#ifdef EXTSTORE
        -: 2990:            if ((old_it->it_flags & ITEM_HDR) != 0) {
        -: 2991:                /* block append/prepend from working with extstore-d items.
        -: 2992:                 * also don't replace the header with the append chunk
        -: 2993:                 * accidentally, so mark as a failed_alloc.
        -: 2994:                 */
        -: 2995:                failed_alloc = 1;
        -: 2996:            } else
        -: 2997:#endif
        -: 2998:            if (stored == NOT_STORED) {
        -: 2999:                /* we have it and old_it here - alloc memory to hold both */
        -: 3000:                /* flags was already lost - so recover them from ITEM_suffix(it) */
    #####: 3001:                FLAGS_CONV(old_it, flags);
    #####: 3002:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);
        -: 3003:
        -: 3004:                /* copy data from it and old_it to new_it */
    #####: 3005:                if (new_it == NULL || _store_item_copy_data(comm, old_it, new_it, it) == -1) {
    #####: 3006:                    failed_alloc = 1;
    #####: 3007:                    stored = NOT_STORED;
        -: 3008:                    // failed data copy, free up.
    #####: 3009:                    if (new_it != NULL)
    #####: 3010:                        item_remove(new_it);
        -: 3011:                } else {
        -: 3012:                    it = new_it;
        -: 3013:                }
        -: 3014:            }
        -: 3015:        }
        -: 3016:
    27600: 3017:        if (stored == NOT_STORED && failed_alloc == 0) {
    27600: 3018:            if (old_it != NULL) {
    27462: 3019:                STORAGE_delete(c->thread->storage, old_it);
    27462: 3020:                item_replace(old_it, it, hv);
        -: 3021:            } else {
      138: 3022:                do_item_link(it, hv);
        -: 3023:            }
        -: 3024:
    27600: 3025:            c->cas = ITEM_get_cas(it);
        -: 3026:
    27600: 3027:            stored = STORED;
        -: 3028:        }
        -: 3029:    }
        -: 3030:
    27600: 3031:    if (old_it != NULL)
    27462: 3032:        do_item_remove(old_it);         /* release our reference */
    27600: 3033:    if (new_it != NULL)
    #####: 3034:        do_item_remove(new_it);
        -: 3035:
    27600: 3036:    if (stored == STORED) {
    27600: 3037:        c->cas = ITEM_get_cas(it);
        -: 3038:    }
   27600*: 3039:    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
        -: 3040:            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it));
        -: 3041:
    27600: 3042:    return stored;
        -: 3043:}
------------------
do_store_item:
     9200: 2926:enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
     9200: 2927:    char *key = ITEM_key(it);
     9200: 2928:    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
     9200: 2929:    enum store_item_type stored = NOT_STORED;
        -: 2930:
     9200: 2931:    item *new_it = NULL;
     9200: 2932:    uint32_t flags;
        -: 2933:
     9200: 2934:    if (old_it != NULL && comm == NREAD_ADD) {
        -: 2935:        /* add only adds a nonexistent item, but promote to head of LRU */
    #####: 2936:        do_item_update(old_it);
     9200: 2937:    } else if (!old_it && (comm == NREAD_REPLACE
       46: 2938:        || comm == NREAD_APPEND || comm == NREAD_PREPEND))
        -: 2939:    {
        -: 2940:        /* replace only replaces an existing value; don't store */
     9200: 2941:    } else if (comm == NREAD_CAS) {
        -: 2942:        /* validate cas operation */
    #####: 2943:        if(old_it == NULL) {
        -: 2944:            // LRU expired
    #####: 2945:            stored = NOT_FOUND;
    #####: 2946:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2947:            c->thread->stats.cas_misses++;
    #####: 2948:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2949:        }
    #####: 2950:        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
        -: 2951:            // cas validates
        -: 2952:            // it and old_it may belong to different classes.
        -: 2953:            // I'm updating the stats for the one that's getting pushed out
    #####: 2954:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2955:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
    #####: 2956:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2957:
    #####: 2958:            STORAGE_delete(c->thread->storage, old_it);
    #####: 2959:            item_replace(old_it, it, hv);
    #####: 2960:            stored = STORED;
        -: 2961:        } else {
    #####: 2962:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2963:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
    #####: 2964:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2965:
    #####: 2966:            if(settings.verbose > 1) {
    #####: 2967:                fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 2968:                        (unsigned long long)ITEM_get_cas(old_it),
    #####: 2969:                        (unsigned long long)ITEM_get_cas(it));
        -: 2970:            }
        -: 2971:            stored = EXISTS;
        -: 2972:        }
        -: 2973:    } else {
     9200: 2974:        int failed_alloc = 0;
        -: 2975:        /*
        -: 2976:         * Append - combine new and old record into single one. Here it's
        -: 2977:         * atomic and thread-safe.
        -: 2978:         */
     9200: 2979:        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
        -: 2980:            /*
        -: 2981:             * Validate CAS
        -: 2982:             */
    #####: 2983:            if (ITEM_get_cas(it) != 0) {
        -: 2984:                // CAS much be equal
    #####: 2985:                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
        -: 2986:                    stored = EXISTS;
        -: 2987:                }
        -: 2988:            }
        -: 2989:#ifdef EXTSTORE
        -: 2990:            if ((old_it->it_flags & ITEM_HDR) != 0) {
        -: 2991:                /* block append/prepend from working with extstore-d items.
        -: 2992:                 * also don't replace the header with the append chunk
        -: 2993:                 * accidentally, so mark as a failed_alloc.
        -: 2994:                 */
        -: 2995:                failed_alloc = 1;
        -: 2996:            } else
        -: 2997:#endif
        -: 2998:            if (stored == NOT_STORED) {
        -: 2999:                /* we have it and old_it here - alloc memory to hold both */
        -: 3000:                /* flags was already lost - so recover them from ITEM_suffix(it) */
    #####: 3001:                FLAGS_CONV(old_it, flags);
    #####: 3002:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);
        -: 3003:
        -: 3004:                /* copy data from it and old_it to new_it */
    #####: 3005:                if (new_it == NULL || _store_item_copy_data(comm, old_it, new_it, it) == -1) {
    #####: 3006:                    failed_alloc = 1;
    #####: 3007:                    stored = NOT_STORED;
        -: 3008:                    // failed data copy, free up.
    #####: 3009:                    if (new_it != NULL)
    #####: 3010:                        item_remove(new_it);
        -: 3011:                } else {
        -: 3012:                    it = new_it;
        -: 3013:                }
        -: 3014:            }
        -: 3015:        }
        -: 3016:
     9200: 3017:        if (stored == NOT_STORED && failed_alloc == 0) {
     9200: 3018:            if (old_it != NULL) {
     9154: 3019:                STORAGE_delete(c->thread->storage, old_it);
     9154: 3020:                item_replace(old_it, it, hv);
        -: 3021:            } else {
       46: 3022:                do_item_link(it, hv);
        -: 3023:            }
        -: 3024:
     9200: 3025:            c->cas = ITEM_get_cas(it);
        -: 3026:
     9200: 3027:            stored = STORED;
        -: 3028:        }
        -: 3029:    }
        -: 3030:
     9200: 3031:    if (old_it != NULL)
     9154: 3032:        do_item_remove(old_it);         /* release our reference */
     9200: 3033:    if (new_it != NULL)
    #####: 3034:        do_item_remove(new_it);
        -: 3035:
     9200: 3036:    if (stored == STORED) {
     9200: 3037:        c->cas = ITEM_get_cas(it);
        -: 3038:    }
    9200*: 3039:    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
        -: 3040:            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it));
        -: 3041:
     9200: 3042:    return stored;
        -: 3043:}
------------------
do_store_item:
     9200: 2926:enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
     9200: 2927:    char *key = ITEM_key(it);
     9200: 2928:    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
     9200: 2929:    enum store_item_type stored = NOT_STORED;
        -: 2930:
     9200: 2931:    item *new_it = NULL;
     9200: 2932:    uint32_t flags;
        -: 2933:
     9200: 2934:    if (old_it != NULL && comm == NREAD_ADD) {
        -: 2935:        /* add only adds a nonexistent item, but promote to head of LRU */
    #####: 2936:        do_item_update(old_it);
     9200: 2937:    } else if (!old_it && (comm == NREAD_REPLACE
       46: 2938:        || comm == NREAD_APPEND || comm == NREAD_PREPEND))
        -: 2939:    {
        -: 2940:        /* replace only replaces an existing value; don't store */
     9200: 2941:    } else if (comm == NREAD_CAS) {
        -: 2942:        /* validate cas operation */
    #####: 2943:        if(old_it == NULL) {
        -: 2944:            // LRU expired
    #####: 2945:            stored = NOT_FOUND;
    #####: 2946:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2947:            c->thread->stats.cas_misses++;
    #####: 2948:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2949:        }
    #####: 2950:        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
        -: 2951:            // cas validates
        -: 2952:            // it and old_it may belong to different classes.
        -: 2953:            // I'm updating the stats for the one that's getting pushed out
    #####: 2954:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2955:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
    #####: 2956:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2957:
    #####: 2958:            STORAGE_delete(c->thread->storage, old_it);
    #####: 2959:            item_replace(old_it, it, hv);
    #####: 2960:            stored = STORED;
        -: 2961:        } else {
    #####: 2962:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2963:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
    #####: 2964:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2965:
    #####: 2966:            if(settings.verbose > 1) {
    #####: 2967:                fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 2968:                        (unsigned long long)ITEM_get_cas(old_it),
    #####: 2969:                        (unsigned long long)ITEM_get_cas(it));
        -: 2970:            }
        -: 2971:            stored = EXISTS;
        -: 2972:        }
        -: 2973:    } else {
     9200: 2974:        int failed_alloc = 0;
        -: 2975:        /*
        -: 2976:         * Append - combine new and old record into single one. Here it's
        -: 2977:         * atomic and thread-safe.
        -: 2978:         */
     9200: 2979:        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
        -: 2980:            /*
        -: 2981:             * Validate CAS
        -: 2982:             */
    #####: 2983:            if (ITEM_get_cas(it) != 0) {
        -: 2984:                // CAS much be equal
    #####: 2985:                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
        -: 2986:                    stored = EXISTS;
        -: 2987:                }
        -: 2988:            }
        -: 2989:#ifdef EXTSTORE
        -: 2990:            if ((old_it->it_flags & ITEM_HDR) != 0) {
        -: 2991:                /* block append/prepend from working with extstore-d items.
        -: 2992:                 * also don't replace the header with the append chunk
        -: 2993:                 * accidentally, so mark as a failed_alloc.
        -: 2994:                 */
        -: 2995:                failed_alloc = 1;
        -: 2996:            } else
        -: 2997:#endif
        -: 2998:            if (stored == NOT_STORED) {
        -: 2999:                /* we have it and old_it here - alloc memory to hold both */
        -: 3000:                /* flags was already lost - so recover them from ITEM_suffix(it) */
    #####: 3001:                FLAGS_CONV(old_it, flags);
    #####: 3002:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);
        -: 3003:
        -: 3004:                /* copy data from it and old_it to new_it */
    #####: 3005:                if (new_it == NULL || _store_item_copy_data(comm, old_it, new_it, it) == -1) {
    #####: 3006:                    failed_alloc = 1;
    #####: 3007:                    stored = NOT_STORED;
        -: 3008:                    // failed data copy, free up.
    #####: 3009:                    if (new_it != NULL)
    #####: 3010:                        item_remove(new_it);
        -: 3011:                } else {
        -: 3012:                    it = new_it;
        -: 3013:                }
        -: 3014:            }
        -: 3015:        }
        -: 3016:
     9200: 3017:        if (stored == NOT_STORED && failed_alloc == 0) {
     9200: 3018:            if (old_it != NULL) {
     9154: 3019:                STORAGE_delete(c->thread->storage, old_it);
     9154: 3020:                item_replace(old_it, it, hv);
        -: 3021:            } else {
       46: 3022:                do_item_link(it, hv);
        -: 3023:            }
        -: 3024:
     9200: 3025:            c->cas = ITEM_get_cas(it);
        -: 3026:
     9200: 3027:            stored = STORED;
        -: 3028:        }
        -: 3029:    }
        -: 3030:
     9200: 3031:    if (old_it != NULL)
     9154: 3032:        do_item_remove(old_it);         /* release our reference */
     9200: 3033:    if (new_it != NULL)
    #####: 3034:        do_item_remove(new_it);
        -: 3035:
     9200: 3036:    if (stored == STORED) {
     9200: 3037:        c->cas = ITEM_get_cas(it);
        -: 3038:    }
    9200*: 3039:    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
        -: 3040:            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it));
        -: 3041:
     9200: 3042:    return stored;
        -: 3043:}
------------------
do_store_item:
     9200: 2926:enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
     9200: 2927:    char *key = ITEM_key(it);
     9200: 2928:    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
     9200: 2929:    enum store_item_type stored = NOT_STORED;
        -: 2930:
     9200: 2931:    item *new_it = NULL;
     9200: 2932:    uint32_t flags;
        -: 2933:
     9200: 2934:    if (old_it != NULL && comm == NREAD_ADD) {
        -: 2935:        /* add only adds a nonexistent item, but promote to head of LRU */
    #####: 2936:        do_item_update(old_it);
     9200: 2937:    } else if (!old_it && (comm == NREAD_REPLACE
       46: 2938:        || comm == NREAD_APPEND || comm == NREAD_PREPEND))
        -: 2939:    {
        -: 2940:        /* replace only replaces an existing value; don't store */
     9200: 2941:    } else if (comm == NREAD_CAS) {
        -: 2942:        /* validate cas operation */
    #####: 2943:        if(old_it == NULL) {
        -: 2944:            // LRU expired
    #####: 2945:            stored = NOT_FOUND;
    #####: 2946:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2947:            c->thread->stats.cas_misses++;
    #####: 2948:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2949:        }
    #####: 2950:        else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
        -: 2951:            // cas validates
        -: 2952:            // it and old_it may belong to different classes.
        -: 2953:            // I'm updating the stats for the one that's getting pushed out
    #####: 2954:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2955:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
    #####: 2956:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2957:
    #####: 2958:            STORAGE_delete(c->thread->storage, old_it);
    #####: 2959:            item_replace(old_it, it, hv);
    #####: 2960:            stored = STORED;
        -: 2961:        } else {
    #####: 2962:            pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 2963:            c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
    #####: 2964:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 2965:
    #####: 2966:            if(settings.verbose > 1) {
    #####: 2967:                fprintf(stderr, "CAS:  failure: expected %llu, got %llu\n",
    #####: 2968:                        (unsigned long long)ITEM_get_cas(old_it),
    #####: 2969:                        (unsigned long long)ITEM_get_cas(it));
        -: 2970:            }
        -: 2971:            stored = EXISTS;
        -: 2972:        }
        -: 2973:    } else {
     9200: 2974:        int failed_alloc = 0;
        -: 2975:        /*
        -: 2976:         * Append - combine new and old record into single one. Here it's
        -: 2977:         * atomic and thread-safe.
        -: 2978:         */
     9200: 2979:        if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
        -: 2980:            /*
        -: 2981:             * Validate CAS
        -: 2982:             */
    #####: 2983:            if (ITEM_get_cas(it) != 0) {
        -: 2984:                // CAS much be equal
    #####: 2985:                if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
        -: 2986:                    stored = EXISTS;
        -: 2987:                }
        -: 2988:            }
        -: 2989:#ifdef EXTSTORE
        -: 2990:            if ((old_it->it_flags & ITEM_HDR) != 0) {
        -: 2991:                /* block append/prepend from working with extstore-d items.
        -: 2992:                 * also don't replace the header with the append chunk
        -: 2993:                 * accidentally, so mark as a failed_alloc.
        -: 2994:                 */
        -: 2995:                failed_alloc = 1;
        -: 2996:            } else
        -: 2997:#endif
        -: 2998:            if (stored == NOT_STORED) {
        -: 2999:                /* we have it and old_it here - alloc memory to hold both */
        -: 3000:                /* flags was already lost - so recover them from ITEM_suffix(it) */
    #####: 3001:                FLAGS_CONV(old_it, flags);
    #####: 3002:                new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */);
        -: 3003:
        -: 3004:                /* copy data from it and old_it to new_it */
    #####: 3005:                if (new_it == NULL || _store_item_copy_data(comm, old_it, new_it, it) == -1) {
    #####: 3006:                    failed_alloc = 1;
    #####: 3007:                    stored = NOT_STORED;
        -: 3008:                    // failed data copy, free up.
    #####: 3009:                    if (new_it != NULL)
    #####: 3010:                        item_remove(new_it);
        -: 3011:                } else {
        -: 3012:                    it = new_it;
        -: 3013:                }
        -: 3014:            }
        -: 3015:        }
        -: 3016:
     9200: 3017:        if (stored == NOT_STORED && failed_alloc == 0) {
     9200: 3018:            if (old_it != NULL) {
     9154: 3019:                STORAGE_delete(c->thread->storage, old_it);
     9154: 3020:                item_replace(old_it, it, hv);
        -: 3021:            } else {
       46: 3022:                do_item_link(it, hv);
        -: 3023:            }
        -: 3024:
     9200: 3025:            c->cas = ITEM_get_cas(it);
        -: 3026:
     9200: 3027:            stored = STORED;
        -: 3028:        }
        -: 3029:    }
        -: 3030:
     9200: 3031:    if (old_it != NULL)
     9154: 3032:        do_item_remove(old_it);         /* release our reference */
     9200: 3033:    if (new_it != NULL)
    #####: 3034:        do_item_remove(new_it);
        -: 3035:
     9200: 3036:    if (stored == STORED) {
     9200: 3037:        c->cas = ITEM_get_cas(it);
        -: 3038:    }
    9200*: 3039:    LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
        -: 3040:            stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it));
        -: 3041:
     9200: 3042:    return stored;
        -: 3043:}
------------------
        -: 3044:
        -: 3045:typedef struct token_s {
        -: 3046:    char *value;
        -: 3047:    size_t length;
        -: 3048:} token_t;
        -: 3049:
        -: 3050:#define COMMAND_TOKEN 0
        -: 3051:#define SUBCOMMAND_TOKEN 1
        -: 3052:#define KEY_TOKEN 1
        -: 3053:
        -: 3054:#define MAX_TOKENS 8
        -: 3055:
        -: 3056:/*
        -: 3057: * Tokenize the command string by replacing whitespace with '\0' and update
        -: 3058: * the token array tokens with pointer to start of each token and length.
        -: 3059: * Returns total number of tokens.  The last valid token is the terminal
        -: 3060: * token (value points to the first unprocessed character of the string and
        -: 3061: * length zero).
        -: 3062: *
        -: 3063: * Usage example:
        -: 3064: *
        -: 3065: *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {
        -: 3066: *      for(int ix = 0; tokens[ix].length != 0; ix++) {
        -: 3067: *          ...
        -: 3068: *      }
        -: 3069: *      ncommand = tokens[ix].value - command;
        -: 3070: *      command  = tokens[ix].value;
        -: 3071: *   }
        -: 3072: */
    #####: 3073:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
    #####: 3074:    char *s, *e;
    #####: 3075:    size_t ntokens = 0;
    #####: 3076:    size_t len = strlen(command);
    #####: 3077:    unsigned int i = 0;
        -: 3078:
    #####: 3079:    assert(command != NULL && tokens != NULL && max_tokens > 1);
        -: 3080:
        -: 3081:    s = e = command;
    #####: 3082:    for (i = 0; i < len; i++) {
    #####: 3083:        if (*e == ' ') {
    #####: 3084:            if (s != e) {
    #####: 3085:                tokens[ntokens].value = s;
    #####: 3086:                tokens[ntokens].length = e - s;
    #####: 3087:                ntokens++;
    #####: 3088:                *e = '\0';
    #####: 3089:                if (ntokens == max_tokens - 1) {
    #####: 3090:                    e++;
    #####: 3091:                    s = e; /* so we don't add an extra token */
    #####: 3092:                    break;
        -: 3093:                }
        -: 3094:            }
    #####: 3095:            s = e + 1;
        -: 3096:        }
    #####: 3097:        e++;
        -: 3098:    }
        -: 3099:
    #####: 3100:    if (s != e) {
    #####: 3101:        tokens[ntokens].value = s;
    #####: 3102:        tokens[ntokens].length = e - s;
    #####: 3103:        ntokens++;
        -: 3104:    }
        -: 3105:
        -: 3106:    /*
        -: 3107:     * If we scanned the whole string, the terminal value pointer is null,
        -: 3108:     * otherwise it is the first unprocessed character.
        -: 3109:     */
    #####: 3110:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
    #####: 3111:    tokens[ntokens].length = 0;
    #####: 3112:    ntokens++;
        -: 3113:
    #####: 3114:    return ntokens;
        -: 3115:}
------------------
tokenize_command:
    #####: 3073:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
    #####: 3074:    char *s, *e;
    #####: 3075:    size_t ntokens = 0;
    #####: 3076:    size_t len = strlen(command);
    #####: 3077:    unsigned int i = 0;
        -: 3078:
    #####: 3079:    assert(command != NULL && tokens != NULL && max_tokens > 1);
        -: 3080:
        -: 3081:    s = e = command;
    #####: 3082:    for (i = 0; i < len; i++) {
    #####: 3083:        if (*e == ' ') {
    #####: 3084:            if (s != e) {
    #####: 3085:                tokens[ntokens].value = s;
    #####: 3086:                tokens[ntokens].length = e - s;
    #####: 3087:                ntokens++;
    #####: 3088:                *e = '\0';
    #####: 3089:                if (ntokens == max_tokens - 1) {
    #####: 3090:                    e++;
    #####: 3091:                    s = e; /* so we don't add an extra token */
    #####: 3092:                    break;
        -: 3093:                }
        -: 3094:            }
    #####: 3095:            s = e + 1;
        -: 3096:        }
    #####: 3097:        e++;
        -: 3098:    }
        -: 3099:
    #####: 3100:    if (s != e) {
    #####: 3101:        tokens[ntokens].value = s;
    #####: 3102:        tokens[ntokens].length = e - s;
    #####: 3103:        ntokens++;
        -: 3104:    }
        -: 3105:
        -: 3106:    /*
        -: 3107:     * If we scanned the whole string, the terminal value pointer is null,
        -: 3108:     * otherwise it is the first unprocessed character.
        -: 3109:     */
    #####: 3110:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
    #####: 3111:    tokens[ntokens].length = 0;
    #####: 3112:    ntokens++;
        -: 3113:
    #####: 3114:    return ntokens;
        -: 3115:}
------------------
tokenize_command:
    #####: 3073:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
    #####: 3074:    char *s, *e;
    #####: 3075:    size_t ntokens = 0;
    #####: 3076:    size_t len = strlen(command);
    #####: 3077:    unsigned int i = 0;
        -: 3078:
    #####: 3079:    assert(command != NULL && tokens != NULL && max_tokens > 1);
        -: 3080:
        -: 3081:    s = e = command;
    #####: 3082:    for (i = 0; i < len; i++) {
    #####: 3083:        if (*e == ' ') {
    #####: 3084:            if (s != e) {
    #####: 3085:                tokens[ntokens].value = s;
    #####: 3086:                tokens[ntokens].length = e - s;
    #####: 3087:                ntokens++;
    #####: 3088:                *e = '\0';
    #####: 3089:                if (ntokens == max_tokens - 1) {
    #####: 3090:                    e++;
    #####: 3091:                    s = e; /* so we don't add an extra token */
    #####: 3092:                    break;
        -: 3093:                }
        -: 3094:            }
    #####: 3095:            s = e + 1;
        -: 3096:        }
    #####: 3097:        e++;
        -: 3098:    }
        -: 3099:
    #####: 3100:    if (s != e) {
    #####: 3101:        tokens[ntokens].value = s;
    #####: 3102:        tokens[ntokens].length = e - s;
    #####: 3103:        ntokens++;
        -: 3104:    }
        -: 3105:
        -: 3106:    /*
        -: 3107:     * If we scanned the whole string, the terminal value pointer is null,
        -: 3108:     * otherwise it is the first unprocessed character.
        -: 3109:     */
    #####: 3110:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
    #####: 3111:    tokens[ntokens].length = 0;
    #####: 3112:    ntokens++;
        -: 3113:
    #####: 3114:    return ntokens;
        -: 3115:}
------------------
tokenize_command:
    #####: 3073:static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
    #####: 3074:    char *s, *e;
    #####: 3075:    size_t ntokens = 0;
    #####: 3076:    size_t len = strlen(command);
    #####: 3077:    unsigned int i = 0;
        -: 3078:
    #####: 3079:    assert(command != NULL && tokens != NULL && max_tokens > 1);
        -: 3080:
        -: 3081:    s = e = command;
    #####: 3082:    for (i = 0; i < len; i++) {
    #####: 3083:        if (*e == ' ') {
    #####: 3084:            if (s != e) {
    #####: 3085:                tokens[ntokens].value = s;
    #####: 3086:                tokens[ntokens].length = e - s;
    #####: 3087:                ntokens++;
    #####: 3088:                *e = '\0';
    #####: 3089:                if (ntokens == max_tokens - 1) {
    #####: 3090:                    e++;
    #####: 3091:                    s = e; /* so we don't add an extra token */
    #####: 3092:                    break;
        -: 3093:                }
        -: 3094:            }
    #####: 3095:            s = e + 1;
        -: 3096:        }
    #####: 3097:        e++;
        -: 3098:    }
        -: 3099:
    #####: 3100:    if (s != e) {
    #####: 3101:        tokens[ntokens].value = s;
    #####: 3102:        tokens[ntokens].length = e - s;
    #####: 3103:        ntokens++;
        -: 3104:    }
        -: 3105:
        -: 3106:    /*
        -: 3107:     * If we scanned the whole string, the terminal value pointer is null,
        -: 3108:     * otherwise it is the first unprocessed character.
        -: 3109:     */
    #####: 3110:    tokens[ntokens].value =  *e == '\0' ? NULL : e;
    #####: 3111:    tokens[ntokens].length = 0;
    #####: 3112:    ntokens++;
        -: 3113:
    #####: 3114:    return ntokens;
        -: 3115:}
------------------
        -: 3116:
        -: 3117:/* set up a connection to write a buffer then free it, used for stats */
    #####: 3118:static void write_and_free(conn *c, char *buf, int bytes) {
    #####: 3119:    if (buf) {
    #####: 3120:        c->write_and_free = buf;
    #####: 3121:        c->wcurr = buf;
    #####: 3122:        c->wbytes = bytes;
    #####: 3123:        conn_set_state(c, conn_write);
    #####: 3124:        c->write_and_go = conn_new_cmd;
        -: 3125:    } else {
    #####: 3126:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3127:    }
    #####: 3128:}
------------------
write_and_free:
    #####: 3118:static void write_and_free(conn *c, char *buf, int bytes) {
    #####: 3119:    if (buf) {
    #####: 3120:        c->write_and_free = buf;
    #####: 3121:        c->wcurr = buf;
    #####: 3122:        c->wbytes = bytes;
    #####: 3123:        conn_set_state(c, conn_write);
    #####: 3124:        c->write_and_go = conn_new_cmd;
        -: 3125:    } else {
    #####: 3126:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3127:    }
    #####: 3128:}
------------------
write_and_free:
    #####: 3118:static void write_and_free(conn *c, char *buf, int bytes) {
    #####: 3119:    if (buf) {
    #####: 3120:        c->write_and_free = buf;
    #####: 3121:        c->wcurr = buf;
    #####: 3122:        c->wbytes = bytes;
    #####: 3123:        conn_set_state(c, conn_write);
    #####: 3124:        c->write_and_go = conn_new_cmd;
        -: 3125:    } else {
    #####: 3126:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3127:    }
    #####: 3128:}
------------------
write_and_free:
    #####: 3118:static void write_and_free(conn *c, char *buf, int bytes) {
    #####: 3119:    if (buf) {
    #####: 3120:        c->write_and_free = buf;
    #####: 3121:        c->wcurr = buf;
    #####: 3122:        c->wbytes = bytes;
    #####: 3123:        conn_set_state(c, conn_write);
    #####: 3124:        c->write_and_go = conn_new_cmd;
        -: 3125:    } else {
    #####: 3126:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3127:    }
    #####: 3128:}
------------------
        -: 3129:
    #####: 3130:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -: 3131:{
    #####: 3132:    int noreply_index = ntokens - 2;
        -: 3133:
        -: 3134:    /*
        -: 3135:      NOTE: this function is not the first place where we are going to
        -: 3136:      send the reply.  We could send it instead from process_command()
        -: 3137:      if the request line has wrong number of tokens.  However parsing
        -: 3138:      malformed line for "noreply" option is not reliable anyway, so
        -: 3139:      it can't be helped.
        -: 3140:    */
    #####: 3141:    if (tokens[noreply_index].value
    #####: 3142:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
    #####: 3143:        c->noreply = true;
        -: 3144:    }
    #####: 3145:    return c->noreply;
        -: 3146:}
------------------
set_noreply_maybe:
    #####: 3130:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -: 3131:{
    #####: 3132:    int noreply_index = ntokens - 2;
        -: 3133:
        -: 3134:    /*
        -: 3135:      NOTE: this function is not the first place where we are going to
        -: 3136:      send the reply.  We could send it instead from process_command()
        -: 3137:      if the request line has wrong number of tokens.  However parsing
        -: 3138:      malformed line for "noreply" option is not reliable anyway, so
        -: 3139:      it can't be helped.
        -: 3140:    */
    #####: 3141:    if (tokens[noreply_index].value
    #####: 3142:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
    #####: 3143:        c->noreply = true;
        -: 3144:    }
    #####: 3145:    return c->noreply;
        -: 3146:}
------------------
set_noreply_maybe:
    #####: 3130:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -: 3131:{
    #####: 3132:    int noreply_index = ntokens - 2;
        -: 3133:
        -: 3134:    /*
        -: 3135:      NOTE: this function is not the first place where we are going to
        -: 3136:      send the reply.  We could send it instead from process_command()
        -: 3137:      if the request line has wrong number of tokens.  However parsing
        -: 3138:      malformed line for "noreply" option is not reliable anyway, so
        -: 3139:      it can't be helped.
        -: 3140:    */
    #####: 3141:    if (tokens[noreply_index].value
    #####: 3142:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
    #####: 3143:        c->noreply = true;
        -: 3144:    }
    #####: 3145:    return c->noreply;
        -: 3146:}
------------------
set_noreply_maybe:
    #####: 3130:static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
        -: 3131:{
    #####: 3132:    int noreply_index = ntokens - 2;
        -: 3133:
        -: 3134:    /*
        -: 3135:      NOTE: this function is not the first place where we are going to
        -: 3136:      send the reply.  We could send it instead from process_command()
        -: 3137:      if the request line has wrong number of tokens.  However parsing
        -: 3138:      malformed line for "noreply" option is not reliable anyway, so
        -: 3139:      it can't be helped.
        -: 3140:    */
    #####: 3141:    if (tokens[noreply_index].value
    #####: 3142:        && strcmp(tokens[noreply_index].value, "noreply") == 0) {
    #####: 3143:        c->noreply = true;
        -: 3144:    }
    #####: 3145:    return c->noreply;
        -: 3146:}
------------------
        -: 3147:
    #####: 3148:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 3149:                 const char *fmt, ...) {
    #####: 3150:    char val_str[STAT_VAL_LEN];
    #####: 3151:    int vlen;
    #####: 3152:    va_list ap;
        -: 3153:
    #####: 3154:    assert(name);
    #####: 3155:    assert(add_stats);
    #####: 3156:    assert(c);
    #####: 3157:    assert(fmt);
        -: 3158:
    #####: 3159:    va_start(ap, fmt);
    #####: 3160:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    #####: 3161:    va_end(ap);
        -: 3162:
    #####: 3163:    add_stats(name, strlen(name), val_str, vlen, c);
    #####: 3164:}
------------------
append_stat:
    #####: 3148:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 3149:                 const char *fmt, ...) {
    #####: 3150:    char val_str[STAT_VAL_LEN];
    #####: 3151:    int vlen;
    #####: 3152:    va_list ap;
        -: 3153:
    #####: 3154:    assert(name);
    #####: 3155:    assert(add_stats);
    #####: 3156:    assert(c);
    #####: 3157:    assert(fmt);
        -: 3158:
    #####: 3159:    va_start(ap, fmt);
    #####: 3160:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    #####: 3161:    va_end(ap);
        -: 3162:
    #####: 3163:    add_stats(name, strlen(name), val_str, vlen, c);
    #####: 3164:}
------------------
append_stat:
    #####: 3148:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 3149:                 const char *fmt, ...) {
    #####: 3150:    char val_str[STAT_VAL_LEN];
    #####: 3151:    int vlen;
    #####: 3152:    va_list ap;
        -: 3153:
    #####: 3154:    assert(name);
    #####: 3155:    assert(add_stats);
    #####: 3156:    assert(c);
    #####: 3157:    assert(fmt);
        -: 3158:
    #####: 3159:    va_start(ap, fmt);
    #####: 3160:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    #####: 3161:    va_end(ap);
        -: 3162:
    #####: 3163:    add_stats(name, strlen(name), val_str, vlen, c);
    #####: 3164:}
------------------
append_stat:
    #####: 3148:void append_stat(const char *name, ADD_STAT add_stats, conn *c,
        -: 3149:                 const char *fmt, ...) {
    #####: 3150:    char val_str[STAT_VAL_LEN];
    #####: 3151:    int vlen;
    #####: 3152:    va_list ap;
        -: 3153:
    #####: 3154:    assert(name);
    #####: 3155:    assert(add_stats);
    #####: 3156:    assert(c);
    #####: 3157:    assert(fmt);
        -: 3158:
    #####: 3159:    va_start(ap, fmt);
    #####: 3160:    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    #####: 3161:    va_end(ap);
        -: 3162:
    #####: 3163:    add_stats(name, strlen(name), val_str, vlen, c);
    #####: 3164:}
------------------
        -: 3165:
    #####: 3166:inline static void process_stats_detail(conn *c, const char *command) {
    #####: 3167:    assert(c != NULL);
        -: 3168:
    #####: 3169:    if (strcmp(command, "on") == 0) {
    #####: 3170:        settings.detail_enabled = 1;
    #####: 3171:        out_string(c, "OK");
        -: 3172:    }
    #####: 3173:    else if (strcmp(command, "off") == 0) {
    #####: 3174:        settings.detail_enabled = 0;
    #####: 3175:        out_string(c, "OK");
        -: 3176:    }
    #####: 3177:    else if (strcmp(command, "dump") == 0) {
    #####: 3178:        int len;
    #####: 3179:        char *stats = stats_prefix_dump(&len);
    #####: 3180:        write_and_free(c, stats, len);
        -: 3181:    }
        -: 3182:    else {
    #####: 3183:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -: 3184:    }
    #####: 3185:}
------------------
process_stats_detail:
    #####: 3166:inline static void process_stats_detail(conn *c, const char *command) {
    #####: 3167:    assert(c != NULL);
        -: 3168:
    #####: 3169:    if (strcmp(command, "on") == 0) {
    #####: 3170:        settings.detail_enabled = 1;
    #####: 3171:        out_string(c, "OK");
        -: 3172:    }
    #####: 3173:    else if (strcmp(command, "off") == 0) {
    #####: 3174:        settings.detail_enabled = 0;
    #####: 3175:        out_string(c, "OK");
        -: 3176:    }
    #####: 3177:    else if (strcmp(command, "dump") == 0) {
    #####: 3178:        int len;
    #####: 3179:        char *stats = stats_prefix_dump(&len);
    #####: 3180:        write_and_free(c, stats, len);
        -: 3181:    }
        -: 3182:    else {
    #####: 3183:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -: 3184:    }
    #####: 3185:}
------------------
process_stats_detail:
    #####: 3166:inline static void process_stats_detail(conn *c, const char *command) {
    #####: 3167:    assert(c != NULL);
        -: 3168:
    #####: 3169:    if (strcmp(command, "on") == 0) {
    #####: 3170:        settings.detail_enabled = 1;
    #####: 3171:        out_string(c, "OK");
        -: 3172:    }
    #####: 3173:    else if (strcmp(command, "off") == 0) {
    #####: 3174:        settings.detail_enabled = 0;
    #####: 3175:        out_string(c, "OK");
        -: 3176:    }
    #####: 3177:    else if (strcmp(command, "dump") == 0) {
    #####: 3178:        int len;
    #####: 3179:        char *stats = stats_prefix_dump(&len);
    #####: 3180:        write_and_free(c, stats, len);
        -: 3181:    }
        -: 3182:    else {
    #####: 3183:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -: 3184:    }
    #####: 3185:}
------------------
process_stats_detail:
    #####: 3166:inline static void process_stats_detail(conn *c, const char *command) {
    #####: 3167:    assert(c != NULL);
        -: 3168:
    #####: 3169:    if (strcmp(command, "on") == 0) {
    #####: 3170:        settings.detail_enabled = 1;
    #####: 3171:        out_string(c, "OK");
        -: 3172:    }
    #####: 3173:    else if (strcmp(command, "off") == 0) {
    #####: 3174:        settings.detail_enabled = 0;
    #####: 3175:        out_string(c, "OK");
        -: 3176:    }
    #####: 3177:    else if (strcmp(command, "dump") == 0) {
    #####: 3178:        int len;
    #####: 3179:        char *stats = stats_prefix_dump(&len);
    #####: 3180:        write_and_free(c, stats, len);
        -: 3181:    }
        -: 3182:    else {
    #####: 3183:        out_string(c, "CLIENT_ERROR usage: stats detail on|off|dump");
        -: 3184:    }
    #####: 3185:}
------------------
        -: 3186:
        -: 3187:/* return server specific stats only */
    #####: 3188:static void server_stats(ADD_STAT add_stats, conn *c) {
    #####: 3189:    pid_t pid = getpid();
    #####: 3190:    rel_time_t now = current_time;
        -: 3191:
    #####: 3192:    struct thread_stats thread_stats;
    #####: 3193:    threadlocal_stats_aggregate(&thread_stats);
    #####: 3194:    struct slab_stats slab_stats;
    #####: 3195:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 3196:#ifdef EXTSTORE
        -: 3197:    struct extstore_stats st;
        -: 3198:#endif
        -: 3199:#ifndef WIN32
    #####: 3200:    struct rusage usage;
    #####: 3201:    getrusage(RUSAGE_SELF, &usage);
        -: 3202:#endif /* !WIN32 */
        -: 3203:
    #####: 3204:    STATS_LOCK();
        -: 3205:
    #####: 3206:    APPEND_STAT("pid", "%lu", (long)pid);
    #####: 3207:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
    #####: 3208:    APPEND_STAT("time", "%ld", now + (long)process_started);
    #####: 3209:    APPEND_STAT("version", "%s", VERSION);
    #####: 3210:    APPEND_STAT("libevent", "%s", event_get_version());
    #####: 3211:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 3212:
        -: 3213:#ifndef WIN32
    #####: 3214:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
    #####: 3215:                (long)usage.ru_utime.tv_sec,
    #####: 3216:                (long)usage.ru_utime.tv_usec);
    #####: 3217:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
    #####: 3218:                (long)usage.ru_stime.tv_sec,
    #####: 3219:                (long)usage.ru_stime.tv_usec);
        -: 3220:#endif /* !WIN32 */
        -: 3221:
    #####: 3222:    APPEND_STAT("max_connections", "%d", settings.maxconns);
    #####: 3223:    APPEND_STAT("curr_connections", "%llu", (unsigned long long)stats_state.curr_conns - 1);
    #####: 3224:    APPEND_STAT("total_connections", "%llu", (unsigned long long)stats.total_conns);
    #####: 3225:    if (settings.maxconns_fast) {
    #####: 3226:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 3227:    }
    #####: 3228:    APPEND_STAT("connection_structures", "%u", stats_state.conn_structs);
    #####: 3229:    APPEND_STAT("reserved_fds", "%u", stats_state.reserved_fds);
    #####: 3230:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
    #####: 3231:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
    #####: 3232:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
    #####: 3233:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
    #####: 3234:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
    #####: 3235:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
    #####: 3236:    APPEND_STAT("get_expired", "%llu", (unsigned long long)thread_stats.get_expired);
    #####: 3237:    APPEND_STAT("get_flushed", "%llu", (unsigned long long)thread_stats.get_flushed);
        -: 3238:#ifdef EXTSTORE
        -: 3239:    if (c->thread->storage) {
        -: 3240:        APPEND_STAT("get_extstore", "%llu", (unsigned long long)thread_stats.get_extstore);
        -: 3241:        APPEND_STAT("get_aborted_extstore", "%llu", (unsigned long long)thread_stats.get_aborted_extstore);
        -: 3242:        APPEND_STAT("get_oom_extstore", "%llu", (unsigned long long)thread_stats.get_oom_extstore);
        -: 3243:        APPEND_STAT("recache_from_extstore", "%llu", (unsigned long long)thread_stats.recache_from_extstore);
        -: 3244:        APPEND_STAT("miss_from_extstore", "%llu", (unsigned long long)thread_stats.miss_from_extstore);
        -: 3245:        APPEND_STAT("badcrc_from_extstore", "%llu", (unsigned long long)thread_stats.badcrc_from_extstore);
        -: 3246:    }
        -: 3247:#endif
    #####: 3248:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
    #####: 3249:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
    #####: 3250:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
    #####: 3251:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
    #####: 3252:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
    #####: 3253:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
    #####: 3254:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
    #####: 3255:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
    #####: 3256:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
    #####: 3257:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
    #####: 3258:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
    #####: 3259:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
    #####: 3260:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
    #####: 3261:    if (settings.idle_timeout) {
    #####: 3262:        APPEND_STAT("idle_kicks", "%llu", (unsigned long long)thread_stats.idle_kicks);
        -: 3263:    }
    #####: 3264:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
    #####: 3265:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
    #####: 3266:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3267:    APPEND_STAT("accepting_conns", "%u", stats_state.accepting_conns);
    #####: 3268:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
    #####: 3269:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
    #####: 3270:    APPEND_STAT("threads", "%d", settings.num_threads);
    #####: 3271:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
    #####: 3272:    APPEND_STAT("hash_power_level", "%u", stats_state.hash_power_level);
    #####: 3273:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats_state.hash_bytes);
    #####: 3274:    APPEND_STAT("hash_is_expanding", "%u", stats_state.hash_is_expanding);
    #####: 3275:    if (settings.slab_reassign) {
    #####: 3276:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
    #####: 3277:        APPEND_STAT("slab_reassign_chunk_rescues", "%llu", stats.slab_reassign_chunk_rescues);
    #####: 3278:        APPEND_STAT("slab_reassign_evictions_nomem", "%llu", stats.slab_reassign_evictions_nomem);
    #####: 3279:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
    #####: 3280:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
    #####: 3281:        APPEND_STAT("slab_reassign_busy_deletes", "%llu", stats.slab_reassign_busy_deletes);
    #####: 3282:        APPEND_STAT("slab_reassign_running", "%u", stats_state.slab_reassign_running);
    #####: 3283:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 3284:    }
    #####: 3285:    if (settings.lru_crawler) {
    #####: 3286:        APPEND_STAT("lru_crawler_running", "%u", stats_state.lru_crawler_running);
    #####: 3287:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 3288:    }
    #####: 3289:    if (settings.lru_maintainer_thread) {
    #####: 3290:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 3291:    }
    #####: 3292:    APPEND_STAT("malloc_fails", "%llu",
    #####: 3293:                (unsigned long long)stats.malloc_fails);
    #####: 3294:    APPEND_STAT("log_worker_dropped", "%llu", (unsigned long long)stats.log_worker_dropped);
    #####: 3295:    APPEND_STAT("log_worker_written", "%llu", (unsigned long long)stats.log_worker_written);
    #####: 3296:    APPEND_STAT("log_watcher_skipped", "%llu", (unsigned long long)stats.log_watcher_skipped);
    #####: 3297:    APPEND_STAT("log_watcher_sent", "%llu", (unsigned long long)stats.log_watcher_sent);
    #####: 3298:    STATS_UNLOCK();
        -: 3299:#ifdef EXTSTORE
        -: 3300:    if (c->thread->storage) {
        -: 3301:        STATS_LOCK();
        -: 3302:        APPEND_STAT("extstore_compact_lost", "%llu", (unsigned long long)stats.extstore_compact_lost);
        -: 3303:        APPEND_STAT("extstore_compact_rescues", "%llu", (unsigned long long)stats.extstore_compact_rescues);
        -: 3304:        APPEND_STAT("extstore_compact_skipped", "%llu", (unsigned long long)stats.extstore_compact_skipped);
        -: 3305:        STATS_UNLOCK();
        -: 3306:        extstore_get_stats(c->thread->storage, &st);
        -: 3307:        APPEND_STAT("extstore_page_allocs", "%llu", (unsigned long long)st.page_allocs);
        -: 3308:        APPEND_STAT("extstore_page_evictions", "%llu", (unsigned long long)st.page_evictions);
        -: 3309:        APPEND_STAT("extstore_page_reclaims", "%llu", (unsigned long long)st.page_reclaims);
        -: 3310:        APPEND_STAT("extstore_pages_free", "%llu", (unsigned long long)st.pages_free);
        -: 3311:        APPEND_STAT("extstore_pages_used", "%llu", (unsigned long long)st.pages_used);
        -: 3312:        APPEND_STAT("extstore_objects_evicted", "%llu", (unsigned long long)st.objects_evicted);
        -: 3313:        APPEND_STAT("extstore_objects_read", "%llu", (unsigned long long)st.objects_read);
        -: 3314:        APPEND_STAT("extstore_objects_written", "%llu", (unsigned long long)st.objects_written);
        -: 3315:        APPEND_STAT("extstore_objects_used", "%llu", (unsigned long long)st.objects_used);
        -: 3316:        APPEND_STAT("extstore_bytes_evicted", "%llu", (unsigned long long)st.bytes_evicted);
        -: 3317:        APPEND_STAT("extstore_bytes_written", "%llu", (unsigned long long)st.bytes_written);
        -: 3318:        APPEND_STAT("extstore_bytes_read", "%llu", (unsigned long long)st.bytes_read);
        -: 3319:        APPEND_STAT("extstore_bytes_used", "%llu", (unsigned long long)st.bytes_used);
        -: 3320:        APPEND_STAT("extstore_bytes_fragmented", "%llu", (unsigned long long)st.bytes_fragmented);
        -: 3321:        APPEND_STAT("extstore_limit_maxbytes", "%llu", (unsigned long long)(st.page_count * st.page_size));
        -: 3322:        APPEND_STAT("extstore_io_queue", "%llu", (unsigned long long)(st.io_queue));
        -: 3323:    }
        -: 3324:#endif
        -: 3325:#ifdef TLS
        -: 3326:    if (settings.ssl_enabled) {
        -: 3327:        SSL_LOCK();
        -: 3328:        APPEND_STAT("time_since_server_cert_refresh", "%u", now - settings.ssl_last_cert_refresh_time);
        -: 3329:        SSL_UNLOCK();
        -: 3330:    }
        -: 3331:#endif
    #####: 3332:}
------------------
server_stats:
    #####: 3188:static void server_stats(ADD_STAT add_stats, conn *c) {
    #####: 3189:    pid_t pid = getpid();
    #####: 3190:    rel_time_t now = current_time;
        -: 3191:
    #####: 3192:    struct thread_stats thread_stats;
    #####: 3193:    threadlocal_stats_aggregate(&thread_stats);
    #####: 3194:    struct slab_stats slab_stats;
    #####: 3195:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 3196:#ifdef EXTSTORE
        -: 3197:    struct extstore_stats st;
        -: 3198:#endif
        -: 3199:#ifndef WIN32
    #####: 3200:    struct rusage usage;
    #####: 3201:    getrusage(RUSAGE_SELF, &usage);
        -: 3202:#endif /* !WIN32 */
        -: 3203:
    #####: 3204:    STATS_LOCK();
        -: 3205:
    #####: 3206:    APPEND_STAT("pid", "%lu", (long)pid);
    #####: 3207:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
    #####: 3208:    APPEND_STAT("time", "%ld", now + (long)process_started);
    #####: 3209:    APPEND_STAT("version", "%s", VERSION);
    #####: 3210:    APPEND_STAT("libevent", "%s", event_get_version());
    #####: 3211:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 3212:
        -: 3213:#ifndef WIN32
    #####: 3214:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
    #####: 3215:                (long)usage.ru_utime.tv_sec,
    #####: 3216:                (long)usage.ru_utime.tv_usec);
    #####: 3217:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
    #####: 3218:                (long)usage.ru_stime.tv_sec,
    #####: 3219:                (long)usage.ru_stime.tv_usec);
        -: 3220:#endif /* !WIN32 */
        -: 3221:
    #####: 3222:    APPEND_STAT("max_connections", "%d", settings.maxconns);
    #####: 3223:    APPEND_STAT("curr_connections", "%llu", (unsigned long long)stats_state.curr_conns - 1);
    #####: 3224:    APPEND_STAT("total_connections", "%llu", (unsigned long long)stats.total_conns);
    #####: 3225:    if (settings.maxconns_fast) {
    #####: 3226:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 3227:    }
    #####: 3228:    APPEND_STAT("connection_structures", "%u", stats_state.conn_structs);
    #####: 3229:    APPEND_STAT("reserved_fds", "%u", stats_state.reserved_fds);
    #####: 3230:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
    #####: 3231:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
    #####: 3232:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
    #####: 3233:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
    #####: 3234:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
    #####: 3235:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
    #####: 3236:    APPEND_STAT("get_expired", "%llu", (unsigned long long)thread_stats.get_expired);
    #####: 3237:    APPEND_STAT("get_flushed", "%llu", (unsigned long long)thread_stats.get_flushed);
        -: 3238:#ifdef EXTSTORE
        -: 3239:    if (c->thread->storage) {
        -: 3240:        APPEND_STAT("get_extstore", "%llu", (unsigned long long)thread_stats.get_extstore);
        -: 3241:        APPEND_STAT("get_aborted_extstore", "%llu", (unsigned long long)thread_stats.get_aborted_extstore);
        -: 3242:        APPEND_STAT("get_oom_extstore", "%llu", (unsigned long long)thread_stats.get_oom_extstore);
        -: 3243:        APPEND_STAT("recache_from_extstore", "%llu", (unsigned long long)thread_stats.recache_from_extstore);
        -: 3244:        APPEND_STAT("miss_from_extstore", "%llu", (unsigned long long)thread_stats.miss_from_extstore);
        -: 3245:        APPEND_STAT("badcrc_from_extstore", "%llu", (unsigned long long)thread_stats.badcrc_from_extstore);
        -: 3246:    }
        -: 3247:#endif
    #####: 3248:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
    #####: 3249:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
    #####: 3250:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
    #####: 3251:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
    #####: 3252:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
    #####: 3253:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
    #####: 3254:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
    #####: 3255:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
    #####: 3256:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
    #####: 3257:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
    #####: 3258:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
    #####: 3259:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
    #####: 3260:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
    #####: 3261:    if (settings.idle_timeout) {
    #####: 3262:        APPEND_STAT("idle_kicks", "%llu", (unsigned long long)thread_stats.idle_kicks);
        -: 3263:    }
    #####: 3264:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
    #####: 3265:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
    #####: 3266:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3267:    APPEND_STAT("accepting_conns", "%u", stats_state.accepting_conns);
    #####: 3268:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
    #####: 3269:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
    #####: 3270:    APPEND_STAT("threads", "%d", settings.num_threads);
    #####: 3271:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
    #####: 3272:    APPEND_STAT("hash_power_level", "%u", stats_state.hash_power_level);
    #####: 3273:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats_state.hash_bytes);
    #####: 3274:    APPEND_STAT("hash_is_expanding", "%u", stats_state.hash_is_expanding);
    #####: 3275:    if (settings.slab_reassign) {
    #####: 3276:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
    #####: 3277:        APPEND_STAT("slab_reassign_chunk_rescues", "%llu", stats.slab_reassign_chunk_rescues);
    #####: 3278:        APPEND_STAT("slab_reassign_evictions_nomem", "%llu", stats.slab_reassign_evictions_nomem);
    #####: 3279:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
    #####: 3280:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
    #####: 3281:        APPEND_STAT("slab_reassign_busy_deletes", "%llu", stats.slab_reassign_busy_deletes);
    #####: 3282:        APPEND_STAT("slab_reassign_running", "%u", stats_state.slab_reassign_running);
    #####: 3283:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 3284:    }
    #####: 3285:    if (settings.lru_crawler) {
    #####: 3286:        APPEND_STAT("lru_crawler_running", "%u", stats_state.lru_crawler_running);
    #####: 3287:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 3288:    }
    #####: 3289:    if (settings.lru_maintainer_thread) {
    #####: 3290:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 3291:    }
    #####: 3292:    APPEND_STAT("malloc_fails", "%llu",
    #####: 3293:                (unsigned long long)stats.malloc_fails);
    #####: 3294:    APPEND_STAT("log_worker_dropped", "%llu", (unsigned long long)stats.log_worker_dropped);
    #####: 3295:    APPEND_STAT("log_worker_written", "%llu", (unsigned long long)stats.log_worker_written);
    #####: 3296:    APPEND_STAT("log_watcher_skipped", "%llu", (unsigned long long)stats.log_watcher_skipped);
    #####: 3297:    APPEND_STAT("log_watcher_sent", "%llu", (unsigned long long)stats.log_watcher_sent);
    #####: 3298:    STATS_UNLOCK();
        -: 3299:#ifdef EXTSTORE
        -: 3300:    if (c->thread->storage) {
        -: 3301:        STATS_LOCK();
        -: 3302:        APPEND_STAT("extstore_compact_lost", "%llu", (unsigned long long)stats.extstore_compact_lost);
        -: 3303:        APPEND_STAT("extstore_compact_rescues", "%llu", (unsigned long long)stats.extstore_compact_rescues);
        -: 3304:        APPEND_STAT("extstore_compact_skipped", "%llu", (unsigned long long)stats.extstore_compact_skipped);
        -: 3305:        STATS_UNLOCK();
        -: 3306:        extstore_get_stats(c->thread->storage, &st);
        -: 3307:        APPEND_STAT("extstore_page_allocs", "%llu", (unsigned long long)st.page_allocs);
        -: 3308:        APPEND_STAT("extstore_page_evictions", "%llu", (unsigned long long)st.page_evictions);
        -: 3309:        APPEND_STAT("extstore_page_reclaims", "%llu", (unsigned long long)st.page_reclaims);
        -: 3310:        APPEND_STAT("extstore_pages_free", "%llu", (unsigned long long)st.pages_free);
        -: 3311:        APPEND_STAT("extstore_pages_used", "%llu", (unsigned long long)st.pages_used);
        -: 3312:        APPEND_STAT("extstore_objects_evicted", "%llu", (unsigned long long)st.objects_evicted);
        -: 3313:        APPEND_STAT("extstore_objects_read", "%llu", (unsigned long long)st.objects_read);
        -: 3314:        APPEND_STAT("extstore_objects_written", "%llu", (unsigned long long)st.objects_written);
        -: 3315:        APPEND_STAT("extstore_objects_used", "%llu", (unsigned long long)st.objects_used);
        -: 3316:        APPEND_STAT("extstore_bytes_evicted", "%llu", (unsigned long long)st.bytes_evicted);
        -: 3317:        APPEND_STAT("extstore_bytes_written", "%llu", (unsigned long long)st.bytes_written);
        -: 3318:        APPEND_STAT("extstore_bytes_read", "%llu", (unsigned long long)st.bytes_read);
        -: 3319:        APPEND_STAT("extstore_bytes_used", "%llu", (unsigned long long)st.bytes_used);
        -: 3320:        APPEND_STAT("extstore_bytes_fragmented", "%llu", (unsigned long long)st.bytes_fragmented);
        -: 3321:        APPEND_STAT("extstore_limit_maxbytes", "%llu", (unsigned long long)(st.page_count * st.page_size));
        -: 3322:        APPEND_STAT("extstore_io_queue", "%llu", (unsigned long long)(st.io_queue));
        -: 3323:    }
        -: 3324:#endif
        -: 3325:#ifdef TLS
        -: 3326:    if (settings.ssl_enabled) {
        -: 3327:        SSL_LOCK();
        -: 3328:        APPEND_STAT("time_since_server_cert_refresh", "%u", now - settings.ssl_last_cert_refresh_time);
        -: 3329:        SSL_UNLOCK();
        -: 3330:    }
        -: 3331:#endif
    #####: 3332:}
------------------
server_stats:
    #####: 3188:static void server_stats(ADD_STAT add_stats, conn *c) {
    #####: 3189:    pid_t pid = getpid();
    #####: 3190:    rel_time_t now = current_time;
        -: 3191:
    #####: 3192:    struct thread_stats thread_stats;
    #####: 3193:    threadlocal_stats_aggregate(&thread_stats);
    #####: 3194:    struct slab_stats slab_stats;
    #####: 3195:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 3196:#ifdef EXTSTORE
        -: 3197:    struct extstore_stats st;
        -: 3198:#endif
        -: 3199:#ifndef WIN32
    #####: 3200:    struct rusage usage;
    #####: 3201:    getrusage(RUSAGE_SELF, &usage);
        -: 3202:#endif /* !WIN32 */
        -: 3203:
    #####: 3204:    STATS_LOCK();
        -: 3205:
    #####: 3206:    APPEND_STAT("pid", "%lu", (long)pid);
    #####: 3207:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
    #####: 3208:    APPEND_STAT("time", "%ld", now + (long)process_started);
    #####: 3209:    APPEND_STAT("version", "%s", VERSION);
    #####: 3210:    APPEND_STAT("libevent", "%s", event_get_version());
    #####: 3211:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 3212:
        -: 3213:#ifndef WIN32
    #####: 3214:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
    #####: 3215:                (long)usage.ru_utime.tv_sec,
    #####: 3216:                (long)usage.ru_utime.tv_usec);
    #####: 3217:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
    #####: 3218:                (long)usage.ru_stime.tv_sec,
    #####: 3219:                (long)usage.ru_stime.tv_usec);
        -: 3220:#endif /* !WIN32 */
        -: 3221:
    #####: 3222:    APPEND_STAT("max_connections", "%d", settings.maxconns);
    #####: 3223:    APPEND_STAT("curr_connections", "%llu", (unsigned long long)stats_state.curr_conns - 1);
    #####: 3224:    APPEND_STAT("total_connections", "%llu", (unsigned long long)stats.total_conns);
    #####: 3225:    if (settings.maxconns_fast) {
    #####: 3226:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 3227:    }
    #####: 3228:    APPEND_STAT("connection_structures", "%u", stats_state.conn_structs);
    #####: 3229:    APPEND_STAT("reserved_fds", "%u", stats_state.reserved_fds);
    #####: 3230:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
    #####: 3231:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
    #####: 3232:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
    #####: 3233:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
    #####: 3234:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
    #####: 3235:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
    #####: 3236:    APPEND_STAT("get_expired", "%llu", (unsigned long long)thread_stats.get_expired);
    #####: 3237:    APPEND_STAT("get_flushed", "%llu", (unsigned long long)thread_stats.get_flushed);
        -: 3238:#ifdef EXTSTORE
        -: 3239:    if (c->thread->storage) {
        -: 3240:        APPEND_STAT("get_extstore", "%llu", (unsigned long long)thread_stats.get_extstore);
        -: 3241:        APPEND_STAT("get_aborted_extstore", "%llu", (unsigned long long)thread_stats.get_aborted_extstore);
        -: 3242:        APPEND_STAT("get_oom_extstore", "%llu", (unsigned long long)thread_stats.get_oom_extstore);
        -: 3243:        APPEND_STAT("recache_from_extstore", "%llu", (unsigned long long)thread_stats.recache_from_extstore);
        -: 3244:        APPEND_STAT("miss_from_extstore", "%llu", (unsigned long long)thread_stats.miss_from_extstore);
        -: 3245:        APPEND_STAT("badcrc_from_extstore", "%llu", (unsigned long long)thread_stats.badcrc_from_extstore);
        -: 3246:    }
        -: 3247:#endif
    #####: 3248:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
    #####: 3249:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
    #####: 3250:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
    #####: 3251:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
    #####: 3252:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
    #####: 3253:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
    #####: 3254:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
    #####: 3255:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
    #####: 3256:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
    #####: 3257:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
    #####: 3258:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
    #####: 3259:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
    #####: 3260:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
    #####: 3261:    if (settings.idle_timeout) {
    #####: 3262:        APPEND_STAT("idle_kicks", "%llu", (unsigned long long)thread_stats.idle_kicks);
        -: 3263:    }
    #####: 3264:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
    #####: 3265:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
    #####: 3266:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3267:    APPEND_STAT("accepting_conns", "%u", stats_state.accepting_conns);
    #####: 3268:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
    #####: 3269:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
    #####: 3270:    APPEND_STAT("threads", "%d", settings.num_threads);
    #####: 3271:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
    #####: 3272:    APPEND_STAT("hash_power_level", "%u", stats_state.hash_power_level);
    #####: 3273:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats_state.hash_bytes);
    #####: 3274:    APPEND_STAT("hash_is_expanding", "%u", stats_state.hash_is_expanding);
    #####: 3275:    if (settings.slab_reassign) {
    #####: 3276:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
    #####: 3277:        APPEND_STAT("slab_reassign_chunk_rescues", "%llu", stats.slab_reassign_chunk_rescues);
    #####: 3278:        APPEND_STAT("slab_reassign_evictions_nomem", "%llu", stats.slab_reassign_evictions_nomem);
    #####: 3279:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
    #####: 3280:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
    #####: 3281:        APPEND_STAT("slab_reassign_busy_deletes", "%llu", stats.slab_reassign_busy_deletes);
    #####: 3282:        APPEND_STAT("slab_reassign_running", "%u", stats_state.slab_reassign_running);
    #####: 3283:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 3284:    }
    #####: 3285:    if (settings.lru_crawler) {
    #####: 3286:        APPEND_STAT("lru_crawler_running", "%u", stats_state.lru_crawler_running);
    #####: 3287:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 3288:    }
    #####: 3289:    if (settings.lru_maintainer_thread) {
    #####: 3290:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 3291:    }
    #####: 3292:    APPEND_STAT("malloc_fails", "%llu",
    #####: 3293:                (unsigned long long)stats.malloc_fails);
    #####: 3294:    APPEND_STAT("log_worker_dropped", "%llu", (unsigned long long)stats.log_worker_dropped);
    #####: 3295:    APPEND_STAT("log_worker_written", "%llu", (unsigned long long)stats.log_worker_written);
    #####: 3296:    APPEND_STAT("log_watcher_skipped", "%llu", (unsigned long long)stats.log_watcher_skipped);
    #####: 3297:    APPEND_STAT("log_watcher_sent", "%llu", (unsigned long long)stats.log_watcher_sent);
    #####: 3298:    STATS_UNLOCK();
        -: 3299:#ifdef EXTSTORE
        -: 3300:    if (c->thread->storage) {
        -: 3301:        STATS_LOCK();
        -: 3302:        APPEND_STAT("extstore_compact_lost", "%llu", (unsigned long long)stats.extstore_compact_lost);
        -: 3303:        APPEND_STAT("extstore_compact_rescues", "%llu", (unsigned long long)stats.extstore_compact_rescues);
        -: 3304:        APPEND_STAT("extstore_compact_skipped", "%llu", (unsigned long long)stats.extstore_compact_skipped);
        -: 3305:        STATS_UNLOCK();
        -: 3306:        extstore_get_stats(c->thread->storage, &st);
        -: 3307:        APPEND_STAT("extstore_page_allocs", "%llu", (unsigned long long)st.page_allocs);
        -: 3308:        APPEND_STAT("extstore_page_evictions", "%llu", (unsigned long long)st.page_evictions);
        -: 3309:        APPEND_STAT("extstore_page_reclaims", "%llu", (unsigned long long)st.page_reclaims);
        -: 3310:        APPEND_STAT("extstore_pages_free", "%llu", (unsigned long long)st.pages_free);
        -: 3311:        APPEND_STAT("extstore_pages_used", "%llu", (unsigned long long)st.pages_used);
        -: 3312:        APPEND_STAT("extstore_objects_evicted", "%llu", (unsigned long long)st.objects_evicted);
        -: 3313:        APPEND_STAT("extstore_objects_read", "%llu", (unsigned long long)st.objects_read);
        -: 3314:        APPEND_STAT("extstore_objects_written", "%llu", (unsigned long long)st.objects_written);
        -: 3315:        APPEND_STAT("extstore_objects_used", "%llu", (unsigned long long)st.objects_used);
        -: 3316:        APPEND_STAT("extstore_bytes_evicted", "%llu", (unsigned long long)st.bytes_evicted);
        -: 3317:        APPEND_STAT("extstore_bytes_written", "%llu", (unsigned long long)st.bytes_written);
        -: 3318:        APPEND_STAT("extstore_bytes_read", "%llu", (unsigned long long)st.bytes_read);
        -: 3319:        APPEND_STAT("extstore_bytes_used", "%llu", (unsigned long long)st.bytes_used);
        -: 3320:        APPEND_STAT("extstore_bytes_fragmented", "%llu", (unsigned long long)st.bytes_fragmented);
        -: 3321:        APPEND_STAT("extstore_limit_maxbytes", "%llu", (unsigned long long)(st.page_count * st.page_size));
        -: 3322:        APPEND_STAT("extstore_io_queue", "%llu", (unsigned long long)(st.io_queue));
        -: 3323:    }
        -: 3324:#endif
        -: 3325:#ifdef TLS
        -: 3326:    if (settings.ssl_enabled) {
        -: 3327:        SSL_LOCK();
        -: 3328:        APPEND_STAT("time_since_server_cert_refresh", "%u", now - settings.ssl_last_cert_refresh_time);
        -: 3329:        SSL_UNLOCK();
        -: 3330:    }
        -: 3331:#endif
    #####: 3332:}
------------------
server_stats:
    #####: 3188:static void server_stats(ADD_STAT add_stats, conn *c) {
    #####: 3189:    pid_t pid = getpid();
    #####: 3190:    rel_time_t now = current_time;
        -: 3191:
    #####: 3192:    struct thread_stats thread_stats;
    #####: 3193:    threadlocal_stats_aggregate(&thread_stats);
    #####: 3194:    struct slab_stats slab_stats;
    #####: 3195:    slab_stats_aggregate(&thread_stats, &slab_stats);
        -: 3196:#ifdef EXTSTORE
        -: 3197:    struct extstore_stats st;
        -: 3198:#endif
        -: 3199:#ifndef WIN32
    #####: 3200:    struct rusage usage;
    #####: 3201:    getrusage(RUSAGE_SELF, &usage);
        -: 3202:#endif /* !WIN32 */
        -: 3203:
    #####: 3204:    STATS_LOCK();
        -: 3205:
    #####: 3206:    APPEND_STAT("pid", "%lu", (long)pid);
    #####: 3207:    APPEND_STAT("uptime", "%u", now - ITEM_UPDATE_INTERVAL);
    #####: 3208:    APPEND_STAT("time", "%ld", now + (long)process_started);
    #####: 3209:    APPEND_STAT("version", "%s", VERSION);
    #####: 3210:    APPEND_STAT("libevent", "%s", event_get_version());
    #####: 3211:    APPEND_STAT("pointer_size", "%d", (int)(8 * sizeof(void *)));
        -: 3212:
        -: 3213:#ifndef WIN32
    #####: 3214:    append_stat("rusage_user", add_stats, c, "%ld.%06ld",
    #####: 3215:                (long)usage.ru_utime.tv_sec,
    #####: 3216:                (long)usage.ru_utime.tv_usec);
    #####: 3217:    append_stat("rusage_system", add_stats, c, "%ld.%06ld",
    #####: 3218:                (long)usage.ru_stime.tv_sec,
    #####: 3219:                (long)usage.ru_stime.tv_usec);
        -: 3220:#endif /* !WIN32 */
        -: 3221:
    #####: 3222:    APPEND_STAT("max_connections", "%d", settings.maxconns);
    #####: 3223:    APPEND_STAT("curr_connections", "%llu", (unsigned long long)stats_state.curr_conns - 1);
    #####: 3224:    APPEND_STAT("total_connections", "%llu", (unsigned long long)stats.total_conns);
    #####: 3225:    if (settings.maxconns_fast) {
    #####: 3226:        APPEND_STAT("rejected_connections", "%llu", (unsigned long long)stats.rejected_conns);
        -: 3227:    }
    #####: 3228:    APPEND_STAT("connection_structures", "%u", stats_state.conn_structs);
    #####: 3229:    APPEND_STAT("reserved_fds", "%u", stats_state.reserved_fds);
    #####: 3230:    APPEND_STAT("cmd_get", "%llu", (unsigned long long)thread_stats.get_cmds);
    #####: 3231:    APPEND_STAT("cmd_set", "%llu", (unsigned long long)slab_stats.set_cmds);
    #####: 3232:    APPEND_STAT("cmd_flush", "%llu", (unsigned long long)thread_stats.flush_cmds);
    #####: 3233:    APPEND_STAT("cmd_touch", "%llu", (unsigned long long)thread_stats.touch_cmds);
    #####: 3234:    APPEND_STAT("get_hits", "%llu", (unsigned long long)slab_stats.get_hits);
    #####: 3235:    APPEND_STAT("get_misses", "%llu", (unsigned long long)thread_stats.get_misses);
    #####: 3236:    APPEND_STAT("get_expired", "%llu", (unsigned long long)thread_stats.get_expired);
    #####: 3237:    APPEND_STAT("get_flushed", "%llu", (unsigned long long)thread_stats.get_flushed);
        -: 3238:#ifdef EXTSTORE
        -: 3239:    if (c->thread->storage) {
        -: 3240:        APPEND_STAT("get_extstore", "%llu", (unsigned long long)thread_stats.get_extstore);
        -: 3241:        APPEND_STAT("get_aborted_extstore", "%llu", (unsigned long long)thread_stats.get_aborted_extstore);
        -: 3242:        APPEND_STAT("get_oom_extstore", "%llu", (unsigned long long)thread_stats.get_oom_extstore);
        -: 3243:        APPEND_STAT("recache_from_extstore", "%llu", (unsigned long long)thread_stats.recache_from_extstore);
        -: 3244:        APPEND_STAT("miss_from_extstore", "%llu", (unsigned long long)thread_stats.miss_from_extstore);
        -: 3245:        APPEND_STAT("badcrc_from_extstore", "%llu", (unsigned long long)thread_stats.badcrc_from_extstore);
        -: 3246:    }
        -: 3247:#endif
    #####: 3248:    APPEND_STAT("delete_misses", "%llu", (unsigned long long)thread_stats.delete_misses);
    #####: 3249:    APPEND_STAT("delete_hits", "%llu", (unsigned long long)slab_stats.delete_hits);
    #####: 3250:    APPEND_STAT("incr_misses", "%llu", (unsigned long long)thread_stats.incr_misses);
    #####: 3251:    APPEND_STAT("incr_hits", "%llu", (unsigned long long)slab_stats.incr_hits);
    #####: 3252:    APPEND_STAT("decr_misses", "%llu", (unsigned long long)thread_stats.decr_misses);
    #####: 3253:    APPEND_STAT("decr_hits", "%llu", (unsigned long long)slab_stats.decr_hits);
    #####: 3254:    APPEND_STAT("cas_misses", "%llu", (unsigned long long)thread_stats.cas_misses);
    #####: 3255:    APPEND_STAT("cas_hits", "%llu", (unsigned long long)slab_stats.cas_hits);
    #####: 3256:    APPEND_STAT("cas_badval", "%llu", (unsigned long long)slab_stats.cas_badval);
    #####: 3257:    APPEND_STAT("touch_hits", "%llu", (unsigned long long)slab_stats.touch_hits);
    #####: 3258:    APPEND_STAT("touch_misses", "%llu", (unsigned long long)thread_stats.touch_misses);
    #####: 3259:    APPEND_STAT("auth_cmds", "%llu", (unsigned long long)thread_stats.auth_cmds);
    #####: 3260:    APPEND_STAT("auth_errors", "%llu", (unsigned long long)thread_stats.auth_errors);
    #####: 3261:    if (settings.idle_timeout) {
    #####: 3262:        APPEND_STAT("idle_kicks", "%llu", (unsigned long long)thread_stats.idle_kicks);
        -: 3263:    }
    #####: 3264:    APPEND_STAT("bytes_read", "%llu", (unsigned long long)thread_stats.bytes_read);
    #####: 3265:    APPEND_STAT("bytes_written", "%llu", (unsigned long long)thread_stats.bytes_written);
    #####: 3266:    APPEND_STAT("limit_maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3267:    APPEND_STAT("accepting_conns", "%u", stats_state.accepting_conns);
    #####: 3268:    APPEND_STAT("listen_disabled_num", "%llu", (unsigned long long)stats.listen_disabled_num);
    #####: 3269:    APPEND_STAT("time_in_listen_disabled_us", "%llu", stats.time_in_listen_disabled_us);
    #####: 3270:    APPEND_STAT("threads", "%d", settings.num_threads);
    #####: 3271:    APPEND_STAT("conn_yields", "%llu", (unsigned long long)thread_stats.conn_yields);
    #####: 3272:    APPEND_STAT("hash_power_level", "%u", stats_state.hash_power_level);
    #####: 3273:    APPEND_STAT("hash_bytes", "%llu", (unsigned long long)stats_state.hash_bytes);
    #####: 3274:    APPEND_STAT("hash_is_expanding", "%u", stats_state.hash_is_expanding);
    #####: 3275:    if (settings.slab_reassign) {
    #####: 3276:        APPEND_STAT("slab_reassign_rescues", "%llu", stats.slab_reassign_rescues);
    #####: 3277:        APPEND_STAT("slab_reassign_chunk_rescues", "%llu", stats.slab_reassign_chunk_rescues);
    #####: 3278:        APPEND_STAT("slab_reassign_evictions_nomem", "%llu", stats.slab_reassign_evictions_nomem);
    #####: 3279:        APPEND_STAT("slab_reassign_inline_reclaim", "%llu", stats.slab_reassign_inline_reclaim);
    #####: 3280:        APPEND_STAT("slab_reassign_busy_items", "%llu", stats.slab_reassign_busy_items);
    #####: 3281:        APPEND_STAT("slab_reassign_busy_deletes", "%llu", stats.slab_reassign_busy_deletes);
    #####: 3282:        APPEND_STAT("slab_reassign_running", "%u", stats_state.slab_reassign_running);
    #####: 3283:        APPEND_STAT("slabs_moved", "%llu", stats.slabs_moved);
        -: 3284:    }
    #####: 3285:    if (settings.lru_crawler) {
    #####: 3286:        APPEND_STAT("lru_crawler_running", "%u", stats_state.lru_crawler_running);
    #####: 3287:        APPEND_STAT("lru_crawler_starts", "%u", stats.lru_crawler_starts);
        -: 3288:    }
    #####: 3289:    if (settings.lru_maintainer_thread) {
    #####: 3290:        APPEND_STAT("lru_maintainer_juggles", "%llu", (unsigned long long)stats.lru_maintainer_juggles);
        -: 3291:    }
    #####: 3292:    APPEND_STAT("malloc_fails", "%llu",
    #####: 3293:                (unsigned long long)stats.malloc_fails);
    #####: 3294:    APPEND_STAT("log_worker_dropped", "%llu", (unsigned long long)stats.log_worker_dropped);
    #####: 3295:    APPEND_STAT("log_worker_written", "%llu", (unsigned long long)stats.log_worker_written);
    #####: 3296:    APPEND_STAT("log_watcher_skipped", "%llu", (unsigned long long)stats.log_watcher_skipped);
    #####: 3297:    APPEND_STAT("log_watcher_sent", "%llu", (unsigned long long)stats.log_watcher_sent);
    #####: 3298:    STATS_UNLOCK();
        -: 3299:#ifdef EXTSTORE
        -: 3300:    if (c->thread->storage) {
        -: 3301:        STATS_LOCK();
        -: 3302:        APPEND_STAT("extstore_compact_lost", "%llu", (unsigned long long)stats.extstore_compact_lost);
        -: 3303:        APPEND_STAT("extstore_compact_rescues", "%llu", (unsigned long long)stats.extstore_compact_rescues);
        -: 3304:        APPEND_STAT("extstore_compact_skipped", "%llu", (unsigned long long)stats.extstore_compact_skipped);
        -: 3305:        STATS_UNLOCK();
        -: 3306:        extstore_get_stats(c->thread->storage, &st);
        -: 3307:        APPEND_STAT("extstore_page_allocs", "%llu", (unsigned long long)st.page_allocs);
        -: 3308:        APPEND_STAT("extstore_page_evictions", "%llu", (unsigned long long)st.page_evictions);
        -: 3309:        APPEND_STAT("extstore_page_reclaims", "%llu", (unsigned long long)st.page_reclaims);
        -: 3310:        APPEND_STAT("extstore_pages_free", "%llu", (unsigned long long)st.pages_free);
        -: 3311:        APPEND_STAT("extstore_pages_used", "%llu", (unsigned long long)st.pages_used);
        -: 3312:        APPEND_STAT("extstore_objects_evicted", "%llu", (unsigned long long)st.objects_evicted);
        -: 3313:        APPEND_STAT("extstore_objects_read", "%llu", (unsigned long long)st.objects_read);
        -: 3314:        APPEND_STAT("extstore_objects_written", "%llu", (unsigned long long)st.objects_written);
        -: 3315:        APPEND_STAT("extstore_objects_used", "%llu", (unsigned long long)st.objects_used);
        -: 3316:        APPEND_STAT("extstore_bytes_evicted", "%llu", (unsigned long long)st.bytes_evicted);
        -: 3317:        APPEND_STAT("extstore_bytes_written", "%llu", (unsigned long long)st.bytes_written);
        -: 3318:        APPEND_STAT("extstore_bytes_read", "%llu", (unsigned long long)st.bytes_read);
        -: 3319:        APPEND_STAT("extstore_bytes_used", "%llu", (unsigned long long)st.bytes_used);
        -: 3320:        APPEND_STAT("extstore_bytes_fragmented", "%llu", (unsigned long long)st.bytes_fragmented);
        -: 3321:        APPEND_STAT("extstore_limit_maxbytes", "%llu", (unsigned long long)(st.page_count * st.page_size));
        -: 3322:        APPEND_STAT("extstore_io_queue", "%llu", (unsigned long long)(st.io_queue));
        -: 3323:    }
        -: 3324:#endif
        -: 3325:#ifdef TLS
        -: 3326:    if (settings.ssl_enabled) {
        -: 3327:        SSL_LOCK();
        -: 3328:        APPEND_STAT("time_since_server_cert_refresh", "%u", now - settings.ssl_last_cert_refresh_time);
        -: 3329:        SSL_UNLOCK();
        -: 3330:    }
        -: 3331:#endif
    #####: 3332:}
------------------
        -: 3333:
    #####: 3334:static void process_stat_settings(ADD_STAT add_stats, void *c) {
    #####: 3335:    assert(add_stats);
    #####: 3336:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3337:    APPEND_STAT("maxconns", "%d", settings.maxconns);
    #####: 3338:    APPEND_STAT("tcpport", "%d", settings.port);
    #####: 3339:    APPEND_STAT("udpport", "%d", settings.udpport);
    #####: 3340:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
    #####: 3341:    APPEND_STAT("verbosity", "%d", settings.verbose);
    #####: 3342:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
    #####: 3343:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
    #####: 3344:    APPEND_STAT("domain_socket", "%s",
    #####: 3345:                settings.socketpath ? settings.socketpath : "NULL");
    #####: 3346:    APPEND_STAT("umask", "%o", settings.access);
    #####: 3347:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
    #####: 3348:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
    #####: 3349:    APPEND_STAT("num_threads", "%d", settings.num_threads);
    #####: 3350:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
    #####: 3351:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
    #####: 3352:    APPEND_STAT("detail_enabled", "%s",
    #####: 3353:                settings.detail_enabled ? "yes" : "no");
    #####: 3354:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
    #####: 3355:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
    #####: 3356:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
    #####: 3357:    APPEND_STAT("binding_protocol", "%s",
    #####: 3358:                prot_text(settings.binding_protocol));
    #####: 3359:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
    #####: 3360:    APPEND_STAT("auth_enabled_ascii", "%s", settings.auth_file ? settings.auth_file : "no");
    #####: 3361:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
    #####: 3362:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
    #####: 3363:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
    #####: 3364:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
    #####: 3365:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
    #####: 3366:    APPEND_STAT("slab_automove_ratio", "%.2f", settings.slab_automove_ratio);
    #####: 3367:    APPEND_STAT("slab_automove_window", "%u", settings.slab_automove_window);
    #####: 3368:    APPEND_STAT("slab_chunk_max", "%d", settings.slab_chunk_size_max);
    #####: 3369:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
    #####: 3370:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
    #####: 3371:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
    #####: 3372:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
    #####: 3373:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
    #####: 3374:    APPEND_STAT("dump_enabled", "%s", settings.dump_enabled ? "yes" : "no");
    #####: 3375:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
    #####: 3376:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
    #####: 3377:    APPEND_STAT("lru_segmented", "%s", settings.lru_segmented ? "yes" : "no");
    #####: 3378:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
    #####: 3379:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
    #####: 3380:    APPEND_STAT("hot_max_factor", "%.2f", settings.hot_max_factor);
    #####: 3381:    APPEND_STAT("warm_max_factor", "%.2f", settings.warm_max_factor);
    #####: 3382:    APPEND_STAT("temp_lru", "%s", settings.temp_lru ? "yes" : "no");
    #####: 3383:    APPEND_STAT("temporary_ttl", "%u", settings.temporary_ttl);
    #####: 3384:    APPEND_STAT("idle_timeout", "%d", settings.idle_timeout);
    #####: 3385:    APPEND_STAT("watcher_logbuf_size", "%u", settings.logger_watcher_buf_size);
    #####: 3386:    APPEND_STAT("worker_logbuf_size", "%u", settings.logger_buf_size);
    #####: 3387:    APPEND_STAT("track_sizes", "%s", item_stats_sizes_status() ? "yes" : "no");
    #####: 3388:    APPEND_STAT("inline_ascii_response", "%s", "no"); // setting is dead, cannot be yes.
        -: 3389:#ifdef HAVE_DROP_PRIVILEGES
        -: 3390:    APPEND_STAT("drop_privileges", "%s", settings.drop_privileges ? "yes" : "no");
        -: 3391:#endif
        -: 3392:#ifdef EXTSTORE
        -: 3393:    APPEND_STAT("ext_item_size", "%u", settings.ext_item_size);
        -: 3394:    APPEND_STAT("ext_item_age", "%u", settings.ext_item_age);
        -: 3395:    APPEND_STAT("ext_low_ttl", "%u", settings.ext_low_ttl);
        -: 3396:    APPEND_STAT("ext_recache_rate", "%u", settings.ext_recache_rate);
        -: 3397:    APPEND_STAT("ext_wbuf_size", "%u", settings.ext_wbuf_size);
        -: 3398:    APPEND_STAT("ext_compact_under", "%u", settings.ext_compact_under);
        -: 3399:    APPEND_STAT("ext_drop_under", "%u", settings.ext_drop_under);
        -: 3400:    APPEND_STAT("ext_max_frag", "%.2f", settings.ext_max_frag);
        -: 3401:    APPEND_STAT("slab_automove_freeratio", "%.3f", settings.slab_automove_freeratio);
        -: 3402:    APPEND_STAT("ext_drop_unread", "%s", settings.ext_drop_unread ? "yes" : "no");
        -: 3403:#endif
        -: 3404:#ifdef TLS
        -: 3405:    APPEND_STAT("ssl_enabled", "%s", settings.ssl_enabled ? "yes" : "no");
        -: 3406:    APPEND_STAT("ssl_chain_cert", "%s", settings.ssl_chain_cert);
        -: 3407:    APPEND_STAT("ssl_key", "%s", settings.ssl_key);
        -: 3408:    APPEND_STAT("ssl_verify_mode", "%d", settings.ssl_verify_mode);
        -: 3409:    APPEND_STAT("ssl_keyformat", "%d", settings.ssl_keyformat);
        -: 3410:    APPEND_STAT("ssl_ciphers", "%s", settings.ssl_ciphers ? settings.ssl_ciphers : "NULL");
        -: 3411:    APPEND_STAT("ssl_ca_cert", "%s", settings.ssl_ca_cert ? settings.ssl_ca_cert : "NULL");
        -: 3412:    APPEND_STAT("ssl_wbuf_size", "%u", settings.ssl_wbuf_size);
        -: 3413:#endif
    #####: 3414:}
------------------
process_stat_settings:
    #####: 3334:static void process_stat_settings(ADD_STAT add_stats, void *c) {
    #####: 3335:    assert(add_stats);
    #####: 3336:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3337:    APPEND_STAT("maxconns", "%d", settings.maxconns);
    #####: 3338:    APPEND_STAT("tcpport", "%d", settings.port);
    #####: 3339:    APPEND_STAT("udpport", "%d", settings.udpport);
    #####: 3340:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
    #####: 3341:    APPEND_STAT("verbosity", "%d", settings.verbose);
    #####: 3342:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
    #####: 3343:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
    #####: 3344:    APPEND_STAT("domain_socket", "%s",
    #####: 3345:                settings.socketpath ? settings.socketpath : "NULL");
    #####: 3346:    APPEND_STAT("umask", "%o", settings.access);
    #####: 3347:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
    #####: 3348:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
    #####: 3349:    APPEND_STAT("num_threads", "%d", settings.num_threads);
    #####: 3350:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
    #####: 3351:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
    #####: 3352:    APPEND_STAT("detail_enabled", "%s",
    #####: 3353:                settings.detail_enabled ? "yes" : "no");
    #####: 3354:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
    #####: 3355:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
    #####: 3356:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
    #####: 3357:    APPEND_STAT("binding_protocol", "%s",
    #####: 3358:                prot_text(settings.binding_protocol));
    #####: 3359:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
    #####: 3360:    APPEND_STAT("auth_enabled_ascii", "%s", settings.auth_file ? settings.auth_file : "no");
    #####: 3361:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
    #####: 3362:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
    #####: 3363:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
    #####: 3364:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
    #####: 3365:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
    #####: 3366:    APPEND_STAT("slab_automove_ratio", "%.2f", settings.slab_automove_ratio);
    #####: 3367:    APPEND_STAT("slab_automove_window", "%u", settings.slab_automove_window);
    #####: 3368:    APPEND_STAT("slab_chunk_max", "%d", settings.slab_chunk_size_max);
    #####: 3369:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
    #####: 3370:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
    #####: 3371:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
    #####: 3372:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
    #####: 3373:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
    #####: 3374:    APPEND_STAT("dump_enabled", "%s", settings.dump_enabled ? "yes" : "no");
    #####: 3375:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
    #####: 3376:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
    #####: 3377:    APPEND_STAT("lru_segmented", "%s", settings.lru_segmented ? "yes" : "no");
    #####: 3378:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
    #####: 3379:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
    #####: 3380:    APPEND_STAT("hot_max_factor", "%.2f", settings.hot_max_factor);
    #####: 3381:    APPEND_STAT("warm_max_factor", "%.2f", settings.warm_max_factor);
    #####: 3382:    APPEND_STAT("temp_lru", "%s", settings.temp_lru ? "yes" : "no");
    #####: 3383:    APPEND_STAT("temporary_ttl", "%u", settings.temporary_ttl);
    #####: 3384:    APPEND_STAT("idle_timeout", "%d", settings.idle_timeout);
    #####: 3385:    APPEND_STAT("watcher_logbuf_size", "%u", settings.logger_watcher_buf_size);
    #####: 3386:    APPEND_STAT("worker_logbuf_size", "%u", settings.logger_buf_size);
    #####: 3387:    APPEND_STAT("track_sizes", "%s", item_stats_sizes_status() ? "yes" : "no");
    #####: 3388:    APPEND_STAT("inline_ascii_response", "%s", "no"); // setting is dead, cannot be yes.
        -: 3389:#ifdef HAVE_DROP_PRIVILEGES
        -: 3390:    APPEND_STAT("drop_privileges", "%s", settings.drop_privileges ? "yes" : "no");
        -: 3391:#endif
        -: 3392:#ifdef EXTSTORE
        -: 3393:    APPEND_STAT("ext_item_size", "%u", settings.ext_item_size);
        -: 3394:    APPEND_STAT("ext_item_age", "%u", settings.ext_item_age);
        -: 3395:    APPEND_STAT("ext_low_ttl", "%u", settings.ext_low_ttl);
        -: 3396:    APPEND_STAT("ext_recache_rate", "%u", settings.ext_recache_rate);
        -: 3397:    APPEND_STAT("ext_wbuf_size", "%u", settings.ext_wbuf_size);
        -: 3398:    APPEND_STAT("ext_compact_under", "%u", settings.ext_compact_under);
        -: 3399:    APPEND_STAT("ext_drop_under", "%u", settings.ext_drop_under);
        -: 3400:    APPEND_STAT("ext_max_frag", "%.2f", settings.ext_max_frag);
        -: 3401:    APPEND_STAT("slab_automove_freeratio", "%.3f", settings.slab_automove_freeratio);
        -: 3402:    APPEND_STAT("ext_drop_unread", "%s", settings.ext_drop_unread ? "yes" : "no");
        -: 3403:#endif
        -: 3404:#ifdef TLS
        -: 3405:    APPEND_STAT("ssl_enabled", "%s", settings.ssl_enabled ? "yes" : "no");
        -: 3406:    APPEND_STAT("ssl_chain_cert", "%s", settings.ssl_chain_cert);
        -: 3407:    APPEND_STAT("ssl_key", "%s", settings.ssl_key);
        -: 3408:    APPEND_STAT("ssl_verify_mode", "%d", settings.ssl_verify_mode);
        -: 3409:    APPEND_STAT("ssl_keyformat", "%d", settings.ssl_keyformat);
        -: 3410:    APPEND_STAT("ssl_ciphers", "%s", settings.ssl_ciphers ? settings.ssl_ciphers : "NULL");
        -: 3411:    APPEND_STAT("ssl_ca_cert", "%s", settings.ssl_ca_cert ? settings.ssl_ca_cert : "NULL");
        -: 3412:    APPEND_STAT("ssl_wbuf_size", "%u", settings.ssl_wbuf_size);
        -: 3413:#endif
    #####: 3414:}
------------------
process_stat_settings:
    #####: 3334:static void process_stat_settings(ADD_STAT add_stats, void *c) {
    #####: 3335:    assert(add_stats);
    #####: 3336:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3337:    APPEND_STAT("maxconns", "%d", settings.maxconns);
    #####: 3338:    APPEND_STAT("tcpport", "%d", settings.port);
    #####: 3339:    APPEND_STAT("udpport", "%d", settings.udpport);
    #####: 3340:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
    #####: 3341:    APPEND_STAT("verbosity", "%d", settings.verbose);
    #####: 3342:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
    #####: 3343:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
    #####: 3344:    APPEND_STAT("domain_socket", "%s",
    #####: 3345:                settings.socketpath ? settings.socketpath : "NULL");
    #####: 3346:    APPEND_STAT("umask", "%o", settings.access);
    #####: 3347:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
    #####: 3348:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
    #####: 3349:    APPEND_STAT("num_threads", "%d", settings.num_threads);
    #####: 3350:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
    #####: 3351:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
    #####: 3352:    APPEND_STAT("detail_enabled", "%s",
    #####: 3353:                settings.detail_enabled ? "yes" : "no");
    #####: 3354:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
    #####: 3355:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
    #####: 3356:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
    #####: 3357:    APPEND_STAT("binding_protocol", "%s",
    #####: 3358:                prot_text(settings.binding_protocol));
    #####: 3359:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
    #####: 3360:    APPEND_STAT("auth_enabled_ascii", "%s", settings.auth_file ? settings.auth_file : "no");
    #####: 3361:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
    #####: 3362:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
    #####: 3363:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
    #####: 3364:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
    #####: 3365:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
    #####: 3366:    APPEND_STAT("slab_automove_ratio", "%.2f", settings.slab_automove_ratio);
    #####: 3367:    APPEND_STAT("slab_automove_window", "%u", settings.slab_automove_window);
    #####: 3368:    APPEND_STAT("slab_chunk_max", "%d", settings.slab_chunk_size_max);
    #####: 3369:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
    #####: 3370:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
    #####: 3371:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
    #####: 3372:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
    #####: 3373:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
    #####: 3374:    APPEND_STAT("dump_enabled", "%s", settings.dump_enabled ? "yes" : "no");
    #####: 3375:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
    #####: 3376:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
    #####: 3377:    APPEND_STAT("lru_segmented", "%s", settings.lru_segmented ? "yes" : "no");
    #####: 3378:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
    #####: 3379:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
    #####: 3380:    APPEND_STAT("hot_max_factor", "%.2f", settings.hot_max_factor);
    #####: 3381:    APPEND_STAT("warm_max_factor", "%.2f", settings.warm_max_factor);
    #####: 3382:    APPEND_STAT("temp_lru", "%s", settings.temp_lru ? "yes" : "no");
    #####: 3383:    APPEND_STAT("temporary_ttl", "%u", settings.temporary_ttl);
    #####: 3384:    APPEND_STAT("idle_timeout", "%d", settings.idle_timeout);
    #####: 3385:    APPEND_STAT("watcher_logbuf_size", "%u", settings.logger_watcher_buf_size);
    #####: 3386:    APPEND_STAT("worker_logbuf_size", "%u", settings.logger_buf_size);
    #####: 3387:    APPEND_STAT("track_sizes", "%s", item_stats_sizes_status() ? "yes" : "no");
    #####: 3388:    APPEND_STAT("inline_ascii_response", "%s", "no"); // setting is dead, cannot be yes.
        -: 3389:#ifdef HAVE_DROP_PRIVILEGES
        -: 3390:    APPEND_STAT("drop_privileges", "%s", settings.drop_privileges ? "yes" : "no");
        -: 3391:#endif
        -: 3392:#ifdef EXTSTORE
        -: 3393:    APPEND_STAT("ext_item_size", "%u", settings.ext_item_size);
        -: 3394:    APPEND_STAT("ext_item_age", "%u", settings.ext_item_age);
        -: 3395:    APPEND_STAT("ext_low_ttl", "%u", settings.ext_low_ttl);
        -: 3396:    APPEND_STAT("ext_recache_rate", "%u", settings.ext_recache_rate);
        -: 3397:    APPEND_STAT("ext_wbuf_size", "%u", settings.ext_wbuf_size);
        -: 3398:    APPEND_STAT("ext_compact_under", "%u", settings.ext_compact_under);
        -: 3399:    APPEND_STAT("ext_drop_under", "%u", settings.ext_drop_under);
        -: 3400:    APPEND_STAT("ext_max_frag", "%.2f", settings.ext_max_frag);
        -: 3401:    APPEND_STAT("slab_automove_freeratio", "%.3f", settings.slab_automove_freeratio);
        -: 3402:    APPEND_STAT("ext_drop_unread", "%s", settings.ext_drop_unread ? "yes" : "no");
        -: 3403:#endif
        -: 3404:#ifdef TLS
        -: 3405:    APPEND_STAT("ssl_enabled", "%s", settings.ssl_enabled ? "yes" : "no");
        -: 3406:    APPEND_STAT("ssl_chain_cert", "%s", settings.ssl_chain_cert);
        -: 3407:    APPEND_STAT("ssl_key", "%s", settings.ssl_key);
        -: 3408:    APPEND_STAT("ssl_verify_mode", "%d", settings.ssl_verify_mode);
        -: 3409:    APPEND_STAT("ssl_keyformat", "%d", settings.ssl_keyformat);
        -: 3410:    APPEND_STAT("ssl_ciphers", "%s", settings.ssl_ciphers ? settings.ssl_ciphers : "NULL");
        -: 3411:    APPEND_STAT("ssl_ca_cert", "%s", settings.ssl_ca_cert ? settings.ssl_ca_cert : "NULL");
        -: 3412:    APPEND_STAT("ssl_wbuf_size", "%u", settings.ssl_wbuf_size);
        -: 3413:#endif
    #####: 3414:}
------------------
process_stat_settings:
    #####: 3334:static void process_stat_settings(ADD_STAT add_stats, void *c) {
    #####: 3335:    assert(add_stats);
    #####: 3336:    APPEND_STAT("maxbytes", "%llu", (unsigned long long)settings.maxbytes);
    #####: 3337:    APPEND_STAT("maxconns", "%d", settings.maxconns);
    #####: 3338:    APPEND_STAT("tcpport", "%d", settings.port);
    #####: 3339:    APPEND_STAT("udpport", "%d", settings.udpport);
    #####: 3340:    APPEND_STAT("inter", "%s", settings.inter ? settings.inter : "NULL");
    #####: 3341:    APPEND_STAT("verbosity", "%d", settings.verbose);
    #####: 3342:    APPEND_STAT("oldest", "%lu", (unsigned long)settings.oldest_live);
    #####: 3343:    APPEND_STAT("evictions", "%s", settings.evict_to_free ? "on" : "off");
    #####: 3344:    APPEND_STAT("domain_socket", "%s",
    #####: 3345:                settings.socketpath ? settings.socketpath : "NULL");
    #####: 3346:    APPEND_STAT("umask", "%o", settings.access);
    #####: 3347:    APPEND_STAT("growth_factor", "%.2f", settings.factor);
    #####: 3348:    APPEND_STAT("chunk_size", "%d", settings.chunk_size);
    #####: 3349:    APPEND_STAT("num_threads", "%d", settings.num_threads);
    #####: 3350:    APPEND_STAT("num_threads_per_udp", "%d", settings.num_threads_per_udp);
    #####: 3351:    APPEND_STAT("stat_key_prefix", "%c", settings.prefix_delimiter);
    #####: 3352:    APPEND_STAT("detail_enabled", "%s",
    #####: 3353:                settings.detail_enabled ? "yes" : "no");
    #####: 3354:    APPEND_STAT("reqs_per_event", "%d", settings.reqs_per_event);
    #####: 3355:    APPEND_STAT("cas_enabled", "%s", settings.use_cas ? "yes" : "no");
    #####: 3356:    APPEND_STAT("tcp_backlog", "%d", settings.backlog);
    #####: 3357:    APPEND_STAT("binding_protocol", "%s",
    #####: 3358:                prot_text(settings.binding_protocol));
    #####: 3359:    APPEND_STAT("auth_enabled_sasl", "%s", settings.sasl ? "yes" : "no");
    #####: 3360:    APPEND_STAT("auth_enabled_ascii", "%s", settings.auth_file ? settings.auth_file : "no");
    #####: 3361:    APPEND_STAT("item_size_max", "%d", settings.item_size_max);
    #####: 3362:    APPEND_STAT("maxconns_fast", "%s", settings.maxconns_fast ? "yes" : "no");
    #####: 3363:    APPEND_STAT("hashpower_init", "%d", settings.hashpower_init);
    #####: 3364:    APPEND_STAT("slab_reassign", "%s", settings.slab_reassign ? "yes" : "no");
    #####: 3365:    APPEND_STAT("slab_automove", "%d", settings.slab_automove);
    #####: 3366:    APPEND_STAT("slab_automove_ratio", "%.2f", settings.slab_automove_ratio);
    #####: 3367:    APPEND_STAT("slab_automove_window", "%u", settings.slab_automove_window);
    #####: 3368:    APPEND_STAT("slab_chunk_max", "%d", settings.slab_chunk_size_max);
    #####: 3369:    APPEND_STAT("lru_crawler", "%s", settings.lru_crawler ? "yes" : "no");
    #####: 3370:    APPEND_STAT("lru_crawler_sleep", "%d", settings.lru_crawler_sleep);
    #####: 3371:    APPEND_STAT("lru_crawler_tocrawl", "%lu", (unsigned long)settings.lru_crawler_tocrawl);
    #####: 3372:    APPEND_STAT("tail_repair_time", "%d", settings.tail_repair_time);
    #####: 3373:    APPEND_STAT("flush_enabled", "%s", settings.flush_enabled ? "yes" : "no");
    #####: 3374:    APPEND_STAT("dump_enabled", "%s", settings.dump_enabled ? "yes" : "no");
    #####: 3375:    APPEND_STAT("hash_algorithm", "%s", settings.hash_algorithm);
    #####: 3376:    APPEND_STAT("lru_maintainer_thread", "%s", settings.lru_maintainer_thread ? "yes" : "no");
    #####: 3377:    APPEND_STAT("lru_segmented", "%s", settings.lru_segmented ? "yes" : "no");
    #####: 3378:    APPEND_STAT("hot_lru_pct", "%d", settings.hot_lru_pct);
    #####: 3379:    APPEND_STAT("warm_lru_pct", "%d", settings.warm_lru_pct);
    #####: 3380:    APPEND_STAT("hot_max_factor", "%.2f", settings.hot_max_factor);
    #####: 3381:    APPEND_STAT("warm_max_factor", "%.2f", settings.warm_max_factor);
    #####: 3382:    APPEND_STAT("temp_lru", "%s", settings.temp_lru ? "yes" : "no");
    #####: 3383:    APPEND_STAT("temporary_ttl", "%u", settings.temporary_ttl);
    #####: 3384:    APPEND_STAT("idle_timeout", "%d", settings.idle_timeout);
    #####: 3385:    APPEND_STAT("watcher_logbuf_size", "%u", settings.logger_watcher_buf_size);
    #####: 3386:    APPEND_STAT("worker_logbuf_size", "%u", settings.logger_buf_size);
    #####: 3387:    APPEND_STAT("track_sizes", "%s", item_stats_sizes_status() ? "yes" : "no");
    #####: 3388:    APPEND_STAT("inline_ascii_response", "%s", "no"); // setting is dead, cannot be yes.
        -: 3389:#ifdef HAVE_DROP_PRIVILEGES
        -: 3390:    APPEND_STAT("drop_privileges", "%s", settings.drop_privileges ? "yes" : "no");
        -: 3391:#endif
        -: 3392:#ifdef EXTSTORE
        -: 3393:    APPEND_STAT("ext_item_size", "%u", settings.ext_item_size);
        -: 3394:    APPEND_STAT("ext_item_age", "%u", settings.ext_item_age);
        -: 3395:    APPEND_STAT("ext_low_ttl", "%u", settings.ext_low_ttl);
        -: 3396:    APPEND_STAT("ext_recache_rate", "%u", settings.ext_recache_rate);
        -: 3397:    APPEND_STAT("ext_wbuf_size", "%u", settings.ext_wbuf_size);
        -: 3398:    APPEND_STAT("ext_compact_under", "%u", settings.ext_compact_under);
        -: 3399:    APPEND_STAT("ext_drop_under", "%u", settings.ext_drop_under);
        -: 3400:    APPEND_STAT("ext_max_frag", "%.2f", settings.ext_max_frag);
        -: 3401:    APPEND_STAT("slab_automove_freeratio", "%.3f", settings.slab_automove_freeratio);
        -: 3402:    APPEND_STAT("ext_drop_unread", "%s", settings.ext_drop_unread ? "yes" : "no");
        -: 3403:#endif
        -: 3404:#ifdef TLS
        -: 3405:    APPEND_STAT("ssl_enabled", "%s", settings.ssl_enabled ? "yes" : "no");
        -: 3406:    APPEND_STAT("ssl_chain_cert", "%s", settings.ssl_chain_cert);
        -: 3407:    APPEND_STAT("ssl_key", "%s", settings.ssl_key);
        -: 3408:    APPEND_STAT("ssl_verify_mode", "%d", settings.ssl_verify_mode);
        -: 3409:    APPEND_STAT("ssl_keyformat", "%d", settings.ssl_keyformat);
        -: 3410:    APPEND_STAT("ssl_ciphers", "%s", settings.ssl_ciphers ? settings.ssl_ciphers : "NULL");
        -: 3411:    APPEND_STAT("ssl_ca_cert", "%s", settings.ssl_ca_cert ? settings.ssl_ca_cert : "NULL");
        -: 3412:    APPEND_STAT("ssl_wbuf_size", "%u", settings.ssl_wbuf_size);
        -: 3413:#endif
    #####: 3414:}
------------------
        -: 3415:
    #####: 3416:static void conn_to_str(const conn *c, char *buf) {
    #####: 3417:    char addr_text[MAXPATHLEN];
        -: 3418:
    #####: 3419:    if (!c) {
    #####: 3420:        strcpy(buf, "<null>");
    #####: 3421:    } else if (c->state == conn_closed) {
    #####: 3422:        strcpy(buf, "<closed>");
        -: 3423:    } else {
    #####: 3424:        const char *protoname = "?";
    #####: 3425:        struct sockaddr_in6 local_addr;
    #####: 3426:        struct sockaddr *addr = (void *)&c->request_addr;
    #####: 3427:        int af;
    #####: 3428:        unsigned short port = 0;
        -: 3429:
        -: 3430:        /* For listen ports and idle UDP ports, show listen address */
    #####: 3431:        if (c->state == conn_listening ||
    #####: 3432:                (IS_UDP(c->transport) &&
        -: 3433:                 c->state == conn_read)) {
    #####: 3434:            socklen_t local_addr_len = sizeof(local_addr);
        -: 3435:
    #####: 3436:            if (getsockname(c->sfd,
        -: 3437:                        (struct sockaddr *)&local_addr,
        -: 3438:                        &local_addr_len) == 0) {
    #####: 3439:                addr = (struct sockaddr *)&local_addr;
        -: 3440:            }
        -: 3441:        }
        -: 3442:
    #####: 3443:        af = addr->sa_family;
    #####: 3444:        addr_text[0] = '\0';
        -: 3445:
    #####: 3446:        switch (af) {
    #####: 3447:            case AF_INET:
    #####: 3448:                (void) inet_ntop(af,
    #####: 3449:                        &((struct sockaddr_in *)addr)->sin_addr,
        -: 3450:                        addr_text,
        -: 3451:                        sizeof(addr_text) - 1);
    #####: 3452:                port = ntohs(((struct sockaddr_in *)addr)->sin_port);
    #####: 3453:                protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        -: 3454:                break;
        -: 3455:
    #####: 3456:            case AF_INET6:
    #####: 3457:                addr_text[0] = '[';
    #####: 3458:                addr_text[1] = '\0';
    #####: 3459:                if (inet_ntop(af,
    #####: 3460:                        &((struct sockaddr_in6 *)addr)->sin6_addr,
        -: 3461:                        addr_text + 1,
        -: 3462:                        sizeof(addr_text) - 2)) {
    #####: 3463:                    strcat(addr_text, "]");
        -: 3464:                }
    #####: 3465:                port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
    #####: 3466:                protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        -: 3467:                break;
        -: 3468:
    #####: 3469:            case AF_UNIX:
    #####: 3470:                strncpy(addr_text,
    #####: 3471:                        ((struct sockaddr_un *)addr)->sun_path,
        -: 3472:                        sizeof(addr_text) - 1);
    #####: 3473:                addr_text[sizeof(addr_text)-1] = '\0';
    #####: 3474:                protoname = "unix";
    #####: 3475:                break;
        -: 3476:        }
        -: 3477:
    #####: 3478:        if (strlen(addr_text) < 2) {
        -: 3479:            /* Most likely this is a connected UNIX-domain client which
        -: 3480:             * has no peer socket address, but there's no portable way
        -: 3481:             * to tell for sure.
        -: 3482:             */
    #####: 3483:            sprintf(addr_text, "<AF %d>", af);
        -: 3484:        }
        -: 3485:
    #####: 3486:        if (port) {
    #####: 3487:            sprintf(buf, "%s:%s:%u", protoname, addr_text, port);
        -: 3488:        } else {
    #####: 3489:            sprintf(buf, "%s:%s", protoname, addr_text);
        -: 3490:        }
        -: 3491:    }
    #####: 3492:}
------------------
conn_to_str:
    #####: 3416:static void conn_to_str(const conn *c, char *buf) {
    #####: 3417:    char addr_text[MAXPATHLEN];
        -: 3418:
    #####: 3419:    if (!c) {
    #####: 3420:        strcpy(buf, "<null>");
    #####: 3421:    } else if (c->state == conn_closed) {
    #####: 3422:        strcpy(buf, "<closed>");
        -: 3423:    } else {
    #####: 3424:        const char *protoname = "?";
    #####: 3425:        struct sockaddr_in6 local_addr;
    #####: 3426:        struct sockaddr *addr = (void *)&c->request_addr;
    #####: 3427:        int af;
    #####: 3428:        unsigned short port = 0;
        -: 3429:
        -: 3430:        /* For listen ports and idle UDP ports, show listen address */
    #####: 3431:        if (c->state == conn_listening ||
    #####: 3432:                (IS_UDP(c->transport) &&
        -: 3433:                 c->state == conn_read)) {
    #####: 3434:            socklen_t local_addr_len = sizeof(local_addr);
        -: 3435:
    #####: 3436:            if (getsockname(c->sfd,
        -: 3437:                        (struct sockaddr *)&local_addr,
        -: 3438:                        &local_addr_len) == 0) {
    #####: 3439:                addr = (struct sockaddr *)&local_addr;
        -: 3440:            }
        -: 3441:        }
        -: 3442:
    #####: 3443:        af = addr->sa_family;
    #####: 3444:        addr_text[0] = '\0';
        -: 3445:
    #####: 3446:        switch (af) {
    #####: 3447:            case AF_INET:
    #####: 3448:                (void) inet_ntop(af,
    #####: 3449:                        &((struct sockaddr_in *)addr)->sin_addr,
        -: 3450:                        addr_text,
        -: 3451:                        sizeof(addr_text) - 1);
    #####: 3452:                port = ntohs(((struct sockaddr_in *)addr)->sin_port);
    #####: 3453:                protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        -: 3454:                break;
        -: 3455:
    #####: 3456:            case AF_INET6:
    #####: 3457:                addr_text[0] = '[';
    #####: 3458:                addr_text[1] = '\0';
    #####: 3459:                if (inet_ntop(af,
    #####: 3460:                        &((struct sockaddr_in6 *)addr)->sin6_addr,
        -: 3461:                        addr_text + 1,
        -: 3462:                        sizeof(addr_text) - 2)) {
    #####: 3463:                    strcat(addr_text, "]");
        -: 3464:                }
    #####: 3465:                port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
    #####: 3466:                protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        -: 3467:                break;
        -: 3468:
    #####: 3469:            case AF_UNIX:
    #####: 3470:                strncpy(addr_text,
    #####: 3471:                        ((struct sockaddr_un *)addr)->sun_path,
        -: 3472:                        sizeof(addr_text) - 1);
    #####: 3473:                addr_text[sizeof(addr_text)-1] = '\0';
    #####: 3474:                protoname = "unix";
    #####: 3475:                break;
        -: 3476:        }
        -: 3477:
    #####: 3478:        if (strlen(addr_text) < 2) {
        -: 3479:            /* Most likely this is a connected UNIX-domain client which
        -: 3480:             * has no peer socket address, but there's no portable way
        -: 3481:             * to tell for sure.
        -: 3482:             */
    #####: 3483:            sprintf(addr_text, "<AF %d>", af);
        -: 3484:        }
        -: 3485:
    #####: 3486:        if (port) {
    #####: 3487:            sprintf(buf, "%s:%s:%u", protoname, addr_text, port);
        -: 3488:        } else {
    #####: 3489:            sprintf(buf, "%s:%s", protoname, addr_text);
        -: 3490:        }
        -: 3491:    }
    #####: 3492:}
------------------
conn_to_str:
    #####: 3416:static void conn_to_str(const conn *c, char *buf) {
    #####: 3417:    char addr_text[MAXPATHLEN];
        -: 3418:
    #####: 3419:    if (!c) {
    #####: 3420:        strcpy(buf, "<null>");
    #####: 3421:    } else if (c->state == conn_closed) {
    #####: 3422:        strcpy(buf, "<closed>");
        -: 3423:    } else {
    #####: 3424:        const char *protoname = "?";
    #####: 3425:        struct sockaddr_in6 local_addr;
    #####: 3426:        struct sockaddr *addr = (void *)&c->request_addr;
    #####: 3427:        int af;
    #####: 3428:        unsigned short port = 0;
        -: 3429:
        -: 3430:        /* For listen ports and idle UDP ports, show listen address */
    #####: 3431:        if (c->state == conn_listening ||
    #####: 3432:                (IS_UDP(c->transport) &&
        -: 3433:                 c->state == conn_read)) {
    #####: 3434:            socklen_t local_addr_len = sizeof(local_addr);
        -: 3435:
    #####: 3436:            if (getsockname(c->sfd,
        -: 3437:                        (struct sockaddr *)&local_addr,
        -: 3438:                        &local_addr_len) == 0) {
    #####: 3439:                addr = (struct sockaddr *)&local_addr;
        -: 3440:            }
        -: 3441:        }
        -: 3442:
    #####: 3443:        af = addr->sa_family;
    #####: 3444:        addr_text[0] = '\0';
        -: 3445:
    #####: 3446:        switch (af) {
    #####: 3447:            case AF_INET:
    #####: 3448:                (void) inet_ntop(af,
    #####: 3449:                        &((struct sockaddr_in *)addr)->sin_addr,
        -: 3450:                        addr_text,
        -: 3451:                        sizeof(addr_text) - 1);
    #####: 3452:                port = ntohs(((struct sockaddr_in *)addr)->sin_port);
    #####: 3453:                protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        -: 3454:                break;
        -: 3455:
    #####: 3456:            case AF_INET6:
    #####: 3457:                addr_text[0] = '[';
    #####: 3458:                addr_text[1] = '\0';
    #####: 3459:                if (inet_ntop(af,
    #####: 3460:                        &((struct sockaddr_in6 *)addr)->sin6_addr,
        -: 3461:                        addr_text + 1,
        -: 3462:                        sizeof(addr_text) - 2)) {
    #####: 3463:                    strcat(addr_text, "]");
        -: 3464:                }
    #####: 3465:                port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
    #####: 3466:                protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        -: 3467:                break;
        -: 3468:
    #####: 3469:            case AF_UNIX:
    #####: 3470:                strncpy(addr_text,
    #####: 3471:                        ((struct sockaddr_un *)addr)->sun_path,
        -: 3472:                        sizeof(addr_text) - 1);
    #####: 3473:                addr_text[sizeof(addr_text)-1] = '\0';
    #####: 3474:                protoname = "unix";
    #####: 3475:                break;
        -: 3476:        }
        -: 3477:
    #####: 3478:        if (strlen(addr_text) < 2) {
        -: 3479:            /* Most likely this is a connected UNIX-domain client which
        -: 3480:             * has no peer socket address, but there's no portable way
        -: 3481:             * to tell for sure.
        -: 3482:             */
    #####: 3483:            sprintf(addr_text, "<AF %d>", af);
        -: 3484:        }
        -: 3485:
    #####: 3486:        if (port) {
    #####: 3487:            sprintf(buf, "%s:%s:%u", protoname, addr_text, port);
        -: 3488:        } else {
    #####: 3489:            sprintf(buf, "%s:%s", protoname, addr_text);
        -: 3490:        }
        -: 3491:    }
    #####: 3492:}
------------------
conn_to_str:
    #####: 3416:static void conn_to_str(const conn *c, char *buf) {
    #####: 3417:    char addr_text[MAXPATHLEN];
        -: 3418:
    #####: 3419:    if (!c) {
    #####: 3420:        strcpy(buf, "<null>");
    #####: 3421:    } else if (c->state == conn_closed) {
    #####: 3422:        strcpy(buf, "<closed>");
        -: 3423:    } else {
    #####: 3424:        const char *protoname = "?";
    #####: 3425:        struct sockaddr_in6 local_addr;
    #####: 3426:        struct sockaddr *addr = (void *)&c->request_addr;
    #####: 3427:        int af;
    #####: 3428:        unsigned short port = 0;
        -: 3429:
        -: 3430:        /* For listen ports and idle UDP ports, show listen address */
    #####: 3431:        if (c->state == conn_listening ||
    #####: 3432:                (IS_UDP(c->transport) &&
        -: 3433:                 c->state == conn_read)) {
    #####: 3434:            socklen_t local_addr_len = sizeof(local_addr);
        -: 3435:
    #####: 3436:            if (getsockname(c->sfd,
        -: 3437:                        (struct sockaddr *)&local_addr,
        -: 3438:                        &local_addr_len) == 0) {
    #####: 3439:                addr = (struct sockaddr *)&local_addr;
        -: 3440:            }
        -: 3441:        }
        -: 3442:
    #####: 3443:        af = addr->sa_family;
    #####: 3444:        addr_text[0] = '\0';
        -: 3445:
    #####: 3446:        switch (af) {
    #####: 3447:            case AF_INET:
    #####: 3448:                (void) inet_ntop(af,
    #####: 3449:                        &((struct sockaddr_in *)addr)->sin_addr,
        -: 3450:                        addr_text,
        -: 3451:                        sizeof(addr_text) - 1);
    #####: 3452:                port = ntohs(((struct sockaddr_in *)addr)->sin_port);
    #####: 3453:                protoname = IS_UDP(c->transport) ? "udp" : "tcp";
        -: 3454:                break;
        -: 3455:
    #####: 3456:            case AF_INET6:
    #####: 3457:                addr_text[0] = '[';
    #####: 3458:                addr_text[1] = '\0';
    #####: 3459:                if (inet_ntop(af,
    #####: 3460:                        &((struct sockaddr_in6 *)addr)->sin6_addr,
        -: 3461:                        addr_text + 1,
        -: 3462:                        sizeof(addr_text) - 2)) {
    #####: 3463:                    strcat(addr_text, "]");
        -: 3464:                }
    #####: 3465:                port = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
    #####: 3466:                protoname = IS_UDP(c->transport) ? "udp6" : "tcp6";
        -: 3467:                break;
        -: 3468:
    #####: 3469:            case AF_UNIX:
    #####: 3470:                strncpy(addr_text,
    #####: 3471:                        ((struct sockaddr_un *)addr)->sun_path,
        -: 3472:                        sizeof(addr_text) - 1);
    #####: 3473:                addr_text[sizeof(addr_text)-1] = '\0';
    #####: 3474:                protoname = "unix";
    #####: 3475:                break;
        -: 3476:        }
        -: 3477:
    #####: 3478:        if (strlen(addr_text) < 2) {
        -: 3479:            /* Most likely this is a connected UNIX-domain client which
        -: 3480:             * has no peer socket address, but there's no portable way
        -: 3481:             * to tell for sure.
        -: 3482:             */
    #####: 3483:            sprintf(addr_text, "<AF %d>", af);
        -: 3484:        }
        -: 3485:
    #####: 3486:        if (port) {
    #####: 3487:            sprintf(buf, "%s:%s:%u", protoname, addr_text, port);
        -: 3488:        } else {
    #####: 3489:            sprintf(buf, "%s:%s", protoname, addr_text);
        -: 3490:        }
        -: 3491:    }
    #####: 3492:}
------------------
        -: 3493:
    #####: 3494:static void process_stats_conns(ADD_STAT add_stats, void *c) {
    #####: 3495:    int i;
    #####: 3496:    char key_str[STAT_KEY_LEN];
    #####: 3497:    char val_str[STAT_VAL_LEN];
    #####: 3498:    char conn_name[MAXPATHLEN + sizeof("unix:") + sizeof("65535")];
    #####: 3499:    int klen = 0, vlen = 0;
        -: 3500:
    #####: 3501:    assert(add_stats);
        -: 3502:
    #####: 3503:    for (i = 0; i < max_fds; i++) {
    #####: 3504:        if (conns[i]) {
        -: 3505:            /* This is safe to do unlocked because conns are never freed; the
        -: 3506:             * worst that'll happen will be a minor inconsistency in the
        -: 3507:             * output -- not worth the complexity of the locking that'd be
        -: 3508:             * required to prevent it.
        -: 3509:             */
    #####: 3510:            if (conns[i]->state != conn_closed) {
    #####: 3511:                conn_to_str(conns[i], conn_name);
        -: 3512:
    #####: 3513:                APPEND_NUM_STAT(i, "addr", "%s", conn_name);
    #####: 3514:                APPEND_NUM_STAT(i, "state", "%s",
    #####: 3515:                        state_text(conns[i]->state));
    #####: 3516:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
    #####: 3517:                        current_time - conns[i]->last_cmd_time);
        -: 3518:            }
        -: 3519:        }
        -: 3520:    }
    #####: 3521:}
------------------
process_stats_conns:
    #####: 3494:static void process_stats_conns(ADD_STAT add_stats, void *c) {
    #####: 3495:    int i;
    #####: 3496:    char key_str[STAT_KEY_LEN];
    #####: 3497:    char val_str[STAT_VAL_LEN];
    #####: 3498:    char conn_name[MAXPATHLEN + sizeof("unix:") + sizeof("65535")];
    #####: 3499:    int klen = 0, vlen = 0;
        -: 3500:
    #####: 3501:    assert(add_stats);
        -: 3502:
    #####: 3503:    for (i = 0; i < max_fds; i++) {
    #####: 3504:        if (conns[i]) {
        -: 3505:            /* This is safe to do unlocked because conns are never freed; the
        -: 3506:             * worst that'll happen will be a minor inconsistency in the
        -: 3507:             * output -- not worth the complexity of the locking that'd be
        -: 3508:             * required to prevent it.
        -: 3509:             */
    #####: 3510:            if (conns[i]->state != conn_closed) {
    #####: 3511:                conn_to_str(conns[i], conn_name);
        -: 3512:
    #####: 3513:                APPEND_NUM_STAT(i, "addr", "%s", conn_name);
    #####: 3514:                APPEND_NUM_STAT(i, "state", "%s",
    #####: 3515:                        state_text(conns[i]->state));
    #####: 3516:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
    #####: 3517:                        current_time - conns[i]->last_cmd_time);
        -: 3518:            }
        -: 3519:        }
        -: 3520:    }
    #####: 3521:}
------------------
process_stats_conns:
    #####: 3494:static void process_stats_conns(ADD_STAT add_stats, void *c) {
    #####: 3495:    int i;
    #####: 3496:    char key_str[STAT_KEY_LEN];
    #####: 3497:    char val_str[STAT_VAL_LEN];
    #####: 3498:    char conn_name[MAXPATHLEN + sizeof("unix:") + sizeof("65535")];
    #####: 3499:    int klen = 0, vlen = 0;
        -: 3500:
    #####: 3501:    assert(add_stats);
        -: 3502:
    #####: 3503:    for (i = 0; i < max_fds; i++) {
    #####: 3504:        if (conns[i]) {
        -: 3505:            /* This is safe to do unlocked because conns are never freed; the
        -: 3506:             * worst that'll happen will be a minor inconsistency in the
        -: 3507:             * output -- not worth the complexity of the locking that'd be
        -: 3508:             * required to prevent it.
        -: 3509:             */
    #####: 3510:            if (conns[i]->state != conn_closed) {
    #####: 3511:                conn_to_str(conns[i], conn_name);
        -: 3512:
    #####: 3513:                APPEND_NUM_STAT(i, "addr", "%s", conn_name);
    #####: 3514:                APPEND_NUM_STAT(i, "state", "%s",
    #####: 3515:                        state_text(conns[i]->state));
    #####: 3516:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
    #####: 3517:                        current_time - conns[i]->last_cmd_time);
        -: 3518:            }
        -: 3519:        }
        -: 3520:    }
    #####: 3521:}
------------------
process_stats_conns:
    #####: 3494:static void process_stats_conns(ADD_STAT add_stats, void *c) {
    #####: 3495:    int i;
    #####: 3496:    char key_str[STAT_KEY_LEN];
    #####: 3497:    char val_str[STAT_VAL_LEN];
    #####: 3498:    char conn_name[MAXPATHLEN + sizeof("unix:") + sizeof("65535")];
    #####: 3499:    int klen = 0, vlen = 0;
        -: 3500:
    #####: 3501:    assert(add_stats);
        -: 3502:
    #####: 3503:    for (i = 0; i < max_fds; i++) {
    #####: 3504:        if (conns[i]) {
        -: 3505:            /* This is safe to do unlocked because conns are never freed; the
        -: 3506:             * worst that'll happen will be a minor inconsistency in the
        -: 3507:             * output -- not worth the complexity of the locking that'd be
        -: 3508:             * required to prevent it.
        -: 3509:             */
    #####: 3510:            if (conns[i]->state != conn_closed) {
    #####: 3511:                conn_to_str(conns[i], conn_name);
        -: 3512:
    #####: 3513:                APPEND_NUM_STAT(i, "addr", "%s", conn_name);
    #####: 3514:                APPEND_NUM_STAT(i, "state", "%s",
    #####: 3515:                        state_text(conns[i]->state));
    #####: 3516:                APPEND_NUM_STAT(i, "secs_since_last_cmd", "%d",
    #####: 3517:                        current_time - conns[i]->last_cmd_time);
        -: 3518:            }
        -: 3519:        }
        -: 3520:    }
    #####: 3521:}
------------------
        -: 3522:#ifdef EXTSTORE
        -: 3523:static void process_extstore_stats(ADD_STAT add_stats, conn *c) {
        -: 3524:    int i;
        -: 3525:    char key_str[STAT_KEY_LEN];
        -: 3526:    char val_str[STAT_VAL_LEN];
        -: 3527:    int klen = 0, vlen = 0;
        -: 3528:    struct extstore_stats st;
        -: 3529:
        -: 3530:    assert(add_stats);
        -: 3531:
        -: 3532:    void *storage = c->thread->storage;
        -: 3533:    extstore_get_stats(storage, &st);
        -: 3534:    st.page_data = calloc(st.page_count, sizeof(struct extstore_page_data));
        -: 3535:    extstore_get_page_data(storage, &st);
        -: 3536:
        -: 3537:    for (i = 0; i < st.page_count; i++) {
        -: 3538:        APPEND_NUM_STAT(i, "version", "%llu",
        -: 3539:                (unsigned long long) st.page_data[i].version);
        -: 3540:        APPEND_NUM_STAT(i, "bytes", "%llu",
        -: 3541:                (unsigned long long) st.page_data[i].bytes_used);
        -: 3542:        APPEND_NUM_STAT(i, "bucket", "%u",
        -: 3543:                st.page_data[i].bucket);
        -: 3544:        APPEND_NUM_STAT(i, "free_bucket", "%u",
        -: 3545:                st.page_data[i].free_bucket);
        -: 3546:    }
        -: 3547:}
        -: 3548:#endif
    #####: 3549:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 3550:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    #####: 3551:    assert(c != NULL);
        -: 3552:
    #####: 3553:    if (ntokens < 2) {
    #####: 3554:        out_string(c, "CLIENT_ERROR bad command line");
    #####: 3555:        return;
        -: 3556:    }
        -: 3557:
    #####: 3558:    if (ntokens == 2) {
    #####: 3559:        server_stats(&append_stats, c);
    #####: 3560:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 3561:    } else if (strcmp(subcommand, "reset") == 0) {
    #####: 3562:        stats_reset();
    #####: 3563:        out_string(c, "RESET");
    #####: 3564:        return ;
    #####: 3565:    } else if (strcmp(subcommand, "detail") == 0) {
        -: 3566:        /* NOTE: how to tackle detail with binary? */
    #####: 3567:        if (ntokens < 4)
    #####: 3568:            process_stats_detail(c, "");  /* outputs the error message */
        -: 3569:        else
    #####: 3570:            process_stats_detail(c, tokens[2].value);
        -: 3571:        /* Output already generated */
    #####: 3572:        return ;
    #####: 3573:    } else if (strcmp(subcommand, "settings") == 0) {
    #####: 3574:        process_stat_settings(&append_stats, c);
    #####: 3575:    } else if (strcmp(subcommand, "cachedump") == 0) {
    #####: 3576:        char *buf;
    #####: 3577:        unsigned int bytes, id, limit = 0;
        -: 3578:
    #####: 3579:        if (!settings.dump_enabled) {
    #####: 3580:            out_string(c, "CLIENT_ERROR stats cachedump not allowed");
    #####: 3581:            return;
        -: 3582:        }
        -: 3583:
    #####: 3584:        if (ntokens < 5) {
    #####: 3585:            out_string(c, "CLIENT_ERROR bad command line");
    #####: 3586:            return;
        -: 3587:        }
        -: 3588:
    #####: 3589:        if (!safe_strtoul(tokens[2].value, &id) ||
    #####: 3590:            !safe_strtoul(tokens[3].value, &limit)) {
    #####: 3591:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3592:            return;
        -: 3593:        }
        -: 3594:
    #####: 3595:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####: 3596:            out_string(c, "CLIENT_ERROR Illegal slab id");
    #####: 3597:            return;
        -: 3598:        }
        -: 3599:
    #####: 3600:        buf = item_cachedump(id, limit, &bytes);
    #####: 3601:        write_and_free(c, buf, bytes);
    #####: 3602:        return ;
    #####: 3603:    } else if (strcmp(subcommand, "conns") == 0) {
    #####: 3604:        process_stats_conns(&append_stats, c);
        -: 3605:#ifdef EXTSTORE
        -: 3606:    } else if (strcmp(subcommand, "extstore") == 0) {
        -: 3607:        process_extstore_stats(&append_stats, c);
        -: 3608:#endif
        -: 3609:    } else {
        -: 3610:        /* getting here means that the subcommand is either engine specific or
        -: 3611:           is invalid. query the engine and see. */
    #####: 3612:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
    #####: 3613:            if (c->stats.buffer == NULL) {
    #####: 3614:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3615:            } else {
    #####: 3616:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3617:                c->stats.buffer = NULL;
        -: 3618:            }
        -: 3619:        } else {
    #####: 3620:            out_string(c, "ERROR");
        -: 3621:        }
    #####: 3622:        return ;
        -: 3623:    }
        -: 3624:
        -: 3625:    /* append terminator and start the transfer */
    #####: 3626:    append_stats(NULL, 0, NULL, 0, c);
        -: 3627:
    #####: 3628:    if (c->stats.buffer == NULL) {
    #####: 3629:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3630:    } else {
    #####: 3631:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3632:        c->stats.buffer = NULL;
        -: 3633:    }
        -: 3634:}
------------------
process_stat:
    #####: 3549:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 3550:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    #####: 3551:    assert(c != NULL);
        -: 3552:
    #####: 3553:    if (ntokens < 2) {
    #####: 3554:        out_string(c, "CLIENT_ERROR bad command line");
    #####: 3555:        return;
        -: 3556:    }
        -: 3557:
    #####: 3558:    if (ntokens == 2) {
    #####: 3559:        server_stats(&append_stats, c);
    #####: 3560:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 3561:    } else if (strcmp(subcommand, "reset") == 0) {
    #####: 3562:        stats_reset();
    #####: 3563:        out_string(c, "RESET");
    #####: 3564:        return ;
    #####: 3565:    } else if (strcmp(subcommand, "detail") == 0) {
        -: 3566:        /* NOTE: how to tackle detail with binary? */
    #####: 3567:        if (ntokens < 4)
    #####: 3568:            process_stats_detail(c, "");  /* outputs the error message */
        -: 3569:        else
    #####: 3570:            process_stats_detail(c, tokens[2].value);
        -: 3571:        /* Output already generated */
    #####: 3572:        return ;
    #####: 3573:    } else if (strcmp(subcommand, "settings") == 0) {
    #####: 3574:        process_stat_settings(&append_stats, c);
    #####: 3575:    } else if (strcmp(subcommand, "cachedump") == 0) {
    #####: 3576:        char *buf;
    #####: 3577:        unsigned int bytes, id, limit = 0;
        -: 3578:
    #####: 3579:        if (!settings.dump_enabled) {
    #####: 3580:            out_string(c, "CLIENT_ERROR stats cachedump not allowed");
    #####: 3581:            return;
        -: 3582:        }
        -: 3583:
    #####: 3584:        if (ntokens < 5) {
    #####: 3585:            out_string(c, "CLIENT_ERROR bad command line");
    #####: 3586:            return;
        -: 3587:        }
        -: 3588:
    #####: 3589:        if (!safe_strtoul(tokens[2].value, &id) ||
    #####: 3590:            !safe_strtoul(tokens[3].value, &limit)) {
    #####: 3591:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3592:            return;
        -: 3593:        }
        -: 3594:
    #####: 3595:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####: 3596:            out_string(c, "CLIENT_ERROR Illegal slab id");
    #####: 3597:            return;
        -: 3598:        }
        -: 3599:
    #####: 3600:        buf = item_cachedump(id, limit, &bytes);
    #####: 3601:        write_and_free(c, buf, bytes);
    #####: 3602:        return ;
    #####: 3603:    } else if (strcmp(subcommand, "conns") == 0) {
    #####: 3604:        process_stats_conns(&append_stats, c);
        -: 3605:#ifdef EXTSTORE
        -: 3606:    } else if (strcmp(subcommand, "extstore") == 0) {
        -: 3607:        process_extstore_stats(&append_stats, c);
        -: 3608:#endif
        -: 3609:    } else {
        -: 3610:        /* getting here means that the subcommand is either engine specific or
        -: 3611:           is invalid. query the engine and see. */
    #####: 3612:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
    #####: 3613:            if (c->stats.buffer == NULL) {
    #####: 3614:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3615:            } else {
    #####: 3616:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3617:                c->stats.buffer = NULL;
        -: 3618:            }
        -: 3619:        } else {
    #####: 3620:            out_string(c, "ERROR");
        -: 3621:        }
    #####: 3622:        return ;
        -: 3623:    }
        -: 3624:
        -: 3625:    /* append terminator and start the transfer */
    #####: 3626:    append_stats(NULL, 0, NULL, 0, c);
        -: 3627:
    #####: 3628:    if (c->stats.buffer == NULL) {
    #####: 3629:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3630:    } else {
    #####: 3631:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3632:        c->stats.buffer = NULL;
        -: 3633:    }
        -: 3634:}
------------------
process_stat:
    #####: 3549:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 3550:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    #####: 3551:    assert(c != NULL);
        -: 3552:
    #####: 3553:    if (ntokens < 2) {
    #####: 3554:        out_string(c, "CLIENT_ERROR bad command line");
    #####: 3555:        return;
        -: 3556:    }
        -: 3557:
    #####: 3558:    if (ntokens == 2) {
    #####: 3559:        server_stats(&append_stats, c);
    #####: 3560:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 3561:    } else if (strcmp(subcommand, "reset") == 0) {
    #####: 3562:        stats_reset();
    #####: 3563:        out_string(c, "RESET");
    #####: 3564:        return ;
    #####: 3565:    } else if (strcmp(subcommand, "detail") == 0) {
        -: 3566:        /* NOTE: how to tackle detail with binary? */
    #####: 3567:        if (ntokens < 4)
    #####: 3568:            process_stats_detail(c, "");  /* outputs the error message */
        -: 3569:        else
    #####: 3570:            process_stats_detail(c, tokens[2].value);
        -: 3571:        /* Output already generated */
    #####: 3572:        return ;
    #####: 3573:    } else if (strcmp(subcommand, "settings") == 0) {
    #####: 3574:        process_stat_settings(&append_stats, c);
    #####: 3575:    } else if (strcmp(subcommand, "cachedump") == 0) {
    #####: 3576:        char *buf;
    #####: 3577:        unsigned int bytes, id, limit = 0;
        -: 3578:
    #####: 3579:        if (!settings.dump_enabled) {
    #####: 3580:            out_string(c, "CLIENT_ERROR stats cachedump not allowed");
    #####: 3581:            return;
        -: 3582:        }
        -: 3583:
    #####: 3584:        if (ntokens < 5) {
    #####: 3585:            out_string(c, "CLIENT_ERROR bad command line");
    #####: 3586:            return;
        -: 3587:        }
        -: 3588:
    #####: 3589:        if (!safe_strtoul(tokens[2].value, &id) ||
    #####: 3590:            !safe_strtoul(tokens[3].value, &limit)) {
    #####: 3591:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3592:            return;
        -: 3593:        }
        -: 3594:
    #####: 3595:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####: 3596:            out_string(c, "CLIENT_ERROR Illegal slab id");
    #####: 3597:            return;
        -: 3598:        }
        -: 3599:
    #####: 3600:        buf = item_cachedump(id, limit, &bytes);
    #####: 3601:        write_and_free(c, buf, bytes);
    #####: 3602:        return ;
    #####: 3603:    } else if (strcmp(subcommand, "conns") == 0) {
    #####: 3604:        process_stats_conns(&append_stats, c);
        -: 3605:#ifdef EXTSTORE
        -: 3606:    } else if (strcmp(subcommand, "extstore") == 0) {
        -: 3607:        process_extstore_stats(&append_stats, c);
        -: 3608:#endif
        -: 3609:    } else {
        -: 3610:        /* getting here means that the subcommand is either engine specific or
        -: 3611:           is invalid. query the engine and see. */
    #####: 3612:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
    #####: 3613:            if (c->stats.buffer == NULL) {
    #####: 3614:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3615:            } else {
    #####: 3616:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3617:                c->stats.buffer = NULL;
        -: 3618:            }
        -: 3619:        } else {
    #####: 3620:            out_string(c, "ERROR");
        -: 3621:        }
    #####: 3622:        return ;
        -: 3623:    }
        -: 3624:
        -: 3625:    /* append terminator and start the transfer */
    #####: 3626:    append_stats(NULL, 0, NULL, 0, c);
        -: 3627:
    #####: 3628:    if (c->stats.buffer == NULL) {
    #####: 3629:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3630:    } else {
    #####: 3631:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3632:        c->stats.buffer = NULL;
        -: 3633:    }
        -: 3634:}
------------------
process_stat:
    #####: 3549:static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 3550:    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    #####: 3551:    assert(c != NULL);
        -: 3552:
    #####: 3553:    if (ntokens < 2) {
    #####: 3554:        out_string(c, "CLIENT_ERROR bad command line");
    #####: 3555:        return;
        -: 3556:    }
        -: 3557:
    #####: 3558:    if (ntokens == 2) {
    #####: 3559:        server_stats(&append_stats, c);
    #####: 3560:        (void)get_stats(NULL, 0, &append_stats, c);
    #####: 3561:    } else if (strcmp(subcommand, "reset") == 0) {
    #####: 3562:        stats_reset();
    #####: 3563:        out_string(c, "RESET");
    #####: 3564:        return ;
    #####: 3565:    } else if (strcmp(subcommand, "detail") == 0) {
        -: 3566:        /* NOTE: how to tackle detail with binary? */
    #####: 3567:        if (ntokens < 4)
    #####: 3568:            process_stats_detail(c, "");  /* outputs the error message */
        -: 3569:        else
    #####: 3570:            process_stats_detail(c, tokens[2].value);
        -: 3571:        /* Output already generated */
    #####: 3572:        return ;
    #####: 3573:    } else if (strcmp(subcommand, "settings") == 0) {
    #####: 3574:        process_stat_settings(&append_stats, c);
    #####: 3575:    } else if (strcmp(subcommand, "cachedump") == 0) {
    #####: 3576:        char *buf;
    #####: 3577:        unsigned int bytes, id, limit = 0;
        -: 3578:
    #####: 3579:        if (!settings.dump_enabled) {
    #####: 3580:            out_string(c, "CLIENT_ERROR stats cachedump not allowed");
    #####: 3581:            return;
        -: 3582:        }
        -: 3583:
    #####: 3584:        if (ntokens < 5) {
    #####: 3585:            out_string(c, "CLIENT_ERROR bad command line");
    #####: 3586:            return;
        -: 3587:        }
        -: 3588:
    #####: 3589:        if (!safe_strtoul(tokens[2].value, &id) ||
    #####: 3590:            !safe_strtoul(tokens[3].value, &limit)) {
    #####: 3591:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 3592:            return;
        -: 3593:        }
        -: 3594:
    #####: 3595:        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
    #####: 3596:            out_string(c, "CLIENT_ERROR Illegal slab id");
    #####: 3597:            return;
        -: 3598:        }
        -: 3599:
    #####: 3600:        buf = item_cachedump(id, limit, &bytes);
    #####: 3601:        write_and_free(c, buf, bytes);
    #####: 3602:        return ;
    #####: 3603:    } else if (strcmp(subcommand, "conns") == 0) {
    #####: 3604:        process_stats_conns(&append_stats, c);
        -: 3605:#ifdef EXTSTORE
        -: 3606:    } else if (strcmp(subcommand, "extstore") == 0) {
        -: 3607:        process_extstore_stats(&append_stats, c);
        -: 3608:#endif
        -: 3609:    } else {
        -: 3610:        /* getting here means that the subcommand is either engine specific or
        -: 3611:           is invalid. query the engine and see. */
    #####: 3612:        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
    #####: 3613:            if (c->stats.buffer == NULL) {
    #####: 3614:                out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3615:            } else {
    #####: 3616:                write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3617:                c->stats.buffer = NULL;
        -: 3618:            }
        -: 3619:        } else {
    #####: 3620:            out_string(c, "ERROR");
        -: 3621:        }
    #####: 3622:        return ;
        -: 3623:    }
        -: 3624:
        -: 3625:    /* append terminator and start the transfer */
    #####: 3626:    append_stats(NULL, 0, NULL, 0, c);
        -: 3627:
    #####: 3628:    if (c->stats.buffer == NULL) {
    #####: 3629:        out_of_memory(c, "SERVER_ERROR out of memory writing stats");
        -: 3630:    } else {
    #####: 3631:        write_and_free(c, c->stats.buffer, c->stats.offset);
    #####: 3632:        c->stats.buffer = NULL;
        -: 3633:    }
        -: 3634:}
------------------
        -: 3635:
        -: 3636:/* client flags == 0 means use no storage for client flags */
    #####: 3637:static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    #####: 3638:    char *p = suffix;
    #####: 3639:    *p = ' ';
    #####: 3640:    p++;
    #####: 3641:    if (FLAGS_SIZE(it) == 0) {
    #####: 3642:        *p = '0';
    #####: 3643:        p++;
        -: 3644:    } else {
    #####: 3645:        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
        -: 3646:    }
    #####: 3647:    *p = ' ';
    #####: 3648:    p = itoa_u32(nbytes-2, p+1);
        -: 3649:
    #####: 3650:    if (return_cas) {
    #####: 3651:        *p = ' ';
    #####: 3652:        p = itoa_u64(ITEM_get_cas(it), p+1);
        -: 3653:    }
        -: 3654:
    #####: 3655:    *p = '\r';
    #####: 3656:    *(p+1) = '\n';
    #####: 3657:    *(p+2) = '\0';
    #####: 3658:    return (p - suffix) + 2;
        -: 3659:}
------------------
make_ascii_get_suffix:
    #####: 3637:static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    #####: 3638:    char *p = suffix;
    #####: 3639:    *p = ' ';
    #####: 3640:    p++;
    #####: 3641:    if (FLAGS_SIZE(it) == 0) {
    #####: 3642:        *p = '0';
    #####: 3643:        p++;
        -: 3644:    } else {
    #####: 3645:        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
        -: 3646:    }
    #####: 3647:    *p = ' ';
    #####: 3648:    p = itoa_u32(nbytes-2, p+1);
        -: 3649:
    #####: 3650:    if (return_cas) {
    #####: 3651:        *p = ' ';
    #####: 3652:        p = itoa_u64(ITEM_get_cas(it), p+1);
        -: 3653:    }
        -: 3654:
    #####: 3655:    *p = '\r';
    #####: 3656:    *(p+1) = '\n';
    #####: 3657:    *(p+2) = '\0';
    #####: 3658:    return (p - suffix) + 2;
        -: 3659:}
------------------
make_ascii_get_suffix:
    #####: 3637:static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    #####: 3638:    char *p = suffix;
    #####: 3639:    *p = ' ';
    #####: 3640:    p++;
    #####: 3641:    if (FLAGS_SIZE(it) == 0) {
    #####: 3642:        *p = '0';
    #####: 3643:        p++;
        -: 3644:    } else {
    #####: 3645:        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
        -: 3646:    }
    #####: 3647:    *p = ' ';
    #####: 3648:    p = itoa_u32(nbytes-2, p+1);
        -: 3649:
    #####: 3650:    if (return_cas) {
    #####: 3651:        *p = ' ';
    #####: 3652:        p = itoa_u64(ITEM_get_cas(it), p+1);
        -: 3653:    }
        -: 3654:
    #####: 3655:    *p = '\r';
    #####: 3656:    *(p+1) = '\n';
    #####: 3657:    *(p+2) = '\0';
    #####: 3658:    return (p - suffix) + 2;
        -: 3659:}
------------------
make_ascii_get_suffix:
    #####: 3637:static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    #####: 3638:    char *p = suffix;
    #####: 3639:    *p = ' ';
    #####: 3640:    p++;
    #####: 3641:    if (FLAGS_SIZE(it) == 0) {
    #####: 3642:        *p = '0';
    #####: 3643:        p++;
        -: 3644:    } else {
    #####: 3645:        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
        -: 3646:    }
    #####: 3647:    *p = ' ';
    #####: 3648:    p = itoa_u32(nbytes-2, p+1);
        -: 3649:
    #####: 3650:    if (return_cas) {
    #####: 3651:        *p = ' ';
    #####: 3652:        p = itoa_u64(ITEM_get_cas(it), p+1);
        -: 3653:    }
        -: 3654:
    #####: 3655:    *p = '\r';
    #####: 3656:    *(p+1) = '\n';
    #####: 3657:    *(p+2) = '\0';
    #####: 3658:    return (p - suffix) + 2;
        -: 3659:}
------------------
        -: 3660:
        -: 3661:#define IT_REFCOUNT_LIMIT 60000
    #####: 3662:static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {
    #####: 3663:    item *it;
    #####: 3664:    if (should_touch) {
    #####: 3665:        it = item_touch(key, nkey, exptime, c);
        -: 3666:    } else {
    #####: 3667:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 3668:    }
    #####: 3669:    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
    #####: 3670:        item_remove(it);
    #####: 3671:        it = NULL;
        -: 3672:    }
    #####: 3673:    return it;
        -: 3674:}
------------------
limited_get:
    #####: 3662:static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {
    #####: 3663:    item *it;
    #####: 3664:    if (should_touch) {
    #####: 3665:        it = item_touch(key, nkey, exptime, c);
        -: 3666:    } else {
    #####: 3667:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 3668:    }
    #####: 3669:    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
    #####: 3670:        item_remove(it);
    #####: 3671:        it = NULL;
        -: 3672:    }
    #####: 3673:    return it;
        -: 3674:}
------------------
limited_get:
    #####: 3662:static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {
    #####: 3663:    item *it;
    #####: 3664:    if (should_touch) {
    #####: 3665:        it = item_touch(key, nkey, exptime, c);
        -: 3666:    } else {
    #####: 3667:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 3668:    }
    #####: 3669:    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
    #####: 3670:        item_remove(it);
    #####: 3671:        it = NULL;
        -: 3672:    }
    #####: 3673:    return it;
        -: 3674:}
------------------
limited_get:
    #####: 3662:static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {
    #####: 3663:    item *it;
    #####: 3664:    if (should_touch) {
    #####: 3665:        it = item_touch(key, nkey, exptime, c);
        -: 3666:    } else {
    #####: 3667:        it = item_get(key, nkey, c, DO_UPDATE);
        -: 3668:    }
    #####: 3669:    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
    #####: 3670:        item_remove(it);
    #####: 3671:        it = NULL;
        -: 3672:    }
    #####: 3673:    return it;
        -: 3674:}
------------------
        -: 3675:
    #####: 3676:static inline int _ascii_get_expand_ilist(conn *c, int i) {
    #####: 3677:    if (i >= c->isize) {
    #####: 3678:        item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
    #####: 3679:        if (new_list) {
    #####: 3680:            c->isize *= 2;
    #####: 3681:            c->ilist = new_list;
        -: 3682:        } else {
    #####: 3683:            STATS_LOCK();
    #####: 3684:            stats.malloc_fails++;
    #####: 3685:            STATS_UNLOCK();
    #####: 3686:            return -1;
        -: 3687:        }
        -: 3688:    }
        -: 3689:    return 0;
        -: 3690:}
------------------
_ascii_get_expand_ilist:
    #####: 3676:static inline int _ascii_get_expand_ilist(conn *c, int i) {
    #####: 3677:    if (i >= c->isize) {
    #####: 3678:        item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
    #####: 3679:        if (new_list) {
    #####: 3680:            c->isize *= 2;
    #####: 3681:            c->ilist = new_list;
        -: 3682:        } else {
    #####: 3683:            STATS_LOCK();
    #####: 3684:            stats.malloc_fails++;
    #####: 3685:            STATS_UNLOCK();
    #####: 3686:            return -1;
        -: 3687:        }
        -: 3688:    }
        -: 3689:    return 0;
        -: 3690:}
------------------
_ascii_get_expand_ilist:
    #####: 3676:static inline int _ascii_get_expand_ilist(conn *c, int i) {
    #####: 3677:    if (i >= c->isize) {
    #####: 3678:        item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
    #####: 3679:        if (new_list) {
    #####: 3680:            c->isize *= 2;
    #####: 3681:            c->ilist = new_list;
        -: 3682:        } else {
    #####: 3683:            STATS_LOCK();
    #####: 3684:            stats.malloc_fails++;
    #####: 3685:            STATS_UNLOCK();
    #####: 3686:            return -1;
        -: 3687:        }
        -: 3688:    }
        -: 3689:    return 0;
        -: 3690:}
------------------
_ascii_get_expand_ilist:
    #####: 3676:static inline int _ascii_get_expand_ilist(conn *c, int i) {
    #####: 3677:    if (i >= c->isize) {
    #####: 3678:        item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
    #####: 3679:        if (new_list) {
    #####: 3680:            c->isize *= 2;
    #####: 3681:            c->ilist = new_list;
        -: 3682:        } else {
    #####: 3683:            STATS_LOCK();
    #####: 3684:            stats.malloc_fails++;
    #####: 3685:            STATS_UNLOCK();
    #####: 3686:            return -1;
        -: 3687:        }
        -: 3688:    }
        -: 3689:    return 0;
        -: 3690:}
------------------
        -: 3691:
    #####: 3692:static inline char *_ascii_get_suffix_buf(conn *c, int i) {
    #####: 3693:    char *suffix;
        -: 3694:    /* Goofy mid-flight realloc. */
    #####: 3695:    if (i >= c->suffixsize) {
    #####: 3696:    char **new_suffix_list = realloc(c->suffixlist,
    #####: 3697:                           sizeof(char *) * c->suffixsize * 2);
    #####: 3698:    if (new_suffix_list) {
    #####: 3699:        c->suffixsize *= 2;
    #####: 3700:        c->suffixlist  = new_suffix_list;
        -: 3701:    } else {
    #####: 3702:        STATS_LOCK();
    #####: 3703:        stats.malloc_fails++;
    #####: 3704:        STATS_UNLOCK();
    #####: 3705:        return NULL;
        -: 3706:    }
        -: 3707:    }
        -: 3708:
    #####: 3709:    suffix = do_cache_alloc(c->thread->suffix_cache);
    #####: 3710:    if (suffix == NULL) {
    #####: 3711:      STATS_LOCK();
    #####: 3712:      stats.malloc_fails++;
    #####: 3713:      STATS_UNLOCK();
    #####: 3714:      out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
    #####: 3715:      return NULL;
        -: 3716:    }
    #####: 3717:    *(c->suffixlist + i) = suffix;
    #####: 3718:    return suffix;
        -: 3719:}
------------------
_ascii_get_suffix_buf:
    #####: 3692:static inline char *_ascii_get_suffix_buf(conn *c, int i) {
    #####: 3693:    char *suffix;
        -: 3694:    /* Goofy mid-flight realloc. */
    #####: 3695:    if (i >= c->suffixsize) {
    #####: 3696:    char **new_suffix_list = realloc(c->suffixlist,
    #####: 3697:                           sizeof(char *) * c->suffixsize * 2);
    #####: 3698:    if (new_suffix_list) {
    #####: 3699:        c->suffixsize *= 2;
    #####: 3700:        c->suffixlist  = new_suffix_list;
        -: 3701:    } else {
    #####: 3702:        STATS_LOCK();
    #####: 3703:        stats.malloc_fails++;
    #####: 3704:        STATS_UNLOCK();
    #####: 3705:        return NULL;
        -: 3706:    }
        -: 3707:    }
        -: 3708:
    #####: 3709:    suffix = do_cache_alloc(c->thread->suffix_cache);
    #####: 3710:    if (suffix == NULL) {
    #####: 3711:      STATS_LOCK();
    #####: 3712:      stats.malloc_fails++;
    #####: 3713:      STATS_UNLOCK();
    #####: 3714:      out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
    #####: 3715:      return NULL;
        -: 3716:    }
    #####: 3717:    *(c->suffixlist + i) = suffix;
    #####: 3718:    return suffix;
        -: 3719:}
------------------
_ascii_get_suffix_buf:
    #####: 3692:static inline char *_ascii_get_suffix_buf(conn *c, int i) {
    #####: 3693:    char *suffix;
        -: 3694:    /* Goofy mid-flight realloc. */
    #####: 3695:    if (i >= c->suffixsize) {
    #####: 3696:    char **new_suffix_list = realloc(c->suffixlist,
    #####: 3697:                           sizeof(char *) * c->suffixsize * 2);
    #####: 3698:    if (new_suffix_list) {
    #####: 3699:        c->suffixsize *= 2;
    #####: 3700:        c->suffixlist  = new_suffix_list;
        -: 3701:    } else {
    #####: 3702:        STATS_LOCK();
    #####: 3703:        stats.malloc_fails++;
    #####: 3704:        STATS_UNLOCK();
    #####: 3705:        return NULL;
        -: 3706:    }
        -: 3707:    }
        -: 3708:
    #####: 3709:    suffix = do_cache_alloc(c->thread->suffix_cache);
    #####: 3710:    if (suffix == NULL) {
    #####: 3711:      STATS_LOCK();
    #####: 3712:      stats.malloc_fails++;
    #####: 3713:      STATS_UNLOCK();
    #####: 3714:      out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
    #####: 3715:      return NULL;
        -: 3716:    }
    #####: 3717:    *(c->suffixlist + i) = suffix;
    #####: 3718:    return suffix;
        -: 3719:}
------------------
_ascii_get_suffix_buf:
    #####: 3692:static inline char *_ascii_get_suffix_buf(conn *c, int i) {
    #####: 3693:    char *suffix;
        -: 3694:    /* Goofy mid-flight realloc. */
    #####: 3695:    if (i >= c->suffixsize) {
    #####: 3696:    char **new_suffix_list = realloc(c->suffixlist,
    #####: 3697:                           sizeof(char *) * c->suffixsize * 2);
    #####: 3698:    if (new_suffix_list) {
    #####: 3699:        c->suffixsize *= 2;
    #####: 3700:        c->suffixlist  = new_suffix_list;
        -: 3701:    } else {
    #####: 3702:        STATS_LOCK();
    #####: 3703:        stats.malloc_fails++;
    #####: 3704:        STATS_UNLOCK();
    #####: 3705:        return NULL;
        -: 3706:    }
        -: 3707:    }
        -: 3708:
    #####: 3709:    suffix = do_cache_alloc(c->thread->suffix_cache);
    #####: 3710:    if (suffix == NULL) {
    #####: 3711:      STATS_LOCK();
    #####: 3712:      stats.malloc_fails++;
    #####: 3713:      STATS_UNLOCK();
    #####: 3714:      out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
    #####: 3715:      return NULL;
        -: 3716:    }
    #####: 3717:    *(c->suffixlist + i) = suffix;
    #####: 3718:    return suffix;
        -: 3719:}
------------------
        -: 3720:#ifdef EXTSTORE
        -: 3721:// FIXME: This runs in the IO thread. to get better IO performance this should
        -: 3722:// simply mark the io wrapper with the return value and decrement wrapleft, if
        -: 3723:// zero redispatching. Still a bit of work being done in the side thread but
        -: 3724:// minimized at least.
        -: 3725:static void _get_extstore_cb(void *e, obj_io *io, int ret) {
        -: 3726:    // FIXME: assumes success
        -: 3727:    io_wrap *wrap = (io_wrap *)io->data;
        -: 3728:    conn *c = wrap->c;
        -: 3729:    assert(wrap->active == true);
        -: 3730:    item *read_it = (item *)io->buf;
        -: 3731:    bool miss = false;
        -: 3732:
        -: 3733:    // TODO: How to do counters for hit/misses?
        -: 3734:    if (ret < 1) {
        -: 3735:        miss = true;
        -: 3736:    } else {
        -: 3737:        uint32_t crc2;
        -: 3738:        uint32_t crc = (uint32_t) read_it->exptime;
        -: 3739:        int x;
        -: 3740:        // item is chunked, crc the iov's
        -: 3741:        if (io->iov != NULL) {
        -: 3742:            // first iov is the header, which we don't use beyond crc
        -: 3743:            crc2 = crc32c(0, (char *)io->iov[0].iov_base+STORE_OFFSET, io->iov[0].iov_len-STORE_OFFSET);
        -: 3744:            // make sure it's not sent. hack :(
        -: 3745:            io->iov[0].iov_len = 0;
        -: 3746:            for (x = 1; x < io->iovcnt; x++) {
        -: 3747:                crc2 = crc32c(crc2, (char *)io->iov[x].iov_base, io->iov[x].iov_len);
        -: 3748:            }
        -: 3749:        } else {
        -: 3750:            crc2 = crc32c(0, (char *)read_it+STORE_OFFSET, io->len-STORE_OFFSET);
        -: 3751:        }
        -: 3752:
        -: 3753:        if (crc != crc2) {
        -: 3754:            miss = true;
        -: 3755:            wrap->badcrc = true;
        -: 3756:        }
        -: 3757:    }
        -: 3758:
        -: 3759:    if (miss) {
        -: 3760:        int i;
        -: 3761:        struct iovec *v;
        -: 3762:        // TODO: This should be movable to the worker thread.
        -: 3763:        if (c->protocol == binary_prot) {
        -: 3764:            protocol_binary_response_header *header =
        -: 3765:                (protocol_binary_response_header *)c->wbuf;
        -: 3766:            // this zeroes out the iovecs since binprot never stacks them.
        -: 3767:            if (header->response.keylen) {
        -: 3768:                write_bin_miss_response(c, ITEM_key(wrap->hdr_it), wrap->hdr_it->nkey);
        -: 3769:            } else {
        -: 3770:                write_bin_miss_response(c, 0, 0);
        -: 3771:            }
        -: 3772:        } else {
        -: 3773:            for (i = 0; i < wrap->iovec_count; i++) {
        -: 3774:                v = &c->iov[wrap->iovec_start + i];
        -: 3775:                v->iov_len = 0;
        -: 3776:                v->iov_base = NULL;
        -: 3777:            }
        -: 3778:        }
        -: 3779:        wrap->miss = true;
        -: 3780:    } else {
        -: 3781:        assert(read_it->slabs_clsid != 0);
        -: 3782:        // kill \r\n for binprot
        -: 3783:        if (io->iov == NULL) {
        -: 3784:            c->iov[wrap->iovec_data].iov_base = ITEM_data(read_it);
        -: 3785:            if (c->protocol == binary_prot)
        -: 3786:                c->iov[wrap->iovec_data].iov_len -= 2;
        -: 3787:        } else {
        -: 3788:            // FIXME: Might need to go back and ensure chunked binprots don't
        -: 3789:            // ever span two chunks for the final \r\n
        -: 3790:            if (c->protocol == binary_prot) {
        -: 3791:                if (io->iov[io->iovcnt-1].iov_len >= 2) {
        -: 3792:                    io->iov[io->iovcnt-1].iov_len -= 2;
        -: 3793:                } else {
        -: 3794:                    io->iov[io->iovcnt-1].iov_len = 0;
        -: 3795:                    io->iov[io->iovcnt-2].iov_len -= 1;
        -: 3796:                }
        -: 3797:            }
        -: 3798:        }
        -: 3799:        wrap->miss = false;
        -: 3800:        // iov_len is already set
        -: 3801:        // TODO: Should do that here instead and cuddle in the wrap object
        -: 3802:    }
        -: 3803:    c->io_wrapleft--;
        -: 3804:    wrap->active = false;
        -: 3805:    //assert(c->io_wrapleft >= 0);
        -: 3806:
        -: 3807:    // All IO's have returned, lets re-attach this connection to our original
        -: 3808:    // thread.
        -: 3809:    if (c->io_wrapleft == 0) {
        -: 3810:        assert(c->io_queued == true);
        -: 3811:        c->io_queued = false;
        -: 3812:        redispatch_conn(c);
        -: 3813:    }
        -: 3814:}
        -: 3815:
        -: 3816:// FIXME: This completely breaks UDP support.
        -: 3817:static inline int _get_extstore(conn *c, item *it, int iovst, int iovcnt) {
        -: 3818:#ifdef NEED_ALIGN
        -: 3819:    item_hdr hdr;
        -: 3820:    memcpy(&hdr, ITEM_data(it), sizeof(hdr));
        -: 3821:#else
        -: 3822:    item_hdr *hdr = (item_hdr *)ITEM_data(it);
        -: 3823:#endif
        -: 3824:    size_t ntotal = ITEM_ntotal(it);
        -: 3825:    unsigned int clsid = slabs_clsid(ntotal);
        -: 3826:    item *new_it;
        -: 3827:    bool chunked = false;
        -: 3828:    if (ntotal > settings.slab_chunk_size_max) {
        -: 3829:        // Pull a chunked item header.
        -: 3830:        uint32_t flags;
        -: 3831:        FLAGS_CONV(it, flags);
        -: 3832:        new_it = item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, it->nbytes);
        -: 3833:        assert(new_it == NULL || (new_it->it_flags & ITEM_CHUNKED));
        -: 3834:        chunked = true;
        -: 3835:    } else {
        -: 3836:        new_it = do_item_alloc_pull(ntotal, clsid);
        -: 3837:    }
        -: 3838:    if (new_it == NULL)
        -: 3839:        return -1;
        -: 3840:    assert(!c->io_queued); // FIXME: debugging.
        -: 3841:    // so we can free the chunk on a miss
        -: 3842:    new_it->slabs_clsid = clsid;
        -: 3843:
        -: 3844:    io_wrap *io = do_cache_alloc(c->thread->io_cache);
        -: 3845:    io->active = true;
        -: 3846:    io->miss = false;
        -: 3847:    io->badcrc = false;
        -: 3848:    // io_wrap owns the reference for this object now.
        -: 3849:    io->hdr_it = it;
        -: 3850:
        -: 3851:    // FIXME: error handling.
        -: 3852:    // The offsets we'll wipe on a miss.
        -: 3853:    io->iovec_start = iovst;
        -: 3854:    io->iovec_count = iovcnt;
        -: 3855:    // This is probably super dangerous. keep it at 0 and fill into wrap
        -: 3856:    // object?
        -: 3857:    if (chunked) {
        -: 3858:        unsigned int ciovcnt = 1;
        -: 3859:        size_t remain = new_it->nbytes;
        -: 3860:        item_chunk *chunk = (item_chunk *) ITEM_schunk(new_it);
        -: 3861:        io->io.iov = &c->iov[c->iovused];
        -: 3862:        // fill the header so we can get the full data + crc back.
        -: 3863:        add_iov(c, new_it, ITEM_ntotal(new_it) - new_it->nbytes);
        -: 3864:        while (remain > 0) {
        -: 3865:            chunk = do_item_alloc_chunk(chunk, remain);
        -: 3866:            if (chunk == NULL) {
        -: 3867:                item_remove(new_it);
        -: 3868:                do_cache_free(c->thread->io_cache, io);
        -: 3869:                return -1;
        -: 3870:            }
        -: 3871:            add_iov(c, chunk->data, (remain < chunk->size) ? remain : chunk->size);
        -: 3872:            chunk->used = (remain < chunk->size) ? remain : chunk->size;
        -: 3873:            remain -= chunk->size;
        -: 3874:            ciovcnt++;
        -: 3875:        }
        -: 3876:        io->io.iovcnt = ciovcnt;
        -: 3877:        // header object was already accounted for, remove one from total
        -: 3878:        io->iovec_count += ciovcnt-1;
        -: 3879:    } else {
        -: 3880:        io->io.iov = NULL;
        -: 3881:        io->iovec_data = c->iovused;
        -: 3882:        add_iov(c, "", it->nbytes);
        -: 3883:    }
        -: 3884:    io->io.buf = (void *)new_it;
        -: 3885:    // The offset we'll fill in on a hit.
        -: 3886:    io->c = c;
        -: 3887:    // We need to stack the sub-struct IO's together as well.
        -: 3888:    if (c->io_wraplist) {
        -: 3889:        io->io.next = &c->io_wraplist->io;
        -: 3890:    } else {
        -: 3891:        io->io.next = NULL;
        -: 3892:    }
        -: 3893:    // IO queue for this connection.
        -: 3894:    io->next = c->io_wraplist;
        -: 3895:    c->io_wraplist = io;
        -: 3896:    assert(c->io_wrapleft >= 0);
        -: 3897:    c->io_wrapleft++;
        -: 3898:    // reference ourselves for the callback.
        -: 3899:    io->io.data = (void *)io;
        -: 3900:
        -: 3901:    // Now, fill in io->io based on what was in our header.
        -: 3902:#ifdef NEED_ALIGN
        -: 3903:    io->io.page_version = hdr.page_version;
        -: 3904:    io->io.page_id = hdr.page_id;
        -: 3905:    io->io.offset = hdr.offset;
        -: 3906:#else
        -: 3907:    io->io.page_version = hdr->page_version;
        -: 3908:    io->io.page_id = hdr->page_id;
        -: 3909:    io->io.offset = hdr->offset;
        -: 3910:#endif
        -: 3911:    io->io.len = ntotal;
        -: 3912:    io->io.mode = OBJ_IO_READ;
        -: 3913:    io->io.cb = _get_extstore_cb;
        -: 3914:
        -: 3915:    //fprintf(stderr, "EXTSTORE: IO stacked %u\n", io->iovec_data);
        -: 3916:    // FIXME: This stat needs to move to reflect # of flash hits vs misses
        -: 3917:    // for now it's a good gauge on how often we request out to flash at
        -: 3918:    // least.
        -: 3919:    pthread_mutex_lock(&c->thread->stats.mutex);
        -: 3920:    c->thread->stats.get_extstore++;
        -: 3921:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 3922:
        -: 3923:    return 0;
        -: 3924:}
        -: 3925:#endif
        -: 3926:/* ntokens is overwritten here... shrug.. */
    #####: 3927:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
    #####: 3928:    char *key;
    #####: 3929:    size_t nkey;
    #####: 3930:    int i = 0;
    #####: 3931:    int si = 0;
    #####: 3932:    item *it;
    #####: 3933:    token_t *key_token = &tokens[KEY_TOKEN];
    #####: 3934:    char *suffix;
    #####: 3935:    int32_t exptime_int = 0;
    #####: 3936:    rel_time_t exptime = 0;
    #####: 3937:    bool fail_length = false;
    #####: 3938:    assert(c != NULL);
        -: 3939:
    #####: 3940:    if (should_touch) {
        -: 3941:        // For get and touch commands, use first token as exptime
    #####: 3942:        if (!safe_strtol(tokens[1].value, &exptime_int)) {
    #####: 3943:            out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 3944:            return;
        -: 3945:        }
    #####: 3946:        key_token++;
    #####: 3947:        exptime = realtime(exptime_int);
        -: 3948:    }
        -: 3949:
        -: 3950:    do {
    #####: 3951:        while(key_token->length != 0) {
        -: 3952:
    #####: 3953:            key = key_token->value;
    #####: 3954:            nkey = key_token->length;
        -: 3955:
    #####: 3956:            if (nkey > KEY_MAX_LENGTH) {
    #####: 3957:                fail_length = true;
    #####: 3958:                goto stop;
        -: 3959:            }
        -: 3960:
    #####: 3961:            it = limited_get(key, nkey, c, exptime, should_touch);
    #####: 3962:            if (settings.detail_enabled) {
    #####: 3963:                stats_prefix_record_get(key, nkey, NULL != it);
        -: 3964:            }
    #####: 3965:            if (it) {
    #####: 3966:                if (_ascii_get_expand_ilist(c, i) != 0) {
    #####: 3967:                    item_remove(it);
    #####: 3968:                    goto stop;
        -: 3969:                }
        -: 3970:
        -: 3971:                /*
        -: 3972:                 * Construct the response. Each hit adds three elements to the
        -: 3973:                 * outgoing data list:
        -: 3974:                 *   "VALUE "
        -: 3975:                 *   key
        -: 3976:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -: 3977:                 */
        -: 3978:
        -: 3979:                {
        -: 3980:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 3981:                                        it->nbytes, ITEM_get_cas(it));
    #####: 3982:                  int nbytes;
    #####: 3983:                  suffix = _ascii_get_suffix_buf(c, si);
    #####: 3984:                  if (suffix == NULL) {
    #####: 3985:                      item_remove(it);
    #####: 3986:                      goto stop;
        -: 3987:                  }
    #####: 3988:                  si++;
    #####: 3989:                  nbytes = it->nbytes;
    #####: 3990:                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes);
    #####: 3991:                  if (add_iov(c, "VALUE ", 6) != 0 ||
    #####: 3992:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
    #####: 3993:                      add_iov(c, suffix, suffix_len) != 0)
        -: 3994:                      {
    #####: 3995:                          item_remove(it);
    #####: 3996:                          goto stop;
        -: 3997:                      }
        -: 3998:#ifdef EXTSTORE
        -: 3999:                  if (it->it_flags & ITEM_HDR) {
        -: 4000:                      if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
        -: 4001:                          pthread_mutex_lock(&c->thread->stats.mutex);
        -: 4002:                          c->thread->stats.get_oom_extstore++;
        -: 4003:                          pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4004:
        -: 4005:                          item_remove(it);
        -: 4006:                          goto stop;
        -: 4007:                      }
        -: 4008:                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4009:#else
    #####: 4010:                  if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4011:#endif
    #####: 4012:                      add_iov(c, ITEM_data(it), it->nbytes);
    #####: 4013:                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 4014:                      item_remove(it);
    #####: 4015:                      goto stop;
        -: 4016:                  }
        -: 4017:                }
        -: 4018:
    #####: 4019:                if (settings.verbose > 1) {
    #####: 4020:                    int ii;
    #####: 4021:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####: 4022:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####: 4023:                        fprintf(stderr, "%c", key[ii]);
        -: 4024:                    }
    #####: 4025:                    fprintf(stderr, "\n");
        -: 4026:                }
        -: 4027:
        -: 4028:                /* item_get() has incremented it->refcount for us */
    #####: 4029:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4030:                if (should_touch) {
    #####: 4031:                    c->thread->stats.touch_cmds++;
    #####: 4032:                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 4033:                } else {
    #####: 4034:                    c->thread->stats.lru_hits[it->slabs_clsid]++;
    #####: 4035:                    c->thread->stats.get_cmds++;
        -: 4036:                }
    #####: 4037:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4038:#ifdef EXTSTORE
        -: 4039:                /* If ITEM_HDR, an io_wrap owns the reference. */
        -: 4040:                if ((it->it_flags & ITEM_HDR) == 0) {
        -: 4041:                    *(c->ilist + i) = it;
        -: 4042:                    i++;
        -: 4043:                }
        -: 4044:#else
    #####: 4045:                *(c->ilist + i) = it;
    #####: 4046:                i++;
        -: 4047:#endif
        -: 4048:            } else {
    #####: 4049:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4050:                if (should_touch) {
    #####: 4051:                    c->thread->stats.touch_cmds++;
    #####: 4052:                    c->thread->stats.touch_misses++;
        -: 4053:                } else {
    #####: 4054:                    c->thread->stats.get_misses++;
    #####: 4055:                    c->thread->stats.get_cmds++;
        -: 4056:                }
    #####: 4057:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
    #####: 4058:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4059:            }
        -: 4060:
    #####: 4061:            key_token++;
        -: 4062:        }
        -: 4063:
        -: 4064:        /*
        -: 4065:         * If the command string hasn't been fully processed, get the next set
        -: 4066:         * of tokens.
        -: 4067:         */
    #####: 4068:        if(key_token->value != NULL) {
    #####: 4069:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
    #####: 4070:            key_token = tokens;
        -: 4071:        }
        -: 4072:
    #####: 4073:    } while(key_token->value != NULL);
    #####: 4074:stop:
        -: 4075:
    #####: 4076:    c->icurr = c->ilist;
    #####: 4077:    c->ileft = i;
    #####: 4078:    c->suffixcurr = c->suffixlist;
    #####: 4079:    c->suffixleft = si;
        -: 4080:
    #####: 4081:    if (settings.verbose > 1)
    #####: 4082:        fprintf(stderr, ">%d END\n", c->sfd);
        -: 4083:
        -: 4084:    /*
        -: 4085:        If the loop was terminated because of out-of-memory, it is not
        -: 4086:        reliable to add END\r\n to the buffer, because it might not end
        -: 4087:        in \r\n. So we send SERVER_ERROR instead.
        -: 4088:    */
    #####: 4089:    if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
    #####: 4090:        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
    #####: 4091:        if (fail_length) {
    #####: 4092:            out_string(c, "CLIENT_ERROR bad command line format");
        -: 4093:        } else {
    #####: 4094:            out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -: 4095:        }
    #####: 4096:        conn_release_items(c);
        -: 4097:    }
        -: 4098:    else {
    #####: 4099:        conn_set_state(c, conn_mwrite);
    #####: 4100:        c->msgcurr = 0;
        -: 4101:    }
        -: 4102:}
------------------
process_get_command:
    #####: 3927:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
    #####: 3928:    char *key;
    #####: 3929:    size_t nkey;
    #####: 3930:    int i = 0;
    #####: 3931:    int si = 0;
    #####: 3932:    item *it;
    #####: 3933:    token_t *key_token = &tokens[KEY_TOKEN];
    #####: 3934:    char *suffix;
    #####: 3935:    int32_t exptime_int = 0;
    #####: 3936:    rel_time_t exptime = 0;
    #####: 3937:    bool fail_length = false;
    #####: 3938:    assert(c != NULL);
        -: 3939:
    #####: 3940:    if (should_touch) {
        -: 3941:        // For get and touch commands, use first token as exptime
    #####: 3942:        if (!safe_strtol(tokens[1].value, &exptime_int)) {
    #####: 3943:            out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 3944:            return;
        -: 3945:        }
    #####: 3946:        key_token++;
    #####: 3947:        exptime = realtime(exptime_int);
        -: 3948:    }
        -: 3949:
        -: 3950:    do {
    #####: 3951:        while(key_token->length != 0) {
        -: 3952:
    #####: 3953:            key = key_token->value;
    #####: 3954:            nkey = key_token->length;
        -: 3955:
    #####: 3956:            if (nkey > KEY_MAX_LENGTH) {
    #####: 3957:                fail_length = true;
    #####: 3958:                goto stop;
        -: 3959:            }
        -: 3960:
    #####: 3961:            it = limited_get(key, nkey, c, exptime, should_touch);
    #####: 3962:            if (settings.detail_enabled) {
    #####: 3963:                stats_prefix_record_get(key, nkey, NULL != it);
        -: 3964:            }
    #####: 3965:            if (it) {
    #####: 3966:                if (_ascii_get_expand_ilist(c, i) != 0) {
    #####: 3967:                    item_remove(it);
    #####: 3968:                    goto stop;
        -: 3969:                }
        -: 3970:
        -: 3971:                /*
        -: 3972:                 * Construct the response. Each hit adds three elements to the
        -: 3973:                 * outgoing data list:
        -: 3974:                 *   "VALUE "
        -: 3975:                 *   key
        -: 3976:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -: 3977:                 */
        -: 3978:
        -: 3979:                {
        -: 3980:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 3981:                                        it->nbytes, ITEM_get_cas(it));
    #####: 3982:                  int nbytes;
    #####: 3983:                  suffix = _ascii_get_suffix_buf(c, si);
    #####: 3984:                  if (suffix == NULL) {
    #####: 3985:                      item_remove(it);
    #####: 3986:                      goto stop;
        -: 3987:                  }
    #####: 3988:                  si++;
    #####: 3989:                  nbytes = it->nbytes;
    #####: 3990:                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes);
    #####: 3991:                  if (add_iov(c, "VALUE ", 6) != 0 ||
    #####: 3992:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
    #####: 3993:                      add_iov(c, suffix, suffix_len) != 0)
        -: 3994:                      {
    #####: 3995:                          item_remove(it);
    #####: 3996:                          goto stop;
        -: 3997:                      }
        -: 3998:#ifdef EXTSTORE
        -: 3999:                  if (it->it_flags & ITEM_HDR) {
        -: 4000:                      if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
        -: 4001:                          pthread_mutex_lock(&c->thread->stats.mutex);
        -: 4002:                          c->thread->stats.get_oom_extstore++;
        -: 4003:                          pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4004:
        -: 4005:                          item_remove(it);
        -: 4006:                          goto stop;
        -: 4007:                      }
        -: 4008:                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4009:#else
    #####: 4010:                  if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4011:#endif
    #####: 4012:                      add_iov(c, ITEM_data(it), it->nbytes);
    #####: 4013:                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 4014:                      item_remove(it);
    #####: 4015:                      goto stop;
        -: 4016:                  }
        -: 4017:                }
        -: 4018:
    #####: 4019:                if (settings.verbose > 1) {
    #####: 4020:                    int ii;
    #####: 4021:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####: 4022:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####: 4023:                        fprintf(stderr, "%c", key[ii]);
        -: 4024:                    }
    #####: 4025:                    fprintf(stderr, "\n");
        -: 4026:                }
        -: 4027:
        -: 4028:                /* item_get() has incremented it->refcount for us */
    #####: 4029:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4030:                if (should_touch) {
    #####: 4031:                    c->thread->stats.touch_cmds++;
    #####: 4032:                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 4033:                } else {
    #####: 4034:                    c->thread->stats.lru_hits[it->slabs_clsid]++;
    #####: 4035:                    c->thread->stats.get_cmds++;
        -: 4036:                }
    #####: 4037:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4038:#ifdef EXTSTORE
        -: 4039:                /* If ITEM_HDR, an io_wrap owns the reference. */
        -: 4040:                if ((it->it_flags & ITEM_HDR) == 0) {
        -: 4041:                    *(c->ilist + i) = it;
        -: 4042:                    i++;
        -: 4043:                }
        -: 4044:#else
    #####: 4045:                *(c->ilist + i) = it;
    #####: 4046:                i++;
        -: 4047:#endif
        -: 4048:            } else {
    #####: 4049:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4050:                if (should_touch) {
    #####: 4051:                    c->thread->stats.touch_cmds++;
    #####: 4052:                    c->thread->stats.touch_misses++;
        -: 4053:                } else {
    #####: 4054:                    c->thread->stats.get_misses++;
    #####: 4055:                    c->thread->stats.get_cmds++;
        -: 4056:                }
    #####: 4057:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
    #####: 4058:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4059:            }
        -: 4060:
    #####: 4061:            key_token++;
        -: 4062:        }
        -: 4063:
        -: 4064:        /*
        -: 4065:         * If the command string hasn't been fully processed, get the next set
        -: 4066:         * of tokens.
        -: 4067:         */
    #####: 4068:        if(key_token->value != NULL) {
    #####: 4069:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
    #####: 4070:            key_token = tokens;
        -: 4071:        }
        -: 4072:
    #####: 4073:    } while(key_token->value != NULL);
    #####: 4074:stop:
        -: 4075:
    #####: 4076:    c->icurr = c->ilist;
    #####: 4077:    c->ileft = i;
    #####: 4078:    c->suffixcurr = c->suffixlist;
    #####: 4079:    c->suffixleft = si;
        -: 4080:
    #####: 4081:    if (settings.verbose > 1)
    #####: 4082:        fprintf(stderr, ">%d END\n", c->sfd);
        -: 4083:
        -: 4084:    /*
        -: 4085:        If the loop was terminated because of out-of-memory, it is not
        -: 4086:        reliable to add END\r\n to the buffer, because it might not end
        -: 4087:        in \r\n. So we send SERVER_ERROR instead.
        -: 4088:    */
    #####: 4089:    if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
    #####: 4090:        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
    #####: 4091:        if (fail_length) {
    #####: 4092:            out_string(c, "CLIENT_ERROR bad command line format");
        -: 4093:        } else {
    #####: 4094:            out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -: 4095:        }
    #####: 4096:        conn_release_items(c);
        -: 4097:    }
        -: 4098:    else {
    #####: 4099:        conn_set_state(c, conn_mwrite);
    #####: 4100:        c->msgcurr = 0;
        -: 4101:    }
        -: 4102:}
------------------
process_get_command:
    #####: 3927:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
    #####: 3928:    char *key;
    #####: 3929:    size_t nkey;
    #####: 3930:    int i = 0;
    #####: 3931:    int si = 0;
    #####: 3932:    item *it;
    #####: 3933:    token_t *key_token = &tokens[KEY_TOKEN];
    #####: 3934:    char *suffix;
    #####: 3935:    int32_t exptime_int = 0;
    #####: 3936:    rel_time_t exptime = 0;
    #####: 3937:    bool fail_length = false;
    #####: 3938:    assert(c != NULL);
        -: 3939:
    #####: 3940:    if (should_touch) {
        -: 3941:        // For get and touch commands, use first token as exptime
    #####: 3942:        if (!safe_strtol(tokens[1].value, &exptime_int)) {
    #####: 3943:            out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 3944:            return;
        -: 3945:        }
    #####: 3946:        key_token++;
    #####: 3947:        exptime = realtime(exptime_int);
        -: 3948:    }
        -: 3949:
        -: 3950:    do {
    #####: 3951:        while(key_token->length != 0) {
        -: 3952:
    #####: 3953:            key = key_token->value;
    #####: 3954:            nkey = key_token->length;
        -: 3955:
    #####: 3956:            if (nkey > KEY_MAX_LENGTH) {
    #####: 3957:                fail_length = true;
    #####: 3958:                goto stop;
        -: 3959:            }
        -: 3960:
    #####: 3961:            it = limited_get(key, nkey, c, exptime, should_touch);
    #####: 3962:            if (settings.detail_enabled) {
    #####: 3963:                stats_prefix_record_get(key, nkey, NULL != it);
        -: 3964:            }
    #####: 3965:            if (it) {
    #####: 3966:                if (_ascii_get_expand_ilist(c, i) != 0) {
    #####: 3967:                    item_remove(it);
    #####: 3968:                    goto stop;
        -: 3969:                }
        -: 3970:
        -: 3971:                /*
        -: 3972:                 * Construct the response. Each hit adds three elements to the
        -: 3973:                 * outgoing data list:
        -: 3974:                 *   "VALUE "
        -: 3975:                 *   key
        -: 3976:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -: 3977:                 */
        -: 3978:
        -: 3979:                {
        -: 3980:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 3981:                                        it->nbytes, ITEM_get_cas(it));
    #####: 3982:                  int nbytes;
    #####: 3983:                  suffix = _ascii_get_suffix_buf(c, si);
    #####: 3984:                  if (suffix == NULL) {
    #####: 3985:                      item_remove(it);
    #####: 3986:                      goto stop;
        -: 3987:                  }
    #####: 3988:                  si++;
    #####: 3989:                  nbytes = it->nbytes;
    #####: 3990:                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes);
    #####: 3991:                  if (add_iov(c, "VALUE ", 6) != 0 ||
    #####: 3992:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
    #####: 3993:                      add_iov(c, suffix, suffix_len) != 0)
        -: 3994:                      {
    #####: 3995:                          item_remove(it);
    #####: 3996:                          goto stop;
        -: 3997:                      }
        -: 3998:#ifdef EXTSTORE
        -: 3999:                  if (it->it_flags & ITEM_HDR) {
        -: 4000:                      if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
        -: 4001:                          pthread_mutex_lock(&c->thread->stats.mutex);
        -: 4002:                          c->thread->stats.get_oom_extstore++;
        -: 4003:                          pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4004:
        -: 4005:                          item_remove(it);
        -: 4006:                          goto stop;
        -: 4007:                      }
        -: 4008:                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4009:#else
    #####: 4010:                  if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4011:#endif
    #####: 4012:                      add_iov(c, ITEM_data(it), it->nbytes);
    #####: 4013:                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 4014:                      item_remove(it);
    #####: 4015:                      goto stop;
        -: 4016:                  }
        -: 4017:                }
        -: 4018:
    #####: 4019:                if (settings.verbose > 1) {
    #####: 4020:                    int ii;
    #####: 4021:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####: 4022:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####: 4023:                        fprintf(stderr, "%c", key[ii]);
        -: 4024:                    }
    #####: 4025:                    fprintf(stderr, "\n");
        -: 4026:                }
        -: 4027:
        -: 4028:                /* item_get() has incremented it->refcount for us */
    #####: 4029:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4030:                if (should_touch) {
    #####: 4031:                    c->thread->stats.touch_cmds++;
    #####: 4032:                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 4033:                } else {
    #####: 4034:                    c->thread->stats.lru_hits[it->slabs_clsid]++;
    #####: 4035:                    c->thread->stats.get_cmds++;
        -: 4036:                }
    #####: 4037:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4038:#ifdef EXTSTORE
        -: 4039:                /* If ITEM_HDR, an io_wrap owns the reference. */
        -: 4040:                if ((it->it_flags & ITEM_HDR) == 0) {
        -: 4041:                    *(c->ilist + i) = it;
        -: 4042:                    i++;
        -: 4043:                }
        -: 4044:#else
    #####: 4045:                *(c->ilist + i) = it;
    #####: 4046:                i++;
        -: 4047:#endif
        -: 4048:            } else {
    #####: 4049:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4050:                if (should_touch) {
    #####: 4051:                    c->thread->stats.touch_cmds++;
    #####: 4052:                    c->thread->stats.touch_misses++;
        -: 4053:                } else {
    #####: 4054:                    c->thread->stats.get_misses++;
    #####: 4055:                    c->thread->stats.get_cmds++;
        -: 4056:                }
    #####: 4057:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
    #####: 4058:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4059:            }
        -: 4060:
    #####: 4061:            key_token++;
        -: 4062:        }
        -: 4063:
        -: 4064:        /*
        -: 4065:         * If the command string hasn't been fully processed, get the next set
        -: 4066:         * of tokens.
        -: 4067:         */
    #####: 4068:        if(key_token->value != NULL) {
    #####: 4069:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
    #####: 4070:            key_token = tokens;
        -: 4071:        }
        -: 4072:
    #####: 4073:    } while(key_token->value != NULL);
    #####: 4074:stop:
        -: 4075:
    #####: 4076:    c->icurr = c->ilist;
    #####: 4077:    c->ileft = i;
    #####: 4078:    c->suffixcurr = c->suffixlist;
    #####: 4079:    c->suffixleft = si;
        -: 4080:
    #####: 4081:    if (settings.verbose > 1)
    #####: 4082:        fprintf(stderr, ">%d END\n", c->sfd);
        -: 4083:
        -: 4084:    /*
        -: 4085:        If the loop was terminated because of out-of-memory, it is not
        -: 4086:        reliable to add END\r\n to the buffer, because it might not end
        -: 4087:        in \r\n. So we send SERVER_ERROR instead.
        -: 4088:    */
    #####: 4089:    if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
    #####: 4090:        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
    #####: 4091:        if (fail_length) {
    #####: 4092:            out_string(c, "CLIENT_ERROR bad command line format");
        -: 4093:        } else {
    #####: 4094:            out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -: 4095:        }
    #####: 4096:        conn_release_items(c);
        -: 4097:    }
        -: 4098:    else {
    #####: 4099:        conn_set_state(c, conn_mwrite);
    #####: 4100:        c->msgcurr = 0;
        -: 4101:    }
        -: 4102:}
------------------
process_get_command:
    #####: 3927:static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
    #####: 3928:    char *key;
    #####: 3929:    size_t nkey;
    #####: 3930:    int i = 0;
    #####: 3931:    int si = 0;
    #####: 3932:    item *it;
    #####: 3933:    token_t *key_token = &tokens[KEY_TOKEN];
    #####: 3934:    char *suffix;
    #####: 3935:    int32_t exptime_int = 0;
    #####: 3936:    rel_time_t exptime = 0;
    #####: 3937:    bool fail_length = false;
    #####: 3938:    assert(c != NULL);
        -: 3939:
    #####: 3940:    if (should_touch) {
        -: 3941:        // For get and touch commands, use first token as exptime
    #####: 3942:        if (!safe_strtol(tokens[1].value, &exptime_int)) {
    #####: 3943:            out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 3944:            return;
        -: 3945:        }
    #####: 3946:        key_token++;
    #####: 3947:        exptime = realtime(exptime_int);
        -: 3948:    }
        -: 3949:
        -: 3950:    do {
    #####: 3951:        while(key_token->length != 0) {
        -: 3952:
    #####: 3953:            key = key_token->value;
    #####: 3954:            nkey = key_token->length;
        -: 3955:
    #####: 3956:            if (nkey > KEY_MAX_LENGTH) {
    #####: 3957:                fail_length = true;
    #####: 3958:                goto stop;
        -: 3959:            }
        -: 3960:
    #####: 3961:            it = limited_get(key, nkey, c, exptime, should_touch);
    #####: 3962:            if (settings.detail_enabled) {
    #####: 3963:                stats_prefix_record_get(key, nkey, NULL != it);
        -: 3964:            }
    #####: 3965:            if (it) {
    #####: 3966:                if (_ascii_get_expand_ilist(c, i) != 0) {
    #####: 3967:                    item_remove(it);
    #####: 3968:                    goto stop;
        -: 3969:                }
        -: 3970:
        -: 3971:                /*
        -: 3972:                 * Construct the response. Each hit adds three elements to the
        -: 3973:                 * outgoing data list:
        -: 3974:                 *   "VALUE "
        -: 3975:                 *   key
        -: 3976:                 *   " " + flags + " " + data length + "\r\n" + data (with \r\n)
        -: 3977:                 */
        -: 3978:
        -: 3979:                {
        -: 3980:                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
    #####: 3981:                                        it->nbytes, ITEM_get_cas(it));
    #####: 3982:                  int nbytes;
    #####: 3983:                  suffix = _ascii_get_suffix_buf(c, si);
    #####: 3984:                  if (suffix == NULL) {
    #####: 3985:                      item_remove(it);
    #####: 3986:                      goto stop;
        -: 3987:                  }
    #####: 3988:                  si++;
    #####: 3989:                  nbytes = it->nbytes;
    #####: 3990:                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes);
    #####: 3991:                  if (add_iov(c, "VALUE ", 6) != 0 ||
    #####: 3992:                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||
    #####: 3993:                      add_iov(c, suffix, suffix_len) != 0)
        -: 3994:                      {
    #####: 3995:                          item_remove(it);
    #####: 3996:                          goto stop;
        -: 3997:                      }
        -: 3998:#ifdef EXTSTORE
        -: 3999:                  if (it->it_flags & ITEM_HDR) {
        -: 4000:                      if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
        -: 4001:                          pthread_mutex_lock(&c->thread->stats.mutex);
        -: 4002:                          c->thread->stats.get_oom_extstore++;
        -: 4003:                          pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4004:
        -: 4005:                          item_remove(it);
        -: 4006:                          goto stop;
        -: 4007:                      }
        -: 4008:                  } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4009:#else
    #####: 4010:                  if ((it->it_flags & ITEM_CHUNKED) == 0) {
        -: 4011:#endif
    #####: 4012:                      add_iov(c, ITEM_data(it), it->nbytes);
    #####: 4013:                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
    #####: 4014:                      item_remove(it);
    #####: 4015:                      goto stop;
        -: 4016:                  }
        -: 4017:                }
        -: 4018:
    #####: 4019:                if (settings.verbose > 1) {
    #####: 4020:                    int ii;
    #####: 4021:                    fprintf(stderr, ">%d sending key ", c->sfd);
    #####: 4022:                    for (ii = 0; ii < it->nkey; ++ii) {
    #####: 4023:                        fprintf(stderr, "%c", key[ii]);
        -: 4024:                    }
    #####: 4025:                    fprintf(stderr, "\n");
        -: 4026:                }
        -: 4027:
        -: 4028:                /* item_get() has incremented it->refcount for us */
    #####: 4029:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4030:                if (should_touch) {
    #####: 4031:                    c->thread->stats.touch_cmds++;
    #####: 4032:                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        -: 4033:                } else {
    #####: 4034:                    c->thread->stats.lru_hits[it->slabs_clsid]++;
    #####: 4035:                    c->thread->stats.get_cmds++;
        -: 4036:                }
    #####: 4037:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4038:#ifdef EXTSTORE
        -: 4039:                /* If ITEM_HDR, an io_wrap owns the reference. */
        -: 4040:                if ((it->it_flags & ITEM_HDR) == 0) {
        -: 4041:                    *(c->ilist + i) = it;
        -: 4042:                    i++;
        -: 4043:                }
        -: 4044:#else
    #####: 4045:                *(c->ilist + i) = it;
    #####: 4046:                i++;
        -: 4047:#endif
        -: 4048:            } else {
    #####: 4049:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4050:                if (should_touch) {
    #####: 4051:                    c->thread->stats.touch_cmds++;
    #####: 4052:                    c->thread->stats.touch_misses++;
        -: 4053:                } else {
    #####: 4054:                    c->thread->stats.get_misses++;
    #####: 4055:                    c->thread->stats.get_cmds++;
        -: 4056:                }
    #####: 4057:                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
    #####: 4058:                pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4059:            }
        -: 4060:
    #####: 4061:            key_token++;
        -: 4062:        }
        -: 4063:
        -: 4064:        /*
        -: 4065:         * If the command string hasn't been fully processed, get the next set
        -: 4066:         * of tokens.
        -: 4067:         */
    #####: 4068:        if(key_token->value != NULL) {
    #####: 4069:            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
    #####: 4070:            key_token = tokens;
        -: 4071:        }
        -: 4072:
    #####: 4073:    } while(key_token->value != NULL);
    #####: 4074:stop:
        -: 4075:
    #####: 4076:    c->icurr = c->ilist;
    #####: 4077:    c->ileft = i;
    #####: 4078:    c->suffixcurr = c->suffixlist;
    #####: 4079:    c->suffixleft = si;
        -: 4080:
    #####: 4081:    if (settings.verbose > 1)
    #####: 4082:        fprintf(stderr, ">%d END\n", c->sfd);
        -: 4083:
        -: 4084:    /*
        -: 4085:        If the loop was terminated because of out-of-memory, it is not
        -: 4086:        reliable to add END\r\n to the buffer, because it might not end
        -: 4087:        in \r\n. So we send SERVER_ERROR instead.
        -: 4088:    */
    #####: 4089:    if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
    #####: 4090:        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
    #####: 4091:        if (fail_length) {
    #####: 4092:            out_string(c, "CLIENT_ERROR bad command line format");
        -: 4093:        } else {
    #####: 4094:            out_of_memory(c, "SERVER_ERROR out of memory writing get response");
        -: 4095:        }
    #####: 4096:        conn_release_items(c);
        -: 4097:    }
        -: 4098:    else {
    #####: 4099:        conn_set_state(c, conn_mwrite);
    #####: 4100:        c->msgcurr = 0;
        -: 4101:    }
        -: 4102:}
------------------
        -: 4103:
    #####: 4104:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    #####: 4105:    char *key;
    #####: 4106:    size_t nkey;
    #####: 4107:    unsigned int flags;
    #####: 4108:    int32_t exptime_int = 0;
    #####: 4109:    time_t exptime;
    #####: 4110:    int vlen;
    #####: 4111:    uint64_t req_cas_id=0;
    #####: 4112:    item *it;
        -: 4113:
    #####: 4114:    assert(c != NULL);
        -: 4115:
    #####: 4116:    set_noreply_maybe(c, tokens, ntokens);
        -: 4117:
    #####: 4118:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4119:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4120:        return;
        -: 4121:    }
        -: 4122:
    #####: 4123:    key = tokens[KEY_TOKEN].value;
    #####: 4124:    nkey = tokens[KEY_TOKEN].length;
        -: 4125:
    #####: 4126:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
    #####: 4127:           && safe_strtol(tokens[3].value, &exptime_int)
    #####: 4128:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
    #####: 4129:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4130:        return;
        -: 4131:    }
        -: 4132:
        -: 4133:    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
    #####: 4134:    exptime = exptime_int;
        -: 4135:
        -: 4136:    /* Negative exptimes can underflow and end up immortal. realtime() will
        -: 4137:       immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -: 4138:       than process_started, so lets aim for that. */
    #####: 4139:    if (exptime < 0)
    #####: 4140:        exptime = REALTIME_MAXDELTA + 1;
        -: 4141:
        -: 4142:    // does cas value exist?
    #####: 4143:    if (handle_cas) {
    #####: 4144:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
    #####: 4145:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4146:            return;
        -: 4147:        }
        -: 4148:    }
        -: 4149:
    #####: 4150:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
    #####: 4151:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4152:        return;
        -: 4153:    }
    #####: 4154:    vlen += 2;
        -: 4155:
    #####: 4156:    if (settings.detail_enabled) {
    #####: 4157:        stats_prefix_record_set(key, nkey);
        -: 4158:    }
        -: 4159:
    #####: 4160:    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
        -: 4161:
    #####: 4162:    if (it == 0) {
    #####: 4163:        enum store_item_type status;
    #####: 4164:        if (! item_size_ok(nkey, flags, vlen)) {
    #####: 4165:            out_string(c, "SERVER_ERROR object too large for cache");
    #####: 4166:            status = TOO_LARGE;
        -: 4167:        } else {
    #####: 4168:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
    #####: 4169:            status = NO_MEMORY;
        -: 4170:        }
    #####: 4171:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 4172:                NULL, status, comm, key, nkey, 0, 0);
        -: 4173:        /* swallow the data line */
    #####: 4174:        c->write_and_go = conn_swallow;
    #####: 4175:        c->sbytes = vlen;
        -: 4176:
        -: 4177:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 4178:         * Unacceptable for SET. Anywhere else too? */
    #####: 4179:        if (comm == NREAD_SET) {
    #####: 4180:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 4181:            if (it) {
    #####: 4182:                item_unlink(it);
    #####: 4183:                STORAGE_delete(c->thread->storage, it);
    #####: 4184:                item_remove(it);
        -: 4185:            }
        -: 4186:        }
        -: 4187:
    #####: 4188:        return;
        -: 4189:    }
    #####: 4190:    ITEM_set_cas(it, req_cas_id);
        -: 4191:
    #####: 4192:    c->item = it;
        -: 4193:#ifdef NEED_ALIGN
        -: 4194:    if (it->it_flags & ITEM_CHUNKED) {
        -: 4195:        c->ritem = ITEM_schunk(it);
        -: 4196:    } else {
        -: 4197:        c->ritem = ITEM_data(it);
        -: 4198:    }
        -: 4199:#else
    #####: 4200:    c->ritem = ITEM_data(it);
        -: 4201:#endif
    #####: 4202:    c->rlbytes = it->nbytes;
    #####: 4203:    c->cmd = comm;
    #####: 4204:    conn_set_state(c, conn_nread);
        -: 4205:}
------------------
process_update_command:
    #####: 4104:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    #####: 4105:    char *key;
    #####: 4106:    size_t nkey;
    #####: 4107:    unsigned int flags;
    #####: 4108:    int32_t exptime_int = 0;
    #####: 4109:    time_t exptime;
    #####: 4110:    int vlen;
    #####: 4111:    uint64_t req_cas_id=0;
    #####: 4112:    item *it;
        -: 4113:
    #####: 4114:    assert(c != NULL);
        -: 4115:
    #####: 4116:    set_noreply_maybe(c, tokens, ntokens);
        -: 4117:
    #####: 4118:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4119:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4120:        return;
        -: 4121:    }
        -: 4122:
    #####: 4123:    key = tokens[KEY_TOKEN].value;
    #####: 4124:    nkey = tokens[KEY_TOKEN].length;
        -: 4125:
    #####: 4126:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
    #####: 4127:           && safe_strtol(tokens[3].value, &exptime_int)
    #####: 4128:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
    #####: 4129:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4130:        return;
        -: 4131:    }
        -: 4132:
        -: 4133:    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
    #####: 4134:    exptime = exptime_int;
        -: 4135:
        -: 4136:    /* Negative exptimes can underflow and end up immortal. realtime() will
        -: 4137:       immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -: 4138:       than process_started, so lets aim for that. */
    #####: 4139:    if (exptime < 0)
    #####: 4140:        exptime = REALTIME_MAXDELTA + 1;
        -: 4141:
        -: 4142:    // does cas value exist?
    #####: 4143:    if (handle_cas) {
    #####: 4144:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
    #####: 4145:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4146:            return;
        -: 4147:        }
        -: 4148:    }
        -: 4149:
    #####: 4150:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
    #####: 4151:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4152:        return;
        -: 4153:    }
    #####: 4154:    vlen += 2;
        -: 4155:
    #####: 4156:    if (settings.detail_enabled) {
    #####: 4157:        stats_prefix_record_set(key, nkey);
        -: 4158:    }
        -: 4159:
    #####: 4160:    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
        -: 4161:
    #####: 4162:    if (it == 0) {
    #####: 4163:        enum store_item_type status;
    #####: 4164:        if (! item_size_ok(nkey, flags, vlen)) {
    #####: 4165:            out_string(c, "SERVER_ERROR object too large for cache");
    #####: 4166:            status = TOO_LARGE;
        -: 4167:        } else {
    #####: 4168:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
    #####: 4169:            status = NO_MEMORY;
        -: 4170:        }
    #####: 4171:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 4172:                NULL, status, comm, key, nkey, 0, 0);
        -: 4173:        /* swallow the data line */
    #####: 4174:        c->write_and_go = conn_swallow;
    #####: 4175:        c->sbytes = vlen;
        -: 4176:
        -: 4177:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 4178:         * Unacceptable for SET. Anywhere else too? */
    #####: 4179:        if (comm == NREAD_SET) {
    #####: 4180:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 4181:            if (it) {
    #####: 4182:                item_unlink(it);
    #####: 4183:                STORAGE_delete(c->thread->storage, it);
    #####: 4184:                item_remove(it);
        -: 4185:            }
        -: 4186:        }
        -: 4187:
    #####: 4188:        return;
        -: 4189:    }
    #####: 4190:    ITEM_set_cas(it, req_cas_id);
        -: 4191:
    #####: 4192:    c->item = it;
        -: 4193:#ifdef NEED_ALIGN
        -: 4194:    if (it->it_flags & ITEM_CHUNKED) {
        -: 4195:        c->ritem = ITEM_schunk(it);
        -: 4196:    } else {
        -: 4197:        c->ritem = ITEM_data(it);
        -: 4198:    }
        -: 4199:#else
    #####: 4200:    c->ritem = ITEM_data(it);
        -: 4201:#endif
    #####: 4202:    c->rlbytes = it->nbytes;
    #####: 4203:    c->cmd = comm;
    #####: 4204:    conn_set_state(c, conn_nread);
        -: 4205:}
------------------
process_update_command:
    #####: 4104:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    #####: 4105:    char *key;
    #####: 4106:    size_t nkey;
    #####: 4107:    unsigned int flags;
    #####: 4108:    int32_t exptime_int = 0;
    #####: 4109:    time_t exptime;
    #####: 4110:    int vlen;
    #####: 4111:    uint64_t req_cas_id=0;
    #####: 4112:    item *it;
        -: 4113:
    #####: 4114:    assert(c != NULL);
        -: 4115:
    #####: 4116:    set_noreply_maybe(c, tokens, ntokens);
        -: 4117:
    #####: 4118:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4119:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4120:        return;
        -: 4121:    }
        -: 4122:
    #####: 4123:    key = tokens[KEY_TOKEN].value;
    #####: 4124:    nkey = tokens[KEY_TOKEN].length;
        -: 4125:
    #####: 4126:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
    #####: 4127:           && safe_strtol(tokens[3].value, &exptime_int)
    #####: 4128:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
    #####: 4129:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4130:        return;
        -: 4131:    }
        -: 4132:
        -: 4133:    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
    #####: 4134:    exptime = exptime_int;
        -: 4135:
        -: 4136:    /* Negative exptimes can underflow and end up immortal. realtime() will
        -: 4137:       immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -: 4138:       than process_started, so lets aim for that. */
    #####: 4139:    if (exptime < 0)
    #####: 4140:        exptime = REALTIME_MAXDELTA + 1;
        -: 4141:
        -: 4142:    // does cas value exist?
    #####: 4143:    if (handle_cas) {
    #####: 4144:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
    #####: 4145:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4146:            return;
        -: 4147:        }
        -: 4148:    }
        -: 4149:
    #####: 4150:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
    #####: 4151:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4152:        return;
        -: 4153:    }
    #####: 4154:    vlen += 2;
        -: 4155:
    #####: 4156:    if (settings.detail_enabled) {
    #####: 4157:        stats_prefix_record_set(key, nkey);
        -: 4158:    }
        -: 4159:
    #####: 4160:    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
        -: 4161:
    #####: 4162:    if (it == 0) {
    #####: 4163:        enum store_item_type status;
    #####: 4164:        if (! item_size_ok(nkey, flags, vlen)) {
    #####: 4165:            out_string(c, "SERVER_ERROR object too large for cache");
    #####: 4166:            status = TOO_LARGE;
        -: 4167:        } else {
    #####: 4168:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
    #####: 4169:            status = NO_MEMORY;
        -: 4170:        }
    #####: 4171:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 4172:                NULL, status, comm, key, nkey, 0, 0);
        -: 4173:        /* swallow the data line */
    #####: 4174:        c->write_and_go = conn_swallow;
    #####: 4175:        c->sbytes = vlen;
        -: 4176:
        -: 4177:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 4178:         * Unacceptable for SET. Anywhere else too? */
    #####: 4179:        if (comm == NREAD_SET) {
    #####: 4180:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 4181:            if (it) {
    #####: 4182:                item_unlink(it);
    #####: 4183:                STORAGE_delete(c->thread->storage, it);
    #####: 4184:                item_remove(it);
        -: 4185:            }
        -: 4186:        }
        -: 4187:
    #####: 4188:        return;
        -: 4189:    }
    #####: 4190:    ITEM_set_cas(it, req_cas_id);
        -: 4191:
    #####: 4192:    c->item = it;
        -: 4193:#ifdef NEED_ALIGN
        -: 4194:    if (it->it_flags & ITEM_CHUNKED) {
        -: 4195:        c->ritem = ITEM_schunk(it);
        -: 4196:    } else {
        -: 4197:        c->ritem = ITEM_data(it);
        -: 4198:    }
        -: 4199:#else
    #####: 4200:    c->ritem = ITEM_data(it);
        -: 4201:#endif
    #####: 4202:    c->rlbytes = it->nbytes;
    #####: 4203:    c->cmd = comm;
    #####: 4204:    conn_set_state(c, conn_nread);
        -: 4205:}
------------------
process_update_command:
    #####: 4104:static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    #####: 4105:    char *key;
    #####: 4106:    size_t nkey;
    #####: 4107:    unsigned int flags;
    #####: 4108:    int32_t exptime_int = 0;
    #####: 4109:    time_t exptime;
    #####: 4110:    int vlen;
    #####: 4111:    uint64_t req_cas_id=0;
    #####: 4112:    item *it;
        -: 4113:
    #####: 4114:    assert(c != NULL);
        -: 4115:
    #####: 4116:    set_noreply_maybe(c, tokens, ntokens);
        -: 4117:
    #####: 4118:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4119:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4120:        return;
        -: 4121:    }
        -: 4122:
    #####: 4123:    key = tokens[KEY_TOKEN].value;
    #####: 4124:    nkey = tokens[KEY_TOKEN].length;
        -: 4125:
    #####: 4126:    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
    #####: 4127:           && safe_strtol(tokens[3].value, &exptime_int)
    #####: 4128:           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
    #####: 4129:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4130:        return;
        -: 4131:    }
        -: 4132:
        -: 4133:    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */
    #####: 4134:    exptime = exptime_int;
        -: 4135:
        -: 4136:    /* Negative exptimes can underflow and end up immortal. realtime() will
        -: 4137:       immediately expire values that are greater than REALTIME_MAXDELTA, but less
        -: 4138:       than process_started, so lets aim for that. */
    #####: 4139:    if (exptime < 0)
    #####: 4140:        exptime = REALTIME_MAXDELTA + 1;
        -: 4141:
        -: 4142:    // does cas value exist?
    #####: 4143:    if (handle_cas) {
    #####: 4144:        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
    #####: 4145:            out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4146:            return;
        -: 4147:        }
        -: 4148:    }
        -: 4149:
    #####: 4150:    if (vlen < 0 || vlen > (INT_MAX - 2)) {
    #####: 4151:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4152:        return;
        -: 4153:    }
    #####: 4154:    vlen += 2;
        -: 4155:
    #####: 4156:    if (settings.detail_enabled) {
    #####: 4157:        stats_prefix_record_set(key, nkey);
        -: 4158:    }
        -: 4159:
    #####: 4160:    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
        -: 4161:
    #####: 4162:    if (it == 0) {
    #####: 4163:        enum store_item_type status;
    #####: 4164:        if (! item_size_ok(nkey, flags, vlen)) {
    #####: 4165:            out_string(c, "SERVER_ERROR object too large for cache");
    #####: 4166:            status = TOO_LARGE;
        -: 4167:        } else {
    #####: 4168:            out_of_memory(c, "SERVER_ERROR out of memory storing object");
    #####: 4169:            status = NO_MEMORY;
        -: 4170:        }
    #####: 4171:        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
        -: 4172:                NULL, status, comm, key, nkey, 0, 0);
        -: 4173:        /* swallow the data line */
    #####: 4174:        c->write_and_go = conn_swallow;
    #####: 4175:        c->sbytes = vlen;
        -: 4176:
        -: 4177:        /* Avoid stale data persisting in cache because we failed alloc.
        -: 4178:         * Unacceptable for SET. Anywhere else too? */
    #####: 4179:        if (comm == NREAD_SET) {
    #####: 4180:            it = item_get(key, nkey, c, DONT_UPDATE);
    #####: 4181:            if (it) {
    #####: 4182:                item_unlink(it);
    #####: 4183:                STORAGE_delete(c->thread->storage, it);
    #####: 4184:                item_remove(it);
        -: 4185:            }
        -: 4186:        }
        -: 4187:
    #####: 4188:        return;
        -: 4189:    }
    #####: 4190:    ITEM_set_cas(it, req_cas_id);
        -: 4191:
    #####: 4192:    c->item = it;
        -: 4193:#ifdef NEED_ALIGN
        -: 4194:    if (it->it_flags & ITEM_CHUNKED) {
        -: 4195:        c->ritem = ITEM_schunk(it);
        -: 4196:    } else {
        -: 4197:        c->ritem = ITEM_data(it);
        -: 4198:    }
        -: 4199:#else
    #####: 4200:    c->ritem = ITEM_data(it);
        -: 4201:#endif
    #####: 4202:    c->rlbytes = it->nbytes;
    #####: 4203:    c->cmd = comm;
    #####: 4204:    conn_set_state(c, conn_nread);
        -: 4205:}
------------------
        -: 4206:
    #####: 4207:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4208:    char *key;
    #####: 4209:    size_t nkey;
    #####: 4210:    int32_t exptime_int = 0;
    #####: 4211:    item *it;
        -: 4212:
    #####: 4213:    assert(c != NULL);
        -: 4214:
    #####: 4215:    set_noreply_maybe(c, tokens, ntokens);
        -: 4216:
    #####: 4217:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4218:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4219:        return;
        -: 4220:    }
        -: 4221:
    #####: 4222:    key = tokens[KEY_TOKEN].value;
    #####: 4223:    nkey = tokens[KEY_TOKEN].length;
        -: 4224:
    #####: 4225:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 4226:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 4227:        return;
        -: 4228:    }
        -: 4229:
    #####: 4230:    it = item_touch(key, nkey, realtime(exptime_int), c);
    #####: 4231:    if (it) {
    #####: 4232:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4233:        c->thread->stats.touch_cmds++;
    #####: 4234:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
    #####: 4235:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4236:
    #####: 4237:        out_string(c, "TOUCHED");
    #####: 4238:        item_remove(it);
        -: 4239:    } else {
    #####: 4240:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4241:        c->thread->stats.touch_cmds++;
    #####: 4242:        c->thread->stats.touch_misses++;
    #####: 4243:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4244:
    #####: 4245:        out_string(c, "NOT_FOUND");
        -: 4246:    }
        -: 4247:}
------------------
process_touch_command:
    #####: 4207:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4208:    char *key;
    #####: 4209:    size_t nkey;
    #####: 4210:    int32_t exptime_int = 0;
    #####: 4211:    item *it;
        -: 4212:
    #####: 4213:    assert(c != NULL);
        -: 4214:
    #####: 4215:    set_noreply_maybe(c, tokens, ntokens);
        -: 4216:
    #####: 4217:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4218:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4219:        return;
        -: 4220:    }
        -: 4221:
    #####: 4222:    key = tokens[KEY_TOKEN].value;
    #####: 4223:    nkey = tokens[KEY_TOKEN].length;
        -: 4224:
    #####: 4225:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 4226:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 4227:        return;
        -: 4228:    }
        -: 4229:
    #####: 4230:    it = item_touch(key, nkey, realtime(exptime_int), c);
    #####: 4231:    if (it) {
    #####: 4232:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4233:        c->thread->stats.touch_cmds++;
    #####: 4234:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
    #####: 4235:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4236:
    #####: 4237:        out_string(c, "TOUCHED");
    #####: 4238:        item_remove(it);
        -: 4239:    } else {
    #####: 4240:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4241:        c->thread->stats.touch_cmds++;
    #####: 4242:        c->thread->stats.touch_misses++;
    #####: 4243:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4244:
    #####: 4245:        out_string(c, "NOT_FOUND");
        -: 4246:    }
        -: 4247:}
------------------
process_touch_command:
    #####: 4207:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4208:    char *key;
    #####: 4209:    size_t nkey;
    #####: 4210:    int32_t exptime_int = 0;
    #####: 4211:    item *it;
        -: 4212:
    #####: 4213:    assert(c != NULL);
        -: 4214:
    #####: 4215:    set_noreply_maybe(c, tokens, ntokens);
        -: 4216:
    #####: 4217:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4218:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4219:        return;
        -: 4220:    }
        -: 4221:
    #####: 4222:    key = tokens[KEY_TOKEN].value;
    #####: 4223:    nkey = tokens[KEY_TOKEN].length;
        -: 4224:
    #####: 4225:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 4226:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 4227:        return;
        -: 4228:    }
        -: 4229:
    #####: 4230:    it = item_touch(key, nkey, realtime(exptime_int), c);
    #####: 4231:    if (it) {
    #####: 4232:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4233:        c->thread->stats.touch_cmds++;
    #####: 4234:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
    #####: 4235:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4236:
    #####: 4237:        out_string(c, "TOUCHED");
    #####: 4238:        item_remove(it);
        -: 4239:    } else {
    #####: 4240:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4241:        c->thread->stats.touch_cmds++;
    #####: 4242:        c->thread->stats.touch_misses++;
    #####: 4243:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4244:
    #####: 4245:        out_string(c, "NOT_FOUND");
        -: 4246:    }
        -: 4247:}
------------------
process_touch_command:
    #####: 4207:static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4208:    char *key;
    #####: 4209:    size_t nkey;
    #####: 4210:    int32_t exptime_int = 0;
    #####: 4211:    item *it;
        -: 4212:
    #####: 4213:    assert(c != NULL);
        -: 4214:
    #####: 4215:    set_noreply_maybe(c, tokens, ntokens);
        -: 4216:
    #####: 4217:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4218:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4219:        return;
        -: 4220:    }
        -: 4221:
    #####: 4222:    key = tokens[KEY_TOKEN].value;
    #####: 4223:    nkey = tokens[KEY_TOKEN].length;
        -: 4224:
    #####: 4225:    if (!safe_strtol(tokens[2].value, &exptime_int)) {
    #####: 4226:        out_string(c, "CLIENT_ERROR invalid exptime argument");
    #####: 4227:        return;
        -: 4228:    }
        -: 4229:
    #####: 4230:    it = item_touch(key, nkey, realtime(exptime_int), c);
    #####: 4231:    if (it) {
    #####: 4232:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4233:        c->thread->stats.touch_cmds++;
    #####: 4234:        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
    #####: 4235:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4236:
    #####: 4237:        out_string(c, "TOUCHED");
    #####: 4238:        item_remove(it);
        -: 4239:    } else {
    #####: 4240:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4241:        c->thread->stats.touch_cmds++;
    #####: 4242:        c->thread->stats.touch_misses++;
    #####: 4243:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4244:
    #####: 4245:        out_string(c, "NOT_FOUND");
        -: 4246:    }
        -: 4247:}
------------------
        -: 4248:
    #####: 4249:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    #####: 4250:    char temp[INCR_MAX_STORAGE_LEN];
    #####: 4251:    uint64_t delta;
    #####: 4252:    char *key;
    #####: 4253:    size_t nkey;
        -: 4254:
    #####: 4255:    assert(c != NULL);
        -: 4256:
    #####: 4257:    set_noreply_maybe(c, tokens, ntokens);
        -: 4258:
    #####: 4259:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4260:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4261:        return;
        -: 4262:    }
        -: 4263:
    #####: 4264:    key = tokens[KEY_TOKEN].value;
    #####: 4265:    nkey = tokens[KEY_TOKEN].length;
        -: 4266:
    #####: 4267:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 4268:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 4269:        return;
        -: 4270:    }
        -: 4271:
    #####: 4272:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    #####: 4273:    case OK:
    #####: 4274:        out_string(c, temp);
    #####: 4275:        break;
    #####: 4276:    case NON_NUMERIC:
    #####: 4277:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
    #####: 4278:        break;
    #####: 4279:    case EOM:
    #####: 4280:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 4281:        break;
    #####: 4282:    case DELTA_ITEM_NOT_FOUND:
    #####: 4283:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4284:        if (incr) {
    #####: 4285:            c->thread->stats.incr_misses++;
        -: 4286:        } else {
    #####: 4287:            c->thread->stats.decr_misses++;
        -: 4288:        }
    #####: 4289:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4290:
    #####: 4291:        out_string(c, "NOT_FOUND");
    #####: 4292:        break;
        -: 4293:    case DELTA_ITEM_CAS_MISMATCH:
        -: 4294:        break; /* Should never get here */
        -: 4295:    }
    #####: 4296:}
------------------
process_arithmetic_command:
    #####: 4249:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    #####: 4250:    char temp[INCR_MAX_STORAGE_LEN];
    #####: 4251:    uint64_t delta;
    #####: 4252:    char *key;
    #####: 4253:    size_t nkey;
        -: 4254:
    #####: 4255:    assert(c != NULL);
        -: 4256:
    #####: 4257:    set_noreply_maybe(c, tokens, ntokens);
        -: 4258:
    #####: 4259:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4260:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4261:        return;
        -: 4262:    }
        -: 4263:
    #####: 4264:    key = tokens[KEY_TOKEN].value;
    #####: 4265:    nkey = tokens[KEY_TOKEN].length;
        -: 4266:
    #####: 4267:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 4268:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 4269:        return;
        -: 4270:    }
        -: 4271:
    #####: 4272:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    #####: 4273:    case OK:
    #####: 4274:        out_string(c, temp);
    #####: 4275:        break;
    #####: 4276:    case NON_NUMERIC:
    #####: 4277:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
    #####: 4278:        break;
    #####: 4279:    case EOM:
    #####: 4280:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 4281:        break;
    #####: 4282:    case DELTA_ITEM_NOT_FOUND:
    #####: 4283:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4284:        if (incr) {
    #####: 4285:            c->thread->stats.incr_misses++;
        -: 4286:        } else {
    #####: 4287:            c->thread->stats.decr_misses++;
        -: 4288:        }
    #####: 4289:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4290:
    #####: 4291:        out_string(c, "NOT_FOUND");
    #####: 4292:        break;
        -: 4293:    case DELTA_ITEM_CAS_MISMATCH:
        -: 4294:        break; /* Should never get here */
        -: 4295:    }
    #####: 4296:}
------------------
process_arithmetic_command:
    #####: 4249:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    #####: 4250:    char temp[INCR_MAX_STORAGE_LEN];
    #####: 4251:    uint64_t delta;
    #####: 4252:    char *key;
    #####: 4253:    size_t nkey;
        -: 4254:
    #####: 4255:    assert(c != NULL);
        -: 4256:
    #####: 4257:    set_noreply_maybe(c, tokens, ntokens);
        -: 4258:
    #####: 4259:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4260:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4261:        return;
        -: 4262:    }
        -: 4263:
    #####: 4264:    key = tokens[KEY_TOKEN].value;
    #####: 4265:    nkey = tokens[KEY_TOKEN].length;
        -: 4266:
    #####: 4267:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 4268:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 4269:        return;
        -: 4270:    }
        -: 4271:
    #####: 4272:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    #####: 4273:    case OK:
    #####: 4274:        out_string(c, temp);
    #####: 4275:        break;
    #####: 4276:    case NON_NUMERIC:
    #####: 4277:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
    #####: 4278:        break;
    #####: 4279:    case EOM:
    #####: 4280:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 4281:        break;
    #####: 4282:    case DELTA_ITEM_NOT_FOUND:
    #####: 4283:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4284:        if (incr) {
    #####: 4285:            c->thread->stats.incr_misses++;
        -: 4286:        } else {
    #####: 4287:            c->thread->stats.decr_misses++;
        -: 4288:        }
    #####: 4289:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4290:
    #####: 4291:        out_string(c, "NOT_FOUND");
    #####: 4292:        break;
        -: 4293:    case DELTA_ITEM_CAS_MISMATCH:
        -: 4294:        break; /* Should never get here */
        -: 4295:    }
    #####: 4296:}
------------------
process_arithmetic_command:
    #####: 4249:static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    #####: 4250:    char temp[INCR_MAX_STORAGE_LEN];
    #####: 4251:    uint64_t delta;
    #####: 4252:    char *key;
    #####: 4253:    size_t nkey;
        -: 4254:
    #####: 4255:    assert(c != NULL);
        -: 4256:
    #####: 4257:    set_noreply_maybe(c, tokens, ntokens);
        -: 4258:
    #####: 4259:    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
    #####: 4260:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4261:        return;
        -: 4262:    }
        -: 4263:
    #####: 4264:    key = tokens[KEY_TOKEN].value;
    #####: 4265:    nkey = tokens[KEY_TOKEN].length;
        -: 4266:
    #####: 4267:    if (!safe_strtoull(tokens[2].value, &delta)) {
    #####: 4268:        out_string(c, "CLIENT_ERROR invalid numeric delta argument");
    #####: 4269:        return;
        -: 4270:    }
        -: 4271:
    #####: 4272:    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    #####: 4273:    case OK:
    #####: 4274:        out_string(c, temp);
    #####: 4275:        break;
    #####: 4276:    case NON_NUMERIC:
    #####: 4277:        out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
    #####: 4278:        break;
    #####: 4279:    case EOM:
    #####: 4280:        out_of_memory(c, "SERVER_ERROR out of memory");
    #####: 4281:        break;
    #####: 4282:    case DELTA_ITEM_NOT_FOUND:
    #####: 4283:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4284:        if (incr) {
    #####: 4285:            c->thread->stats.incr_misses++;
        -: 4286:        } else {
    #####: 4287:            c->thread->stats.decr_misses++;
        -: 4288:        }
    #####: 4289:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4290:
    #####: 4291:        out_string(c, "NOT_FOUND");
    #####: 4292:        break;
        -: 4293:    case DELTA_ITEM_CAS_MISMATCH:
        -: 4294:        break; /* Should never get here */
        -: 4295:    }
    #####: 4296:}
------------------
        -: 4297:
        -: 4298:/*
        -: 4299: * adds a delta value to a numeric item.
        -: 4300: *
        -: 4301: * c     connection requesting the operation
        -: 4302: * it    item to adjust
        -: 4303: * incr  true to increment value, false to decrement
        -: 4304: * delta amount to adjust value by
        -: 4305: * buf   buffer for response string
        -: 4306: *
        -: 4307: * returns a response string to send back to the client.
        -: 4308: */
    #####: 4309:enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
        -: 4310:                                    const bool incr, const int64_t delta,
        -: 4311:                                    char *buf, uint64_t *cas,
        -: 4312:                                    const uint32_t hv) {
    #####: 4313:    char *ptr;
    #####: 4314:    uint64_t value;
    #####: 4315:    int res;
    #####: 4316:    item *it;
        -: 4317:
    #####: 4318:    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    #####: 4319:    if (!it) {
        -: 4320:        return DELTA_ITEM_NOT_FOUND;
        -: 4321:    }
        -: 4322:
        -: 4323:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
        -: 4324:    /* Also can't delta for chunked items. Too large to be a number */
        -: 4325:#ifdef EXTSTORE
        -: 4326:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
        -: 4327:#else
    #####: 4328:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
        -: 4329:#endif
    #####: 4330:        do_item_remove(it);
    #####: 4331:        return NON_NUMERIC;
        -: 4332:    }
        -: 4333:
    #####: 4334:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
    #####: 4335:        do_item_remove(it);
    #####: 4336:        return DELTA_ITEM_CAS_MISMATCH;
        -: 4337:    }
        -: 4338:
    #####: 4339:    ptr = ITEM_data(it);
        -: 4340:
    #####: 4341:    if (!safe_strtoull(ptr, &value)) {
    #####: 4342:        do_item_remove(it);
    #####: 4343:        return NON_NUMERIC;
        -: 4344:    }
        -: 4345:
    #####: 4346:    if (incr) {
    #####: 4347:        value += delta;
    #####: 4348:        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4349:    } else {
    #####: 4350:        if(delta > value) {
    #####: 4351:            value = 0;
        -: 4352:        } else {
    #####: 4353:            value -= delta;
        -: 4354:        }
    #####: 4355:        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4356:    }
        -: 4357:
    #####: 4358:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4359:    if (incr) {
    #####: 4360:        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 4361:    } else {
    #####: 4362:        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 4363:    }
    #####: 4364:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4365:
    #####: 4366:    itoa_u64(value, buf);
    #####: 4367:    res = strlen(buf);
        -: 4368:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 4369:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 4370:     * increase. */
    #####: 4371:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 4372:        /* When changing the value without replacing the item, we
        -: 4373:           need to update the CAS on the existing item. */
        -: 4374:        /* We also need to fiddle it in the sizes tracker in case the tracking
        -: 4375:         * was enabled at runtime, since it relies on the CAS value to know
        -: 4376:         * whether to remove an item or not. */
    #####: 4377:        item_stats_sizes_remove(it);
    #####: 4378:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    #####: 4379:        item_stats_sizes_add(it);
    #####: 4380:        memcpy(ITEM_data(it), buf, res);
    #####: 4381:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
    #####: 4382:        do_item_update(it);
    #####: 4383:    } else if (it->refcount > 1) {
    #####: 4384:        item *new_it;
    #####: 4385:        uint32_t flags;
    #####: 4386:        FLAGS_CONV(it, flags);
    #####: 4387:        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
    #####: 4388:        if (new_it == 0) {
    #####: 4389:            do_item_remove(it);
    #####: 4390:            return EOM;
        -: 4391:        }
    #####: 4392:        memcpy(ITEM_data(new_it), buf, res);
    #####: 4393:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
    #####: 4394:        item_replace(it, new_it, hv);
        -: 4395:        // Overwrite the older item's CAS with our new CAS since we're
        -: 4396:        // returning the CAS of the old item below.
    #####: 4397:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
    #####: 4398:        do_item_remove(new_it);       /* release our reference */
        -: 4399:    } else {
        -: 4400:        /* Should never get here. This means we somehow fetched an unlinked
        -: 4401:         * item. TODO: Add a counter? */
    #####: 4402:        if (settings.verbose) {
    #####: 4403:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 4404:        }
    #####: 4405:        if (it->refcount == 1)
    #####: 4406:            do_item_remove(it);
    #####: 4407:        return DELTA_ITEM_NOT_FOUND;
        -: 4408:    }
        -: 4409:
    #####: 4410:    if (cas) {
    #####: 4411:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 4412:    }
    #####: 4413:    do_item_remove(it);         /* release our reference */
    #####: 4414:    return OK;
        -: 4415:}
------------------
do_add_delta:
    #####: 4309:enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
        -: 4310:                                    const bool incr, const int64_t delta,
        -: 4311:                                    char *buf, uint64_t *cas,
        -: 4312:                                    const uint32_t hv) {
    #####: 4313:    char *ptr;
    #####: 4314:    uint64_t value;
    #####: 4315:    int res;
    #####: 4316:    item *it;
        -: 4317:
    #####: 4318:    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    #####: 4319:    if (!it) {
        -: 4320:        return DELTA_ITEM_NOT_FOUND;
        -: 4321:    }
        -: 4322:
        -: 4323:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
        -: 4324:    /* Also can't delta for chunked items. Too large to be a number */
        -: 4325:#ifdef EXTSTORE
        -: 4326:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
        -: 4327:#else
    #####: 4328:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
        -: 4329:#endif
    #####: 4330:        do_item_remove(it);
    #####: 4331:        return NON_NUMERIC;
        -: 4332:    }
        -: 4333:
    #####: 4334:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
    #####: 4335:        do_item_remove(it);
    #####: 4336:        return DELTA_ITEM_CAS_MISMATCH;
        -: 4337:    }
        -: 4338:
    #####: 4339:    ptr = ITEM_data(it);
        -: 4340:
    #####: 4341:    if (!safe_strtoull(ptr, &value)) {
    #####: 4342:        do_item_remove(it);
    #####: 4343:        return NON_NUMERIC;
        -: 4344:    }
        -: 4345:
    #####: 4346:    if (incr) {
    #####: 4347:        value += delta;
    #####: 4348:        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4349:    } else {
    #####: 4350:        if(delta > value) {
    #####: 4351:            value = 0;
        -: 4352:        } else {
    #####: 4353:            value -= delta;
        -: 4354:        }
    #####: 4355:        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4356:    }
        -: 4357:
    #####: 4358:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4359:    if (incr) {
    #####: 4360:        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 4361:    } else {
    #####: 4362:        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 4363:    }
    #####: 4364:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4365:
    #####: 4366:    itoa_u64(value, buf);
    #####: 4367:    res = strlen(buf);
        -: 4368:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 4369:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 4370:     * increase. */
    #####: 4371:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 4372:        /* When changing the value without replacing the item, we
        -: 4373:           need to update the CAS on the existing item. */
        -: 4374:        /* We also need to fiddle it in the sizes tracker in case the tracking
        -: 4375:         * was enabled at runtime, since it relies on the CAS value to know
        -: 4376:         * whether to remove an item or not. */
    #####: 4377:        item_stats_sizes_remove(it);
    #####: 4378:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    #####: 4379:        item_stats_sizes_add(it);
    #####: 4380:        memcpy(ITEM_data(it), buf, res);
    #####: 4381:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
    #####: 4382:        do_item_update(it);
    #####: 4383:    } else if (it->refcount > 1) {
    #####: 4384:        item *new_it;
    #####: 4385:        uint32_t flags;
    #####: 4386:        FLAGS_CONV(it, flags);
    #####: 4387:        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
    #####: 4388:        if (new_it == 0) {
    #####: 4389:            do_item_remove(it);
    #####: 4390:            return EOM;
        -: 4391:        }
    #####: 4392:        memcpy(ITEM_data(new_it), buf, res);
    #####: 4393:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
    #####: 4394:        item_replace(it, new_it, hv);
        -: 4395:        // Overwrite the older item's CAS with our new CAS since we're
        -: 4396:        // returning the CAS of the old item below.
    #####: 4397:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
    #####: 4398:        do_item_remove(new_it);       /* release our reference */
        -: 4399:    } else {
        -: 4400:        /* Should never get here. This means we somehow fetched an unlinked
        -: 4401:         * item. TODO: Add a counter? */
    #####: 4402:        if (settings.verbose) {
    #####: 4403:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 4404:        }
    #####: 4405:        if (it->refcount == 1)
    #####: 4406:            do_item_remove(it);
    #####: 4407:        return DELTA_ITEM_NOT_FOUND;
        -: 4408:    }
        -: 4409:
    #####: 4410:    if (cas) {
    #####: 4411:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 4412:    }
    #####: 4413:    do_item_remove(it);         /* release our reference */
    #####: 4414:    return OK;
        -: 4415:}
------------------
do_add_delta:
    #####: 4309:enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
        -: 4310:                                    const bool incr, const int64_t delta,
        -: 4311:                                    char *buf, uint64_t *cas,
        -: 4312:                                    const uint32_t hv) {
    #####: 4313:    char *ptr;
    #####: 4314:    uint64_t value;
    #####: 4315:    int res;
    #####: 4316:    item *it;
        -: 4317:
    #####: 4318:    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    #####: 4319:    if (!it) {
        -: 4320:        return DELTA_ITEM_NOT_FOUND;
        -: 4321:    }
        -: 4322:
        -: 4323:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
        -: 4324:    /* Also can't delta for chunked items. Too large to be a number */
        -: 4325:#ifdef EXTSTORE
        -: 4326:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
        -: 4327:#else
    #####: 4328:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
        -: 4329:#endif
    #####: 4330:        do_item_remove(it);
    #####: 4331:        return NON_NUMERIC;
        -: 4332:    }
        -: 4333:
    #####: 4334:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
    #####: 4335:        do_item_remove(it);
    #####: 4336:        return DELTA_ITEM_CAS_MISMATCH;
        -: 4337:    }
        -: 4338:
    #####: 4339:    ptr = ITEM_data(it);
        -: 4340:
    #####: 4341:    if (!safe_strtoull(ptr, &value)) {
    #####: 4342:        do_item_remove(it);
    #####: 4343:        return NON_NUMERIC;
        -: 4344:    }
        -: 4345:
    #####: 4346:    if (incr) {
    #####: 4347:        value += delta;
    #####: 4348:        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4349:    } else {
    #####: 4350:        if(delta > value) {
    #####: 4351:            value = 0;
        -: 4352:        } else {
    #####: 4353:            value -= delta;
        -: 4354:        }
    #####: 4355:        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4356:    }
        -: 4357:
    #####: 4358:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4359:    if (incr) {
    #####: 4360:        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 4361:    } else {
    #####: 4362:        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 4363:    }
    #####: 4364:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4365:
    #####: 4366:    itoa_u64(value, buf);
    #####: 4367:    res = strlen(buf);
        -: 4368:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 4369:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 4370:     * increase. */
    #####: 4371:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 4372:        /* When changing the value without replacing the item, we
        -: 4373:           need to update the CAS on the existing item. */
        -: 4374:        /* We also need to fiddle it in the sizes tracker in case the tracking
        -: 4375:         * was enabled at runtime, since it relies on the CAS value to know
        -: 4376:         * whether to remove an item or not. */
    #####: 4377:        item_stats_sizes_remove(it);
    #####: 4378:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    #####: 4379:        item_stats_sizes_add(it);
    #####: 4380:        memcpy(ITEM_data(it), buf, res);
    #####: 4381:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
    #####: 4382:        do_item_update(it);
    #####: 4383:    } else if (it->refcount > 1) {
    #####: 4384:        item *new_it;
    #####: 4385:        uint32_t flags;
    #####: 4386:        FLAGS_CONV(it, flags);
    #####: 4387:        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
    #####: 4388:        if (new_it == 0) {
    #####: 4389:            do_item_remove(it);
    #####: 4390:            return EOM;
        -: 4391:        }
    #####: 4392:        memcpy(ITEM_data(new_it), buf, res);
    #####: 4393:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
    #####: 4394:        item_replace(it, new_it, hv);
        -: 4395:        // Overwrite the older item's CAS with our new CAS since we're
        -: 4396:        // returning the CAS of the old item below.
    #####: 4397:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
    #####: 4398:        do_item_remove(new_it);       /* release our reference */
        -: 4399:    } else {
        -: 4400:        /* Should never get here. This means we somehow fetched an unlinked
        -: 4401:         * item. TODO: Add a counter? */
    #####: 4402:        if (settings.verbose) {
    #####: 4403:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 4404:        }
    #####: 4405:        if (it->refcount == 1)
    #####: 4406:            do_item_remove(it);
    #####: 4407:        return DELTA_ITEM_NOT_FOUND;
        -: 4408:    }
        -: 4409:
    #####: 4410:    if (cas) {
    #####: 4411:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 4412:    }
    #####: 4413:    do_item_remove(it);         /* release our reference */
    #####: 4414:    return OK;
        -: 4415:}
------------------
do_add_delta:
    #####: 4309:enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
        -: 4310:                                    const bool incr, const int64_t delta,
        -: 4311:                                    char *buf, uint64_t *cas,
        -: 4312:                                    const uint32_t hv) {
    #####: 4313:    char *ptr;
    #####: 4314:    uint64_t value;
    #####: 4315:    int res;
    #####: 4316:    item *it;
        -: 4317:
    #####: 4318:    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    #####: 4319:    if (!it) {
        -: 4320:        return DELTA_ITEM_NOT_FOUND;
        -: 4321:    }
        -: 4322:
        -: 4323:    /* Can't delta zero byte values. 2-byte are the "\r\n" */
        -: 4324:    /* Also can't delta for chunked items. Too large to be a number */
        -: 4325:#ifdef EXTSTORE
        -: 4326:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
        -: 4327:#else
    #####: 4328:    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
        -: 4329:#endif
    #####: 4330:        do_item_remove(it);
    #####: 4331:        return NON_NUMERIC;
        -: 4332:    }
        -: 4333:
    #####: 4334:    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
    #####: 4335:        do_item_remove(it);
    #####: 4336:        return DELTA_ITEM_CAS_MISMATCH;
        -: 4337:    }
        -: 4338:
    #####: 4339:    ptr = ITEM_data(it);
        -: 4340:
    #####: 4341:    if (!safe_strtoull(ptr, &value)) {
    #####: 4342:        do_item_remove(it);
    #####: 4343:        return NON_NUMERIC;
        -: 4344:    }
        -: 4345:
    #####: 4346:    if (incr) {
    #####: 4347:        value += delta;
    #####: 4348:        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4349:    } else {
    #####: 4350:        if(delta > value) {
    #####: 4351:            value = 0;
        -: 4352:        } else {
    #####: 4353:            value -= delta;
        -: 4354:        }
    #####: 4355:        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
        -: 4356:    }
        -: 4357:
    #####: 4358:    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4359:    if (incr) {
    #####: 4360:        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
        -: 4361:    } else {
    #####: 4362:        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
        -: 4363:    }
    #####: 4364:    pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4365:
    #####: 4366:    itoa_u64(value, buf);
    #####: 4367:    res = strlen(buf);
        -: 4368:    /* refcount == 2 means we are the only ones holding the item, and it is
        -: 4369:     * linked. We hold the item's lock in this function, so refcount cannot
        -: 4370:     * increase. */
    #####: 4371:    if (res + 2 <= it->nbytes && it->refcount == 2) { /* replace in-place */
        -: 4372:        /* When changing the value without replacing the item, we
        -: 4373:           need to update the CAS on the existing item. */
        -: 4374:        /* We also need to fiddle it in the sizes tracker in case the tracking
        -: 4375:         * was enabled at runtime, since it relies on the CAS value to know
        -: 4376:         * whether to remove an item or not. */
    #####: 4377:        item_stats_sizes_remove(it);
    #####: 4378:        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    #####: 4379:        item_stats_sizes_add(it);
    #####: 4380:        memcpy(ITEM_data(it), buf, res);
    #####: 4381:        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
    #####: 4382:        do_item_update(it);
    #####: 4383:    } else if (it->refcount > 1) {
    #####: 4384:        item *new_it;
    #####: 4385:        uint32_t flags;
    #####: 4386:        FLAGS_CONV(it, flags);
    #####: 4387:        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
    #####: 4388:        if (new_it == 0) {
    #####: 4389:            do_item_remove(it);
    #####: 4390:            return EOM;
        -: 4391:        }
    #####: 4392:        memcpy(ITEM_data(new_it), buf, res);
    #####: 4393:        memcpy(ITEM_data(new_it) + res, "\r\n", 2);
    #####: 4394:        item_replace(it, new_it, hv);
        -: 4395:        // Overwrite the older item's CAS with our new CAS since we're
        -: 4396:        // returning the CAS of the old item below.
    #####: 4397:        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
    #####: 4398:        do_item_remove(new_it);       /* release our reference */
        -: 4399:    } else {
        -: 4400:        /* Should never get here. This means we somehow fetched an unlinked
        -: 4401:         * item. TODO: Add a counter? */
    #####: 4402:        if (settings.verbose) {
    #####: 4403:            fprintf(stderr, "Tried to do incr/decr on invalid item\n");
        -: 4404:        }
    #####: 4405:        if (it->refcount == 1)
    #####: 4406:            do_item_remove(it);
    #####: 4407:        return DELTA_ITEM_NOT_FOUND;
        -: 4408:    }
        -: 4409:
    #####: 4410:    if (cas) {
    #####: 4411:        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
        -: 4412:    }
    #####: 4413:    do_item_remove(it);         /* release our reference */
    #####: 4414:    return OK;
        -: 4415:}
------------------
        -: 4416:
    #####: 4417:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4418:    char *key;
    #####: 4419:    size_t nkey;
    #####: 4420:    item *it;
    #####: 4421:    uint32_t hv;
        -: 4422:
    #####: 4423:    assert(c != NULL);
        -: 4424:
    #####: 4425:    if (ntokens > 3) {
    #####: 4426:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
    #####: 4427:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
    #####: 4428:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
    #####: 4429:            || (ntokens == 5 && hold_is_zero && sets_noreply);
    #####: 4430:        if (!valid) {
    #####: 4431:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 4432:                       "Usage: delete <key> [noreply]");
    #####: 4433:            return;
        -: 4434:        }
        -: 4435:    }
        -: 4436:
        -: 4437:
    #####: 4438:    key = tokens[KEY_TOKEN].value;
    #####: 4439:    nkey = tokens[KEY_TOKEN].length;
        -: 4440:
    #####: 4441:    if(nkey > KEY_MAX_LENGTH) {
    #####: 4442:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4443:        return;
        -: 4444:    }
        -: 4445:
    #####: 4446:    if (settings.detail_enabled) {
    #####: 4447:        stats_prefix_record_delete(key, nkey);
        -: 4448:    }
        -: 4449:
    #####: 4450:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 4451:    if (it) {
    #####: 4452:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 4453:
    #####: 4454:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4455:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 4456:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4457:
    #####: 4458:        do_item_unlink(it, hv);
    #####: 4459:        STORAGE_delete(c->thread->storage, it);
    #####: 4460:        do_item_remove(it);      /* release our reference */
    #####: 4461:        out_string(c, "DELETED");
        -: 4462:    } else {
    #####: 4463:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4464:        c->thread->stats.delete_misses++;
    #####: 4465:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4466:
    #####: 4467:        out_string(c, "NOT_FOUND");
        -: 4468:    }
    #####: 4469:    item_unlock(hv);
        -: 4470:}
------------------
process_delete_command:
    #####: 4417:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4418:    char *key;
    #####: 4419:    size_t nkey;
    #####: 4420:    item *it;
    #####: 4421:    uint32_t hv;
        -: 4422:
    #####: 4423:    assert(c != NULL);
        -: 4424:
    #####: 4425:    if (ntokens > 3) {
    #####: 4426:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
    #####: 4427:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
    #####: 4428:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
    #####: 4429:            || (ntokens == 5 && hold_is_zero && sets_noreply);
    #####: 4430:        if (!valid) {
    #####: 4431:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 4432:                       "Usage: delete <key> [noreply]");
    #####: 4433:            return;
        -: 4434:        }
        -: 4435:    }
        -: 4436:
        -: 4437:
    #####: 4438:    key = tokens[KEY_TOKEN].value;
    #####: 4439:    nkey = tokens[KEY_TOKEN].length;
        -: 4440:
    #####: 4441:    if(nkey > KEY_MAX_LENGTH) {
    #####: 4442:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4443:        return;
        -: 4444:    }
        -: 4445:
    #####: 4446:    if (settings.detail_enabled) {
    #####: 4447:        stats_prefix_record_delete(key, nkey);
        -: 4448:    }
        -: 4449:
    #####: 4450:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 4451:    if (it) {
    #####: 4452:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 4453:
    #####: 4454:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4455:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 4456:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4457:
    #####: 4458:        do_item_unlink(it, hv);
    #####: 4459:        STORAGE_delete(c->thread->storage, it);
    #####: 4460:        do_item_remove(it);      /* release our reference */
    #####: 4461:        out_string(c, "DELETED");
        -: 4462:    } else {
    #####: 4463:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4464:        c->thread->stats.delete_misses++;
    #####: 4465:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4466:
    #####: 4467:        out_string(c, "NOT_FOUND");
        -: 4468:    }
    #####: 4469:    item_unlock(hv);
        -: 4470:}
------------------
process_delete_command:
    #####: 4417:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4418:    char *key;
    #####: 4419:    size_t nkey;
    #####: 4420:    item *it;
    #####: 4421:    uint32_t hv;
        -: 4422:
    #####: 4423:    assert(c != NULL);
        -: 4424:
    #####: 4425:    if (ntokens > 3) {
    #####: 4426:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
    #####: 4427:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
    #####: 4428:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
    #####: 4429:            || (ntokens == 5 && hold_is_zero && sets_noreply);
    #####: 4430:        if (!valid) {
    #####: 4431:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 4432:                       "Usage: delete <key> [noreply]");
    #####: 4433:            return;
        -: 4434:        }
        -: 4435:    }
        -: 4436:
        -: 4437:
    #####: 4438:    key = tokens[KEY_TOKEN].value;
    #####: 4439:    nkey = tokens[KEY_TOKEN].length;
        -: 4440:
    #####: 4441:    if(nkey > KEY_MAX_LENGTH) {
    #####: 4442:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4443:        return;
        -: 4444:    }
        -: 4445:
    #####: 4446:    if (settings.detail_enabled) {
    #####: 4447:        stats_prefix_record_delete(key, nkey);
        -: 4448:    }
        -: 4449:
    #####: 4450:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 4451:    if (it) {
    #####: 4452:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 4453:
    #####: 4454:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4455:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 4456:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4457:
    #####: 4458:        do_item_unlink(it, hv);
    #####: 4459:        STORAGE_delete(c->thread->storage, it);
    #####: 4460:        do_item_remove(it);      /* release our reference */
    #####: 4461:        out_string(c, "DELETED");
        -: 4462:    } else {
    #####: 4463:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4464:        c->thread->stats.delete_misses++;
    #####: 4465:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4466:
    #####: 4467:        out_string(c, "NOT_FOUND");
        -: 4468:    }
    #####: 4469:    item_unlock(hv);
        -: 4470:}
------------------
process_delete_command:
    #####: 4417:static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4418:    char *key;
    #####: 4419:    size_t nkey;
    #####: 4420:    item *it;
    #####: 4421:    uint32_t hv;
        -: 4422:
    #####: 4423:    assert(c != NULL);
        -: 4424:
    #####: 4425:    if (ntokens > 3) {
    #####: 4426:        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
    #####: 4427:        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
    #####: 4428:        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
    #####: 4429:            || (ntokens == 5 && hold_is_zero && sets_noreply);
    #####: 4430:        if (!valid) {
    #####: 4431:            out_string(c, "CLIENT_ERROR bad command line format.  "
        -: 4432:                       "Usage: delete <key> [noreply]");
    #####: 4433:            return;
        -: 4434:        }
        -: 4435:    }
        -: 4436:
        -: 4437:
    #####: 4438:    key = tokens[KEY_TOKEN].value;
    #####: 4439:    nkey = tokens[KEY_TOKEN].length;
        -: 4440:
    #####: 4441:    if(nkey > KEY_MAX_LENGTH) {
    #####: 4442:        out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4443:        return;
        -: 4444:    }
        -: 4445:
    #####: 4446:    if (settings.detail_enabled) {
    #####: 4447:        stats_prefix_record_delete(key, nkey);
        -: 4448:    }
        -: 4449:
    #####: 4450:    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    #####: 4451:    if (it) {
    #####: 4452:        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
        -: 4453:
    #####: 4454:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4455:        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
    #####: 4456:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4457:
    #####: 4458:        do_item_unlink(it, hv);
    #####: 4459:        STORAGE_delete(c->thread->storage, it);
    #####: 4460:        do_item_remove(it);      /* release our reference */
    #####: 4461:        out_string(c, "DELETED");
        -: 4462:    } else {
    #####: 4463:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4464:        c->thread->stats.delete_misses++;
    #####: 4465:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4466:
    #####: 4467:        out_string(c, "NOT_FOUND");
        -: 4468:    }
    #####: 4469:    item_unlock(hv);
        -: 4470:}
------------------
        -: 4471:
    #####: 4472:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4473:    unsigned int level;
        -: 4474:
    #####: 4475:    assert(c != NULL);
        -: 4476:
    #####: 4477:    set_noreply_maybe(c, tokens, ntokens);
        -: 4478:
    #####: 4479:    level = strtoul(tokens[1].value, NULL, 10);
    #####: 4480:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    #####: 4481:    out_string(c, "OK");
    #####: 4482:    return;
        -: 4483:}
------------------
process_verbosity_command:
    #####: 4472:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4473:    unsigned int level;
        -: 4474:
    #####: 4475:    assert(c != NULL);
        -: 4476:
    #####: 4477:    set_noreply_maybe(c, tokens, ntokens);
        -: 4478:
    #####: 4479:    level = strtoul(tokens[1].value, NULL, 10);
    #####: 4480:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    #####: 4481:    out_string(c, "OK");
    #####: 4482:    return;
        -: 4483:}
------------------
process_verbosity_command:
    #####: 4472:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4473:    unsigned int level;
        -: 4474:
    #####: 4475:    assert(c != NULL);
        -: 4476:
    #####: 4477:    set_noreply_maybe(c, tokens, ntokens);
        -: 4478:
    #####: 4479:    level = strtoul(tokens[1].value, NULL, 10);
    #####: 4480:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    #####: 4481:    out_string(c, "OK");
    #####: 4482:    return;
        -: 4483:}
------------------
process_verbosity_command:
    #####: 4472:static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4473:    unsigned int level;
        -: 4474:
    #####: 4475:    assert(c != NULL);
        -: 4476:
    #####: 4477:    set_noreply_maybe(c, tokens, ntokens);
        -: 4478:
    #####: 4479:    level = strtoul(tokens[1].value, NULL, 10);
    #####: 4480:    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    #####: 4481:    out_string(c, "OK");
    #####: 4482:    return;
        -: 4483:}
------------------
        -: 4484:
        -: 4485:#ifdef MEMCACHED_DEBUG
    #####: 4486:static void process_misbehave_command(conn *c) {
    #####: 4487:    int allowed = 0;
        -: 4488:
        -: 4489:    // try opening new TCP socket
    #####: 4490:    int i = socket(AF_INET, SOCK_STREAM, 0);
    #####: 4491:    if (i != -1) {
    #####: 4492:        allowed++;
    #####: 4493:        close(i);
        -: 4494:    }
        -: 4495:
        -: 4496:    // try executing new commands
    #####: 4497:    i = system("sleep 0");
    #####: 4498:    if (i != -1) {
    #####: 4499:        allowed++;
        -: 4500:    }
        -: 4501:
    #####: 4502:    if (allowed) {
    #####: 4503:        out_string(c, "ERROR");
        -: 4504:    } else {
    #####: 4505:        out_string(c, "OK");
        -: 4506:    }
    #####: 4507:}
------------------
process_misbehave_command:
    #####: 4486:static void process_misbehave_command(conn *c) {
    #####: 4487:    int allowed = 0;
        -: 4488:
        -: 4489:    // try opening new TCP socket
    #####: 4490:    int i = socket(AF_INET, SOCK_STREAM, 0);
    #####: 4491:    if (i != -1) {
    #####: 4492:        allowed++;
    #####: 4493:        close(i);
        -: 4494:    }
        -: 4495:
        -: 4496:    // try executing new commands
    #####: 4497:    i = system("sleep 0");
    #####: 4498:    if (i != -1) {
    #####: 4499:        allowed++;
        -: 4500:    }
        -: 4501:
    #####: 4502:    if (allowed) {
    #####: 4503:        out_string(c, "ERROR");
        -: 4504:    } else {
    #####: 4505:        out_string(c, "OK");
        -: 4506:    }
    #####: 4507:}
------------------
process_misbehave_command:
    #####: 4486:static void process_misbehave_command(conn *c) {
    #####: 4487:    int allowed = 0;
        -: 4488:
        -: 4489:    // try opening new TCP socket
    #####: 4490:    int i = socket(AF_INET, SOCK_STREAM, 0);
    #####: 4491:    if (i != -1) {
    #####: 4492:        allowed++;
    #####: 4493:        close(i);
        -: 4494:    }
        -: 4495:
        -: 4496:    // try executing new commands
    #####: 4497:    i = system("sleep 0");
    #####: 4498:    if (i != -1) {
    #####: 4499:        allowed++;
        -: 4500:    }
        -: 4501:
    #####: 4502:    if (allowed) {
    #####: 4503:        out_string(c, "ERROR");
        -: 4504:    } else {
    #####: 4505:        out_string(c, "OK");
        -: 4506:    }
    #####: 4507:}
------------------
process_misbehave_command:
    #####: 4486:static void process_misbehave_command(conn *c) {
    #####: 4487:    int allowed = 0;
        -: 4488:
        -: 4489:    // try opening new TCP socket
    #####: 4490:    int i = socket(AF_INET, SOCK_STREAM, 0);
    #####: 4491:    if (i != -1) {
    #####: 4492:        allowed++;
    #####: 4493:        close(i);
        -: 4494:    }
        -: 4495:
        -: 4496:    // try executing new commands
    #####: 4497:    i = system("sleep 0");
    #####: 4498:    if (i != -1) {
    #####: 4499:        allowed++;
        -: 4500:    }
        -: 4501:
    #####: 4502:    if (allowed) {
    #####: 4503:        out_string(c, "ERROR");
        -: 4504:    } else {
    #####: 4505:        out_string(c, "OK");
        -: 4506:    }
    #####: 4507:}
------------------
        -: 4508:#endif
        -: 4509:
    #####: 4510:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4511:    unsigned int level;
    #####: 4512:    double ratio;
        -: 4513:
    #####: 4514:    assert(c != NULL);
        -: 4515:
    #####: 4516:    set_noreply_maybe(c, tokens, ntokens);
        -: 4517:
    #####: 4518:    if (strcmp(tokens[2].value, "ratio") == 0) {
    #####: 4519:        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
    #####: 4520:            out_string(c, "ERROR");
    #####: 4521:            return;
        -: 4522:        }
    #####: 4523:        settings.slab_automove_ratio = ratio;
        -: 4524:    } else {
    #####: 4525:        level = strtoul(tokens[2].value, NULL, 10);
    #####: 4526:        if (level == 0) {
    #####: 4527:            settings.slab_automove = 0;
    #####: 4528:        } else if (level == 1 || level == 2) {
    #####: 4529:            settings.slab_automove = level;
        -: 4530:        } else {
    #####: 4531:            out_string(c, "ERROR");
    #####: 4532:            return;
        -: 4533:        }
        -: 4534:    }
    #####: 4535:    out_string(c, "OK");
    #####: 4536:    return;
        -: 4537:}
------------------
process_slabs_automove_command:
    #####: 4510:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4511:    unsigned int level;
    #####: 4512:    double ratio;
        -: 4513:
    #####: 4514:    assert(c != NULL);
        -: 4515:
    #####: 4516:    set_noreply_maybe(c, tokens, ntokens);
        -: 4517:
    #####: 4518:    if (strcmp(tokens[2].value, "ratio") == 0) {
    #####: 4519:        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
    #####: 4520:            out_string(c, "ERROR");
    #####: 4521:            return;
        -: 4522:        }
    #####: 4523:        settings.slab_automove_ratio = ratio;
        -: 4524:    } else {
    #####: 4525:        level = strtoul(tokens[2].value, NULL, 10);
    #####: 4526:        if (level == 0) {
    #####: 4527:            settings.slab_automove = 0;
    #####: 4528:        } else if (level == 1 || level == 2) {
    #####: 4529:            settings.slab_automove = level;
        -: 4530:        } else {
    #####: 4531:            out_string(c, "ERROR");
    #####: 4532:            return;
        -: 4533:        }
        -: 4534:    }
    #####: 4535:    out_string(c, "OK");
    #####: 4536:    return;
        -: 4537:}
------------------
process_slabs_automove_command:
    #####: 4510:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4511:    unsigned int level;
    #####: 4512:    double ratio;
        -: 4513:
    #####: 4514:    assert(c != NULL);
        -: 4515:
    #####: 4516:    set_noreply_maybe(c, tokens, ntokens);
        -: 4517:
    #####: 4518:    if (strcmp(tokens[2].value, "ratio") == 0) {
    #####: 4519:        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
    #####: 4520:            out_string(c, "ERROR");
    #####: 4521:            return;
        -: 4522:        }
    #####: 4523:        settings.slab_automove_ratio = ratio;
        -: 4524:    } else {
    #####: 4525:        level = strtoul(tokens[2].value, NULL, 10);
    #####: 4526:        if (level == 0) {
    #####: 4527:            settings.slab_automove = 0;
    #####: 4528:        } else if (level == 1 || level == 2) {
    #####: 4529:            settings.slab_automove = level;
        -: 4530:        } else {
    #####: 4531:            out_string(c, "ERROR");
    #####: 4532:            return;
        -: 4533:        }
        -: 4534:    }
    #####: 4535:    out_string(c, "OK");
    #####: 4536:    return;
        -: 4537:}
------------------
process_slabs_automove_command:
    #####: 4510:static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4511:    unsigned int level;
    #####: 4512:    double ratio;
        -: 4513:
    #####: 4514:    assert(c != NULL);
        -: 4515:
    #####: 4516:    set_noreply_maybe(c, tokens, ntokens);
        -: 4517:
    #####: 4518:    if (strcmp(tokens[2].value, "ratio") == 0) {
    #####: 4519:        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
    #####: 4520:            out_string(c, "ERROR");
    #####: 4521:            return;
        -: 4522:        }
    #####: 4523:        settings.slab_automove_ratio = ratio;
        -: 4524:    } else {
    #####: 4525:        level = strtoul(tokens[2].value, NULL, 10);
    #####: 4526:        if (level == 0) {
    #####: 4527:            settings.slab_automove = 0;
    #####: 4528:        } else if (level == 1 || level == 2) {
    #####: 4529:            settings.slab_automove = level;
        -: 4530:        } else {
    #####: 4531:            out_string(c, "ERROR");
    #####: 4532:            return;
        -: 4533:        }
        -: 4534:    }
    #####: 4535:    out_string(c, "OK");
    #####: 4536:    return;
        -: 4537:}
------------------
        -: 4538:
        -: 4539:/* TODO: decide on syntax for sampling? */
    #####: 4540:static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4541:    uint16_t f = 0;
    #####: 4542:    int x;
    #####: 4543:    assert(c != NULL);
        -: 4544:
    #####: 4545:    set_noreply_maybe(c, tokens, ntokens);
    #####: 4546:    if (ntokens > 2) {
    #####: 4547:        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
    #####: 4548:            if ((strcmp(tokens[x].value, "rawcmds") == 0)) {
    #####: 4549:                f |= LOG_RAWCMDS;
    #####: 4550:            } else if ((strcmp(tokens[x].value, "evictions") == 0)) {
    #####: 4551:                f |= LOG_EVICTIONS;
    #####: 4552:            } else if ((strcmp(tokens[x].value, "fetchers") == 0)) {
    #####: 4553:                f |= LOG_FETCHERS;
    #####: 4554:            } else if ((strcmp(tokens[x].value, "mutations") == 0)) {
    #####: 4555:                f |= LOG_MUTATIONS;
    #####: 4556:            } else if ((strcmp(tokens[x].value, "sysevents") == 0)) {
    #####: 4557:                f |= LOG_SYSEVENTS;
        -: 4558:            } else {
    #####: 4559:                out_string(c, "ERROR");
    #####: 4560:                return;
        -: 4561:            }
        -: 4562:        }
        -: 4563:    } else {
        -: 4564:        f |= LOG_FETCHERS;
        -: 4565:    }
        -: 4566:
    #####: 4567:    switch(logger_add_watcher(c, c->sfd, f)) {
    #####: 4568:        case LOGGER_ADD_WATCHER_TOO_MANY:
    #####: 4569:            out_string(c, "WATCHER_TOO_MANY log watcher limit reached");
    #####: 4570:            break;
    #####: 4571:        case LOGGER_ADD_WATCHER_FAILED:
    #####: 4572:            out_string(c, "WATCHER_FAILED failed to add log watcher");
    #####: 4573:            break;
    #####: 4574:        case LOGGER_ADD_WATCHER_OK:
    #####: 4575:            conn_set_state(c, conn_watch);
    #####: 4576:            event_del(&c->event);
    #####: 4577:            break;
        -: 4578:    }
    #####: 4579:}
------------------
process_watch_command:
    #####: 4540:static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4541:    uint16_t f = 0;
    #####: 4542:    int x;
    #####: 4543:    assert(c != NULL);
        -: 4544:
    #####: 4545:    set_noreply_maybe(c, tokens, ntokens);
    #####: 4546:    if (ntokens > 2) {
    #####: 4547:        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
    #####: 4548:            if ((strcmp(tokens[x].value, "rawcmds") == 0)) {
    #####: 4549:                f |= LOG_RAWCMDS;
    #####: 4550:            } else if ((strcmp(tokens[x].value, "evictions") == 0)) {
    #####: 4551:                f |= LOG_EVICTIONS;
    #####: 4552:            } else if ((strcmp(tokens[x].value, "fetchers") == 0)) {
    #####: 4553:                f |= LOG_FETCHERS;
    #####: 4554:            } else if ((strcmp(tokens[x].value, "mutations") == 0)) {
    #####: 4555:                f |= LOG_MUTATIONS;
    #####: 4556:            } else if ((strcmp(tokens[x].value, "sysevents") == 0)) {
    #####: 4557:                f |= LOG_SYSEVENTS;
        -: 4558:            } else {
    #####: 4559:                out_string(c, "ERROR");
    #####: 4560:                return;
        -: 4561:            }
        -: 4562:        }
        -: 4563:    } else {
        -: 4564:        f |= LOG_FETCHERS;
        -: 4565:    }
        -: 4566:
    #####: 4567:    switch(logger_add_watcher(c, c->sfd, f)) {
    #####: 4568:        case LOGGER_ADD_WATCHER_TOO_MANY:
    #####: 4569:            out_string(c, "WATCHER_TOO_MANY log watcher limit reached");
    #####: 4570:            break;
    #####: 4571:        case LOGGER_ADD_WATCHER_FAILED:
    #####: 4572:            out_string(c, "WATCHER_FAILED failed to add log watcher");
    #####: 4573:            break;
    #####: 4574:        case LOGGER_ADD_WATCHER_OK:
    #####: 4575:            conn_set_state(c, conn_watch);
    #####: 4576:            event_del(&c->event);
    #####: 4577:            break;
        -: 4578:    }
    #####: 4579:}
------------------
process_watch_command:
    #####: 4540:static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4541:    uint16_t f = 0;
    #####: 4542:    int x;
    #####: 4543:    assert(c != NULL);
        -: 4544:
    #####: 4545:    set_noreply_maybe(c, tokens, ntokens);
    #####: 4546:    if (ntokens > 2) {
    #####: 4547:        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
    #####: 4548:            if ((strcmp(tokens[x].value, "rawcmds") == 0)) {
    #####: 4549:                f |= LOG_RAWCMDS;
    #####: 4550:            } else if ((strcmp(tokens[x].value, "evictions") == 0)) {
    #####: 4551:                f |= LOG_EVICTIONS;
    #####: 4552:            } else if ((strcmp(tokens[x].value, "fetchers") == 0)) {
    #####: 4553:                f |= LOG_FETCHERS;
    #####: 4554:            } else if ((strcmp(tokens[x].value, "mutations") == 0)) {
    #####: 4555:                f |= LOG_MUTATIONS;
    #####: 4556:            } else if ((strcmp(tokens[x].value, "sysevents") == 0)) {
    #####: 4557:                f |= LOG_SYSEVENTS;
        -: 4558:            } else {
    #####: 4559:                out_string(c, "ERROR");
    #####: 4560:                return;
        -: 4561:            }
        -: 4562:        }
        -: 4563:    } else {
        -: 4564:        f |= LOG_FETCHERS;
        -: 4565:    }
        -: 4566:
    #####: 4567:    switch(logger_add_watcher(c, c->sfd, f)) {
    #####: 4568:        case LOGGER_ADD_WATCHER_TOO_MANY:
    #####: 4569:            out_string(c, "WATCHER_TOO_MANY log watcher limit reached");
    #####: 4570:            break;
    #####: 4571:        case LOGGER_ADD_WATCHER_FAILED:
    #####: 4572:            out_string(c, "WATCHER_FAILED failed to add log watcher");
    #####: 4573:            break;
    #####: 4574:        case LOGGER_ADD_WATCHER_OK:
    #####: 4575:            conn_set_state(c, conn_watch);
    #####: 4576:            event_del(&c->event);
    #####: 4577:            break;
        -: 4578:    }
    #####: 4579:}
------------------
process_watch_command:
    #####: 4540:static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4541:    uint16_t f = 0;
    #####: 4542:    int x;
    #####: 4543:    assert(c != NULL);
        -: 4544:
    #####: 4545:    set_noreply_maybe(c, tokens, ntokens);
    #####: 4546:    if (ntokens > 2) {
    #####: 4547:        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
    #####: 4548:            if ((strcmp(tokens[x].value, "rawcmds") == 0)) {
    #####: 4549:                f |= LOG_RAWCMDS;
    #####: 4550:            } else if ((strcmp(tokens[x].value, "evictions") == 0)) {
    #####: 4551:                f |= LOG_EVICTIONS;
    #####: 4552:            } else if ((strcmp(tokens[x].value, "fetchers") == 0)) {
    #####: 4553:                f |= LOG_FETCHERS;
    #####: 4554:            } else if ((strcmp(tokens[x].value, "mutations") == 0)) {
    #####: 4555:                f |= LOG_MUTATIONS;
    #####: 4556:            } else if ((strcmp(tokens[x].value, "sysevents") == 0)) {
    #####: 4557:                f |= LOG_SYSEVENTS;
        -: 4558:            } else {
    #####: 4559:                out_string(c, "ERROR");
    #####: 4560:                return;
        -: 4561:            }
        -: 4562:        }
        -: 4563:    } else {
        -: 4564:        f |= LOG_FETCHERS;
        -: 4565:    }
        -: 4566:
    #####: 4567:    switch(logger_add_watcher(c, c->sfd, f)) {
    #####: 4568:        case LOGGER_ADD_WATCHER_TOO_MANY:
    #####: 4569:            out_string(c, "WATCHER_TOO_MANY log watcher limit reached");
    #####: 4570:            break;
    #####: 4571:        case LOGGER_ADD_WATCHER_FAILED:
    #####: 4572:            out_string(c, "WATCHER_FAILED failed to add log watcher");
    #####: 4573:            break;
    #####: 4574:        case LOGGER_ADD_WATCHER_OK:
    #####: 4575:            conn_set_state(c, conn_watch);
    #####: 4576:            event_del(&c->event);
    #####: 4577:            break;
        -: 4578:    }
    #####: 4579:}
------------------
        -: 4580:
    #####: 4581:static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4582:    uint32_t memlimit;
    #####: 4583:    assert(c != NULL);
        -: 4584:
    #####: 4585:    set_noreply_maybe(c, tokens, ntokens);
        -: 4586:
    #####: 4587:    if (!safe_strtoul(tokens[1].value, &memlimit)) {
    #####: 4588:        out_string(c, "ERROR");
        -: 4589:    } else {
    #####: 4590:        if (memlimit < 8) {
    #####: 4591:            out_string(c, "MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m");
        -: 4592:        } else {
    #####: 4593:            if (memlimit > 1000000000) {
    #####: 4594:                out_string(c, "MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes");
    #####: 4595:            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
    #####: 4596:                if (settings.verbose > 0) {
    #####: 4597:                    fprintf(stderr, "maxbytes adjusted to %llum\n", (unsigned long long)memlimit);
        -: 4598:                }
        -: 4599:
    #####: 4600:                out_string(c, "OK");
        -: 4601:            } else {
    #####: 4602:                out_string(c, "MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust");
        -: 4603:            }
        -: 4604:        }
        -: 4605:    }
    #####: 4606:}
------------------
process_memlimit_command:
    #####: 4581:static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4582:    uint32_t memlimit;
    #####: 4583:    assert(c != NULL);
        -: 4584:
    #####: 4585:    set_noreply_maybe(c, tokens, ntokens);
        -: 4586:
    #####: 4587:    if (!safe_strtoul(tokens[1].value, &memlimit)) {
    #####: 4588:        out_string(c, "ERROR");
        -: 4589:    } else {
    #####: 4590:        if (memlimit < 8) {
    #####: 4591:            out_string(c, "MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m");
        -: 4592:        } else {
    #####: 4593:            if (memlimit > 1000000000) {
    #####: 4594:                out_string(c, "MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes");
    #####: 4595:            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
    #####: 4596:                if (settings.verbose > 0) {
    #####: 4597:                    fprintf(stderr, "maxbytes adjusted to %llum\n", (unsigned long long)memlimit);
        -: 4598:                }
        -: 4599:
    #####: 4600:                out_string(c, "OK");
        -: 4601:            } else {
    #####: 4602:                out_string(c, "MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust");
        -: 4603:            }
        -: 4604:        }
        -: 4605:    }
    #####: 4606:}
------------------
process_memlimit_command:
    #####: 4581:static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4582:    uint32_t memlimit;
    #####: 4583:    assert(c != NULL);
        -: 4584:
    #####: 4585:    set_noreply_maybe(c, tokens, ntokens);
        -: 4586:
    #####: 4587:    if (!safe_strtoul(tokens[1].value, &memlimit)) {
    #####: 4588:        out_string(c, "ERROR");
        -: 4589:    } else {
    #####: 4590:        if (memlimit < 8) {
    #####: 4591:            out_string(c, "MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m");
        -: 4592:        } else {
    #####: 4593:            if (memlimit > 1000000000) {
    #####: 4594:                out_string(c, "MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes");
    #####: 4595:            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
    #####: 4596:                if (settings.verbose > 0) {
    #####: 4597:                    fprintf(stderr, "maxbytes adjusted to %llum\n", (unsigned long long)memlimit);
        -: 4598:                }
        -: 4599:
    #####: 4600:                out_string(c, "OK");
        -: 4601:            } else {
    #####: 4602:                out_string(c, "MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust");
        -: 4603:            }
        -: 4604:        }
        -: 4605:    }
    #####: 4606:}
------------------
process_memlimit_command:
    #####: 4581:static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4582:    uint32_t memlimit;
    #####: 4583:    assert(c != NULL);
        -: 4584:
    #####: 4585:    set_noreply_maybe(c, tokens, ntokens);
        -: 4586:
    #####: 4587:    if (!safe_strtoul(tokens[1].value, &memlimit)) {
    #####: 4588:        out_string(c, "ERROR");
        -: 4589:    } else {
    #####: 4590:        if (memlimit < 8) {
    #####: 4591:            out_string(c, "MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m");
        -: 4592:        } else {
    #####: 4593:            if (memlimit > 1000000000) {
    #####: 4594:                out_string(c, "MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes");
    #####: 4595:            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
    #####: 4596:                if (settings.verbose > 0) {
    #####: 4597:                    fprintf(stderr, "maxbytes adjusted to %llum\n", (unsigned long long)memlimit);
        -: 4598:                }
        -: 4599:
    #####: 4600:                out_string(c, "OK");
        -: 4601:            } else {
    #####: 4602:                out_string(c, "MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust");
        -: 4603:            }
        -: 4604:        }
        -: 4605:    }
    #####: 4606:}
------------------
        -: 4607:
    #####: 4608:static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4609:    uint32_t pct_hot;
    #####: 4610:    uint32_t pct_warm;
    #####: 4611:    double hot_factor;
    #####: 4612:    int32_t ttl;
    #####: 4613:    double factor;
        -: 4614:
    #####: 4615:    set_noreply_maybe(c, tokens, ntokens);
        -: 4616:
    #####: 4617:    if (strcmp(tokens[1].value, "tune") == 0 && ntokens >= 7) {
    #####: 4618:        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
    #####: 4619:            !safe_strtoul(tokens[3].value, &pct_warm) ||
    #####: 4620:            !safe_strtod(tokens[4].value, &hot_factor) ||
    #####: 4621:            !safe_strtod(tokens[5].value, &factor)) {
    #####: 4622:            out_string(c, "ERROR");
        -: 4623:        } else {
    #####: 4624:            if (pct_hot + pct_warm > 80) {
    #####: 4625:                out_string(c, "ERROR hot and warm pcts must not exceed 80");
    #####: 4626:            } else if (factor <= 0 || hot_factor <= 0) {
    #####: 4627:                out_string(c, "ERROR hot/warm age factors must be greater than 0");
        -: 4628:            } else {
    #####: 4629:                settings.hot_lru_pct = pct_hot;
    #####: 4630:                settings.warm_lru_pct = pct_warm;
    #####: 4631:                settings.hot_max_factor = hot_factor;
    #####: 4632:                settings.warm_max_factor = factor;
    #####: 4633:                out_string(c, "OK");
        -: 4634:            }
        -: 4635:        }
    #####: 4636:    } else if (strcmp(tokens[1].value, "mode") == 0 && ntokens >= 4 &&
    #####: 4637:               settings.lru_maintainer_thread) {
    #####: 4638:        if (strcmp(tokens[2].value, "flat") == 0) {
    #####: 4639:            settings.lru_segmented = false;
    #####: 4640:            out_string(c, "OK");
    #####: 4641:        } else if (strcmp(tokens[2].value, "segmented") == 0) {
    #####: 4642:            settings.lru_segmented = true;
    #####: 4643:            out_string(c, "OK");
        -: 4644:        } else {
    #####: 4645:            out_string(c, "ERROR");
        -: 4646:        }
    #####: 4647:    } else if (strcmp(tokens[1].value, "temp_ttl") == 0 && ntokens >= 4 &&
    #####: 4648:               settings.lru_maintainer_thread) {
    #####: 4649:        if (!safe_strtol(tokens[2].value, &ttl)) {
    #####: 4650:            out_string(c, "ERROR");
        -: 4651:        } else {
    #####: 4652:            if (ttl < 0) {
    #####: 4653:                settings.temp_lru = false;
        -: 4654:            } else {
    #####: 4655:                settings.temp_lru = true;
    #####: 4656:                settings.temporary_ttl = ttl;
        -: 4657:            }
    #####: 4658:            out_string(c, "OK");
        -: 4659:        }
        -: 4660:    } else {
    #####: 4661:        out_string(c, "ERROR");
        -: 4662:    }
    #####: 4663:}
------------------
process_lru_command:
    #####: 4608:static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4609:    uint32_t pct_hot;
    #####: 4610:    uint32_t pct_warm;
    #####: 4611:    double hot_factor;
    #####: 4612:    int32_t ttl;
    #####: 4613:    double factor;
        -: 4614:
    #####: 4615:    set_noreply_maybe(c, tokens, ntokens);
        -: 4616:
    #####: 4617:    if (strcmp(tokens[1].value, "tune") == 0 && ntokens >= 7) {
    #####: 4618:        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
    #####: 4619:            !safe_strtoul(tokens[3].value, &pct_warm) ||
    #####: 4620:            !safe_strtod(tokens[4].value, &hot_factor) ||
    #####: 4621:            !safe_strtod(tokens[5].value, &factor)) {
    #####: 4622:            out_string(c, "ERROR");
        -: 4623:        } else {
    #####: 4624:            if (pct_hot + pct_warm > 80) {
    #####: 4625:                out_string(c, "ERROR hot and warm pcts must not exceed 80");
    #####: 4626:            } else if (factor <= 0 || hot_factor <= 0) {
    #####: 4627:                out_string(c, "ERROR hot/warm age factors must be greater than 0");
        -: 4628:            } else {
    #####: 4629:                settings.hot_lru_pct = pct_hot;
    #####: 4630:                settings.warm_lru_pct = pct_warm;
    #####: 4631:                settings.hot_max_factor = hot_factor;
    #####: 4632:                settings.warm_max_factor = factor;
    #####: 4633:                out_string(c, "OK");
        -: 4634:            }
        -: 4635:        }
    #####: 4636:    } else if (strcmp(tokens[1].value, "mode") == 0 && ntokens >= 4 &&
    #####: 4637:               settings.lru_maintainer_thread) {
    #####: 4638:        if (strcmp(tokens[2].value, "flat") == 0) {
    #####: 4639:            settings.lru_segmented = false;
    #####: 4640:            out_string(c, "OK");
    #####: 4641:        } else if (strcmp(tokens[2].value, "segmented") == 0) {
    #####: 4642:            settings.lru_segmented = true;
    #####: 4643:            out_string(c, "OK");
        -: 4644:        } else {
    #####: 4645:            out_string(c, "ERROR");
        -: 4646:        }
    #####: 4647:    } else if (strcmp(tokens[1].value, "temp_ttl") == 0 && ntokens >= 4 &&
    #####: 4648:               settings.lru_maintainer_thread) {
    #####: 4649:        if (!safe_strtol(tokens[2].value, &ttl)) {
    #####: 4650:            out_string(c, "ERROR");
        -: 4651:        } else {
    #####: 4652:            if (ttl < 0) {
    #####: 4653:                settings.temp_lru = false;
        -: 4654:            } else {
    #####: 4655:                settings.temp_lru = true;
    #####: 4656:                settings.temporary_ttl = ttl;
        -: 4657:            }
    #####: 4658:            out_string(c, "OK");
        -: 4659:        }
        -: 4660:    } else {
    #####: 4661:        out_string(c, "ERROR");
        -: 4662:    }
    #####: 4663:}
------------------
process_lru_command:
    #####: 4608:static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4609:    uint32_t pct_hot;
    #####: 4610:    uint32_t pct_warm;
    #####: 4611:    double hot_factor;
    #####: 4612:    int32_t ttl;
    #####: 4613:    double factor;
        -: 4614:
    #####: 4615:    set_noreply_maybe(c, tokens, ntokens);
        -: 4616:
    #####: 4617:    if (strcmp(tokens[1].value, "tune") == 0 && ntokens >= 7) {
    #####: 4618:        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
    #####: 4619:            !safe_strtoul(tokens[3].value, &pct_warm) ||
    #####: 4620:            !safe_strtod(tokens[4].value, &hot_factor) ||
    #####: 4621:            !safe_strtod(tokens[5].value, &factor)) {
    #####: 4622:            out_string(c, "ERROR");
        -: 4623:        } else {
    #####: 4624:            if (pct_hot + pct_warm > 80) {
    #####: 4625:                out_string(c, "ERROR hot and warm pcts must not exceed 80");
    #####: 4626:            } else if (factor <= 0 || hot_factor <= 0) {
    #####: 4627:                out_string(c, "ERROR hot/warm age factors must be greater than 0");
        -: 4628:            } else {
    #####: 4629:                settings.hot_lru_pct = pct_hot;
    #####: 4630:                settings.warm_lru_pct = pct_warm;
    #####: 4631:                settings.hot_max_factor = hot_factor;
    #####: 4632:                settings.warm_max_factor = factor;
    #####: 4633:                out_string(c, "OK");
        -: 4634:            }
        -: 4635:        }
    #####: 4636:    } else if (strcmp(tokens[1].value, "mode") == 0 && ntokens >= 4 &&
    #####: 4637:               settings.lru_maintainer_thread) {
    #####: 4638:        if (strcmp(tokens[2].value, "flat") == 0) {
    #####: 4639:            settings.lru_segmented = false;
    #####: 4640:            out_string(c, "OK");
    #####: 4641:        } else if (strcmp(tokens[2].value, "segmented") == 0) {
    #####: 4642:            settings.lru_segmented = true;
    #####: 4643:            out_string(c, "OK");
        -: 4644:        } else {
    #####: 4645:            out_string(c, "ERROR");
        -: 4646:        }
    #####: 4647:    } else if (strcmp(tokens[1].value, "temp_ttl") == 0 && ntokens >= 4 &&
    #####: 4648:               settings.lru_maintainer_thread) {
    #####: 4649:        if (!safe_strtol(tokens[2].value, &ttl)) {
    #####: 4650:            out_string(c, "ERROR");
        -: 4651:        } else {
    #####: 4652:            if (ttl < 0) {
    #####: 4653:                settings.temp_lru = false;
        -: 4654:            } else {
    #####: 4655:                settings.temp_lru = true;
    #####: 4656:                settings.temporary_ttl = ttl;
        -: 4657:            }
    #####: 4658:            out_string(c, "OK");
        -: 4659:        }
        -: 4660:    } else {
    #####: 4661:        out_string(c, "ERROR");
        -: 4662:    }
    #####: 4663:}
------------------
process_lru_command:
    #####: 4608:static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    #####: 4609:    uint32_t pct_hot;
    #####: 4610:    uint32_t pct_warm;
    #####: 4611:    double hot_factor;
    #####: 4612:    int32_t ttl;
    #####: 4613:    double factor;
        -: 4614:
    #####: 4615:    set_noreply_maybe(c, tokens, ntokens);
        -: 4616:
    #####: 4617:    if (strcmp(tokens[1].value, "tune") == 0 && ntokens >= 7) {
    #####: 4618:        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
    #####: 4619:            !safe_strtoul(tokens[3].value, &pct_warm) ||
    #####: 4620:            !safe_strtod(tokens[4].value, &hot_factor) ||
    #####: 4621:            !safe_strtod(tokens[5].value, &factor)) {
    #####: 4622:            out_string(c, "ERROR");
        -: 4623:        } else {
    #####: 4624:            if (pct_hot + pct_warm > 80) {
    #####: 4625:                out_string(c, "ERROR hot and warm pcts must not exceed 80");
    #####: 4626:            } else if (factor <= 0 || hot_factor <= 0) {
    #####: 4627:                out_string(c, "ERROR hot/warm age factors must be greater than 0");
        -: 4628:            } else {
    #####: 4629:                settings.hot_lru_pct = pct_hot;
    #####: 4630:                settings.warm_lru_pct = pct_warm;
    #####: 4631:                settings.hot_max_factor = hot_factor;
    #####: 4632:                settings.warm_max_factor = factor;
    #####: 4633:                out_string(c, "OK");
        -: 4634:            }
        -: 4635:        }
    #####: 4636:    } else if (strcmp(tokens[1].value, "mode") == 0 && ntokens >= 4 &&
    #####: 4637:               settings.lru_maintainer_thread) {
    #####: 4638:        if (strcmp(tokens[2].value, "flat") == 0) {
    #####: 4639:            settings.lru_segmented = false;
    #####: 4640:            out_string(c, "OK");
    #####: 4641:        } else if (strcmp(tokens[2].value, "segmented") == 0) {
    #####: 4642:            settings.lru_segmented = true;
    #####: 4643:            out_string(c, "OK");
        -: 4644:        } else {
    #####: 4645:            out_string(c, "ERROR");
        -: 4646:        }
    #####: 4647:    } else if (strcmp(tokens[1].value, "temp_ttl") == 0 && ntokens >= 4 &&
    #####: 4648:               settings.lru_maintainer_thread) {
    #####: 4649:        if (!safe_strtol(tokens[2].value, &ttl)) {
    #####: 4650:            out_string(c, "ERROR");
        -: 4651:        } else {
    #####: 4652:            if (ttl < 0) {
    #####: 4653:                settings.temp_lru = false;
        -: 4654:            } else {
    #####: 4655:                settings.temp_lru = true;
    #####: 4656:                settings.temporary_ttl = ttl;
        -: 4657:            }
    #####: 4658:            out_string(c, "OK");
        -: 4659:        }
        -: 4660:    } else {
    #####: 4661:        out_string(c, "ERROR");
        -: 4662:    }
    #####: 4663:}
------------------
        -: 4664:#ifdef EXTSTORE
        -: 4665:static void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {
        -: 4666:    set_noreply_maybe(c, tokens, ntokens);
        -: 4667:    bool ok = true;
        -: 4668:    if (ntokens < 4) {
        -: 4669:        ok = false;
        -: 4670:    } else if (strcmp(tokens[1].value, "free_memchunks") == 0 && ntokens > 4) {
        -: 4671:        /* per-slab-class free chunk setting. */
        -: 4672:        unsigned int clsid = 0;
        -: 4673:        unsigned int limit = 0;
        -: 4674:        if (!safe_strtoul(tokens[2].value, &clsid) ||
        -: 4675:                !safe_strtoul(tokens[3].value, &limit)) {
        -: 4676:            ok = false;
        -: 4677:        } else {
        -: 4678:            if (clsid < MAX_NUMBER_OF_SLAB_CLASSES) {
        -: 4679:                settings.ext_free_memchunks[clsid] = limit;
        -: 4680:            } else {
        -: 4681:                ok = false;
        -: 4682:            }
        -: 4683:        }
        -: 4684:    } else if (strcmp(tokens[1].value, "item_size") == 0) {
        -: 4685:        if (!safe_strtoul(tokens[2].value, &settings.ext_item_size))
        -: 4686:            ok = false;
        -: 4687:    } else if (strcmp(tokens[1].value, "item_age") == 0) {
        -: 4688:        if (!safe_strtoul(tokens[2].value, &settings.ext_item_age))
        -: 4689:            ok = false;
        -: 4690:    } else if (strcmp(tokens[1].value, "low_ttl") == 0) {
        -: 4691:        if (!safe_strtoul(tokens[2].value, &settings.ext_low_ttl))
        -: 4692:            ok = false;
        -: 4693:    } else if (strcmp(tokens[1].value, "recache_rate") == 0) {
        -: 4694:        if (!safe_strtoul(tokens[2].value, &settings.ext_recache_rate))
        -: 4695:            ok = false;
        -: 4696:    } else if (strcmp(tokens[1].value, "compact_under") == 0) {
        -: 4697:        if (!safe_strtoul(tokens[2].value, &settings.ext_compact_under))
        -: 4698:            ok = false;
        -: 4699:    } else if (strcmp(tokens[1].value, "drop_under") == 0) {
        -: 4700:        if (!safe_strtoul(tokens[2].value, &settings.ext_drop_under))
        -: 4701:            ok = false;
        -: 4702:    } else if (strcmp(tokens[1].value, "max_frag") == 0) {
        -: 4703:        if (!safe_strtod(tokens[2].value, &settings.ext_max_frag))
        -: 4704:            ok = false;
        -: 4705:    } else if (strcmp(tokens[1].value, "drop_unread") == 0) {
        -: 4706:        unsigned int v;
        -: 4707:        if (!safe_strtoul(tokens[2].value, &v)) {
        -: 4708:            ok = false;
        -: 4709:        } else {
        -: 4710:            settings.ext_drop_unread = v == 0 ? false : true;
        -: 4711:        }
        -: 4712:    } else {
        -: 4713:        ok = false;
        -: 4714:    }
        -: 4715:    if (!ok) {
        -: 4716:        out_string(c, "ERROR");
        -: 4717:    } else {
        -: 4718:        out_string(c, "OK");
        -: 4719:    }
        -: 4720:}
        -: 4721:#endif
    #####: 4722:static void process_command(conn *c, char *command) {
        -: 4723:
    #####: 4724:    token_t tokens[MAX_TOKENS];
    #####: 4725:    size_t ntokens;
    #####: 4726:    int comm;
        -: 4727:
    #####: 4728:    assert(c != NULL);
        -: 4729:
    #####: 4730:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 4731:
    #####: 4732:    if (settings.verbose > 1)
    #####: 4733:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 4734:
        -: 4735:    /*
        -: 4736:     * for commands set/add/replace, we build an item and read the data
        -: 4737:     * directly into it, then continue in nread_complete().
        -: 4738:     */
        -: 4739:
    #####: 4740:    c->msgcurr = 0;
    #####: 4741:    c->msgused = 0;
    #####: 4742:    c->iovused = 0;
    #####: 4743:    if (add_msghdr(c) != 0) {
    #####: 4744:        out_of_memory(c, "SERVER_ERROR out of memory preparing response");
    #####: 4745:        return;
        -: 4746:    }
        -: 4747:
    #####: 4748:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    #####: 4749:    if (ntokens >= 3 &&
    #####: 4750:        ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
    #####: 4751:         (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {
        -: 4752:
    #####: 4753:        process_get_command(c, tokens, ntokens, false, false);
        -: 4754:
    #####: 4755:    } else if ((ntokens == 6 || ntokens == 7) &&
    #####: 4756:               ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
    #####: 4757:                (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
    #####: 4758:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
    #####: 4759:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
    #####: 4760:                (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
        -: 4761:
    #####: 4762:        process_update_command(c, tokens, ntokens, comm, false);
        -: 4763:
    #####: 4764:    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
        -: 4765:
    #####: 4766:        process_update_command(c, tokens, ntokens, comm, true);
        -: 4767:
    #####: 4768:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
        -: 4769:
    #####: 4770:        process_arithmetic_command(c, tokens, ntokens, 1);
        -: 4771:
    #####: 4772:    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
        -: 4773:
    #####: 4774:        process_get_command(c, tokens, ntokens, true, false);
        -: 4775:
    #####: 4776:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
        -: 4777:
    #####: 4778:        process_arithmetic_command(c, tokens, ntokens, 0);
        -: 4779:
    #####: 4780:    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
        -: 4781:
    #####: 4782:        process_delete_command(c, tokens, ntokens);
        -: 4783:
    #####: 4784:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
        -: 4785:
    #####: 4786:        process_touch_command(c, tokens, ntokens);
        -: 4787:
    #####: 4788:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0)) {
        -: 4789:
    #####: 4790:        process_get_command(c, tokens, ntokens, false, true);
        -: 4791:
    #####: 4792:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats") == 0)) {
        -: 4793:
    #####: 4794:        process_get_command(c, tokens, ntokens, true, true);
        -: 4795:
    #####: 4796:    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
        -: 4797:
    #####: 4798:        process_stat(c, tokens, ntokens);
        -: 4799:
    #####: 4800:    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
    #####: 4801:        time_t exptime = 0;
    #####: 4802:        rel_time_t new_oldest = 0;
        -: 4803:
    #####: 4804:        set_noreply_maybe(c, tokens, ntokens);
        -: 4805:
    #####: 4806:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4807:        c->thread->stats.flush_cmds++;
    #####: 4808:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4809:
    #####: 4810:        if (!settings.flush_enabled) {
        -: 4811:            // flush_all is not allowed but we log it on stats
    #####: 4812:            out_string(c, "CLIENT_ERROR flush_all not allowed");
    #####: 4813:            return;
        -: 4814:        }
        -: 4815:
    #####: 4816:        if (ntokens != (c->noreply ? 3 : 2)) {
    #####: 4817:            exptime = strtol(tokens[1].value, NULL, 10);
    #####: 4818:            if(errno == ERANGE) {
    #####: 4819:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4820:                return;
        -: 4821:            }
        -: 4822:        }
        -: 4823:
        -: 4824:        /*
        -: 4825:          If exptime is zero realtime() would return zero too, and
        -: 4826:          realtime(exptime) - 1 would overflow to the max unsigned
        -: 4827:          value.  So we process exptime == 0 the same way we do when
        -: 4828:          no delay is given at all.
        -: 4829:        */
    #####: 4830:        if (exptime > 0) {
    #####: 4831:            new_oldest = realtime(exptime);
        -: 4832:        } else { /* exptime == 0 */
    #####: 4833:            new_oldest = current_time;
        -: 4834:        }
        -: 4835:
    #####: 4836:        if (settings.use_cas) {
    #####: 4837:            settings.oldest_live = new_oldest - 1;
    #####: 4838:            if (settings.oldest_live <= current_time)
    #####: 4839:                settings.oldest_cas = get_cas_id();
        -: 4840:        } else {
    #####: 4841:            settings.oldest_live = new_oldest;
        -: 4842:        }
    #####: 4843:        out_string(c, "OK");
    #####: 4844:        return;
        -: 4845:
    #####: 4846:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
        -: 4847:
    #####: 4848:        out_string(c, "VERSION " VERSION);
        -: 4849:
    #####: 4850:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
        -: 4851:
    #####: 4852:        conn_set_state(c, conn_closing);
        -: 4853:
    #####: 4854:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
        -: 4855:
    #####: 4856:        if (settings.shutdown_command) {
    #####: 4857:            conn_set_state(c, conn_closing);
    #####: 4858:            raise(SIGINT);
        -: 4859:        } else {
    #####: 4860:            out_string(c, "ERROR: shutdown not enabled");
        -: 4861:        }
        -: 4862:
    #####: 4863:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
    #####: 4864:        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
    #####: 4865:            int src, dst, rv;
        -: 4866:
    #####: 4867:            if (settings.slab_reassign == false) {
    #####: 4868:                out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 4869:                return;
        -: 4870:            }
        -: 4871:
    #####: 4872:            src = strtol(tokens[2].value, NULL, 10);
    #####: 4873:            dst = strtol(tokens[3].value, NULL, 10);
        -: 4874:
    #####: 4875:            if (errno == ERANGE) {
    #####: 4876:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4877:                return;
        -: 4878:            }
        -: 4879:
    #####: 4880:            rv = slabs_reassign(src, dst);
    #####: 4881:            switch (rv) {
    #####: 4882:            case REASSIGN_OK:
    #####: 4883:                out_string(c, "OK");
    #####: 4884:                break;
    #####: 4885:            case REASSIGN_RUNNING:
    #####: 4886:                out_string(c, "BUSY currently processing reassign request");
    #####: 4887:                break;
    #####: 4888:            case REASSIGN_BADCLASS:
    #####: 4889:                out_string(c, "BADCLASS invalid src or dst class id");
    #####: 4890:                break;
    #####: 4891:            case REASSIGN_NOSPARE:
    #####: 4892:                out_string(c, "NOSPARE source class has no spare pages");
    #####: 4893:                break;
    #####: 4894:            case REASSIGN_SRC_DST_SAME:
    #####: 4895:                out_string(c, "SAME src and dst class are identical");
    #####: 4896:                break;
        -: 4897:            }
    #####: 4898:            return;
    #####: 4899:        } else if (ntokens >= 4 &&
    #####: 4900:            (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
    #####: 4901:            process_slabs_automove_command(c, tokens, ntokens);
        -: 4902:        } else {
    #####: 4903:            out_string(c, "ERROR");
        -: 4904:        }
    #####: 4905:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
    #####: 4906:        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
    #####: 4907:            int rv;
    #####: 4908:            if (settings.lru_crawler == false) {
    #####: 4909:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4910:                return;
        -: 4911:            }
        -: 4912:
    #####: 4913:            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
        -: 4914:                    settings.lru_crawler_tocrawl);
    #####: 4915:            switch(rv) {
    #####: 4916:            case CRAWLER_OK:
    #####: 4917:                out_string(c, "OK");
    #####: 4918:                break;
    #####: 4919:            case CRAWLER_RUNNING:
    #####: 4920:                out_string(c, "BUSY currently processing crawler request");
    #####: 4921:                break;
    #####: 4922:            case CRAWLER_BADCLASS:
    #####: 4923:                out_string(c, "BADCLASS invalid class id");
    #####: 4924:                break;
    #####: 4925:            case CRAWLER_NOTSTARTED:
    #####: 4926:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 4927:                break;
    #####: 4928:            case CRAWLER_ERROR:
    #####: 4929:                out_string(c, "ERROR an unknown error happened");
    #####: 4930:                break;
        -: 4931:            }
    #####: 4932:            return;
    #####: 4933:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
    #####: 4934:            if (settings.lru_crawler == false) {
    #####: 4935:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4936:                return;
        -: 4937:            }
    #####: 4938:            if (!settings.dump_enabled) {
    #####: 4939:                out_string(c, "ERROR metadump not allowed");
    #####: 4940:                return;
        -: 4941:            }
        -: 4942:
    #####: 4943:            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
        -: 4944:                    c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
    #####: 4945:            switch(rv) {
    #####: 4946:                case CRAWLER_OK:
    #####: 4947:                    out_string(c, "OK");
        -: 4948:                    // TODO: Don't reuse conn_watch here.
    #####: 4949:                    conn_set_state(c, conn_watch);
    #####: 4950:                    event_del(&c->event);
    #####: 4951:                    break;
    #####: 4952:                case CRAWLER_RUNNING:
    #####: 4953:                    out_string(c, "BUSY currently processing crawler request");
    #####: 4954:                    break;
    #####: 4955:                case CRAWLER_BADCLASS:
    #####: 4956:                    out_string(c, "BADCLASS invalid class id");
    #####: 4957:                    break;
    #####: 4958:                case CRAWLER_NOTSTARTED:
    #####: 4959:                    out_string(c, "NOTSTARTED no items to crawl");
    #####: 4960:                    break;
    #####: 4961:                case CRAWLER_ERROR:
    #####: 4962:                    out_string(c, "ERROR an unknown error happened");
    #####: 4963:                    break;
        -: 4964:            }
    #####: 4965:            return;
    #####: 4966:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
    #####: 4967:            uint32_t tocrawl;
    #####: 4968:             if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 4969:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4970:                return;
        -: 4971:            }
    #####: 4972:            settings.lru_crawler_tocrawl = tocrawl;
    #####: 4973:            out_string(c, "OK");
    #####: 4974:            return;
    #####: 4975:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
    #####: 4976:            uint32_t tosleep;
    #####: 4977:            if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 4978:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4979:                return;
        -: 4980:            }
    #####: 4981:            if (tosleep > 1000000) {
    #####: 4982:                out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 4983:                return;
        -: 4984:            }
    #####: 4985:            settings.lru_crawler_sleep = tosleep;
    #####: 4986:            out_string(c, "OK");
    #####: 4987:            return;
    #####: 4988:        } else if (ntokens == 3) {
    #####: 4989:            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
    #####: 4990:                if (start_item_crawler_thread() == 0) {
    #####: 4991:                    out_string(c, "OK");
        -: 4992:                } else {
    #####: 4993:                    out_string(c, "ERROR failed to start lru crawler thread");
        -: 4994:                }
    #####: 4995:            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
    #####: 4996:                if (stop_item_crawler_thread() == 0) {
    #####: 4997:                    out_string(c, "OK");
        -: 4998:                } else {
    #####: 4999:                    out_string(c, "ERROR failed to stop lru crawler thread");
        -: 5000:                }
        -: 5001:            } else {
    #####: 5002:                out_string(c, "ERROR");
        -: 5003:            }
    #####: 5004:            return;
        -: 5005:        } else {
    #####: 5006:            out_string(c, "ERROR");
        -: 5007:        }
    #####: 5008:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
    #####: 5009:        process_watch_command(c, tokens, ntokens);
    #####: 5010:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
    #####: 5011:        process_memlimit_command(c, tokens, ntokens);
    #####: 5012:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
    #####: 5013:        process_verbosity_command(c, tokens, ntokens);
    #####: 5014:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
    #####: 5015:        process_lru_command(c, tokens, ntokens);
        -: 5016:#ifdef MEMCACHED_DEBUG
        -: 5017:    // commands which exist only for testing the memcached's security protection
    #####: 5018:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
    #####: 5019:        process_misbehave_command(c);
        -: 5020:#endif
        -: 5021:#ifdef EXTSTORE
        -: 5022:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
        -: 5023:        process_extstore_command(c, tokens, ntokens);
        -: 5024:#endif
        -: 5025:#ifdef TLS
        -: 5026:    } else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
        -: 5027:        set_noreply_maybe(c, tokens, ntokens);
        -: 5028:        char *errmsg = NULL;
        -: 5029:        if (refresh_certs(&errmsg)) {
        -: 5030:            out_string(c, "OK");
        -: 5031:        } else {
        -: 5032:            write_and_free(c, errmsg, strlen(errmsg));
        -: 5033:        }
        -: 5034:        return;
        -: 5035:#endif
        -: 5036:    } else {
    #####: 5037:        if (ntokens >= 2 && strncmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
    #####: 5038:            conn_set_state(c, conn_closing);
        -: 5039:        } else {
    #####: 5040:            out_string(c, "ERROR");
        -: 5041:        }
        -: 5042:    }
        -: 5043:    return;
        -: 5044:}
------------------
process_command:
    #####: 4722:static void process_command(conn *c, char *command) {
        -: 4723:
    #####: 4724:    token_t tokens[MAX_TOKENS];
    #####: 4725:    size_t ntokens;
    #####: 4726:    int comm;
        -: 4727:
    #####: 4728:    assert(c != NULL);
        -: 4729:
    #####: 4730:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 4731:
    #####: 4732:    if (settings.verbose > 1)
    #####: 4733:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 4734:
        -: 4735:    /*
        -: 4736:     * for commands set/add/replace, we build an item and read the data
        -: 4737:     * directly into it, then continue in nread_complete().
        -: 4738:     */
        -: 4739:
    #####: 4740:    c->msgcurr = 0;
    #####: 4741:    c->msgused = 0;
    #####: 4742:    c->iovused = 0;
    #####: 4743:    if (add_msghdr(c) != 0) {
    #####: 4744:        out_of_memory(c, "SERVER_ERROR out of memory preparing response");
    #####: 4745:        return;
        -: 4746:    }
        -: 4747:
    #####: 4748:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    #####: 4749:    if (ntokens >= 3 &&
    #####: 4750:        ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
    #####: 4751:         (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {
        -: 4752:
    #####: 4753:        process_get_command(c, tokens, ntokens, false, false);
        -: 4754:
    #####: 4755:    } else if ((ntokens == 6 || ntokens == 7) &&
    #####: 4756:               ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
    #####: 4757:                (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
    #####: 4758:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
    #####: 4759:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
    #####: 4760:                (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
        -: 4761:
    #####: 4762:        process_update_command(c, tokens, ntokens, comm, false);
        -: 4763:
    #####: 4764:    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
        -: 4765:
    #####: 4766:        process_update_command(c, tokens, ntokens, comm, true);
        -: 4767:
    #####: 4768:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
        -: 4769:
    #####: 4770:        process_arithmetic_command(c, tokens, ntokens, 1);
        -: 4771:
    #####: 4772:    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
        -: 4773:
    #####: 4774:        process_get_command(c, tokens, ntokens, true, false);
        -: 4775:
    #####: 4776:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
        -: 4777:
    #####: 4778:        process_arithmetic_command(c, tokens, ntokens, 0);
        -: 4779:
    #####: 4780:    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
        -: 4781:
    #####: 4782:        process_delete_command(c, tokens, ntokens);
        -: 4783:
    #####: 4784:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
        -: 4785:
    #####: 4786:        process_touch_command(c, tokens, ntokens);
        -: 4787:
    #####: 4788:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0)) {
        -: 4789:
    #####: 4790:        process_get_command(c, tokens, ntokens, false, true);
        -: 4791:
    #####: 4792:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats") == 0)) {
        -: 4793:
    #####: 4794:        process_get_command(c, tokens, ntokens, true, true);
        -: 4795:
    #####: 4796:    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
        -: 4797:
    #####: 4798:        process_stat(c, tokens, ntokens);
        -: 4799:
    #####: 4800:    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
    #####: 4801:        time_t exptime = 0;
    #####: 4802:        rel_time_t new_oldest = 0;
        -: 4803:
    #####: 4804:        set_noreply_maybe(c, tokens, ntokens);
        -: 4805:
    #####: 4806:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4807:        c->thread->stats.flush_cmds++;
    #####: 4808:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4809:
    #####: 4810:        if (!settings.flush_enabled) {
        -: 4811:            // flush_all is not allowed but we log it on stats
    #####: 4812:            out_string(c, "CLIENT_ERROR flush_all not allowed");
    #####: 4813:            return;
        -: 4814:        }
        -: 4815:
    #####: 4816:        if (ntokens != (c->noreply ? 3 : 2)) {
    #####: 4817:            exptime = strtol(tokens[1].value, NULL, 10);
    #####: 4818:            if(errno == ERANGE) {
    #####: 4819:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4820:                return;
        -: 4821:            }
        -: 4822:        }
        -: 4823:
        -: 4824:        /*
        -: 4825:          If exptime is zero realtime() would return zero too, and
        -: 4826:          realtime(exptime) - 1 would overflow to the max unsigned
        -: 4827:          value.  So we process exptime == 0 the same way we do when
        -: 4828:          no delay is given at all.
        -: 4829:        */
    #####: 4830:        if (exptime > 0) {
    #####: 4831:            new_oldest = realtime(exptime);
        -: 4832:        } else { /* exptime == 0 */
    #####: 4833:            new_oldest = current_time;
        -: 4834:        }
        -: 4835:
    #####: 4836:        if (settings.use_cas) {
    #####: 4837:            settings.oldest_live = new_oldest - 1;
    #####: 4838:            if (settings.oldest_live <= current_time)
    #####: 4839:                settings.oldest_cas = get_cas_id();
        -: 4840:        } else {
    #####: 4841:            settings.oldest_live = new_oldest;
        -: 4842:        }
    #####: 4843:        out_string(c, "OK");
    #####: 4844:        return;
        -: 4845:
    #####: 4846:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
        -: 4847:
    #####: 4848:        out_string(c, "VERSION " VERSION);
        -: 4849:
    #####: 4850:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
        -: 4851:
    #####: 4852:        conn_set_state(c, conn_closing);
        -: 4853:
    #####: 4854:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
        -: 4855:
    #####: 4856:        if (settings.shutdown_command) {
    #####: 4857:            conn_set_state(c, conn_closing);
    #####: 4858:            raise(SIGINT);
        -: 4859:        } else {
    #####: 4860:            out_string(c, "ERROR: shutdown not enabled");
        -: 4861:        }
        -: 4862:
    #####: 4863:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
    #####: 4864:        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
    #####: 4865:            int src, dst, rv;
        -: 4866:
    #####: 4867:            if (settings.slab_reassign == false) {
    #####: 4868:                out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 4869:                return;
        -: 4870:            }
        -: 4871:
    #####: 4872:            src = strtol(tokens[2].value, NULL, 10);
    #####: 4873:            dst = strtol(tokens[3].value, NULL, 10);
        -: 4874:
    #####: 4875:            if (errno == ERANGE) {
    #####: 4876:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4877:                return;
        -: 4878:            }
        -: 4879:
    #####: 4880:            rv = slabs_reassign(src, dst);
    #####: 4881:            switch (rv) {
    #####: 4882:            case REASSIGN_OK:
    #####: 4883:                out_string(c, "OK");
    #####: 4884:                break;
    #####: 4885:            case REASSIGN_RUNNING:
    #####: 4886:                out_string(c, "BUSY currently processing reassign request");
    #####: 4887:                break;
    #####: 4888:            case REASSIGN_BADCLASS:
    #####: 4889:                out_string(c, "BADCLASS invalid src or dst class id");
    #####: 4890:                break;
    #####: 4891:            case REASSIGN_NOSPARE:
    #####: 4892:                out_string(c, "NOSPARE source class has no spare pages");
    #####: 4893:                break;
    #####: 4894:            case REASSIGN_SRC_DST_SAME:
    #####: 4895:                out_string(c, "SAME src and dst class are identical");
    #####: 4896:                break;
        -: 4897:            }
    #####: 4898:            return;
    #####: 4899:        } else if (ntokens >= 4 &&
    #####: 4900:            (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
    #####: 4901:            process_slabs_automove_command(c, tokens, ntokens);
        -: 4902:        } else {
    #####: 4903:            out_string(c, "ERROR");
        -: 4904:        }
    #####: 4905:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
    #####: 4906:        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
    #####: 4907:            int rv;
    #####: 4908:            if (settings.lru_crawler == false) {
    #####: 4909:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4910:                return;
        -: 4911:            }
        -: 4912:
    #####: 4913:            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
        -: 4914:                    settings.lru_crawler_tocrawl);
    #####: 4915:            switch(rv) {
    #####: 4916:            case CRAWLER_OK:
    #####: 4917:                out_string(c, "OK");
    #####: 4918:                break;
    #####: 4919:            case CRAWLER_RUNNING:
    #####: 4920:                out_string(c, "BUSY currently processing crawler request");
    #####: 4921:                break;
    #####: 4922:            case CRAWLER_BADCLASS:
    #####: 4923:                out_string(c, "BADCLASS invalid class id");
    #####: 4924:                break;
    #####: 4925:            case CRAWLER_NOTSTARTED:
    #####: 4926:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 4927:                break;
    #####: 4928:            case CRAWLER_ERROR:
    #####: 4929:                out_string(c, "ERROR an unknown error happened");
    #####: 4930:                break;
        -: 4931:            }
    #####: 4932:            return;
    #####: 4933:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
    #####: 4934:            if (settings.lru_crawler == false) {
    #####: 4935:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4936:                return;
        -: 4937:            }
    #####: 4938:            if (!settings.dump_enabled) {
    #####: 4939:                out_string(c, "ERROR metadump not allowed");
    #####: 4940:                return;
        -: 4941:            }
        -: 4942:
    #####: 4943:            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
        -: 4944:                    c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
    #####: 4945:            switch(rv) {
    #####: 4946:                case CRAWLER_OK:
    #####: 4947:                    out_string(c, "OK");
        -: 4948:                    // TODO: Don't reuse conn_watch here.
    #####: 4949:                    conn_set_state(c, conn_watch);
    #####: 4950:                    event_del(&c->event);
    #####: 4951:                    break;
    #####: 4952:                case CRAWLER_RUNNING:
    #####: 4953:                    out_string(c, "BUSY currently processing crawler request");
    #####: 4954:                    break;
    #####: 4955:                case CRAWLER_BADCLASS:
    #####: 4956:                    out_string(c, "BADCLASS invalid class id");
    #####: 4957:                    break;
    #####: 4958:                case CRAWLER_NOTSTARTED:
    #####: 4959:                    out_string(c, "NOTSTARTED no items to crawl");
    #####: 4960:                    break;
    #####: 4961:                case CRAWLER_ERROR:
    #####: 4962:                    out_string(c, "ERROR an unknown error happened");
    #####: 4963:                    break;
        -: 4964:            }
    #####: 4965:            return;
    #####: 4966:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
    #####: 4967:            uint32_t tocrawl;
    #####: 4968:             if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 4969:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4970:                return;
        -: 4971:            }
    #####: 4972:            settings.lru_crawler_tocrawl = tocrawl;
    #####: 4973:            out_string(c, "OK");
    #####: 4974:            return;
    #####: 4975:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
    #####: 4976:            uint32_t tosleep;
    #####: 4977:            if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 4978:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4979:                return;
        -: 4980:            }
    #####: 4981:            if (tosleep > 1000000) {
    #####: 4982:                out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 4983:                return;
        -: 4984:            }
    #####: 4985:            settings.lru_crawler_sleep = tosleep;
    #####: 4986:            out_string(c, "OK");
    #####: 4987:            return;
    #####: 4988:        } else if (ntokens == 3) {
    #####: 4989:            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
    #####: 4990:                if (start_item_crawler_thread() == 0) {
    #####: 4991:                    out_string(c, "OK");
        -: 4992:                } else {
    #####: 4993:                    out_string(c, "ERROR failed to start lru crawler thread");
        -: 4994:                }
    #####: 4995:            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
    #####: 4996:                if (stop_item_crawler_thread() == 0) {
    #####: 4997:                    out_string(c, "OK");
        -: 4998:                } else {
    #####: 4999:                    out_string(c, "ERROR failed to stop lru crawler thread");
        -: 5000:                }
        -: 5001:            } else {
    #####: 5002:                out_string(c, "ERROR");
        -: 5003:            }
    #####: 5004:            return;
        -: 5005:        } else {
    #####: 5006:            out_string(c, "ERROR");
        -: 5007:        }
    #####: 5008:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
    #####: 5009:        process_watch_command(c, tokens, ntokens);
    #####: 5010:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
    #####: 5011:        process_memlimit_command(c, tokens, ntokens);
    #####: 5012:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
    #####: 5013:        process_verbosity_command(c, tokens, ntokens);
    #####: 5014:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
    #####: 5015:        process_lru_command(c, tokens, ntokens);
        -: 5016:#ifdef MEMCACHED_DEBUG
        -: 5017:    // commands which exist only for testing the memcached's security protection
    #####: 5018:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
    #####: 5019:        process_misbehave_command(c);
        -: 5020:#endif
        -: 5021:#ifdef EXTSTORE
        -: 5022:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
        -: 5023:        process_extstore_command(c, tokens, ntokens);
        -: 5024:#endif
        -: 5025:#ifdef TLS
        -: 5026:    } else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
        -: 5027:        set_noreply_maybe(c, tokens, ntokens);
        -: 5028:        char *errmsg = NULL;
        -: 5029:        if (refresh_certs(&errmsg)) {
        -: 5030:            out_string(c, "OK");
        -: 5031:        } else {
        -: 5032:            write_and_free(c, errmsg, strlen(errmsg));
        -: 5033:        }
        -: 5034:        return;
        -: 5035:#endif
        -: 5036:    } else {
    #####: 5037:        if (ntokens >= 2 && strncmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
    #####: 5038:            conn_set_state(c, conn_closing);
        -: 5039:        } else {
    #####: 5040:            out_string(c, "ERROR");
        -: 5041:        }
        -: 5042:    }
        -: 5043:    return;
        -: 5044:}
------------------
process_command:
    #####: 4722:static void process_command(conn *c, char *command) {
        -: 4723:
    #####: 4724:    token_t tokens[MAX_TOKENS];
    #####: 4725:    size_t ntokens;
    #####: 4726:    int comm;
        -: 4727:
    #####: 4728:    assert(c != NULL);
        -: 4729:
    #####: 4730:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 4731:
    #####: 4732:    if (settings.verbose > 1)
    #####: 4733:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 4734:
        -: 4735:    /*
        -: 4736:     * for commands set/add/replace, we build an item and read the data
        -: 4737:     * directly into it, then continue in nread_complete().
        -: 4738:     */
        -: 4739:
    #####: 4740:    c->msgcurr = 0;
    #####: 4741:    c->msgused = 0;
    #####: 4742:    c->iovused = 0;
    #####: 4743:    if (add_msghdr(c) != 0) {
    #####: 4744:        out_of_memory(c, "SERVER_ERROR out of memory preparing response");
    #####: 4745:        return;
        -: 4746:    }
        -: 4747:
    #####: 4748:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    #####: 4749:    if (ntokens >= 3 &&
    #####: 4750:        ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
    #####: 4751:         (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {
        -: 4752:
    #####: 4753:        process_get_command(c, tokens, ntokens, false, false);
        -: 4754:
    #####: 4755:    } else if ((ntokens == 6 || ntokens == 7) &&
    #####: 4756:               ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
    #####: 4757:                (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
    #####: 4758:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
    #####: 4759:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
    #####: 4760:                (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
        -: 4761:
    #####: 4762:        process_update_command(c, tokens, ntokens, comm, false);
        -: 4763:
    #####: 4764:    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
        -: 4765:
    #####: 4766:        process_update_command(c, tokens, ntokens, comm, true);
        -: 4767:
    #####: 4768:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
        -: 4769:
    #####: 4770:        process_arithmetic_command(c, tokens, ntokens, 1);
        -: 4771:
    #####: 4772:    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
        -: 4773:
    #####: 4774:        process_get_command(c, tokens, ntokens, true, false);
        -: 4775:
    #####: 4776:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
        -: 4777:
    #####: 4778:        process_arithmetic_command(c, tokens, ntokens, 0);
        -: 4779:
    #####: 4780:    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
        -: 4781:
    #####: 4782:        process_delete_command(c, tokens, ntokens);
        -: 4783:
    #####: 4784:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
        -: 4785:
    #####: 4786:        process_touch_command(c, tokens, ntokens);
        -: 4787:
    #####: 4788:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0)) {
        -: 4789:
    #####: 4790:        process_get_command(c, tokens, ntokens, false, true);
        -: 4791:
    #####: 4792:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats") == 0)) {
        -: 4793:
    #####: 4794:        process_get_command(c, tokens, ntokens, true, true);
        -: 4795:
    #####: 4796:    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
        -: 4797:
    #####: 4798:        process_stat(c, tokens, ntokens);
        -: 4799:
    #####: 4800:    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
    #####: 4801:        time_t exptime = 0;
    #####: 4802:        rel_time_t new_oldest = 0;
        -: 4803:
    #####: 4804:        set_noreply_maybe(c, tokens, ntokens);
        -: 4805:
    #####: 4806:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4807:        c->thread->stats.flush_cmds++;
    #####: 4808:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4809:
    #####: 4810:        if (!settings.flush_enabled) {
        -: 4811:            // flush_all is not allowed but we log it on stats
    #####: 4812:            out_string(c, "CLIENT_ERROR flush_all not allowed");
    #####: 4813:            return;
        -: 4814:        }
        -: 4815:
    #####: 4816:        if (ntokens != (c->noreply ? 3 : 2)) {
    #####: 4817:            exptime = strtol(tokens[1].value, NULL, 10);
    #####: 4818:            if(errno == ERANGE) {
    #####: 4819:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4820:                return;
        -: 4821:            }
        -: 4822:        }
        -: 4823:
        -: 4824:        /*
        -: 4825:          If exptime is zero realtime() would return zero too, and
        -: 4826:          realtime(exptime) - 1 would overflow to the max unsigned
        -: 4827:          value.  So we process exptime == 0 the same way we do when
        -: 4828:          no delay is given at all.
        -: 4829:        */
    #####: 4830:        if (exptime > 0) {
    #####: 4831:            new_oldest = realtime(exptime);
        -: 4832:        } else { /* exptime == 0 */
    #####: 4833:            new_oldest = current_time;
        -: 4834:        }
        -: 4835:
    #####: 4836:        if (settings.use_cas) {
    #####: 4837:            settings.oldest_live = new_oldest - 1;
    #####: 4838:            if (settings.oldest_live <= current_time)
    #####: 4839:                settings.oldest_cas = get_cas_id();
        -: 4840:        } else {
    #####: 4841:            settings.oldest_live = new_oldest;
        -: 4842:        }
    #####: 4843:        out_string(c, "OK");
    #####: 4844:        return;
        -: 4845:
    #####: 4846:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
        -: 4847:
    #####: 4848:        out_string(c, "VERSION " VERSION);
        -: 4849:
    #####: 4850:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
        -: 4851:
    #####: 4852:        conn_set_state(c, conn_closing);
        -: 4853:
    #####: 4854:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
        -: 4855:
    #####: 4856:        if (settings.shutdown_command) {
    #####: 4857:            conn_set_state(c, conn_closing);
    #####: 4858:            raise(SIGINT);
        -: 4859:        } else {
    #####: 4860:            out_string(c, "ERROR: shutdown not enabled");
        -: 4861:        }
        -: 4862:
    #####: 4863:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
    #####: 4864:        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
    #####: 4865:            int src, dst, rv;
        -: 4866:
    #####: 4867:            if (settings.slab_reassign == false) {
    #####: 4868:                out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 4869:                return;
        -: 4870:            }
        -: 4871:
    #####: 4872:            src = strtol(tokens[2].value, NULL, 10);
    #####: 4873:            dst = strtol(tokens[3].value, NULL, 10);
        -: 4874:
    #####: 4875:            if (errno == ERANGE) {
    #####: 4876:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4877:                return;
        -: 4878:            }
        -: 4879:
    #####: 4880:            rv = slabs_reassign(src, dst);
    #####: 4881:            switch (rv) {
    #####: 4882:            case REASSIGN_OK:
    #####: 4883:                out_string(c, "OK");
    #####: 4884:                break;
    #####: 4885:            case REASSIGN_RUNNING:
    #####: 4886:                out_string(c, "BUSY currently processing reassign request");
    #####: 4887:                break;
    #####: 4888:            case REASSIGN_BADCLASS:
    #####: 4889:                out_string(c, "BADCLASS invalid src or dst class id");
    #####: 4890:                break;
    #####: 4891:            case REASSIGN_NOSPARE:
    #####: 4892:                out_string(c, "NOSPARE source class has no spare pages");
    #####: 4893:                break;
    #####: 4894:            case REASSIGN_SRC_DST_SAME:
    #####: 4895:                out_string(c, "SAME src and dst class are identical");
    #####: 4896:                break;
        -: 4897:            }
    #####: 4898:            return;
    #####: 4899:        } else if (ntokens >= 4 &&
    #####: 4900:            (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
    #####: 4901:            process_slabs_automove_command(c, tokens, ntokens);
        -: 4902:        } else {
    #####: 4903:            out_string(c, "ERROR");
        -: 4904:        }
    #####: 4905:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
    #####: 4906:        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
    #####: 4907:            int rv;
    #####: 4908:            if (settings.lru_crawler == false) {
    #####: 4909:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4910:                return;
        -: 4911:            }
        -: 4912:
    #####: 4913:            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
        -: 4914:                    settings.lru_crawler_tocrawl);
    #####: 4915:            switch(rv) {
    #####: 4916:            case CRAWLER_OK:
    #####: 4917:                out_string(c, "OK");
    #####: 4918:                break;
    #####: 4919:            case CRAWLER_RUNNING:
    #####: 4920:                out_string(c, "BUSY currently processing crawler request");
    #####: 4921:                break;
    #####: 4922:            case CRAWLER_BADCLASS:
    #####: 4923:                out_string(c, "BADCLASS invalid class id");
    #####: 4924:                break;
    #####: 4925:            case CRAWLER_NOTSTARTED:
    #####: 4926:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 4927:                break;
    #####: 4928:            case CRAWLER_ERROR:
    #####: 4929:                out_string(c, "ERROR an unknown error happened");
    #####: 4930:                break;
        -: 4931:            }
    #####: 4932:            return;
    #####: 4933:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
    #####: 4934:            if (settings.lru_crawler == false) {
    #####: 4935:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4936:                return;
        -: 4937:            }
    #####: 4938:            if (!settings.dump_enabled) {
    #####: 4939:                out_string(c, "ERROR metadump not allowed");
    #####: 4940:                return;
        -: 4941:            }
        -: 4942:
    #####: 4943:            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
        -: 4944:                    c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
    #####: 4945:            switch(rv) {
    #####: 4946:                case CRAWLER_OK:
    #####: 4947:                    out_string(c, "OK");
        -: 4948:                    // TODO: Don't reuse conn_watch here.
    #####: 4949:                    conn_set_state(c, conn_watch);
    #####: 4950:                    event_del(&c->event);
    #####: 4951:                    break;
    #####: 4952:                case CRAWLER_RUNNING:
    #####: 4953:                    out_string(c, "BUSY currently processing crawler request");
    #####: 4954:                    break;
    #####: 4955:                case CRAWLER_BADCLASS:
    #####: 4956:                    out_string(c, "BADCLASS invalid class id");
    #####: 4957:                    break;
    #####: 4958:                case CRAWLER_NOTSTARTED:
    #####: 4959:                    out_string(c, "NOTSTARTED no items to crawl");
    #####: 4960:                    break;
    #####: 4961:                case CRAWLER_ERROR:
    #####: 4962:                    out_string(c, "ERROR an unknown error happened");
    #####: 4963:                    break;
        -: 4964:            }
    #####: 4965:            return;
    #####: 4966:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
    #####: 4967:            uint32_t tocrawl;
    #####: 4968:             if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 4969:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4970:                return;
        -: 4971:            }
    #####: 4972:            settings.lru_crawler_tocrawl = tocrawl;
    #####: 4973:            out_string(c, "OK");
    #####: 4974:            return;
    #####: 4975:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
    #####: 4976:            uint32_t tosleep;
    #####: 4977:            if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 4978:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4979:                return;
        -: 4980:            }
    #####: 4981:            if (tosleep > 1000000) {
    #####: 4982:                out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 4983:                return;
        -: 4984:            }
    #####: 4985:            settings.lru_crawler_sleep = tosleep;
    #####: 4986:            out_string(c, "OK");
    #####: 4987:            return;
    #####: 4988:        } else if (ntokens == 3) {
    #####: 4989:            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
    #####: 4990:                if (start_item_crawler_thread() == 0) {
    #####: 4991:                    out_string(c, "OK");
        -: 4992:                } else {
    #####: 4993:                    out_string(c, "ERROR failed to start lru crawler thread");
        -: 4994:                }
    #####: 4995:            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
    #####: 4996:                if (stop_item_crawler_thread() == 0) {
    #####: 4997:                    out_string(c, "OK");
        -: 4998:                } else {
    #####: 4999:                    out_string(c, "ERROR failed to stop lru crawler thread");
        -: 5000:                }
        -: 5001:            } else {
    #####: 5002:                out_string(c, "ERROR");
        -: 5003:            }
    #####: 5004:            return;
        -: 5005:        } else {
    #####: 5006:            out_string(c, "ERROR");
        -: 5007:        }
    #####: 5008:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
    #####: 5009:        process_watch_command(c, tokens, ntokens);
    #####: 5010:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
    #####: 5011:        process_memlimit_command(c, tokens, ntokens);
    #####: 5012:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
    #####: 5013:        process_verbosity_command(c, tokens, ntokens);
    #####: 5014:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
    #####: 5015:        process_lru_command(c, tokens, ntokens);
        -: 5016:#ifdef MEMCACHED_DEBUG
        -: 5017:    // commands which exist only for testing the memcached's security protection
    #####: 5018:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
    #####: 5019:        process_misbehave_command(c);
        -: 5020:#endif
        -: 5021:#ifdef EXTSTORE
        -: 5022:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
        -: 5023:        process_extstore_command(c, tokens, ntokens);
        -: 5024:#endif
        -: 5025:#ifdef TLS
        -: 5026:    } else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
        -: 5027:        set_noreply_maybe(c, tokens, ntokens);
        -: 5028:        char *errmsg = NULL;
        -: 5029:        if (refresh_certs(&errmsg)) {
        -: 5030:            out_string(c, "OK");
        -: 5031:        } else {
        -: 5032:            write_and_free(c, errmsg, strlen(errmsg));
        -: 5033:        }
        -: 5034:        return;
        -: 5035:#endif
        -: 5036:    } else {
    #####: 5037:        if (ntokens >= 2 && strncmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
    #####: 5038:            conn_set_state(c, conn_closing);
        -: 5039:        } else {
    #####: 5040:            out_string(c, "ERROR");
        -: 5041:        }
        -: 5042:    }
        -: 5043:    return;
        -: 5044:}
------------------
process_command:
    #####: 4722:static void process_command(conn *c, char *command) {
        -: 4723:
    #####: 4724:    token_t tokens[MAX_TOKENS];
    #####: 4725:    size_t ntokens;
    #####: 4726:    int comm;
        -: 4727:
    #####: 4728:    assert(c != NULL);
        -: 4729:
    #####: 4730:    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
        -: 4731:
    #####: 4732:    if (settings.verbose > 1)
    #####: 4733:        fprintf(stderr, "<%d %s\n", c->sfd, command);
        -: 4734:
        -: 4735:    /*
        -: 4736:     * for commands set/add/replace, we build an item and read the data
        -: 4737:     * directly into it, then continue in nread_complete().
        -: 4738:     */
        -: 4739:
    #####: 4740:    c->msgcurr = 0;
    #####: 4741:    c->msgused = 0;
    #####: 4742:    c->iovused = 0;
    #####: 4743:    if (add_msghdr(c) != 0) {
    #####: 4744:        out_of_memory(c, "SERVER_ERROR out of memory preparing response");
    #####: 4745:        return;
        -: 4746:    }
        -: 4747:
    #####: 4748:    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    #####: 4749:    if (ntokens >= 3 &&
    #####: 4750:        ((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
    #####: 4751:         (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) {
        -: 4752:
    #####: 4753:        process_get_command(c, tokens, ntokens, false, false);
        -: 4754:
    #####: 4755:    } else if ((ntokens == 6 || ntokens == 7) &&
    #####: 4756:               ((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
    #####: 4757:                (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
    #####: 4758:                (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
    #####: 4759:                (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
    #####: 4760:                (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
        -: 4761:
    #####: 4762:        process_update_command(c, tokens, ntokens, comm, false);
        -: 4763:
    #####: 4764:    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
        -: 4765:
    #####: 4766:        process_update_command(c, tokens, ntokens, comm, true);
        -: 4767:
    #####: 4768:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
        -: 4769:
    #####: 4770:        process_arithmetic_command(c, tokens, ntokens, 1);
        -: 4771:
    #####: 4772:    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
        -: 4773:
    #####: 4774:        process_get_command(c, tokens, ntokens, true, false);
        -: 4775:
    #####: 4776:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
        -: 4777:
    #####: 4778:        process_arithmetic_command(c, tokens, ntokens, 0);
        -: 4779:
    #####: 4780:    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
        -: 4781:
    #####: 4782:        process_delete_command(c, tokens, ntokens);
        -: 4783:
    #####: 4784:    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
        -: 4785:
    #####: 4786:        process_touch_command(c, tokens, ntokens);
        -: 4787:
    #####: 4788:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0)) {
        -: 4789:
    #####: 4790:        process_get_command(c, tokens, ntokens, false, true);
        -: 4791:
    #####: 4792:    } else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats") == 0)) {
        -: 4793:
    #####: 4794:        process_get_command(c, tokens, ntokens, true, true);
        -: 4795:
    #####: 4796:    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
        -: 4797:
    #####: 4798:        process_stat(c, tokens, ntokens);
        -: 4799:
    #####: 4800:    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
    #####: 4801:        time_t exptime = 0;
    #####: 4802:        rel_time_t new_oldest = 0;
        -: 4803:
    #####: 4804:        set_noreply_maybe(c, tokens, ntokens);
        -: 4805:
    #####: 4806:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 4807:        c->thread->stats.flush_cmds++;
    #####: 4808:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 4809:
    #####: 4810:        if (!settings.flush_enabled) {
        -: 4811:            // flush_all is not allowed but we log it on stats
    #####: 4812:            out_string(c, "CLIENT_ERROR flush_all not allowed");
    #####: 4813:            return;
        -: 4814:        }
        -: 4815:
    #####: 4816:        if (ntokens != (c->noreply ? 3 : 2)) {
    #####: 4817:            exptime = strtol(tokens[1].value, NULL, 10);
    #####: 4818:            if(errno == ERANGE) {
    #####: 4819:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4820:                return;
        -: 4821:            }
        -: 4822:        }
        -: 4823:
        -: 4824:        /*
        -: 4825:          If exptime is zero realtime() would return zero too, and
        -: 4826:          realtime(exptime) - 1 would overflow to the max unsigned
        -: 4827:          value.  So we process exptime == 0 the same way we do when
        -: 4828:          no delay is given at all.
        -: 4829:        */
    #####: 4830:        if (exptime > 0) {
    #####: 4831:            new_oldest = realtime(exptime);
        -: 4832:        } else { /* exptime == 0 */
    #####: 4833:            new_oldest = current_time;
        -: 4834:        }
        -: 4835:
    #####: 4836:        if (settings.use_cas) {
    #####: 4837:            settings.oldest_live = new_oldest - 1;
    #####: 4838:            if (settings.oldest_live <= current_time)
    #####: 4839:                settings.oldest_cas = get_cas_id();
        -: 4840:        } else {
    #####: 4841:            settings.oldest_live = new_oldest;
        -: 4842:        }
    #####: 4843:        out_string(c, "OK");
    #####: 4844:        return;
        -: 4845:
    #####: 4846:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
        -: 4847:
    #####: 4848:        out_string(c, "VERSION " VERSION);
        -: 4849:
    #####: 4850:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
        -: 4851:
    #####: 4852:        conn_set_state(c, conn_closing);
        -: 4853:
    #####: 4854:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
        -: 4855:
    #####: 4856:        if (settings.shutdown_command) {
    #####: 4857:            conn_set_state(c, conn_closing);
    #####: 4858:            raise(SIGINT);
        -: 4859:        } else {
    #####: 4860:            out_string(c, "ERROR: shutdown not enabled");
        -: 4861:        }
        -: 4862:
    #####: 4863:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
    #####: 4864:        if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
    #####: 4865:            int src, dst, rv;
        -: 4866:
    #####: 4867:            if (settings.slab_reassign == false) {
    #####: 4868:                out_string(c, "CLIENT_ERROR slab reassignment disabled");
    #####: 4869:                return;
        -: 4870:            }
        -: 4871:
    #####: 4872:            src = strtol(tokens[2].value, NULL, 10);
    #####: 4873:            dst = strtol(tokens[3].value, NULL, 10);
        -: 4874:
    #####: 4875:            if (errno == ERANGE) {
    #####: 4876:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4877:                return;
        -: 4878:            }
        -: 4879:
    #####: 4880:            rv = slabs_reassign(src, dst);
    #####: 4881:            switch (rv) {
    #####: 4882:            case REASSIGN_OK:
    #####: 4883:                out_string(c, "OK");
    #####: 4884:                break;
    #####: 4885:            case REASSIGN_RUNNING:
    #####: 4886:                out_string(c, "BUSY currently processing reassign request");
    #####: 4887:                break;
    #####: 4888:            case REASSIGN_BADCLASS:
    #####: 4889:                out_string(c, "BADCLASS invalid src or dst class id");
    #####: 4890:                break;
    #####: 4891:            case REASSIGN_NOSPARE:
    #####: 4892:                out_string(c, "NOSPARE source class has no spare pages");
    #####: 4893:                break;
    #####: 4894:            case REASSIGN_SRC_DST_SAME:
    #####: 4895:                out_string(c, "SAME src and dst class are identical");
    #####: 4896:                break;
        -: 4897:            }
    #####: 4898:            return;
    #####: 4899:        } else if (ntokens >= 4 &&
    #####: 4900:            (strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
    #####: 4901:            process_slabs_automove_command(c, tokens, ntokens);
        -: 4902:        } else {
    #####: 4903:            out_string(c, "ERROR");
        -: 4904:        }
    #####: 4905:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
    #####: 4906:        if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
    #####: 4907:            int rv;
    #####: 4908:            if (settings.lru_crawler == false) {
    #####: 4909:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4910:                return;
        -: 4911:            }
        -: 4912:
    #####: 4913:            rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
        -: 4914:                    settings.lru_crawler_tocrawl);
    #####: 4915:            switch(rv) {
    #####: 4916:            case CRAWLER_OK:
    #####: 4917:                out_string(c, "OK");
    #####: 4918:                break;
    #####: 4919:            case CRAWLER_RUNNING:
    #####: 4920:                out_string(c, "BUSY currently processing crawler request");
    #####: 4921:                break;
    #####: 4922:            case CRAWLER_BADCLASS:
    #####: 4923:                out_string(c, "BADCLASS invalid class id");
    #####: 4924:                break;
    #####: 4925:            case CRAWLER_NOTSTARTED:
    #####: 4926:                out_string(c, "NOTSTARTED no items to crawl");
    #####: 4927:                break;
    #####: 4928:            case CRAWLER_ERROR:
    #####: 4929:                out_string(c, "ERROR an unknown error happened");
    #####: 4930:                break;
        -: 4931:            }
    #####: 4932:            return;
    #####: 4933:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
    #####: 4934:            if (settings.lru_crawler == false) {
    #####: 4935:                out_string(c, "CLIENT_ERROR lru crawler disabled");
    #####: 4936:                return;
        -: 4937:            }
    #####: 4938:            if (!settings.dump_enabled) {
    #####: 4939:                out_string(c, "ERROR metadump not allowed");
    #####: 4940:                return;
        -: 4941:            }
        -: 4942:
    #####: 4943:            int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
        -: 4944:                    c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
    #####: 4945:            switch(rv) {
    #####: 4946:                case CRAWLER_OK:
    #####: 4947:                    out_string(c, "OK");
        -: 4948:                    // TODO: Don't reuse conn_watch here.
    #####: 4949:                    conn_set_state(c, conn_watch);
    #####: 4950:                    event_del(&c->event);
    #####: 4951:                    break;
    #####: 4952:                case CRAWLER_RUNNING:
    #####: 4953:                    out_string(c, "BUSY currently processing crawler request");
    #####: 4954:                    break;
    #####: 4955:                case CRAWLER_BADCLASS:
    #####: 4956:                    out_string(c, "BADCLASS invalid class id");
    #####: 4957:                    break;
    #####: 4958:                case CRAWLER_NOTSTARTED:
    #####: 4959:                    out_string(c, "NOTSTARTED no items to crawl");
    #####: 4960:                    break;
    #####: 4961:                case CRAWLER_ERROR:
    #####: 4962:                    out_string(c, "ERROR an unknown error happened");
    #####: 4963:                    break;
        -: 4964:            }
    #####: 4965:            return;
    #####: 4966:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
    #####: 4967:            uint32_t tocrawl;
    #####: 4968:             if (!safe_strtoul(tokens[2].value, &tocrawl)) {
    #####: 4969:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4970:                return;
        -: 4971:            }
    #####: 4972:            settings.lru_crawler_tocrawl = tocrawl;
    #####: 4973:            out_string(c, "OK");
    #####: 4974:            return;
    #####: 4975:        } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
    #####: 4976:            uint32_t tosleep;
    #####: 4977:            if (!safe_strtoul(tokens[2].value, &tosleep)) {
    #####: 4978:                out_string(c, "CLIENT_ERROR bad command line format");
    #####: 4979:                return;
        -: 4980:            }
    #####: 4981:            if (tosleep > 1000000) {
    #####: 4982:                out_string(c, "CLIENT_ERROR sleep must be one second or less");
    #####: 4983:                return;
        -: 4984:            }
    #####: 4985:            settings.lru_crawler_sleep = tosleep;
    #####: 4986:            out_string(c, "OK");
    #####: 4987:            return;
    #####: 4988:        } else if (ntokens == 3) {
    #####: 4989:            if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
    #####: 4990:                if (start_item_crawler_thread() == 0) {
    #####: 4991:                    out_string(c, "OK");
        -: 4992:                } else {
    #####: 4993:                    out_string(c, "ERROR failed to start lru crawler thread");
        -: 4994:                }
    #####: 4995:            } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
    #####: 4996:                if (stop_item_crawler_thread() == 0) {
    #####: 4997:                    out_string(c, "OK");
        -: 4998:                } else {
    #####: 4999:                    out_string(c, "ERROR failed to stop lru crawler thread");
        -: 5000:                }
        -: 5001:            } else {
    #####: 5002:                out_string(c, "ERROR");
        -: 5003:            }
    #####: 5004:            return;
        -: 5005:        } else {
    #####: 5006:            out_string(c, "ERROR");
        -: 5007:        }
    #####: 5008:    } else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
    #####: 5009:        process_watch_command(c, tokens, ntokens);
    #####: 5010:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
    #####: 5011:        process_memlimit_command(c, tokens, ntokens);
    #####: 5012:    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
    #####: 5013:        process_verbosity_command(c, tokens, ntokens);
    #####: 5014:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
    #####: 5015:        process_lru_command(c, tokens, ntokens);
        -: 5016:#ifdef MEMCACHED_DEBUG
        -: 5017:    // commands which exist only for testing the memcached's security protection
    #####: 5018:    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
    #####: 5019:        process_misbehave_command(c);
        -: 5020:#endif
        -: 5021:#ifdef EXTSTORE
        -: 5022:    } else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
        -: 5023:        process_extstore_command(c, tokens, ntokens);
        -: 5024:#endif
        -: 5025:#ifdef TLS
        -: 5026:    } else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
        -: 5027:        set_noreply_maybe(c, tokens, ntokens);
        -: 5028:        char *errmsg = NULL;
        -: 5029:        if (refresh_certs(&errmsg)) {
        -: 5030:            out_string(c, "OK");
        -: 5031:        } else {
        -: 5032:            write_and_free(c, errmsg, strlen(errmsg));
        -: 5033:        }
        -: 5034:        return;
        -: 5035:#endif
        -: 5036:    } else {
    #####: 5037:        if (ntokens >= 2 && strncmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
    #####: 5038:            conn_set_state(c, conn_closing);
        -: 5039:        } else {
    #####: 5040:            out_string(c, "ERROR");
        -: 5041:        }
        -: 5042:    }
        -: 5043:    return;
        -: 5044:}
------------------
        -: 5045:
      600: 5046:static int try_read_command_negotiate(conn *c) {
     600*: 5047:    assert(c->protocol == negotiating_prot);
      600: 5048:    assert(c != NULL);
     600*: 5049:    assert(c->rcurr <= (c->rbuf + c->rsize));
     600*: 5050:    assert(c->rbytes > 0);
        -: 5051:
      600: 5052:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
      600: 5053:        c->protocol = binary_prot;
      600: 5054:        c->try_read_command = try_read_command_binary;
        -: 5055:    } else {
        -: 5056:        // authentication doesn't work with negotiated protocol.
    #####: 5057:        c->protocol = ascii_prot;
    #####: 5058:        c->try_read_command = try_read_command_ascii;
        -: 5059:    }
        -: 5060:
      600: 5061:    if (settings.verbose > 1) {
    #####: 5062:        fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 5063:                prot_text(c->protocol));
        -: 5064:    }
        -: 5065:
      600: 5066:    return c->try_read_command(c);
        -: 5067:}
------------------
try_read_command_negotiate:
      200: 5046:static int try_read_command_negotiate(conn *c) {
     200*: 5047:    assert(c->protocol == negotiating_prot);
      200: 5048:    assert(c != NULL);
     200*: 5049:    assert(c->rcurr <= (c->rbuf + c->rsize));
     200*: 5050:    assert(c->rbytes > 0);
        -: 5051:
      200: 5052:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
      200: 5053:        c->protocol = binary_prot;
      200: 5054:        c->try_read_command = try_read_command_binary;
        -: 5055:    } else {
        -: 5056:        // authentication doesn't work with negotiated protocol.
    #####: 5057:        c->protocol = ascii_prot;
    #####: 5058:        c->try_read_command = try_read_command_ascii;
        -: 5059:    }
        -: 5060:
      200: 5061:    if (settings.verbose > 1) {
    #####: 5062:        fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 5063:                prot_text(c->protocol));
        -: 5064:    }
        -: 5065:
      200: 5066:    return c->try_read_command(c);
        -: 5067:}
------------------
try_read_command_negotiate:
      200: 5046:static int try_read_command_negotiate(conn *c) {
     200*: 5047:    assert(c->protocol == negotiating_prot);
      200: 5048:    assert(c != NULL);
     200*: 5049:    assert(c->rcurr <= (c->rbuf + c->rsize));
     200*: 5050:    assert(c->rbytes > 0);
        -: 5051:
      200: 5052:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
      200: 5053:        c->protocol = binary_prot;
      200: 5054:        c->try_read_command = try_read_command_binary;
        -: 5055:    } else {
        -: 5056:        // authentication doesn't work with negotiated protocol.
    #####: 5057:        c->protocol = ascii_prot;
    #####: 5058:        c->try_read_command = try_read_command_ascii;
        -: 5059:    }
        -: 5060:
      200: 5061:    if (settings.verbose > 1) {
    #####: 5062:        fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 5063:                prot_text(c->protocol));
        -: 5064:    }
        -: 5065:
      200: 5066:    return c->try_read_command(c);
        -: 5067:}
------------------
try_read_command_negotiate:
      200: 5046:static int try_read_command_negotiate(conn *c) {
     200*: 5047:    assert(c->protocol == negotiating_prot);
      200: 5048:    assert(c != NULL);
     200*: 5049:    assert(c->rcurr <= (c->rbuf + c->rsize));
     200*: 5050:    assert(c->rbytes > 0);
        -: 5051:
      200: 5052:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
      200: 5053:        c->protocol = binary_prot;
      200: 5054:        c->try_read_command = try_read_command_binary;
        -: 5055:    } else {
        -: 5056:        // authentication doesn't work with negotiated protocol.
    #####: 5057:        c->protocol = ascii_prot;
    #####: 5058:        c->try_read_command = try_read_command_ascii;
        -: 5059:    }
        -: 5060:
      200: 5061:    if (settings.verbose > 1) {
    #####: 5062:        fprintf(stderr, "%d: Client using the %s protocol\n", c->sfd,
        -: 5063:                prot_text(c->protocol));
        -: 5064:    }
        -: 5065:
      200: 5066:    return c->try_read_command(c);
        -: 5067:}
------------------
        -: 5068:
    #####: 5069:static int try_read_command_udp(conn *c) {
    #####: 5070:    assert(c != NULL);
    #####: 5071:    assert(c->rcurr <= (c->rbuf + c->rsize));
    #####: 5072:    assert(c->rbytes > 0);
        -: 5073:
    #####: 5074:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
    #####: 5075:        c->protocol = binary_prot;
    #####: 5076:        return try_read_command_binary(c);
        -: 5077:    } else {
    #####: 5078:        c->protocol = ascii_prot;
    #####: 5079:        return try_read_command_ascii(c);
        -: 5080:    }
        -: 5081:}
------------------
try_read_command_udp:
    #####: 5069:static int try_read_command_udp(conn *c) {
    #####: 5070:    assert(c != NULL);
    #####: 5071:    assert(c->rcurr <= (c->rbuf + c->rsize));
    #####: 5072:    assert(c->rbytes > 0);
        -: 5073:
    #####: 5074:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
    #####: 5075:        c->protocol = binary_prot;
    #####: 5076:        return try_read_command_binary(c);
        -: 5077:    } else {
    #####: 5078:        c->protocol = ascii_prot;
    #####: 5079:        return try_read_command_ascii(c);
        -: 5080:    }
        -: 5081:}
------------------
try_read_command_udp:
    #####: 5069:static int try_read_command_udp(conn *c) {
    #####: 5070:    assert(c != NULL);
    #####: 5071:    assert(c->rcurr <= (c->rbuf + c->rsize));
    #####: 5072:    assert(c->rbytes > 0);
        -: 5073:
    #####: 5074:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
    #####: 5075:        c->protocol = binary_prot;
    #####: 5076:        return try_read_command_binary(c);
        -: 5077:    } else {
    #####: 5078:        c->protocol = ascii_prot;
    #####: 5079:        return try_read_command_ascii(c);
        -: 5080:    }
        -: 5081:}
------------------
try_read_command_udp:
    #####: 5069:static int try_read_command_udp(conn *c) {
    #####: 5070:    assert(c != NULL);
    #####: 5071:    assert(c->rcurr <= (c->rbuf + c->rsize));
    #####: 5072:    assert(c->rbytes > 0);
        -: 5073:
    #####: 5074:    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
    #####: 5075:        c->protocol = binary_prot;
    #####: 5076:        return try_read_command_binary(c);
        -: 5077:    } else {
    #####: 5078:        c->protocol = ascii_prot;
    #####: 5079:        return try_read_command_ascii(c);
        -: 5080:    }
        -: 5081:}
------------------
        -: 5082:
   300000: 5083:static int try_read_command_binary(conn *c) {
        -: 5084:    /* Do we have the complete packet header? */
   300000: 5085:    if (c->rbytes < sizeof(c->binary_header)) {
        -: 5086:        /* need more data! */
        -: 5087:        return 0;
        -: 5088:    } else {
        -: 5089:#ifdef NEED_ALIGN
        -: 5090:        if (((long)(c->rcurr)) % 8 != 0) {
        -: 5091:            /* must realign input buffer */
        -: 5092:            memmove(c->rbuf, c->rcurr, c->rbytes);
        -: 5093:            c->rcurr = c->rbuf;
        -: 5094:            if (settings.verbose > 1) {
        -: 5095:                fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
        -: 5096:            }
        -: 5097:        }
        -: 5098:#endif
   300000: 5099:        protocol_binary_request_header* req;
   300000: 5100:        req = (protocol_binary_request_header*)c->rcurr;
        -: 5101:
   300000: 5102:        if (settings.verbose > 1) {
        -: 5103:            /* Dump the packet before we convert it to host order */
    #####: 5104:            int ii;
    #####: 5105:            fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
    #####: 5106:            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
    #####: 5107:                if (ii % 4 == 0) {
    #####: 5108:                    fprintf(stderr, "\n<%d   ", c->sfd);
        -: 5109:                }
    #####: 5110:                fprintf(stderr, " 0x%02x", req->bytes[ii]);
        -: 5111:            }
    #####: 5112:            fprintf(stderr, "\n");
        -: 5113:        }
        -: 5114:
   300000: 5115:        c->binary_header = *req;
   300000: 5116:        c->binary_header.request.keylen = ntohs(req->request.keylen);
   300000: 5117:        c->binary_header.request.bodylen = ntohl(req->request.bodylen);
   300000: 5118:        c->binary_header.request.cas = ntohll(req->request.cas);
        -: 5119:
   300000: 5120:        if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
    #####: 5121:            if (settings.verbose) {
    #####: 5122:                fprintf(stderr, "Invalid magic:  %x\n",
        -: 5123:                        c->binary_header.request.magic);
        -: 5124:            }
    #####: 5125:            conn_set_state(c, conn_closing);
    #####: 5126:            return -1;
        -: 5127:        }
        -: 5128:
   300000: 5129:        c->msgcurr = 0;
   300000: 5130:        c->msgused = 0;
   300000: 5131:        c->iovused = 0;
   300000: 5132:        if (add_msghdr(c) != 0) {
    #####: 5133:            out_of_memory(c,
        -: 5134:                    "SERVER_ERROR Out of memory allocating headers");
    #####: 5135:            return 0;
        -: 5136:        }
        -: 5137:
   300000: 5138:        c->cmd = c->binary_header.request.opcode;
   300000: 5139:        c->keylen = c->binary_header.request.keylen;
   300000: 5140:        c->opaque = c->binary_header.request.opaque;
        -: 5141:        /* clear the returned cas value */
   300000: 5142:        c->cas = 0;
        -: 5143:
   300000: 5144:        c->last_cmd_time = current_time;
   300000: 5145:        dispatch_bin_command(c);
        -: 5146:
   300000: 5147:        c->rbytes -= sizeof(c->binary_header);
   300000: 5148:        c->rcurr += sizeof(c->binary_header);
        -: 5149:    }
        -: 5150:
   300000: 5151:    return 1;
        -: 5152:}
------------------
try_read_command_binary:
   100000: 5083:static int try_read_command_binary(conn *c) {
        -: 5084:    /* Do we have the complete packet header? */
   100000: 5085:    if (c->rbytes < sizeof(c->binary_header)) {
        -: 5086:        /* need more data! */
        -: 5087:        return 0;
        -: 5088:    } else {
        -: 5089:#ifdef NEED_ALIGN
        -: 5090:        if (((long)(c->rcurr)) % 8 != 0) {
        -: 5091:            /* must realign input buffer */
        -: 5092:            memmove(c->rbuf, c->rcurr, c->rbytes);
        -: 5093:            c->rcurr = c->rbuf;
        -: 5094:            if (settings.verbose > 1) {
        -: 5095:                fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
        -: 5096:            }
        -: 5097:        }
        -: 5098:#endif
   100000: 5099:        protocol_binary_request_header* req;
   100000: 5100:        req = (protocol_binary_request_header*)c->rcurr;
        -: 5101:
   100000: 5102:        if (settings.verbose > 1) {
        -: 5103:            /* Dump the packet before we convert it to host order */
    #####: 5104:            int ii;
    #####: 5105:            fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
    #####: 5106:            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
    #####: 5107:                if (ii % 4 == 0) {
    #####: 5108:                    fprintf(stderr, "\n<%d   ", c->sfd);
        -: 5109:                }
    #####: 5110:                fprintf(stderr, " 0x%02x", req->bytes[ii]);
        -: 5111:            }
    #####: 5112:            fprintf(stderr, "\n");
        -: 5113:        }
        -: 5114:
   100000: 5115:        c->binary_header = *req;
   100000: 5116:        c->binary_header.request.keylen = ntohs(req->request.keylen);
   100000: 5117:        c->binary_header.request.bodylen = ntohl(req->request.bodylen);
   100000: 5118:        c->binary_header.request.cas = ntohll(req->request.cas);
        -: 5119:
   100000: 5120:        if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
    #####: 5121:            if (settings.verbose) {
    #####: 5122:                fprintf(stderr, "Invalid magic:  %x\n",
        -: 5123:                        c->binary_header.request.magic);
        -: 5124:            }
    #####: 5125:            conn_set_state(c, conn_closing);
    #####: 5126:            return -1;
        -: 5127:        }
        -: 5128:
   100000: 5129:        c->msgcurr = 0;
   100000: 5130:        c->msgused = 0;
   100000: 5131:        c->iovused = 0;
   100000: 5132:        if (add_msghdr(c) != 0) {
    #####: 5133:            out_of_memory(c,
        -: 5134:                    "SERVER_ERROR Out of memory allocating headers");
    #####: 5135:            return 0;
        -: 5136:        }
        -: 5137:
   100000: 5138:        c->cmd = c->binary_header.request.opcode;
   100000: 5139:        c->keylen = c->binary_header.request.keylen;
   100000: 5140:        c->opaque = c->binary_header.request.opaque;
        -: 5141:        /* clear the returned cas value */
   100000: 5142:        c->cas = 0;
        -: 5143:
   100000: 5144:        c->last_cmd_time = current_time;
   100000: 5145:        dispatch_bin_command(c);
        -: 5146:
   100000: 5147:        c->rbytes -= sizeof(c->binary_header);
   100000: 5148:        c->rcurr += sizeof(c->binary_header);
        -: 5149:    }
        -: 5150:
   100000: 5151:    return 1;
        -: 5152:}
------------------
try_read_command_binary:
   100000: 5083:static int try_read_command_binary(conn *c) {
        -: 5084:    /* Do we have the complete packet header? */
   100000: 5085:    if (c->rbytes < sizeof(c->binary_header)) {
        -: 5086:        /* need more data! */
        -: 5087:        return 0;
        -: 5088:    } else {
        -: 5089:#ifdef NEED_ALIGN
        -: 5090:        if (((long)(c->rcurr)) % 8 != 0) {
        -: 5091:            /* must realign input buffer */
        -: 5092:            memmove(c->rbuf, c->rcurr, c->rbytes);
        -: 5093:            c->rcurr = c->rbuf;
        -: 5094:            if (settings.verbose > 1) {
        -: 5095:                fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
        -: 5096:            }
        -: 5097:        }
        -: 5098:#endif
   100000: 5099:        protocol_binary_request_header* req;
   100000: 5100:        req = (protocol_binary_request_header*)c->rcurr;
        -: 5101:
   100000: 5102:        if (settings.verbose > 1) {
        -: 5103:            /* Dump the packet before we convert it to host order */
    #####: 5104:            int ii;
    #####: 5105:            fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
    #####: 5106:            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
    #####: 5107:                if (ii % 4 == 0) {
    #####: 5108:                    fprintf(stderr, "\n<%d   ", c->sfd);
        -: 5109:                }
    #####: 5110:                fprintf(stderr, " 0x%02x", req->bytes[ii]);
        -: 5111:            }
    #####: 5112:            fprintf(stderr, "\n");
        -: 5113:        }
        -: 5114:
   100000: 5115:        c->binary_header = *req;
   100000: 5116:        c->binary_header.request.keylen = ntohs(req->request.keylen);
   100000: 5117:        c->binary_header.request.bodylen = ntohl(req->request.bodylen);
   100000: 5118:        c->binary_header.request.cas = ntohll(req->request.cas);
        -: 5119:
   100000: 5120:        if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
    #####: 5121:            if (settings.verbose) {
    #####: 5122:                fprintf(stderr, "Invalid magic:  %x\n",
        -: 5123:                        c->binary_header.request.magic);
        -: 5124:            }
    #####: 5125:            conn_set_state(c, conn_closing);
    #####: 5126:            return -1;
        -: 5127:        }
        -: 5128:
   100000: 5129:        c->msgcurr = 0;
   100000: 5130:        c->msgused = 0;
   100000: 5131:        c->iovused = 0;
   100000: 5132:        if (add_msghdr(c) != 0) {
    #####: 5133:            out_of_memory(c,
        -: 5134:                    "SERVER_ERROR Out of memory allocating headers");
    #####: 5135:            return 0;
        -: 5136:        }
        -: 5137:
   100000: 5138:        c->cmd = c->binary_header.request.opcode;
   100000: 5139:        c->keylen = c->binary_header.request.keylen;
   100000: 5140:        c->opaque = c->binary_header.request.opaque;
        -: 5141:        /* clear the returned cas value */
   100000: 5142:        c->cas = 0;
        -: 5143:
   100000: 5144:        c->last_cmd_time = current_time;
   100000: 5145:        dispatch_bin_command(c);
        -: 5146:
   100000: 5147:        c->rbytes -= sizeof(c->binary_header);
   100000: 5148:        c->rcurr += sizeof(c->binary_header);
        -: 5149:    }
        -: 5150:
   100000: 5151:    return 1;
        -: 5152:}
------------------
try_read_command_binary:
   100000: 5083:static int try_read_command_binary(conn *c) {
        -: 5084:    /* Do we have the complete packet header? */
   100000: 5085:    if (c->rbytes < sizeof(c->binary_header)) {
        -: 5086:        /* need more data! */
        -: 5087:        return 0;
        -: 5088:    } else {
        -: 5089:#ifdef NEED_ALIGN
        -: 5090:        if (((long)(c->rcurr)) % 8 != 0) {
        -: 5091:            /* must realign input buffer */
        -: 5092:            memmove(c->rbuf, c->rcurr, c->rbytes);
        -: 5093:            c->rcurr = c->rbuf;
        -: 5094:            if (settings.verbose > 1) {
        -: 5095:                fprintf(stderr, "%d: Realign input buffer\n", c->sfd);
        -: 5096:            }
        -: 5097:        }
        -: 5098:#endif
   100000: 5099:        protocol_binary_request_header* req;
   100000: 5100:        req = (protocol_binary_request_header*)c->rcurr;
        -: 5101:
   100000: 5102:        if (settings.verbose > 1) {
        -: 5103:            /* Dump the packet before we convert it to host order */
    #####: 5104:            int ii;
    #####: 5105:            fprintf(stderr, "<%d Read binary protocol data:", c->sfd);
    #####: 5106:            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
    #####: 5107:                if (ii % 4 == 0) {
    #####: 5108:                    fprintf(stderr, "\n<%d   ", c->sfd);
        -: 5109:                }
    #####: 5110:                fprintf(stderr, " 0x%02x", req->bytes[ii]);
        -: 5111:            }
    #####: 5112:            fprintf(stderr, "\n");
        -: 5113:        }
        -: 5114:
   100000: 5115:        c->binary_header = *req;
   100000: 5116:        c->binary_header.request.keylen = ntohs(req->request.keylen);
   100000: 5117:        c->binary_header.request.bodylen = ntohl(req->request.bodylen);
   100000: 5118:        c->binary_header.request.cas = ntohll(req->request.cas);
        -: 5119:
   100000: 5120:        if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
    #####: 5121:            if (settings.verbose) {
    #####: 5122:                fprintf(stderr, "Invalid magic:  %x\n",
        -: 5123:                        c->binary_header.request.magic);
        -: 5124:            }
    #####: 5125:            conn_set_state(c, conn_closing);
    #####: 5126:            return -1;
        -: 5127:        }
        -: 5128:
   100000: 5129:        c->msgcurr = 0;
   100000: 5130:        c->msgused = 0;
   100000: 5131:        c->iovused = 0;
   100000: 5132:        if (add_msghdr(c) != 0) {
    #####: 5133:            out_of_memory(c,
        -: 5134:                    "SERVER_ERROR Out of memory allocating headers");
    #####: 5135:            return 0;
        -: 5136:        }
        -: 5137:
   100000: 5138:        c->cmd = c->binary_header.request.opcode;
   100000: 5139:        c->keylen = c->binary_header.request.keylen;
   100000: 5140:        c->opaque = c->binary_header.request.opaque;
        -: 5141:        /* clear the returned cas value */
   100000: 5142:        c->cas = 0;
        -: 5143:
   100000: 5144:        c->last_cmd_time = current_time;
   100000: 5145:        dispatch_bin_command(c);
        -: 5146:
   100000: 5147:        c->rbytes -= sizeof(c->binary_header);
   100000: 5148:        c->rcurr += sizeof(c->binary_header);
        -: 5149:    }
        -: 5150:
   100000: 5151:    return 1;
        -: 5152:}
------------------
        -: 5153:
    #####: 5154:static int try_read_command_asciiauth(conn *c) {
    #####: 5155:    token_t tokens[MAX_TOKENS];
    #####: 5156:    size_t ntokens;
    #####: 5157:    char *cont = NULL;
        -: 5158:
        -: 5159:    // TODO: move to another function.
    #####: 5160:    if (!c->sasl_started) {
    #####: 5161:        char *el;
    #####: 5162:        uint32_t size = 0;
        -: 5163:
        -: 5164:        // impossible for the auth command to be this short.
    #####: 5165:        if (c->rbytes < 2)
    #####: 5166:            return 0;
        -: 5167:
    #####: 5168:        el = memchr(c->rcurr, '\n', c->rbytes);
        -: 5169:
        -: 5170:        // If no newline after 1k, getting junk data, close out.
    #####: 5171:        if (!el) {
    #####: 5172:            if (c->rbytes > 1024) {
    #####: 5173:                conn_set_state(c, conn_closing);
    #####: 5174:                return 1;
        -: 5175:            }
        -: 5176:            return 0;
        -: 5177:        }
        -: 5178:
        -: 5179:        // Looking for: "set foo 0 0 N\r\nuser pass\r\n"
        -: 5180:        // key, flags, and ttl are ignored. N is used to see if we have the rest.
        -: 5181:
        -: 5182:        // so tokenize doesn't walk past into the value.
        -: 5183:        // it's fine to leave the \r in, as strtoul will stop at it.
    #####: 5184:        *el = '\0';
        -: 5185:
    #####: 5186:        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        -: 5187:        // ensure the buffer is consumed.
    #####: 5188:        c->rbytes -= (el - c->rcurr) + 1;
    #####: 5189:        c->rcurr += (el - c->rcurr) + 1;
        -: 5190:
        -: 5191:        // final token is a NULL ender, so we have one more than expected.
    #####: 5192:        if (ntokens < 6
    #####: 5193:                || strcmp(tokens[0].value, "set") != 0
    #####: 5194:                || !safe_strtoul(tokens[4].value, &size)) {
    #####: 5195:            out_string(c, "CLIENT_ERROR unauthenticated");
    #####: 5196:            return 1;
        -: 5197:        }
        -: 5198:
        -: 5199:        // we don't actually care about the key at all; it can be anything.
        -: 5200:        // we do care about the size of the remaining read.
    #####: 5201:        c->rlbytes = size + 2;
        -: 5202:
    #####: 5203:        c->sasl_started = true; // reuse from binprot sasl, but not sasl :)
        -: 5204:    }
        -: 5205:
    #####: 5206:    if (c->rbytes < c->rlbytes) {
        -: 5207:        // need more bytes.
        -: 5208:        return 0;
        -: 5209:    }
        -: 5210:
    #####: 5211:    cont = c->rcurr;
        -: 5212:    // advance buffer. no matter what we're stopping.
    #####: 5213:    c->rbytes -= c->rlbytes;
    #####: 5214:    c->rcurr += c->rlbytes;
    #####: 5215:    c->sasl_started = false;
        -: 5216:
        -: 5217:    // must end with \r\n
        -: 5218:    // NB: I thought ASCII sets also worked with just \n, but according to
        -: 5219:    // complete_nread_ascii only \r\n is valid.
    #####: 5220:    if (strncmp(cont + c->rlbytes - 2, "\r\n", 2) != 0) {
    #####: 5221:        out_string(c, "CLIENT_ERROR bad command line termination");
    #####: 5222:        return 1;
        -: 5223:    }
        -: 5224:
        -: 5225:    // payload should be "user pass", so we can use the tokenizer.
    #####: 5226:    cont[c->rlbytes - 2] = '\0';
    #####: 5227:    ntokens = tokenize_command(cont, tokens, MAX_TOKENS);
        -: 5228:
    #####: 5229:    if (ntokens < 3) {
    #####: 5230:        out_string(c, "CLIENT_ERROR bad authentication token format");
    #####: 5231:        return 1;
        -: 5232:    }
        -: 5233:
    #####: 5234:    if (authfile_check(tokens[0].value, tokens[1].value) == 1) {
    #####: 5235:        out_string(c, "STORED");
    #####: 5236:        c->authenticated = true;
    #####: 5237:        c->try_read_command = try_read_command_ascii;
    #####: 5238:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5239:        c->thread->stats.auth_cmds++;
    #####: 5240:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5241:    } else {
    #####: 5242:        out_string(c, "CLIENT_ERROR authentication failure");
    #####: 5243:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5244:        c->thread->stats.auth_cmds++;
    #####: 5245:        c->thread->stats.auth_errors++;
    #####: 5246:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5247:    }
        -: 5248:
        -: 5249:    return 1;
        -: 5250:}
------------------
try_read_command_asciiauth:
    #####: 5154:static int try_read_command_asciiauth(conn *c) {
    #####: 5155:    token_t tokens[MAX_TOKENS];
    #####: 5156:    size_t ntokens;
    #####: 5157:    char *cont = NULL;
        -: 5158:
        -: 5159:    // TODO: move to another function.
    #####: 5160:    if (!c->sasl_started) {
    #####: 5161:        char *el;
    #####: 5162:        uint32_t size = 0;
        -: 5163:
        -: 5164:        // impossible for the auth command to be this short.
    #####: 5165:        if (c->rbytes < 2)
    #####: 5166:            return 0;
        -: 5167:
    #####: 5168:        el = memchr(c->rcurr, '\n', c->rbytes);
        -: 5169:
        -: 5170:        // If no newline after 1k, getting junk data, close out.
    #####: 5171:        if (!el) {
    #####: 5172:            if (c->rbytes > 1024) {
    #####: 5173:                conn_set_state(c, conn_closing);
    #####: 5174:                return 1;
        -: 5175:            }
        -: 5176:            return 0;
        -: 5177:        }
        -: 5178:
        -: 5179:        // Looking for: "set foo 0 0 N\r\nuser pass\r\n"
        -: 5180:        // key, flags, and ttl are ignored. N is used to see if we have the rest.
        -: 5181:
        -: 5182:        // so tokenize doesn't walk past into the value.
        -: 5183:        // it's fine to leave the \r in, as strtoul will stop at it.
    #####: 5184:        *el = '\0';
        -: 5185:
    #####: 5186:        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        -: 5187:        // ensure the buffer is consumed.
    #####: 5188:        c->rbytes -= (el - c->rcurr) + 1;
    #####: 5189:        c->rcurr += (el - c->rcurr) + 1;
        -: 5190:
        -: 5191:        // final token is a NULL ender, so we have one more than expected.
    #####: 5192:        if (ntokens < 6
    #####: 5193:                || strcmp(tokens[0].value, "set") != 0
    #####: 5194:                || !safe_strtoul(tokens[4].value, &size)) {
    #####: 5195:            out_string(c, "CLIENT_ERROR unauthenticated");
    #####: 5196:            return 1;
        -: 5197:        }
        -: 5198:
        -: 5199:        // we don't actually care about the key at all; it can be anything.
        -: 5200:        // we do care about the size of the remaining read.
    #####: 5201:        c->rlbytes = size + 2;
        -: 5202:
    #####: 5203:        c->sasl_started = true; // reuse from binprot sasl, but not sasl :)
        -: 5204:    }
        -: 5205:
    #####: 5206:    if (c->rbytes < c->rlbytes) {
        -: 5207:        // need more bytes.
        -: 5208:        return 0;
        -: 5209:    }
        -: 5210:
    #####: 5211:    cont = c->rcurr;
        -: 5212:    // advance buffer. no matter what we're stopping.
    #####: 5213:    c->rbytes -= c->rlbytes;
    #####: 5214:    c->rcurr += c->rlbytes;
    #####: 5215:    c->sasl_started = false;
        -: 5216:
        -: 5217:    // must end with \r\n
        -: 5218:    // NB: I thought ASCII sets also worked with just \n, but according to
        -: 5219:    // complete_nread_ascii only \r\n is valid.
    #####: 5220:    if (strncmp(cont + c->rlbytes - 2, "\r\n", 2) != 0) {
    #####: 5221:        out_string(c, "CLIENT_ERROR bad command line termination");
    #####: 5222:        return 1;
        -: 5223:    }
        -: 5224:
        -: 5225:    // payload should be "user pass", so we can use the tokenizer.
    #####: 5226:    cont[c->rlbytes - 2] = '\0';
    #####: 5227:    ntokens = tokenize_command(cont, tokens, MAX_TOKENS);
        -: 5228:
    #####: 5229:    if (ntokens < 3) {
    #####: 5230:        out_string(c, "CLIENT_ERROR bad authentication token format");
    #####: 5231:        return 1;
        -: 5232:    }
        -: 5233:
    #####: 5234:    if (authfile_check(tokens[0].value, tokens[1].value) == 1) {
    #####: 5235:        out_string(c, "STORED");
    #####: 5236:        c->authenticated = true;
    #####: 5237:        c->try_read_command = try_read_command_ascii;
    #####: 5238:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5239:        c->thread->stats.auth_cmds++;
    #####: 5240:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5241:    } else {
    #####: 5242:        out_string(c, "CLIENT_ERROR authentication failure");
    #####: 5243:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5244:        c->thread->stats.auth_cmds++;
    #####: 5245:        c->thread->stats.auth_errors++;
    #####: 5246:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5247:    }
        -: 5248:
        -: 5249:    return 1;
        -: 5250:}
------------------
try_read_command_asciiauth:
    #####: 5154:static int try_read_command_asciiauth(conn *c) {
    #####: 5155:    token_t tokens[MAX_TOKENS];
    #####: 5156:    size_t ntokens;
    #####: 5157:    char *cont = NULL;
        -: 5158:
        -: 5159:    // TODO: move to another function.
    #####: 5160:    if (!c->sasl_started) {
    #####: 5161:        char *el;
    #####: 5162:        uint32_t size = 0;
        -: 5163:
        -: 5164:        // impossible for the auth command to be this short.
    #####: 5165:        if (c->rbytes < 2)
    #####: 5166:            return 0;
        -: 5167:
    #####: 5168:        el = memchr(c->rcurr, '\n', c->rbytes);
        -: 5169:
        -: 5170:        // If no newline after 1k, getting junk data, close out.
    #####: 5171:        if (!el) {
    #####: 5172:            if (c->rbytes > 1024) {
    #####: 5173:                conn_set_state(c, conn_closing);
    #####: 5174:                return 1;
        -: 5175:            }
        -: 5176:            return 0;
        -: 5177:        }
        -: 5178:
        -: 5179:        // Looking for: "set foo 0 0 N\r\nuser pass\r\n"
        -: 5180:        // key, flags, and ttl are ignored. N is used to see if we have the rest.
        -: 5181:
        -: 5182:        // so tokenize doesn't walk past into the value.
        -: 5183:        // it's fine to leave the \r in, as strtoul will stop at it.
    #####: 5184:        *el = '\0';
        -: 5185:
    #####: 5186:        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        -: 5187:        // ensure the buffer is consumed.
    #####: 5188:        c->rbytes -= (el - c->rcurr) + 1;
    #####: 5189:        c->rcurr += (el - c->rcurr) + 1;
        -: 5190:
        -: 5191:        // final token is a NULL ender, so we have one more than expected.
    #####: 5192:        if (ntokens < 6
    #####: 5193:                || strcmp(tokens[0].value, "set") != 0
    #####: 5194:                || !safe_strtoul(tokens[4].value, &size)) {
    #####: 5195:            out_string(c, "CLIENT_ERROR unauthenticated");
    #####: 5196:            return 1;
        -: 5197:        }
        -: 5198:
        -: 5199:        // we don't actually care about the key at all; it can be anything.
        -: 5200:        // we do care about the size of the remaining read.
    #####: 5201:        c->rlbytes = size + 2;
        -: 5202:
    #####: 5203:        c->sasl_started = true; // reuse from binprot sasl, but not sasl :)
        -: 5204:    }
        -: 5205:
    #####: 5206:    if (c->rbytes < c->rlbytes) {
        -: 5207:        // need more bytes.
        -: 5208:        return 0;
        -: 5209:    }
        -: 5210:
    #####: 5211:    cont = c->rcurr;
        -: 5212:    // advance buffer. no matter what we're stopping.
    #####: 5213:    c->rbytes -= c->rlbytes;
    #####: 5214:    c->rcurr += c->rlbytes;
    #####: 5215:    c->sasl_started = false;
        -: 5216:
        -: 5217:    // must end with \r\n
        -: 5218:    // NB: I thought ASCII sets also worked with just \n, but according to
        -: 5219:    // complete_nread_ascii only \r\n is valid.
    #####: 5220:    if (strncmp(cont + c->rlbytes - 2, "\r\n", 2) != 0) {
    #####: 5221:        out_string(c, "CLIENT_ERROR bad command line termination");
    #####: 5222:        return 1;
        -: 5223:    }
        -: 5224:
        -: 5225:    // payload should be "user pass", so we can use the tokenizer.
    #####: 5226:    cont[c->rlbytes - 2] = '\0';
    #####: 5227:    ntokens = tokenize_command(cont, tokens, MAX_TOKENS);
        -: 5228:
    #####: 5229:    if (ntokens < 3) {
    #####: 5230:        out_string(c, "CLIENT_ERROR bad authentication token format");
    #####: 5231:        return 1;
        -: 5232:    }
        -: 5233:
    #####: 5234:    if (authfile_check(tokens[0].value, tokens[1].value) == 1) {
    #####: 5235:        out_string(c, "STORED");
    #####: 5236:        c->authenticated = true;
    #####: 5237:        c->try_read_command = try_read_command_ascii;
    #####: 5238:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5239:        c->thread->stats.auth_cmds++;
    #####: 5240:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5241:    } else {
    #####: 5242:        out_string(c, "CLIENT_ERROR authentication failure");
    #####: 5243:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5244:        c->thread->stats.auth_cmds++;
    #####: 5245:        c->thread->stats.auth_errors++;
    #####: 5246:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5247:    }
        -: 5248:
        -: 5249:    return 1;
        -: 5250:}
------------------
try_read_command_asciiauth:
    #####: 5154:static int try_read_command_asciiauth(conn *c) {
    #####: 5155:    token_t tokens[MAX_TOKENS];
    #####: 5156:    size_t ntokens;
    #####: 5157:    char *cont = NULL;
        -: 5158:
        -: 5159:    // TODO: move to another function.
    #####: 5160:    if (!c->sasl_started) {
    #####: 5161:        char *el;
    #####: 5162:        uint32_t size = 0;
        -: 5163:
        -: 5164:        // impossible for the auth command to be this short.
    #####: 5165:        if (c->rbytes < 2)
    #####: 5166:            return 0;
        -: 5167:
    #####: 5168:        el = memchr(c->rcurr, '\n', c->rbytes);
        -: 5169:
        -: 5170:        // If no newline after 1k, getting junk data, close out.
    #####: 5171:        if (!el) {
    #####: 5172:            if (c->rbytes > 1024) {
    #####: 5173:                conn_set_state(c, conn_closing);
    #####: 5174:                return 1;
        -: 5175:            }
        -: 5176:            return 0;
        -: 5177:        }
        -: 5178:
        -: 5179:        // Looking for: "set foo 0 0 N\r\nuser pass\r\n"
        -: 5180:        // key, flags, and ttl are ignored. N is used to see if we have the rest.
        -: 5181:
        -: 5182:        // so tokenize doesn't walk past into the value.
        -: 5183:        // it's fine to leave the \r in, as strtoul will stop at it.
    #####: 5184:        *el = '\0';
        -: 5185:
    #####: 5186:        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        -: 5187:        // ensure the buffer is consumed.
    #####: 5188:        c->rbytes -= (el - c->rcurr) + 1;
    #####: 5189:        c->rcurr += (el - c->rcurr) + 1;
        -: 5190:
        -: 5191:        // final token is a NULL ender, so we have one more than expected.
    #####: 5192:        if (ntokens < 6
    #####: 5193:                || strcmp(tokens[0].value, "set") != 0
    #####: 5194:                || !safe_strtoul(tokens[4].value, &size)) {
    #####: 5195:            out_string(c, "CLIENT_ERROR unauthenticated");
    #####: 5196:            return 1;
        -: 5197:        }
        -: 5198:
        -: 5199:        // we don't actually care about the key at all; it can be anything.
        -: 5200:        // we do care about the size of the remaining read.
    #####: 5201:        c->rlbytes = size + 2;
        -: 5202:
    #####: 5203:        c->sasl_started = true; // reuse from binprot sasl, but not sasl :)
        -: 5204:    }
        -: 5205:
    #####: 5206:    if (c->rbytes < c->rlbytes) {
        -: 5207:        // need more bytes.
        -: 5208:        return 0;
        -: 5209:    }
        -: 5210:
    #####: 5211:    cont = c->rcurr;
        -: 5212:    // advance buffer. no matter what we're stopping.
    #####: 5213:    c->rbytes -= c->rlbytes;
    #####: 5214:    c->rcurr += c->rlbytes;
    #####: 5215:    c->sasl_started = false;
        -: 5216:
        -: 5217:    // must end with \r\n
        -: 5218:    // NB: I thought ASCII sets also worked with just \n, but according to
        -: 5219:    // complete_nread_ascii only \r\n is valid.
    #####: 5220:    if (strncmp(cont + c->rlbytes - 2, "\r\n", 2) != 0) {
    #####: 5221:        out_string(c, "CLIENT_ERROR bad command line termination");
    #####: 5222:        return 1;
        -: 5223:    }
        -: 5224:
        -: 5225:    // payload should be "user pass", so we can use the tokenizer.
    #####: 5226:    cont[c->rlbytes - 2] = '\0';
    #####: 5227:    ntokens = tokenize_command(cont, tokens, MAX_TOKENS);
        -: 5228:
    #####: 5229:    if (ntokens < 3) {
    #####: 5230:        out_string(c, "CLIENT_ERROR bad authentication token format");
    #####: 5231:        return 1;
        -: 5232:    }
        -: 5233:
    #####: 5234:    if (authfile_check(tokens[0].value, tokens[1].value) == 1) {
    #####: 5235:        out_string(c, "STORED");
    #####: 5236:        c->authenticated = true;
    #####: 5237:        c->try_read_command = try_read_command_ascii;
    #####: 5238:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5239:        c->thread->stats.auth_cmds++;
    #####: 5240:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5241:    } else {
    #####: 5242:        out_string(c, "CLIENT_ERROR authentication failure");
    #####: 5243:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5244:        c->thread->stats.auth_cmds++;
    #####: 5245:        c->thread->stats.auth_errors++;
    #####: 5246:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5247:    }
        -: 5248:
        -: 5249:    return 1;
        -: 5250:}
------------------
        -: 5251:
    #####: 5252:static int try_read_command_ascii(conn *c) {
    #####: 5253:    char *el, *cont;
        -: 5254:
    #####: 5255:    if (c->rbytes == 0)
        -: 5256:        return 0;
        -: 5257:
    #####: 5258:    el = memchr(c->rcurr, '\n', c->rbytes);
    #####: 5259:    if (!el) {
    #####: 5260:        if (c->rbytes > 1024) {
        -: 5261:            /*
        -: 5262:             * We didn't have a '\n' in the first k. This _has_ to be a
        -: 5263:             * large multiget, if not we should just nuke the connection.
        -: 5264:             */
        -: 5265:            char *ptr = c->rcurr;
    #####: 5266:            while (*ptr == ' ') { /* ignore leading whitespaces */
    #####: 5267:                ++ptr;
        -: 5268:            }
        -: 5269:
    #####: 5270:            if (ptr - c->rcurr > 100 ||
    #####: 5271:                (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -: 5272:
    #####: 5273:                conn_set_state(c, conn_closing);
    #####: 5274:                return 1;
        -: 5275:            }
        -: 5276:        }
        -: 5277:
        -: 5278:        return 0;
        -: 5279:    }
    #####: 5280:    cont = el + 1;
    #####: 5281:    if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
    #####: 5282:        el--;
        -: 5283:    }
    #####: 5284:    *el = '\0';
        -: 5285:
    #####: 5286:    assert(cont <= (c->rcurr + c->rbytes));
        -: 5287:
    #####: 5288:    c->last_cmd_time = current_time;
    #####: 5289:    process_command(c, c->rcurr);
        -: 5290:
    #####: 5291:    c->rbytes -= (cont - c->rcurr);
    #####: 5292:    c->rcurr = cont;
        -: 5293:
    #####: 5294:    assert(c->rcurr <= (c->rbuf + c->rsize));
        -: 5295:
        -: 5296:    return 1;
        -: 5297:}
------------------
try_read_command_ascii:
    #####: 5252:static int try_read_command_ascii(conn *c) {
    #####: 5253:    char *el, *cont;
        -: 5254:
    #####: 5255:    if (c->rbytes == 0)
        -: 5256:        return 0;
        -: 5257:
    #####: 5258:    el = memchr(c->rcurr, '\n', c->rbytes);
    #####: 5259:    if (!el) {
    #####: 5260:        if (c->rbytes > 1024) {
        -: 5261:            /*
        -: 5262:             * We didn't have a '\n' in the first k. This _has_ to be a
        -: 5263:             * large multiget, if not we should just nuke the connection.
        -: 5264:             */
        -: 5265:            char *ptr = c->rcurr;
    #####: 5266:            while (*ptr == ' ') { /* ignore leading whitespaces */
    #####: 5267:                ++ptr;
        -: 5268:            }
        -: 5269:
    #####: 5270:            if (ptr - c->rcurr > 100 ||
    #####: 5271:                (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -: 5272:
    #####: 5273:                conn_set_state(c, conn_closing);
    #####: 5274:                return 1;
        -: 5275:            }
        -: 5276:        }
        -: 5277:
        -: 5278:        return 0;
        -: 5279:    }
    #####: 5280:    cont = el + 1;
    #####: 5281:    if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
    #####: 5282:        el--;
        -: 5283:    }
    #####: 5284:    *el = '\0';
        -: 5285:
    #####: 5286:    assert(cont <= (c->rcurr + c->rbytes));
        -: 5287:
    #####: 5288:    c->last_cmd_time = current_time;
    #####: 5289:    process_command(c, c->rcurr);
        -: 5290:
    #####: 5291:    c->rbytes -= (cont - c->rcurr);
    #####: 5292:    c->rcurr = cont;
        -: 5293:
    #####: 5294:    assert(c->rcurr <= (c->rbuf + c->rsize));
        -: 5295:
        -: 5296:    return 1;
        -: 5297:}
------------------
try_read_command_ascii:
    #####: 5252:static int try_read_command_ascii(conn *c) {
    #####: 5253:    char *el, *cont;
        -: 5254:
    #####: 5255:    if (c->rbytes == 0)
        -: 5256:        return 0;
        -: 5257:
    #####: 5258:    el = memchr(c->rcurr, '\n', c->rbytes);
    #####: 5259:    if (!el) {
    #####: 5260:        if (c->rbytes > 1024) {
        -: 5261:            /*
        -: 5262:             * We didn't have a '\n' in the first k. This _has_ to be a
        -: 5263:             * large multiget, if not we should just nuke the connection.
        -: 5264:             */
        -: 5265:            char *ptr = c->rcurr;
    #####: 5266:            while (*ptr == ' ') { /* ignore leading whitespaces */
    #####: 5267:                ++ptr;
        -: 5268:            }
        -: 5269:
    #####: 5270:            if (ptr - c->rcurr > 100 ||
    #####: 5271:                (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -: 5272:
    #####: 5273:                conn_set_state(c, conn_closing);
    #####: 5274:                return 1;
        -: 5275:            }
        -: 5276:        }
        -: 5277:
        -: 5278:        return 0;
        -: 5279:    }
    #####: 5280:    cont = el + 1;
    #####: 5281:    if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
    #####: 5282:        el--;
        -: 5283:    }
    #####: 5284:    *el = '\0';
        -: 5285:
    #####: 5286:    assert(cont <= (c->rcurr + c->rbytes));
        -: 5287:
    #####: 5288:    c->last_cmd_time = current_time;
    #####: 5289:    process_command(c, c->rcurr);
        -: 5290:
    #####: 5291:    c->rbytes -= (cont - c->rcurr);
    #####: 5292:    c->rcurr = cont;
        -: 5293:
    #####: 5294:    assert(c->rcurr <= (c->rbuf + c->rsize));
        -: 5295:
        -: 5296:    return 1;
        -: 5297:}
------------------
try_read_command_ascii:
    #####: 5252:static int try_read_command_ascii(conn *c) {
    #####: 5253:    char *el, *cont;
        -: 5254:
    #####: 5255:    if (c->rbytes == 0)
        -: 5256:        return 0;
        -: 5257:
    #####: 5258:    el = memchr(c->rcurr, '\n', c->rbytes);
    #####: 5259:    if (!el) {
    #####: 5260:        if (c->rbytes > 1024) {
        -: 5261:            /*
        -: 5262:             * We didn't have a '\n' in the first k. This _has_ to be a
        -: 5263:             * large multiget, if not we should just nuke the connection.
        -: 5264:             */
        -: 5265:            char *ptr = c->rcurr;
    #####: 5266:            while (*ptr == ' ') { /* ignore leading whitespaces */
    #####: 5267:                ++ptr;
        -: 5268:            }
        -: 5269:
    #####: 5270:            if (ptr - c->rcurr > 100 ||
    #####: 5271:                (strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
        -: 5272:
    #####: 5273:                conn_set_state(c, conn_closing);
    #####: 5274:                return 1;
        -: 5275:            }
        -: 5276:        }
        -: 5277:
        -: 5278:        return 0;
        -: 5279:    }
    #####: 5280:    cont = el + 1;
    #####: 5281:    if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
    #####: 5282:        el--;
        -: 5283:    }
    #####: 5284:    *el = '\0';
        -: 5285:
    #####: 5286:    assert(cont <= (c->rcurr + c->rbytes));
        -: 5287:
    #####: 5288:    c->last_cmd_time = current_time;
    #####: 5289:    process_command(c, c->rcurr);
        -: 5290:
    #####: 5291:    c->rbytes -= (cont - c->rcurr);
    #####: 5292:    c->rcurr = cont;
        -: 5293:
    #####: 5294:    assert(c->rcurr <= (c->rbuf + c->rsize));
        -: 5295:
        -: 5296:    return 1;
        -: 5297:}
------------------
        -: 5298:
        -: 5299:/*
        -: 5300: * read a UDP request.
        -: 5301: */
    #####: 5302:static enum try_read_result try_read_udp(conn *c) {
    #####: 5303:    int res;
        -: 5304:
    #####: 5305:    assert(c != NULL);
        -: 5306:
    #####: 5307:    c->request_addr_size = sizeof(c->request_addr);
    #####: 5308:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
    #####: 5309:                   0, (struct sockaddr *)&c->request_addr,
        -: 5310:                   &c->request_addr_size);
    #####: 5311:    if (res > 8) {
    #####: 5312:        unsigned char *buf = (unsigned char *)c->rbuf;
    #####: 5313:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5314:        c->thread->stats.bytes_read += res;
    #####: 5315:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5316:
        -: 5317:        /* Beginning of UDP packet is the request ID; save it. */
    #####: 5318:        c->request_id = buf[0] * 256 + buf[1];
        -: 5319:
        -: 5320:        /* If this is a multi-packet request, drop it. */
    #####: 5321:        if (buf[4] != 0 || buf[5] != 1) {
    #####: 5322:            out_string(c, "SERVER_ERROR multi-packet request not supported");
    #####: 5323:            return READ_NO_DATA_RECEIVED;
        -: 5324:        }
        -: 5325:
        -: 5326:        /* Don't care about any of the rest of the header. */
    #####: 5327:        res -= 8;
    #####: 5328:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 5329:
    #####: 5330:        c->rbytes = res;
    #####: 5331:        c->rcurr = c->rbuf;
    #####: 5332:        return READ_DATA_RECEIVED;
        -: 5333:    }
        -: 5334:    return READ_NO_DATA_RECEIVED;
        -: 5335:}
------------------
try_read_udp:
    #####: 5302:static enum try_read_result try_read_udp(conn *c) {
    #####: 5303:    int res;
        -: 5304:
    #####: 5305:    assert(c != NULL);
        -: 5306:
    #####: 5307:    c->request_addr_size = sizeof(c->request_addr);
    #####: 5308:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
    #####: 5309:                   0, (struct sockaddr *)&c->request_addr,
        -: 5310:                   &c->request_addr_size);
    #####: 5311:    if (res > 8) {
    #####: 5312:        unsigned char *buf = (unsigned char *)c->rbuf;
    #####: 5313:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5314:        c->thread->stats.bytes_read += res;
    #####: 5315:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5316:
        -: 5317:        /* Beginning of UDP packet is the request ID; save it. */
    #####: 5318:        c->request_id = buf[0] * 256 + buf[1];
        -: 5319:
        -: 5320:        /* If this is a multi-packet request, drop it. */
    #####: 5321:        if (buf[4] != 0 || buf[5] != 1) {
    #####: 5322:            out_string(c, "SERVER_ERROR multi-packet request not supported");
    #####: 5323:            return READ_NO_DATA_RECEIVED;
        -: 5324:        }
        -: 5325:
        -: 5326:        /* Don't care about any of the rest of the header. */
    #####: 5327:        res -= 8;
    #####: 5328:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 5329:
    #####: 5330:        c->rbytes = res;
    #####: 5331:        c->rcurr = c->rbuf;
    #####: 5332:        return READ_DATA_RECEIVED;
        -: 5333:    }
        -: 5334:    return READ_NO_DATA_RECEIVED;
        -: 5335:}
------------------
try_read_udp:
    #####: 5302:static enum try_read_result try_read_udp(conn *c) {
    #####: 5303:    int res;
        -: 5304:
    #####: 5305:    assert(c != NULL);
        -: 5306:
    #####: 5307:    c->request_addr_size = sizeof(c->request_addr);
    #####: 5308:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
    #####: 5309:                   0, (struct sockaddr *)&c->request_addr,
        -: 5310:                   &c->request_addr_size);
    #####: 5311:    if (res > 8) {
    #####: 5312:        unsigned char *buf = (unsigned char *)c->rbuf;
    #####: 5313:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5314:        c->thread->stats.bytes_read += res;
    #####: 5315:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5316:
        -: 5317:        /* Beginning of UDP packet is the request ID; save it. */
    #####: 5318:        c->request_id = buf[0] * 256 + buf[1];
        -: 5319:
        -: 5320:        /* If this is a multi-packet request, drop it. */
    #####: 5321:        if (buf[4] != 0 || buf[5] != 1) {
    #####: 5322:            out_string(c, "SERVER_ERROR multi-packet request not supported");
    #####: 5323:            return READ_NO_DATA_RECEIVED;
        -: 5324:        }
        -: 5325:
        -: 5326:        /* Don't care about any of the rest of the header. */
    #####: 5327:        res -= 8;
    #####: 5328:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 5329:
    #####: 5330:        c->rbytes = res;
    #####: 5331:        c->rcurr = c->rbuf;
    #####: 5332:        return READ_DATA_RECEIVED;
        -: 5333:    }
        -: 5334:    return READ_NO_DATA_RECEIVED;
        -: 5335:}
------------------
try_read_udp:
    #####: 5302:static enum try_read_result try_read_udp(conn *c) {
    #####: 5303:    int res;
        -: 5304:
    #####: 5305:    assert(c != NULL);
        -: 5306:
    #####: 5307:    c->request_addr_size = sizeof(c->request_addr);
    #####: 5308:    res = recvfrom(c->sfd, c->rbuf, c->rsize,
    #####: 5309:                   0, (struct sockaddr *)&c->request_addr,
        -: 5310:                   &c->request_addr_size);
    #####: 5311:    if (res > 8) {
    #####: 5312:        unsigned char *buf = (unsigned char *)c->rbuf;
    #####: 5313:        pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5314:        c->thread->stats.bytes_read += res;
    #####: 5315:        pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5316:
        -: 5317:        /* Beginning of UDP packet is the request ID; save it. */
    #####: 5318:        c->request_id = buf[0] * 256 + buf[1];
        -: 5319:
        -: 5320:        /* If this is a multi-packet request, drop it. */
    #####: 5321:        if (buf[4] != 0 || buf[5] != 1) {
    #####: 5322:            out_string(c, "SERVER_ERROR multi-packet request not supported");
    #####: 5323:            return READ_NO_DATA_RECEIVED;
        -: 5324:        }
        -: 5325:
        -: 5326:        /* Don't care about any of the rest of the header. */
    #####: 5327:        res -= 8;
    #####: 5328:        memmove(c->rbuf, c->rbuf + 8, res);
        -: 5329:
    #####: 5330:        c->rbytes = res;
    #####: 5331:        c->rcurr = c->rbuf;
    #####: 5332:        return READ_DATA_RECEIVED;
        -: 5333:    }
        -: 5334:    return READ_NO_DATA_RECEIVED;
        -: 5335:}
------------------
        -: 5336:
        -: 5337:/*
        -: 5338: * read from network as much as we can, handle buffer overflow and connection
        -: 5339: * close.
        -: 5340: * before reading, move the remaining incomplete fragment of a command
        -: 5341: * (if any) to the beginning of the buffer.
        -: 5342: *
        -: 5343: * To protect us from someone flooding a connection with bogus data causing
        -: 5344: * the connection to eat up all available memory, break out and start looking
        -: 5345: * at the data I've got after a number of reallocs...
        -: 5346: *
        -: 5347: * @return enum try_read_result
        -: 5348: */
   300600: 5349:static enum try_read_result try_read_network(conn *c) {
   300600: 5350:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
   300600: 5351:    int res;
   300600: 5352:    int num_allocs = 0;
  300600*: 5353:    assert(c != NULL);
        -: 5354:
   300600: 5355:    if (c->rcurr != c->rbuf) {
   300000: 5356:        if (c->rbytes != 0) /* otherwise there's nothing to copy */
    #####: 5357:            memmove(c->rbuf, c->rcurr, c->rbytes);
   300000: 5358:        c->rcurr = c->rbuf;
        -: 5359:    }
        -: 5360:
   300600: 5361:    while (1) {
   300600: 5362:        if (c->rbytes >= c->rsize) {
    #####: 5363:            if (num_allocs == 4) {
    #####: 5364:                return gotdata;
        -: 5365:            }
    #####: 5366:            ++num_allocs;
    #####: 5367:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
    #####: 5368:            if (!new_rbuf) {
    #####: 5369:                STATS_LOCK();
    #####: 5370:                stats.malloc_fails++;
    #####: 5371:                STATS_UNLOCK();
    #####: 5372:                if (settings.verbose > 0) {
    #####: 5373:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 5374:                }
    #####: 5375:                c->rbytes = 0; /* ignore what we read */
    #####: 5376:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 5377:                c->write_and_go = conn_closing;
    #####: 5378:                return READ_MEMORY_ERROR;
        -: 5379:            }
    #####: 5380:            c->rcurr = c->rbuf = new_rbuf;
    #####: 5381:            c->rsize *= 2;
        -: 5382:        }
        -: 5383:
   300600: 5384:        int avail = c->rsize - c->rbytes;
   300600: 5385:        res = c->read(c, c->rbuf + c->rbytes, avail);
   300600: 5386:        if (res > 0) {
   300000: 5387:            pthread_mutex_lock(&c->thread->stats.mutex);
   300000: 5388:            c->thread->stats.bytes_read += res;
   300000: 5389:            pthread_mutex_unlock(&c->thread->stats.mutex);
   300000: 5390:            gotdata = READ_DATA_RECEIVED;
   300000: 5391:            c->rbytes += res;
   300000: 5392:            if (res == avail) {
        -: 5393:                continue;
        -: 5394:            } else {
        -: 5395:                break;
        -: 5396:            }
        -: 5397:        }
      600: 5398:        if (res == 0) {
        -: 5399:            return READ_ERROR;
        -: 5400:        }
    #####: 5401:        if (res == -1) {
    #####: 5402:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5403:                break;
        -: 5404:            }
    #####: 5405:            return READ_ERROR;
        -: 5406:        }
        -: 5407:    }
        -: 5408:    return gotdata;
        -: 5409:}
------------------
try_read_network:
   100200: 5349:static enum try_read_result try_read_network(conn *c) {
   100200: 5350:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
   100200: 5351:    int res;
   100200: 5352:    int num_allocs = 0;
  100200*: 5353:    assert(c != NULL);
        -: 5354:
   100200: 5355:    if (c->rcurr != c->rbuf) {
   100000: 5356:        if (c->rbytes != 0) /* otherwise there's nothing to copy */
    #####: 5357:            memmove(c->rbuf, c->rcurr, c->rbytes);
   100000: 5358:        c->rcurr = c->rbuf;
        -: 5359:    }
        -: 5360:
   100200: 5361:    while (1) {
   100200: 5362:        if (c->rbytes >= c->rsize) {
    #####: 5363:            if (num_allocs == 4) {
    #####: 5364:                return gotdata;
        -: 5365:            }
    #####: 5366:            ++num_allocs;
    #####: 5367:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
    #####: 5368:            if (!new_rbuf) {
    #####: 5369:                STATS_LOCK();
    #####: 5370:                stats.malloc_fails++;
    #####: 5371:                STATS_UNLOCK();
    #####: 5372:                if (settings.verbose > 0) {
    #####: 5373:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 5374:                }
    #####: 5375:                c->rbytes = 0; /* ignore what we read */
    #####: 5376:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 5377:                c->write_and_go = conn_closing;
    #####: 5378:                return READ_MEMORY_ERROR;
        -: 5379:            }
    #####: 5380:            c->rcurr = c->rbuf = new_rbuf;
    #####: 5381:            c->rsize *= 2;
        -: 5382:        }
        -: 5383:
   100200: 5384:        int avail = c->rsize - c->rbytes;
   100200: 5385:        res = c->read(c, c->rbuf + c->rbytes, avail);
   100200: 5386:        if (res > 0) {
   100000: 5387:            pthread_mutex_lock(&c->thread->stats.mutex);
   100000: 5388:            c->thread->stats.bytes_read += res;
   100000: 5389:            pthread_mutex_unlock(&c->thread->stats.mutex);
   100000: 5390:            gotdata = READ_DATA_RECEIVED;
   100000: 5391:            c->rbytes += res;
   100000: 5392:            if (res == avail) {
        -: 5393:                continue;
        -: 5394:            } else {
        -: 5395:                break;
        -: 5396:            }
        -: 5397:        }
      200: 5398:        if (res == 0) {
        -: 5399:            return READ_ERROR;
        -: 5400:        }
    #####: 5401:        if (res == -1) {
    #####: 5402:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5403:                break;
        -: 5404:            }
    #####: 5405:            return READ_ERROR;
        -: 5406:        }
        -: 5407:    }
        -: 5408:    return gotdata;
        -: 5409:}
------------------
try_read_network:
   100200: 5349:static enum try_read_result try_read_network(conn *c) {
   100200: 5350:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
   100200: 5351:    int res;
   100200: 5352:    int num_allocs = 0;
  100200*: 5353:    assert(c != NULL);
        -: 5354:
   100200: 5355:    if (c->rcurr != c->rbuf) {
   100000: 5356:        if (c->rbytes != 0) /* otherwise there's nothing to copy */
    #####: 5357:            memmove(c->rbuf, c->rcurr, c->rbytes);
   100000: 5358:        c->rcurr = c->rbuf;
        -: 5359:    }
        -: 5360:
   100200: 5361:    while (1) {
   100200: 5362:        if (c->rbytes >= c->rsize) {
    #####: 5363:            if (num_allocs == 4) {
    #####: 5364:                return gotdata;
        -: 5365:            }
    #####: 5366:            ++num_allocs;
    #####: 5367:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
    #####: 5368:            if (!new_rbuf) {
    #####: 5369:                STATS_LOCK();
    #####: 5370:                stats.malloc_fails++;
    #####: 5371:                STATS_UNLOCK();
    #####: 5372:                if (settings.verbose > 0) {
    #####: 5373:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 5374:                }
    #####: 5375:                c->rbytes = 0; /* ignore what we read */
    #####: 5376:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 5377:                c->write_and_go = conn_closing;
    #####: 5378:                return READ_MEMORY_ERROR;
        -: 5379:            }
    #####: 5380:            c->rcurr = c->rbuf = new_rbuf;
    #####: 5381:            c->rsize *= 2;
        -: 5382:        }
        -: 5383:
   100200: 5384:        int avail = c->rsize - c->rbytes;
   100200: 5385:        res = c->read(c, c->rbuf + c->rbytes, avail);
   100200: 5386:        if (res > 0) {
   100000: 5387:            pthread_mutex_lock(&c->thread->stats.mutex);
   100000: 5388:            c->thread->stats.bytes_read += res;
   100000: 5389:            pthread_mutex_unlock(&c->thread->stats.mutex);
   100000: 5390:            gotdata = READ_DATA_RECEIVED;
   100000: 5391:            c->rbytes += res;
   100000: 5392:            if (res == avail) {
        -: 5393:                continue;
        -: 5394:            } else {
        -: 5395:                break;
        -: 5396:            }
        -: 5397:        }
      200: 5398:        if (res == 0) {
        -: 5399:            return READ_ERROR;
        -: 5400:        }
    #####: 5401:        if (res == -1) {
    #####: 5402:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5403:                break;
        -: 5404:            }
    #####: 5405:            return READ_ERROR;
        -: 5406:        }
        -: 5407:    }
        -: 5408:    return gotdata;
        -: 5409:}
------------------
try_read_network:
   100200: 5349:static enum try_read_result try_read_network(conn *c) {
   100200: 5350:    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
   100200: 5351:    int res;
   100200: 5352:    int num_allocs = 0;
  100200*: 5353:    assert(c != NULL);
        -: 5354:
   100200: 5355:    if (c->rcurr != c->rbuf) {
   100000: 5356:        if (c->rbytes != 0) /* otherwise there's nothing to copy */
    #####: 5357:            memmove(c->rbuf, c->rcurr, c->rbytes);
   100000: 5358:        c->rcurr = c->rbuf;
        -: 5359:    }
        -: 5360:
   100200: 5361:    while (1) {
   100200: 5362:        if (c->rbytes >= c->rsize) {
    #####: 5363:            if (num_allocs == 4) {
    #####: 5364:                return gotdata;
        -: 5365:            }
    #####: 5366:            ++num_allocs;
    #####: 5367:            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
    #####: 5368:            if (!new_rbuf) {
    #####: 5369:                STATS_LOCK();
    #####: 5370:                stats.malloc_fails++;
    #####: 5371:                STATS_UNLOCK();
    #####: 5372:                if (settings.verbose > 0) {
    #####: 5373:                    fprintf(stderr, "Couldn't realloc input buffer\n");
        -: 5374:                }
    #####: 5375:                c->rbytes = 0; /* ignore what we read */
    #####: 5376:                out_of_memory(c, "SERVER_ERROR out of memory reading request");
    #####: 5377:                c->write_and_go = conn_closing;
    #####: 5378:                return READ_MEMORY_ERROR;
        -: 5379:            }
    #####: 5380:            c->rcurr = c->rbuf = new_rbuf;
    #####: 5381:            c->rsize *= 2;
        -: 5382:        }
        -: 5383:
   100200: 5384:        int avail = c->rsize - c->rbytes;
   100200: 5385:        res = c->read(c, c->rbuf + c->rbytes, avail);
   100200: 5386:        if (res > 0) {
   100000: 5387:            pthread_mutex_lock(&c->thread->stats.mutex);
   100000: 5388:            c->thread->stats.bytes_read += res;
   100000: 5389:            pthread_mutex_unlock(&c->thread->stats.mutex);
   100000: 5390:            gotdata = READ_DATA_RECEIVED;
   100000: 5391:            c->rbytes += res;
   100000: 5392:            if (res == avail) {
        -: 5393:                continue;
        -: 5394:            } else {
        -: 5395:                break;
        -: 5396:            }
        -: 5397:        }
      200: 5398:        if (res == 0) {
        -: 5399:            return READ_ERROR;
        -: 5400:        }
    #####: 5401:        if (res == -1) {
    #####: 5402:            if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5403:                break;
        -: 5404:            }
    #####: 5405:            return READ_ERROR;
        -: 5406:        }
        -: 5407:    }
        -: 5408:    return gotdata;
        -: 5409:}
------------------
        -: 5410:
   300600: 5411:static bool update_event(conn *c, const int new_flags) {
  300600*: 5412:    assert(c != NULL);
        -: 5413:
   300600: 5414:    struct event_base *base = c->event.ev_base;
   300600: 5415:    if (c->ev_flags == new_flags)
        -: 5416:        return true;
    #####: 5417:    if (event_del(&c->event) == -1) return false;
    #####: 5418:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    #####: 5419:    event_base_set(base, &c->event);
    #####: 5420:    c->ev_flags = new_flags;
    #####: 5421:    if (event_add(&c->event, 0) == -1) return false;
        -: 5422:    return true;
        -: 5423:}
------------------
update_event:
   100200: 5411:static bool update_event(conn *c, const int new_flags) {
  100200*: 5412:    assert(c != NULL);
        -: 5413:
   100200: 5414:    struct event_base *base = c->event.ev_base;
   100200: 5415:    if (c->ev_flags == new_flags)
        -: 5416:        return true;
    #####: 5417:    if (event_del(&c->event) == -1) return false;
    #####: 5418:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    #####: 5419:    event_base_set(base, &c->event);
    #####: 5420:    c->ev_flags = new_flags;
    #####: 5421:    if (event_add(&c->event, 0) == -1) return false;
        -: 5422:    return true;
        -: 5423:}
------------------
update_event:
   100200: 5411:static bool update_event(conn *c, const int new_flags) {
  100200*: 5412:    assert(c != NULL);
        -: 5413:
   100200: 5414:    struct event_base *base = c->event.ev_base;
   100200: 5415:    if (c->ev_flags == new_flags)
        -: 5416:        return true;
    #####: 5417:    if (event_del(&c->event) == -1) return false;
    #####: 5418:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    #####: 5419:    event_base_set(base, &c->event);
    #####: 5420:    c->ev_flags = new_flags;
    #####: 5421:    if (event_add(&c->event, 0) == -1) return false;
        -: 5422:    return true;
        -: 5423:}
------------------
update_event:
   100200: 5411:static bool update_event(conn *c, const int new_flags) {
  100200*: 5412:    assert(c != NULL);
        -: 5413:
   100200: 5414:    struct event_base *base = c->event.ev_base;
   100200: 5415:    if (c->ev_flags == new_flags)
        -: 5416:        return true;
    #####: 5417:    if (event_del(&c->event) == -1) return false;
    #####: 5418:    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    #####: 5419:    event_base_set(base, &c->event);
    #####: 5420:    c->ev_flags = new_flags;
    #####: 5421:    if (event_add(&c->event, 0) == -1) return false;
        -: 5422:    return true;
        -: 5423:}
------------------
        -: 5424:
        -: 5425:/*
        -: 5426: * Sets whether we are listening for new connections or not.
        -: 5427: */
    #####: 5428:void do_accept_new_conns(const bool do_accept) {
    #####: 5429:    conn *next;
        -: 5430:
    #####: 5431:    for (next = listen_conn; next; next = next->next) {
    #####: 5432:        if (do_accept) {
    #####: 5433:            update_event(next, EV_READ | EV_PERSIST);
    #####: 5434:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 5435:                perror("listen");
        -: 5436:            }
        -: 5437:        }
        -: 5438:        else {
    #####: 5439:            update_event(next, 0);
    #####: 5440:            if (listen(next->sfd, 0) != 0) {
    #####: 5441:                perror("listen");
        -: 5442:            }
        -: 5443:        }
        -: 5444:    }
        -: 5445:
    #####: 5446:    if (do_accept) {
    #####: 5447:        struct timeval maxconns_exited;
    #####: 5448:        uint64_t elapsed_us;
    #####: 5449:        gettimeofday(&maxconns_exited,NULL);
    #####: 5450:        STATS_LOCK();
    #####: 5451:        elapsed_us =
    #####: 5452:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 5453:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 5454:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 5455:        stats_state.accepting_conns = true;
    #####: 5456:        STATS_UNLOCK();
        -: 5457:    } else {
    #####: 5458:        STATS_LOCK();
    #####: 5459:        stats_state.accepting_conns = false;
    #####: 5460:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 5461:        stats.listen_disabled_num++;
    #####: 5462:        STATS_UNLOCK();
    #####: 5463:        allow_new_conns = false;
    #####: 5464:        maxconns_handler(-42, 0, 0);
        -: 5465:    }
    #####: 5466:}
------------------
do_accept_new_conns:
    #####: 5428:void do_accept_new_conns(const bool do_accept) {
    #####: 5429:    conn *next;
        -: 5430:
    #####: 5431:    for (next = listen_conn; next; next = next->next) {
    #####: 5432:        if (do_accept) {
    #####: 5433:            update_event(next, EV_READ | EV_PERSIST);
    #####: 5434:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 5435:                perror("listen");
        -: 5436:            }
        -: 5437:        }
        -: 5438:        else {
    #####: 5439:            update_event(next, 0);
    #####: 5440:            if (listen(next->sfd, 0) != 0) {
    #####: 5441:                perror("listen");
        -: 5442:            }
        -: 5443:        }
        -: 5444:    }
        -: 5445:
    #####: 5446:    if (do_accept) {
    #####: 5447:        struct timeval maxconns_exited;
    #####: 5448:        uint64_t elapsed_us;
    #####: 5449:        gettimeofday(&maxconns_exited,NULL);
    #####: 5450:        STATS_LOCK();
    #####: 5451:        elapsed_us =
    #####: 5452:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 5453:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 5454:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 5455:        stats_state.accepting_conns = true;
    #####: 5456:        STATS_UNLOCK();
        -: 5457:    } else {
    #####: 5458:        STATS_LOCK();
    #####: 5459:        stats_state.accepting_conns = false;
    #####: 5460:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 5461:        stats.listen_disabled_num++;
    #####: 5462:        STATS_UNLOCK();
    #####: 5463:        allow_new_conns = false;
    #####: 5464:        maxconns_handler(-42, 0, 0);
        -: 5465:    }
    #####: 5466:}
------------------
do_accept_new_conns:
    #####: 5428:void do_accept_new_conns(const bool do_accept) {
    #####: 5429:    conn *next;
        -: 5430:
    #####: 5431:    for (next = listen_conn; next; next = next->next) {
    #####: 5432:        if (do_accept) {
    #####: 5433:            update_event(next, EV_READ | EV_PERSIST);
    #####: 5434:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 5435:                perror("listen");
        -: 5436:            }
        -: 5437:        }
        -: 5438:        else {
    #####: 5439:            update_event(next, 0);
    #####: 5440:            if (listen(next->sfd, 0) != 0) {
    #####: 5441:                perror("listen");
        -: 5442:            }
        -: 5443:        }
        -: 5444:    }
        -: 5445:
    #####: 5446:    if (do_accept) {
    #####: 5447:        struct timeval maxconns_exited;
    #####: 5448:        uint64_t elapsed_us;
    #####: 5449:        gettimeofday(&maxconns_exited,NULL);
    #####: 5450:        STATS_LOCK();
    #####: 5451:        elapsed_us =
    #####: 5452:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 5453:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 5454:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 5455:        stats_state.accepting_conns = true;
    #####: 5456:        STATS_UNLOCK();
        -: 5457:    } else {
    #####: 5458:        STATS_LOCK();
    #####: 5459:        stats_state.accepting_conns = false;
    #####: 5460:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 5461:        stats.listen_disabled_num++;
    #####: 5462:        STATS_UNLOCK();
    #####: 5463:        allow_new_conns = false;
    #####: 5464:        maxconns_handler(-42, 0, 0);
        -: 5465:    }
    #####: 5466:}
------------------
do_accept_new_conns:
    #####: 5428:void do_accept_new_conns(const bool do_accept) {
    #####: 5429:    conn *next;
        -: 5430:
    #####: 5431:    for (next = listen_conn; next; next = next->next) {
    #####: 5432:        if (do_accept) {
    #####: 5433:            update_event(next, EV_READ | EV_PERSIST);
    #####: 5434:            if (listen(next->sfd, settings.backlog) != 0) {
    #####: 5435:                perror("listen");
        -: 5436:            }
        -: 5437:        }
        -: 5438:        else {
    #####: 5439:            update_event(next, 0);
    #####: 5440:            if (listen(next->sfd, 0) != 0) {
    #####: 5441:                perror("listen");
        -: 5442:            }
        -: 5443:        }
        -: 5444:    }
        -: 5445:
    #####: 5446:    if (do_accept) {
    #####: 5447:        struct timeval maxconns_exited;
    #####: 5448:        uint64_t elapsed_us;
    #####: 5449:        gettimeofday(&maxconns_exited,NULL);
    #####: 5450:        STATS_LOCK();
    #####: 5451:        elapsed_us =
    #####: 5452:            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
    #####: 5453:            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
    #####: 5454:        stats.time_in_listen_disabled_us += elapsed_us;
    #####: 5455:        stats_state.accepting_conns = true;
    #####: 5456:        STATS_UNLOCK();
        -: 5457:    } else {
    #####: 5458:        STATS_LOCK();
    #####: 5459:        stats_state.accepting_conns = false;
    #####: 5460:        gettimeofday(&stats.maxconns_entered,NULL);
    #####: 5461:        stats.listen_disabled_num++;
    #####: 5462:        STATS_UNLOCK();
    #####: 5463:        allow_new_conns = false;
    #####: 5464:        maxconns_handler(-42, 0, 0);
        -: 5465:    }
    #####: 5466:}
------------------
        -: 5467:
        -: 5468:/*
        -: 5469: * Transmit the next chunk of data from our list of msgbuf structures.
        -: 5470: *
        -: 5471: * Returns:
        -: 5472: *   TRANSMIT_COMPLETE   All done writing.
        -: 5473: *   TRANSMIT_INCOMPLETE More data remaining to write.
        -: 5474: *   TRANSMIT_SOFT_ERROR Can't write any more right now.
        -: 5475: *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)
        -: 5476: */
   600000: 5477:static enum transmit_result transmit(conn *c) {
  600000*: 5478:    assert(c != NULL);
        -: 5479:
   600000: 5480:    if (c->msgcurr < c->msgused &&
   600000: 5481:            c->msglist[c->msgcurr].msg_iovlen == 0) {
        -: 5482:        /* Finished writing the current msg; advance to the next. */
   300000: 5483:        c->msgcurr++;
        -: 5484:    }
   600000: 5485:    if (c->msgcurr < c->msgused) {
   300000: 5486:        ssize_t res;
   300000: 5487:        struct msghdr *m = &c->msglist[c->msgcurr];
        -: 5488:
   300000: 5489:        res = c->sendmsg(c, m, 0);
   300000: 5490:        if (res > 0) {
   300000: 5491:            pthread_mutex_lock(&c->thread->stats.mutex);
   300000: 5492:            c->thread->stats.bytes_written += res;
   300000: 5493:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5494:
        -: 5495:            /* We've written some of the data. Remove the completed
        -: 5496:               iovec entries from the list of pending writes. */
   872400: 5497:            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
   572400: 5498:                res -= m->msg_iov->iov_len;
   572400: 5499:                m->msg_iovlen--;
   572400: 5500:                m->msg_iov++;
        -: 5501:            }
        -: 5502:
        -: 5503:            /* Might have written just part of the last iovec entry;
        -: 5504:               adjust it so the next write will do the rest. */
   300000: 5505:            if (res > 0) {
    #####: 5506:                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
    #####: 5507:                m->msg_iov->iov_len -= res;
        -: 5508:            }
   300000: 5509:            return TRANSMIT_INCOMPLETE;
        -: 5510:        }
    #####: 5511:        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5512:            if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5513:                if (settings.verbose > 0)
    #####: 5514:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5515:                conn_set_state(c, conn_closing);
    #####: 5516:                return TRANSMIT_HARD_ERROR;
        -: 5517:            }
        -: 5518:            return TRANSMIT_SOFT_ERROR;
        -: 5519:        }
        -: 5520:        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 5521:           we have a real error, on which we close the connection */
    #####: 5522:        if (settings.verbose > 0)
    #####: 5523:            perror("Failed to write, and not due to blocking");
        -: 5524:
    #####: 5525:        if (IS_UDP(c->transport))
    #####: 5526:            conn_set_state(c, conn_read);
        -: 5527:        else
    #####: 5528:            conn_set_state(c, conn_closing);
    #####: 5529:        return TRANSMIT_HARD_ERROR;
        -: 5530:    } else {
        -: 5531:        return TRANSMIT_COMPLETE;
        -: 5532:    }
        -: 5533:}
------------------
transmit:
   200000: 5477:static enum transmit_result transmit(conn *c) {
  200000*: 5478:    assert(c != NULL);
        -: 5479:
   200000: 5480:    if (c->msgcurr < c->msgused &&
   200000: 5481:            c->msglist[c->msgcurr].msg_iovlen == 0) {
        -: 5482:        /* Finished writing the current msg; advance to the next. */
   100000: 5483:        c->msgcurr++;
        -: 5484:    }
   200000: 5485:    if (c->msgcurr < c->msgused) {
   100000: 5486:        ssize_t res;
   100000: 5487:        struct msghdr *m = &c->msglist[c->msgcurr];
        -: 5488:
   100000: 5489:        res = c->sendmsg(c, m, 0);
   100000: 5490:        if (res > 0) {
   100000: 5491:            pthread_mutex_lock(&c->thread->stats.mutex);
   100000: 5492:            c->thread->stats.bytes_written += res;
   100000: 5493:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5494:
        -: 5495:            /* We've written some of the data. Remove the completed
        -: 5496:               iovec entries from the list of pending writes. */
   290800: 5497:            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
   190800: 5498:                res -= m->msg_iov->iov_len;
   190800: 5499:                m->msg_iovlen--;
   190800: 5500:                m->msg_iov++;
        -: 5501:            }
        -: 5502:
        -: 5503:            /* Might have written just part of the last iovec entry;
        -: 5504:               adjust it so the next write will do the rest. */
   100000: 5505:            if (res > 0) {
    #####: 5506:                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
    #####: 5507:                m->msg_iov->iov_len -= res;
        -: 5508:            }
   100000: 5509:            return TRANSMIT_INCOMPLETE;
        -: 5510:        }
    #####: 5511:        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5512:            if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5513:                if (settings.verbose > 0)
    #####: 5514:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5515:                conn_set_state(c, conn_closing);
    #####: 5516:                return TRANSMIT_HARD_ERROR;
        -: 5517:            }
        -: 5518:            return TRANSMIT_SOFT_ERROR;
        -: 5519:        }
        -: 5520:        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 5521:           we have a real error, on which we close the connection */
    #####: 5522:        if (settings.verbose > 0)
    #####: 5523:            perror("Failed to write, and not due to blocking");
        -: 5524:
    #####: 5525:        if (IS_UDP(c->transport))
    #####: 5526:            conn_set_state(c, conn_read);
        -: 5527:        else
    #####: 5528:            conn_set_state(c, conn_closing);
    #####: 5529:        return TRANSMIT_HARD_ERROR;
        -: 5530:    } else {
        -: 5531:        return TRANSMIT_COMPLETE;
        -: 5532:    }
        -: 5533:}
------------------
transmit:
   200000: 5477:static enum transmit_result transmit(conn *c) {
  200000*: 5478:    assert(c != NULL);
        -: 5479:
   200000: 5480:    if (c->msgcurr < c->msgused &&
   200000: 5481:            c->msglist[c->msgcurr].msg_iovlen == 0) {
        -: 5482:        /* Finished writing the current msg; advance to the next. */
   100000: 5483:        c->msgcurr++;
        -: 5484:    }
   200000: 5485:    if (c->msgcurr < c->msgused) {
   100000: 5486:        ssize_t res;
   100000: 5487:        struct msghdr *m = &c->msglist[c->msgcurr];
        -: 5488:
   100000: 5489:        res = c->sendmsg(c, m, 0);
   100000: 5490:        if (res > 0) {
   100000: 5491:            pthread_mutex_lock(&c->thread->stats.mutex);
   100000: 5492:            c->thread->stats.bytes_written += res;
   100000: 5493:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5494:
        -: 5495:            /* We've written some of the data. Remove the completed
        -: 5496:               iovec entries from the list of pending writes. */
   290800: 5497:            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
   190800: 5498:                res -= m->msg_iov->iov_len;
   190800: 5499:                m->msg_iovlen--;
   190800: 5500:                m->msg_iov++;
        -: 5501:            }
        -: 5502:
        -: 5503:            /* Might have written just part of the last iovec entry;
        -: 5504:               adjust it so the next write will do the rest. */
   100000: 5505:            if (res > 0) {
    #####: 5506:                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
    #####: 5507:                m->msg_iov->iov_len -= res;
        -: 5508:            }
   100000: 5509:            return TRANSMIT_INCOMPLETE;
        -: 5510:        }
    #####: 5511:        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5512:            if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5513:                if (settings.verbose > 0)
    #####: 5514:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5515:                conn_set_state(c, conn_closing);
    #####: 5516:                return TRANSMIT_HARD_ERROR;
        -: 5517:            }
        -: 5518:            return TRANSMIT_SOFT_ERROR;
        -: 5519:        }
        -: 5520:        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 5521:           we have a real error, on which we close the connection */
    #####: 5522:        if (settings.verbose > 0)
    #####: 5523:            perror("Failed to write, and not due to blocking");
        -: 5524:
    #####: 5525:        if (IS_UDP(c->transport))
    #####: 5526:            conn_set_state(c, conn_read);
        -: 5527:        else
    #####: 5528:            conn_set_state(c, conn_closing);
    #####: 5529:        return TRANSMIT_HARD_ERROR;
        -: 5530:    } else {
        -: 5531:        return TRANSMIT_COMPLETE;
        -: 5532:    }
        -: 5533:}
------------------
transmit:
   200000: 5477:static enum transmit_result transmit(conn *c) {
  200000*: 5478:    assert(c != NULL);
        -: 5479:
   200000: 5480:    if (c->msgcurr < c->msgused &&
   200000: 5481:            c->msglist[c->msgcurr].msg_iovlen == 0) {
        -: 5482:        /* Finished writing the current msg; advance to the next. */
   100000: 5483:        c->msgcurr++;
        -: 5484:    }
   200000: 5485:    if (c->msgcurr < c->msgused) {
   100000: 5486:        ssize_t res;
   100000: 5487:        struct msghdr *m = &c->msglist[c->msgcurr];
        -: 5488:
   100000: 5489:        res = c->sendmsg(c, m, 0);
   100000: 5490:        if (res > 0) {
   100000: 5491:            pthread_mutex_lock(&c->thread->stats.mutex);
   100000: 5492:            c->thread->stats.bytes_written += res;
   100000: 5493:            pthread_mutex_unlock(&c->thread->stats.mutex);
        -: 5494:
        -: 5495:            /* We've written some of the data. Remove the completed
        -: 5496:               iovec entries from the list of pending writes. */
   290800: 5497:            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
   190800: 5498:                res -= m->msg_iov->iov_len;
   190800: 5499:                m->msg_iovlen--;
   190800: 5500:                m->msg_iov++;
        -: 5501:            }
        -: 5502:
        -: 5503:            /* Might have written just part of the last iovec entry;
        -: 5504:               adjust it so the next write will do the rest. */
   100000: 5505:            if (res > 0) {
    #####: 5506:                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
    #####: 5507:                m->msg_iov->iov_len -= res;
        -: 5508:            }
   100000: 5509:            return TRANSMIT_INCOMPLETE;
        -: 5510:        }
    #####: 5511:        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5512:            if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5513:                if (settings.verbose > 0)
    #####: 5514:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5515:                conn_set_state(c, conn_closing);
    #####: 5516:                return TRANSMIT_HARD_ERROR;
        -: 5517:            }
        -: 5518:            return TRANSMIT_SOFT_ERROR;
        -: 5519:        }
        -: 5520:        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
        -: 5521:           we have a real error, on which we close the connection */
    #####: 5522:        if (settings.verbose > 0)
    #####: 5523:            perror("Failed to write, and not due to blocking");
        -: 5524:
    #####: 5525:        if (IS_UDP(c->transport))
    #####: 5526:            conn_set_state(c, conn_read);
        -: 5527:        else
    #####: 5528:            conn_set_state(c, conn_closing);
    #####: 5529:        return TRANSMIT_HARD_ERROR;
        -: 5530:    } else {
        -: 5531:        return TRANSMIT_COMPLETE;
        -: 5532:    }
        -: 5533:}
------------------
        -: 5534:
        -: 5535:/* Does a looped read to fill data chunks */
        -: 5536:/* TODO: restrict number of times this can loop.
        -: 5537: * Also, benchmark using readv's.
        -: 5538: */
    #####: 5539:static int read_into_chunked_item(conn *c) {
    #####: 5540:    int total = 0;
    #####: 5541:    int res;
    #####: 5542:    assert(c->rcurr != c->ritem);
        -: 5543:
    #####: 5544:    while (c->rlbytes > 0) {
    #####: 5545:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5546:        if (ch->size == ch->used) {
        -: 5547:            // FIXME: ch->next is currently always 0. remove this?
    #####: 5548:            if (ch->next) {
    #####: 5549:                c->ritem = (char *) ch->next;
        -: 5550:            } else {
        -: 5551:                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
    #####: 5552:                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
    #####: 5553:                       ((c->protocol == binary_prot) ? 2 : 0));
    #####: 5554:                if (!c->ritem) {
        -: 5555:                    // We failed an allocation. Let caller handle cleanup.
        -: 5556:                    total = -2;
        -: 5557:                    break;
        -: 5558:                }
        -: 5559:                // ritem has new chunk, restart the loop.
        -: 5560:                continue;
        -: 5561:                //assert(c->rlbytes == 0);
        -: 5562:            }
        -: 5563:        }
        -: 5564:
    #####: 5565:        int unused = ch->size - ch->used;
        -: 5566:        /* first check if we have leftovers in the conn_read buffer */
    #####: 5567:        if (c->rbytes > 0) {
    #####: 5568:            total = 0;
    #####: 5569:            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    #####: 5570:            tocopy = tocopy > unused ? unused : tocopy;
    #####: 5571:            if (c->ritem != c->rcurr) {
    #####: 5572:                memmove(ch->data + ch->used, c->rcurr, tocopy);
        -: 5573:            }
    #####: 5574:            total += tocopy;
    #####: 5575:            c->rlbytes -= tocopy;
    #####: 5576:            c->rcurr += tocopy;
    #####: 5577:            c->rbytes -= tocopy;
    #####: 5578:            ch->used += tocopy;
    #####: 5579:            if (c->rlbytes == 0) {
        -: 5580:                break;
        -: 5581:            }
        -: 5582:        } else {
        -: 5583:            /*  now try reading from the socket */
    #####: 5584:            res = c->read(c, ch->data + ch->used,
    #####: 5585:                    (unused > c->rlbytes ? c->rlbytes : unused));
    #####: 5586:            if (res > 0) {
    #####: 5587:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5588:                c->thread->stats.bytes_read += res;
    #####: 5589:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5590:                ch->used += res;
    #####: 5591:                total += res;
    #####: 5592:                c->rlbytes -= res;
        -: 5593:            } else {
        -: 5594:                /* Reset total to the latest result so caller can handle it */
        -: 5595:                total = res;
        -: 5596:                break;
        -: 5597:            }
        -: 5598:        }
        -: 5599:    }
        -: 5600:
        -: 5601:    /* At some point I will be able to ditch the \r\n from item storage and
        -: 5602:       remove all of these kludges.
        -: 5603:       The above binprot check ensures inline space for \r\n, but if we do
        -: 5604:       exactly enough allocs there will be no additional chunk for \r\n.
        -: 5605:     */
    #####: 5606:    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {
    #####: 5607:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5608:        if (ch->size - ch->used < 2) {
    #####: 5609:            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
    #####: 5610:            if (!c->ritem) {
    #####: 5611:                total = -2;
        -: 5612:            }
        -: 5613:        }
        -: 5614:    }
    #####: 5615:    return total;
        -: 5616:}
------------------
read_into_chunked_item:
    #####: 5539:static int read_into_chunked_item(conn *c) {
    #####: 5540:    int total = 0;
    #####: 5541:    int res;
    #####: 5542:    assert(c->rcurr != c->ritem);
        -: 5543:
    #####: 5544:    while (c->rlbytes > 0) {
    #####: 5545:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5546:        if (ch->size == ch->used) {
        -: 5547:            // FIXME: ch->next is currently always 0. remove this?
    #####: 5548:            if (ch->next) {
    #####: 5549:                c->ritem = (char *) ch->next;
        -: 5550:            } else {
        -: 5551:                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
    #####: 5552:                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
    #####: 5553:                       ((c->protocol == binary_prot) ? 2 : 0));
    #####: 5554:                if (!c->ritem) {
        -: 5555:                    // We failed an allocation. Let caller handle cleanup.
        -: 5556:                    total = -2;
        -: 5557:                    break;
        -: 5558:                }
        -: 5559:                // ritem has new chunk, restart the loop.
        -: 5560:                continue;
        -: 5561:                //assert(c->rlbytes == 0);
        -: 5562:            }
        -: 5563:        }
        -: 5564:
    #####: 5565:        int unused = ch->size - ch->used;
        -: 5566:        /* first check if we have leftovers in the conn_read buffer */
    #####: 5567:        if (c->rbytes > 0) {
    #####: 5568:            total = 0;
    #####: 5569:            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    #####: 5570:            tocopy = tocopy > unused ? unused : tocopy;
    #####: 5571:            if (c->ritem != c->rcurr) {
    #####: 5572:                memmove(ch->data + ch->used, c->rcurr, tocopy);
        -: 5573:            }
    #####: 5574:            total += tocopy;
    #####: 5575:            c->rlbytes -= tocopy;
    #####: 5576:            c->rcurr += tocopy;
    #####: 5577:            c->rbytes -= tocopy;
    #####: 5578:            ch->used += tocopy;
    #####: 5579:            if (c->rlbytes == 0) {
        -: 5580:                break;
        -: 5581:            }
        -: 5582:        } else {
        -: 5583:            /*  now try reading from the socket */
    #####: 5584:            res = c->read(c, ch->data + ch->used,
    #####: 5585:                    (unused > c->rlbytes ? c->rlbytes : unused));
    #####: 5586:            if (res > 0) {
    #####: 5587:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5588:                c->thread->stats.bytes_read += res;
    #####: 5589:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5590:                ch->used += res;
    #####: 5591:                total += res;
    #####: 5592:                c->rlbytes -= res;
        -: 5593:            } else {
        -: 5594:                /* Reset total to the latest result so caller can handle it */
        -: 5595:                total = res;
        -: 5596:                break;
        -: 5597:            }
        -: 5598:        }
        -: 5599:    }
        -: 5600:
        -: 5601:    /* At some point I will be able to ditch the \r\n from item storage and
        -: 5602:       remove all of these kludges.
        -: 5603:       The above binprot check ensures inline space for \r\n, but if we do
        -: 5604:       exactly enough allocs there will be no additional chunk for \r\n.
        -: 5605:     */
    #####: 5606:    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {
    #####: 5607:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5608:        if (ch->size - ch->used < 2) {
    #####: 5609:            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
    #####: 5610:            if (!c->ritem) {
    #####: 5611:                total = -2;
        -: 5612:            }
        -: 5613:        }
        -: 5614:    }
    #####: 5615:    return total;
        -: 5616:}
------------------
read_into_chunked_item:
    #####: 5539:static int read_into_chunked_item(conn *c) {
    #####: 5540:    int total = 0;
    #####: 5541:    int res;
    #####: 5542:    assert(c->rcurr != c->ritem);
        -: 5543:
    #####: 5544:    while (c->rlbytes > 0) {
    #####: 5545:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5546:        if (ch->size == ch->used) {
        -: 5547:            // FIXME: ch->next is currently always 0. remove this?
    #####: 5548:            if (ch->next) {
    #####: 5549:                c->ritem = (char *) ch->next;
        -: 5550:            } else {
        -: 5551:                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
    #####: 5552:                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
    #####: 5553:                       ((c->protocol == binary_prot) ? 2 : 0));
    #####: 5554:                if (!c->ritem) {
        -: 5555:                    // We failed an allocation. Let caller handle cleanup.
        -: 5556:                    total = -2;
        -: 5557:                    break;
        -: 5558:                }
        -: 5559:                // ritem has new chunk, restart the loop.
        -: 5560:                continue;
        -: 5561:                //assert(c->rlbytes == 0);
        -: 5562:            }
        -: 5563:        }
        -: 5564:
    #####: 5565:        int unused = ch->size - ch->used;
        -: 5566:        /* first check if we have leftovers in the conn_read buffer */
    #####: 5567:        if (c->rbytes > 0) {
    #####: 5568:            total = 0;
    #####: 5569:            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    #####: 5570:            tocopy = tocopy > unused ? unused : tocopy;
    #####: 5571:            if (c->ritem != c->rcurr) {
    #####: 5572:                memmove(ch->data + ch->used, c->rcurr, tocopy);
        -: 5573:            }
    #####: 5574:            total += tocopy;
    #####: 5575:            c->rlbytes -= tocopy;
    #####: 5576:            c->rcurr += tocopy;
    #####: 5577:            c->rbytes -= tocopy;
    #####: 5578:            ch->used += tocopy;
    #####: 5579:            if (c->rlbytes == 0) {
        -: 5580:                break;
        -: 5581:            }
        -: 5582:        } else {
        -: 5583:            /*  now try reading from the socket */
    #####: 5584:            res = c->read(c, ch->data + ch->used,
    #####: 5585:                    (unused > c->rlbytes ? c->rlbytes : unused));
    #####: 5586:            if (res > 0) {
    #####: 5587:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5588:                c->thread->stats.bytes_read += res;
    #####: 5589:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5590:                ch->used += res;
    #####: 5591:                total += res;
    #####: 5592:                c->rlbytes -= res;
        -: 5593:            } else {
        -: 5594:                /* Reset total to the latest result so caller can handle it */
        -: 5595:                total = res;
        -: 5596:                break;
        -: 5597:            }
        -: 5598:        }
        -: 5599:    }
        -: 5600:
        -: 5601:    /* At some point I will be able to ditch the \r\n from item storage and
        -: 5602:       remove all of these kludges.
        -: 5603:       The above binprot check ensures inline space for \r\n, but if we do
        -: 5604:       exactly enough allocs there will be no additional chunk for \r\n.
        -: 5605:     */
    #####: 5606:    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {
    #####: 5607:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5608:        if (ch->size - ch->used < 2) {
    #####: 5609:            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
    #####: 5610:            if (!c->ritem) {
    #####: 5611:                total = -2;
        -: 5612:            }
        -: 5613:        }
        -: 5614:    }
    #####: 5615:    return total;
        -: 5616:}
------------------
read_into_chunked_item:
    #####: 5539:static int read_into_chunked_item(conn *c) {
    #####: 5540:    int total = 0;
    #####: 5541:    int res;
    #####: 5542:    assert(c->rcurr != c->ritem);
        -: 5543:
    #####: 5544:    while (c->rlbytes > 0) {
    #####: 5545:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5546:        if (ch->size == ch->used) {
        -: 5547:            // FIXME: ch->next is currently always 0. remove this?
    #####: 5548:            if (ch->next) {
    #####: 5549:                c->ritem = (char *) ch->next;
        -: 5550:            } else {
        -: 5551:                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
    #####: 5552:                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
    #####: 5553:                       ((c->protocol == binary_prot) ? 2 : 0));
    #####: 5554:                if (!c->ritem) {
        -: 5555:                    // We failed an allocation. Let caller handle cleanup.
        -: 5556:                    total = -2;
        -: 5557:                    break;
        -: 5558:                }
        -: 5559:                // ritem has new chunk, restart the loop.
        -: 5560:                continue;
        -: 5561:                //assert(c->rlbytes == 0);
        -: 5562:            }
        -: 5563:        }
        -: 5564:
    #####: 5565:        int unused = ch->size - ch->used;
        -: 5566:        /* first check if we have leftovers in the conn_read buffer */
    #####: 5567:        if (c->rbytes > 0) {
    #####: 5568:            total = 0;
    #####: 5569:            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
    #####: 5570:            tocopy = tocopy > unused ? unused : tocopy;
    #####: 5571:            if (c->ritem != c->rcurr) {
    #####: 5572:                memmove(ch->data + ch->used, c->rcurr, tocopy);
        -: 5573:            }
    #####: 5574:            total += tocopy;
    #####: 5575:            c->rlbytes -= tocopy;
    #####: 5576:            c->rcurr += tocopy;
    #####: 5577:            c->rbytes -= tocopy;
    #####: 5578:            ch->used += tocopy;
    #####: 5579:            if (c->rlbytes == 0) {
        -: 5580:                break;
        -: 5581:            }
        -: 5582:        } else {
        -: 5583:            /*  now try reading from the socket */
    #####: 5584:            res = c->read(c, ch->data + ch->used,
    #####: 5585:                    (unused > c->rlbytes ? c->rlbytes : unused));
    #####: 5586:            if (res > 0) {
    #####: 5587:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5588:                c->thread->stats.bytes_read += res;
    #####: 5589:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5590:                ch->used += res;
    #####: 5591:                total += res;
    #####: 5592:                c->rlbytes -= res;
        -: 5593:            } else {
        -: 5594:                /* Reset total to the latest result so caller can handle it */
        -: 5595:                total = res;
        -: 5596:                break;
        -: 5597:            }
        -: 5598:        }
        -: 5599:    }
        -: 5600:
        -: 5601:    /* At some point I will be able to ditch the \r\n from item storage and
        -: 5602:       remove all of these kludges.
        -: 5603:       The above binprot check ensures inline space for \r\n, but if we do
        -: 5604:       exactly enough allocs there will be no additional chunk for \r\n.
        -: 5605:     */
    #####: 5606:    if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {
    #####: 5607:        item_chunk *ch = (item_chunk *)c->ritem;
    #####: 5608:        if (ch->size - ch->used < 2) {
    #####: 5609:            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
    #####: 5610:            if (!c->ritem) {
    #####: 5611:                total = -2;
        -: 5612:            }
        -: 5613:        }
        -: 5614:    }
    #####: 5615:    return total;
        -: 5616:}
------------------
        -: 5617:
   301800: 5618:static void drive_machine(conn *c) {
   301800: 5619:    bool stop = false;
   301800: 5620:    int sfd;
   301800: 5621:    socklen_t addrlen;
   301800: 5622:    struct sockaddr_storage addr;
   301800: 5623:    int nreqs = settings.reqs_per_event;
   301800: 5624:    int res;
   301800: 5625:    const char *str;
        -: 5626:#ifdef HAVE_ACCEPT4
   301800: 5627:    static int  use_accept4 = 1;
        -: 5628:#else
        -: 5629:    static int  use_accept4 = 0;
        -: 5630:#endif
        -: 5631:
  301800*: 5632:    assert(c != NULL);
        -: 5633:
  2760000: 5634:    while (!stop) {
        -: 5635:
  2458200: 5636:        switch(c->state) {
      600: 5637:        case conn_listening:
      600: 5638:            addrlen = sizeof(addr);
        -: 5639:#ifdef HAVE_ACCEPT4
      600: 5640:            if (use_accept4) {
      600: 5641:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 5642:            } else {
    #####: 5643:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5644:            }
        -: 5645:#else
        -: 5646:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5647:#endif
      600: 5648:            if (sfd == -1) {
    #####: 5649:                if (use_accept4 && errno == ENOSYS) {
    #####: 5650:                    use_accept4 = 0;
    #####: 5651:                    continue;
        -: 5652:                }
    #####: 5653:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 5654:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5655:                    /* these are transient, so don't log anything */
        -: 5656:                    stop = true;
    #####: 5657:                } else if (errno == EMFILE) {
    #####: 5658:                    if (settings.verbose > 0)
    #####: 5659:                        fprintf(stderr, "Too many open connections\n");
    #####: 5660:                    accept_new_conns(false);
    #####: 5661:                    stop = true;
        -: 5662:                } else {
    #####: 5663:                    perror("accept()");
    #####: 5664:                    stop = true;
        -: 5665:                }
        -: 5666:                break;
        -: 5667:            }
      600: 5668:            if (!use_accept4) {
    #####: 5669:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 5670:                    perror("setting O_NONBLOCK");
    #####: 5671:                    close(sfd);
    #####: 5672:                    break;
        -: 5673:                }
        -: 5674:            }
        -: 5675:
      600: 5676:            if (settings.maxconns_fast &&
      600: 5677:                stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 5678:                str = "ERROR Too many open connections\r\n";
    #####: 5679:                res = write(sfd, str, strlen(str));
    #####: 5680:                close(sfd);
    #####: 5681:                STATS_LOCK();
    #####: 5682:                stats.rejected_conns++;
    #####: 5683:                STATS_UNLOCK();
        -: 5684:            } else {
      600: 5685:                void *ssl_v = NULL;
        -: 5686:#ifdef TLS
        -: 5687:                SSL *ssl = NULL;
        -: 5688:                if (c->ssl_enabled) {
        -: 5689:                    assert(IS_TCP(c->transport) && settings.ssl_enabled);
        -: 5690:
        -: 5691:                    if (settings.ssl_ctx == NULL) {
        -: 5692:                        if (settings.verbose) {
        -: 5693:                            fprintf(stderr, "SSL context is not initialized\n");
        -: 5694:                        }
        -: 5695:                        close(sfd);
        -: 5696:                        break;
        -: 5697:                    }
        -: 5698:                    SSL_LOCK();
        -: 5699:                    ssl = SSL_new(settings.ssl_ctx);
        -: 5700:                    SSL_UNLOCK();
        -: 5701:                    if (ssl == NULL) {
        -: 5702:                        if (settings.verbose) {
        -: 5703:                            fprintf(stderr, "Failed to created the SSL object\n");
        -: 5704:                        }
        -: 5705:                        close(sfd);
        -: 5706:                        break;
        -: 5707:                    }
        -: 5708:                    SSL_set_fd(ssl, sfd);
        -: 5709:                    int ret = SSL_accept(ssl);
        -: 5710:                    if (ret < 0) {
        -: 5711:                        int err = SSL_get_error(ssl, ret);
        -: 5712:                        if (err == SSL_ERROR_SYSCALL || err == SSL_ERROR_SSL) {
        -: 5713:                            if (settings.verbose) {
        -: 5714:                                fprintf(stderr, "SSL connection failed with error code : %d : %s\n", err, strerror(errno));
        -: 5715:                            }
        -: 5716:                            close(sfd);
        -: 5717:                            break;
        -: 5718:                        }
        -: 5719:                    }
        -: 5720:                }
        -: 5721:                ssl_v = (void*) ssl;
        -: 5722:#endif
        -: 5723:
      600: 5724:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 5725:                                     DATA_BUFFER_SIZE, c->transport, ssl_v);
        -: 5726:            }
        -: 5727:
        -: 5728:            stop = true;
        -: 5729:            break;
        -: 5730:
   300600: 5731:        case conn_waiting:
   300600: 5732:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5733:                if (settings.verbose > 0)
    #####: 5734:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5735:                conn_set_state(c, conn_closing);
    #####: 5736:                break;
        -: 5737:            }
        -: 5738:
   300600: 5739:            conn_set_state(c, conn_read);
   300600: 5740:            stop = true;
   300600: 5741:            break;
        -: 5742:
   300600: 5743:        case conn_read:
  300600*: 5744:            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
        -: 5745:
   300600: 5746:            switch (res) {
    #####: 5747:            case READ_NO_DATA_RECEIVED:
    #####: 5748:                conn_set_state(c, conn_waiting);
    #####: 5749:                break;
   300000: 5750:            case READ_DATA_RECEIVED:
   300000: 5751:                conn_set_state(c, conn_parse_cmd);
   300000: 5752:                break;
      600: 5753:            case READ_ERROR:
      600: 5754:                conn_set_state(c, conn_closing);
      600: 5755:                break;
        -: 5756:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 5757:                /* State already set by try_read_network */
        -: 5758:                break;
        -: 5759:            }
        -: 5760:            break;
        -: 5761:
   300000: 5762:        case conn_parse_cmd :
   300000: 5763:            if (c->try_read_command(c) == 0) {
        -: 5764:                /* wee need more data! */
    #####: 5765:                conn_set_state(c, conn_waiting);
        -: 5766:            }
        -: 5767:
        -: 5768:            break;
        -: 5769:
   300600: 5770:        case conn_new_cmd:
        -: 5771:            /* Only process nreqs at a time to avoid starving other
        -: 5772:               connections */
        -: 5773:
   300600: 5774:            --nreqs;
   300600: 5775:            if (nreqs >= 0) {
   300600: 5776:                reset_cmd_handler(c);
        -: 5777:            } else {
    #####: 5778:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5779:                c->thread->stats.conn_yields++;
    #####: 5780:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5781:                if (c->rbytes > 0) {
        -: 5782:                    /* We have already read in data into the input buffer,
        -: 5783:                       so libevent will most likely not signal read events
        -: 5784:                       on the socket (unless more data is available. As a
        -: 5785:                       hack we should just put in a request to write data,
        -: 5786:                       because that should be possible ;-)
        -: 5787:                    */
    #####: 5788:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5789:                        if (settings.verbose > 0)
    #####: 5790:                            fprintf(stderr, "Couldn't update event\n");
    #####: 5791:                        conn_set_state(c, conn_closing);
    #####: 5792:                        break;
        -: 5793:                    }
        -: 5794:                }
        -: 5795:                stop = true;
        -: 5796:            }
        -: 5797:            break;
        -: 5798:
   655200: 5799:        case conn_nread:
   655200: 5800:            if (c->rlbytes == 0) {
   327600: 5801:                complete_nread(c);
   327600: 5802:                break;
        -: 5803:            }
        -: 5804:
        -: 5805:            /* Check if rbytes < 0, to prevent crash */
   327600: 5806:            if (c->rlbytes < 0) {
    #####: 5807:                if (settings.verbose) {
    #####: 5808:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 5809:                }
    #####: 5810:                conn_set_state(c, conn_closing);
    #####: 5811:                break;
        -: 5812:            }
        -: 5813:
   327600: 5814:            if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
        -: 5815:                /* first check if we have leftovers in the conn_read buffer */
   327600: 5816:                if (c->rbytes > 0) {
   327600: 5817:                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
   327600: 5818:                    if (c->ritem != c->rcurr) {
    27600: 5819:                        memmove(c->ritem, c->rcurr, tocopy);
        -: 5820:                    }
   327600: 5821:                    c->ritem += tocopy;
   327600: 5822:                    c->rlbytes -= tocopy;
   327600: 5823:                    c->rcurr += tocopy;
   327600: 5824:                    c->rbytes -= tocopy;
   327600: 5825:                    if (c->rlbytes == 0) {
        -: 5826:                        break;
        -: 5827:                    }
        -: 5828:                }
        -: 5829:
        -: 5830:                /*  now try reading from the socket */
    #####: 5831:                res = c->read(c, c->ritem, c->rlbytes);
    #####: 5832:                if (res > 0) {
    #####: 5833:                    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5834:                    c->thread->stats.bytes_read += res;
    #####: 5835:                    pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5836:                    if (c->rcurr == c->ritem) {
    #####: 5837:                        c->rcurr += res;
        -: 5838:                    }
    #####: 5839:                    c->ritem += res;
    #####: 5840:                    c->rlbytes -= res;
    #####: 5841:                    break;
        -: 5842:                }
        -: 5843:            } else {
    #####: 5844:                res = read_into_chunked_item(c);
    #####: 5845:                if (res > 0)
        -: 5846:                    break;
        -: 5847:            }
        -: 5848:
    #####: 5849:            if (res == 0) { /* end of stream */
    #####: 5850:                conn_set_state(c, conn_closing);
    #####: 5851:                break;
        -: 5852:            }
        -: 5853:
    #####: 5854:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5855:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5856:                    if (settings.verbose > 0)
    #####: 5857:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5858:                    conn_set_state(c, conn_closing);
    #####: 5859:                    break;
        -: 5860:                }
        -: 5861:                stop = true;
        -: 5862:                break;
        -: 5863:            }
        -: 5864:
        -: 5865:            /* Memory allocation failure */
    #####: 5866:            if (res == -2) {
    #####: 5867:                out_of_memory(c, "SERVER_ERROR Out of memory during read");
    #####: 5868:                c->sbytes = c->rlbytes;
    #####: 5869:                c->write_and_go = conn_swallow;
    #####: 5870:                break;
        -: 5871:            }
        -: 5872:            /* otherwise we have a real error, on which we close the connection */
    #####: 5873:            if (settings.verbose > 0) {
    #####: 5874:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 5875:                        "errno: %d %s \n"
        -: 5876:                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
    #####: 5877:                        errno, strerror(errno),
    #####: 5878:                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
        -: 5879:                        (int)c->rlbytes, (int)c->rsize);
        -: 5880:            }
    #####: 5881:            conn_set_state(c, conn_closing);
    #####: 5882:            break;
        -: 5883:
    #####: 5884:        case conn_swallow:
        -: 5885:            /* we are reading sbytes and throwing them away */
    #####: 5886:            if (c->sbytes <= 0) {
    #####: 5887:                conn_set_state(c, conn_new_cmd);
    #####: 5888:                break;
        -: 5889:            }
        -: 5890:
        -: 5891:            /* first check if we have leftovers in the conn_read buffer */
    #####: 5892:            if (c->rbytes > 0) {
    #####: 5893:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
    #####: 5894:                c->sbytes -= tocopy;
    #####: 5895:                c->rcurr += tocopy;
    #####: 5896:                c->rbytes -= tocopy;
    #####: 5897:                break;
        -: 5898:            }
        -: 5899:
        -: 5900:            /*  now try reading from the socket */
    #####: 5901:            res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
    #####: 5902:            if (res > 0) {
    #####: 5903:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5904:                c->thread->stats.bytes_read += res;
    #####: 5905:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5906:                c->sbytes -= res;
    #####: 5907:                break;
        -: 5908:            }
    #####: 5909:            if (res == 0) { /* end of stream */
    #####: 5910:                conn_set_state(c, conn_closing);
    #####: 5911:                break;
        -: 5912:            }
    #####: 5913:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5914:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5915:                    if (settings.verbose > 0)
    #####: 5916:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5917:                    conn_set_state(c, conn_closing);
    #####: 5918:                    break;
        -: 5919:                }
        -: 5920:                stop = true;
        -: 5921:                break;
        -: 5922:            }
        -: 5923:            /* otherwise we have a real error, on which we close the connection */
    #####: 5924:            if (settings.verbose > 0)
    #####: 5925:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 5926:            conn_set_state(c, conn_closing);
    #####: 5927:            break;
        -: 5928:
    #####: 5929:        case conn_write:
        -: 5930:            /*
        -: 5931:             * We want to write out a simple response. If we haven't already,
        -: 5932:             * assemble it into a msgbuf list (this will be a single-entry
        -: 5933:             * list for TCP or a two-entry list for UDP).
        -: 5934:             */
    #####: 5935:            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
    #####: 5936:                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
    #####: 5937:                    if (settings.verbose > 0)
    #####: 5938:                        fprintf(stderr, "Couldn't build response\n");
    #####: 5939:                    conn_set_state(c, conn_closing);
    #####: 5940:                    break;
        -: 5941:                }
        -: 5942:            }
        -: 5943:
        -: 5944:            /* fall through... */
        -: 5945:
        -: 5946:        case conn_mwrite:
        -: 5947:#ifdef EXTSTORE
        -: 5948:            /* have side IO's that must process before transmit() can run.
        -: 5949:             * remove the connection from the worker thread and dispatch the
        -: 5950:             * IO queue
        -: 5951:             */
        -: 5952:            if (c->io_wrapleft) {
        -: 5953:                assert(c->io_queued == false);
        -: 5954:                assert(c->io_wraplist != NULL);
        -: 5955:                // TODO: create proper state for this condition
        -: 5956:                conn_set_state(c, conn_watch);
        -: 5957:                event_del(&c->event);
        -: 5958:                c->io_queued = true;
        -: 5959:                extstore_submit(c->thread->storage, &c->io_wraplist->io);
        -: 5960:                stop = true;
        -: 5961:                break;
        -: 5962:            }
        -: 5963:#endif
  600000*: 5964:          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
    #####: 5965:            if (settings.verbose > 0)
    #####: 5966:              fprintf(stderr, "Failed to build UDP headers\n");
    #####: 5967:            conn_set_state(c, conn_closing);
    #####: 5968:            break;
        -: 5969:          }
   600000: 5970:            switch (transmit(c)) {
   300000: 5971:            case TRANSMIT_COMPLETE:
   300000: 5972:                if (c->state == conn_mwrite) {
   300000: 5973:                    conn_release_items(c);
        -: 5974:                    /* XXX:  I don't know why this wasn't the general case */
   300000: 5975:                    if(c->protocol == binary_prot) {
   300000: 5976:                        conn_set_state(c, c->write_and_go);
        -: 5977:                    } else {
    #####: 5978:                        conn_set_state(c, conn_new_cmd);
        -: 5979:                    }
    #####: 5980:                } else if (c->state == conn_write) {
    #####: 5981:                    if (c->write_and_free) {
    #####: 5982:                        free(c->write_and_free);
    #####: 5983:                        c->write_and_free = 0;
        -: 5984:                    }
    #####: 5985:                    conn_set_state(c, c->write_and_go);
        -: 5986:                } else {
    #####: 5987:                    if (settings.verbose > 0)
    #####: 5988:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 5989:                    conn_set_state(c, conn_closing);
        -: 5990:                }
        -: 5991:                break;
        -: 5992:
        -: 5993:            case TRANSMIT_INCOMPLETE:
        -: 5994:            case TRANSMIT_HARD_ERROR:
        -: 5995:                break;                   /* Continue in state machine. */
        -: 5996:
    #####: 5997:            case TRANSMIT_SOFT_ERROR:
    #####: 5998:                stop = true;
    #####: 5999:                break;
        -: 6000:            }
        -: 6001:            break;
        -: 6002:
      600: 6003:        case conn_closing:
      600: 6004:            if (IS_UDP(c->transport))
    #####: 6005:                conn_cleanup(c);
        -: 6006:            else
      600: 6007:                conn_close(c);
        -: 6008:            stop = true;
        -: 6009:            break;
        -: 6010:
    #####: 6011:        case conn_closed:
        -: 6012:            /* This only happens if dormando is an idiot. */
    #####: 6013:            abort();
        -: 6014:            break;
        -: 6015:
        -: 6016:        case conn_watch:
        -: 6017:            /* We handed off our connection to the logger thread. */
        -: 6018:            stop = true;
        -: 6019:            break;
        -: 6020:        case conn_max_state:
    #####: 6021:            assert(false);
        -: 6022:            break;
        -: 6023:        }
  327600*: 6024:    }
        -: 6025:
   301800: 6026:    return;
        -: 6027:}
------------------
drive_machine:
   100600: 5618:static void drive_machine(conn *c) {
   100600: 5619:    bool stop = false;
   100600: 5620:    int sfd;
   100600: 5621:    socklen_t addrlen;
   100600: 5622:    struct sockaddr_storage addr;
   100600: 5623:    int nreqs = settings.reqs_per_event;
   100600: 5624:    int res;
   100600: 5625:    const char *str;
        -: 5626:#ifdef HAVE_ACCEPT4
   100600: 5627:    static int  use_accept4 = 1;
        -: 5628:#else
        -: 5629:    static int  use_accept4 = 0;
        -: 5630:#endif
        -: 5631:
  100600*: 5632:    assert(c != NULL);
        -: 5633:
   920000: 5634:    while (!stop) {
        -: 5635:
   819400: 5636:        switch(c->state) {
      200: 5637:        case conn_listening:
      200: 5638:            addrlen = sizeof(addr);
        -: 5639:#ifdef HAVE_ACCEPT4
      200: 5640:            if (use_accept4) {
      200: 5641:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 5642:            } else {
    #####: 5643:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5644:            }
        -: 5645:#else
        -: 5646:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5647:#endif
      200: 5648:            if (sfd == -1) {
    #####: 5649:                if (use_accept4 && errno == ENOSYS) {
    #####: 5650:                    use_accept4 = 0;
    #####: 5651:                    continue;
        -: 5652:                }
    #####: 5653:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 5654:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5655:                    /* these are transient, so don't log anything */
        -: 5656:                    stop = true;
    #####: 5657:                } else if (errno == EMFILE) {
    #####: 5658:                    if (settings.verbose > 0)
    #####: 5659:                        fprintf(stderr, "Too many open connections\n");
    #####: 5660:                    accept_new_conns(false);
    #####: 5661:                    stop = true;
        -: 5662:                } else {
    #####: 5663:                    perror("accept()");
    #####: 5664:                    stop = true;
        -: 5665:                }
        -: 5666:                break;
        -: 5667:            }
      200: 5668:            if (!use_accept4) {
    #####: 5669:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 5670:                    perror("setting O_NONBLOCK");
    #####: 5671:                    close(sfd);
    #####: 5672:                    break;
        -: 5673:                }
        -: 5674:            }
        -: 5675:
      200: 5676:            if (settings.maxconns_fast &&
      200: 5677:                stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 5678:                str = "ERROR Too many open connections\r\n";
    #####: 5679:                res = write(sfd, str, strlen(str));
    #####: 5680:                close(sfd);
    #####: 5681:                STATS_LOCK();
    #####: 5682:                stats.rejected_conns++;
    #####: 5683:                STATS_UNLOCK();
        -: 5684:            } else {
      200: 5685:                void *ssl_v = NULL;
        -: 5686:#ifdef TLS
        -: 5687:                SSL *ssl = NULL;
        -: 5688:                if (c->ssl_enabled) {
        -: 5689:                    assert(IS_TCP(c->transport) && settings.ssl_enabled);
        -: 5690:
        -: 5691:                    if (settings.ssl_ctx == NULL) {
        -: 5692:                        if (settings.verbose) {
        -: 5693:                            fprintf(stderr, "SSL context is not initialized\n");
        -: 5694:                        }
        -: 5695:                        close(sfd);
        -: 5696:                        break;
        -: 5697:                    }
        -: 5698:                    SSL_LOCK();
        -: 5699:                    ssl = SSL_new(settings.ssl_ctx);
        -: 5700:                    SSL_UNLOCK();
        -: 5701:                    if (ssl == NULL) {
        -: 5702:                        if (settings.verbose) {
        -: 5703:                            fprintf(stderr, "Failed to created the SSL object\n");
        -: 5704:                        }
        -: 5705:                        close(sfd);
        -: 5706:                        break;
        -: 5707:                    }
        -: 5708:                    SSL_set_fd(ssl, sfd);
        -: 5709:                    int ret = SSL_accept(ssl);
        -: 5710:                    if (ret < 0) {
        -: 5711:                        int err = SSL_get_error(ssl, ret);
        -: 5712:                        if (err == SSL_ERROR_SYSCALL || err == SSL_ERROR_SSL) {
        -: 5713:                            if (settings.verbose) {
        -: 5714:                                fprintf(stderr, "SSL connection failed with error code : %d : %s\n", err, strerror(errno));
        -: 5715:                            }
        -: 5716:                            close(sfd);
        -: 5717:                            break;
        -: 5718:                        }
        -: 5719:                    }
        -: 5720:                }
        -: 5721:                ssl_v = (void*) ssl;
        -: 5722:#endif
        -: 5723:
      200: 5724:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 5725:                                     DATA_BUFFER_SIZE, c->transport, ssl_v);
        -: 5726:            }
        -: 5727:
        -: 5728:            stop = true;
        -: 5729:            break;
        -: 5730:
   100200: 5731:        case conn_waiting:
   100200: 5732:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5733:                if (settings.verbose > 0)
    #####: 5734:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5735:                conn_set_state(c, conn_closing);
    #####: 5736:                break;
        -: 5737:            }
        -: 5738:
   100200: 5739:            conn_set_state(c, conn_read);
   100200: 5740:            stop = true;
   100200: 5741:            break;
        -: 5742:
   100200: 5743:        case conn_read:
  100200*: 5744:            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
        -: 5745:
   100200: 5746:            switch (res) {
    #####: 5747:            case READ_NO_DATA_RECEIVED:
    #####: 5748:                conn_set_state(c, conn_waiting);
    #####: 5749:                break;
   100000: 5750:            case READ_DATA_RECEIVED:
   100000: 5751:                conn_set_state(c, conn_parse_cmd);
   100000: 5752:                break;
      200: 5753:            case READ_ERROR:
      200: 5754:                conn_set_state(c, conn_closing);
      200: 5755:                break;
        -: 5756:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 5757:                /* State already set by try_read_network */
        -: 5758:                break;
        -: 5759:            }
        -: 5760:            break;
        -: 5761:
   100000: 5762:        case conn_parse_cmd :
   100000: 5763:            if (c->try_read_command(c) == 0) {
        -: 5764:                /* wee need more data! */
    #####: 5765:                conn_set_state(c, conn_waiting);
        -: 5766:            }
        -: 5767:
        -: 5768:            break;
        -: 5769:
   100200: 5770:        case conn_new_cmd:
        -: 5771:            /* Only process nreqs at a time to avoid starving other
        -: 5772:               connections */
        -: 5773:
   100200: 5774:            --nreqs;
   100200: 5775:            if (nreqs >= 0) {
   100200: 5776:                reset_cmd_handler(c);
        -: 5777:            } else {
    #####: 5778:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5779:                c->thread->stats.conn_yields++;
    #####: 5780:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5781:                if (c->rbytes > 0) {
        -: 5782:                    /* We have already read in data into the input buffer,
        -: 5783:                       so libevent will most likely not signal read events
        -: 5784:                       on the socket (unless more data is available. As a
        -: 5785:                       hack we should just put in a request to write data,
        -: 5786:                       because that should be possible ;-)
        -: 5787:                    */
    #####: 5788:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5789:                        if (settings.verbose > 0)
    #####: 5790:                            fprintf(stderr, "Couldn't update event\n");
    #####: 5791:                        conn_set_state(c, conn_closing);
    #####: 5792:                        break;
        -: 5793:                    }
        -: 5794:                }
        -: 5795:                stop = true;
        -: 5796:            }
        -: 5797:            break;
        -: 5798:
   218400: 5799:        case conn_nread:
   218400: 5800:            if (c->rlbytes == 0) {
   109200: 5801:                complete_nread(c);
   109200: 5802:                break;
        -: 5803:            }
        -: 5804:
        -: 5805:            /* Check if rbytes < 0, to prevent crash */
   109200: 5806:            if (c->rlbytes < 0) {
    #####: 5807:                if (settings.verbose) {
    #####: 5808:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 5809:                }
    #####: 5810:                conn_set_state(c, conn_closing);
    #####: 5811:                break;
        -: 5812:            }
        -: 5813:
   109200: 5814:            if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
        -: 5815:                /* first check if we have leftovers in the conn_read buffer */
   109200: 5816:                if (c->rbytes > 0) {
   109200: 5817:                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
   109200: 5818:                    if (c->ritem != c->rcurr) {
     9200: 5819:                        memmove(c->ritem, c->rcurr, tocopy);
        -: 5820:                    }
   109200: 5821:                    c->ritem += tocopy;
   109200: 5822:                    c->rlbytes -= tocopy;
   109200: 5823:                    c->rcurr += tocopy;
   109200: 5824:                    c->rbytes -= tocopy;
   109200: 5825:                    if (c->rlbytes == 0) {
        -: 5826:                        break;
        -: 5827:                    }
        -: 5828:                }
        -: 5829:
        -: 5830:                /*  now try reading from the socket */
    #####: 5831:                res = c->read(c, c->ritem, c->rlbytes);
    #####: 5832:                if (res > 0) {
    #####: 5833:                    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5834:                    c->thread->stats.bytes_read += res;
    #####: 5835:                    pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5836:                    if (c->rcurr == c->ritem) {
    #####: 5837:                        c->rcurr += res;
        -: 5838:                    }
    #####: 5839:                    c->ritem += res;
    #####: 5840:                    c->rlbytes -= res;
    #####: 5841:                    break;
        -: 5842:                }
        -: 5843:            } else {
    #####: 5844:                res = read_into_chunked_item(c);
    #####: 5845:                if (res > 0)
        -: 5846:                    break;
        -: 5847:            }
        -: 5848:
    #####: 5849:            if (res == 0) { /* end of stream */
    #####: 5850:                conn_set_state(c, conn_closing);
    #####: 5851:                break;
        -: 5852:            }
        -: 5853:
    #####: 5854:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5855:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5856:                    if (settings.verbose > 0)
    #####: 5857:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5858:                    conn_set_state(c, conn_closing);
    #####: 5859:                    break;
        -: 5860:                }
        -: 5861:                stop = true;
        -: 5862:                break;
        -: 5863:            }
        -: 5864:
        -: 5865:            /* Memory allocation failure */
    #####: 5866:            if (res == -2) {
    #####: 5867:                out_of_memory(c, "SERVER_ERROR Out of memory during read");
    #####: 5868:                c->sbytes = c->rlbytes;
    #####: 5869:                c->write_and_go = conn_swallow;
    #####: 5870:                break;
        -: 5871:            }
        -: 5872:            /* otherwise we have a real error, on which we close the connection */
    #####: 5873:            if (settings.verbose > 0) {
    #####: 5874:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 5875:                        "errno: %d %s \n"
        -: 5876:                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
    #####: 5877:                        errno, strerror(errno),
    #####: 5878:                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
        -: 5879:                        (int)c->rlbytes, (int)c->rsize);
        -: 5880:            }
    #####: 5881:            conn_set_state(c, conn_closing);
    #####: 5882:            break;
        -: 5883:
    #####: 5884:        case conn_swallow:
        -: 5885:            /* we are reading sbytes and throwing them away */
    #####: 5886:            if (c->sbytes <= 0) {
    #####: 5887:                conn_set_state(c, conn_new_cmd);
    #####: 5888:                break;
        -: 5889:            }
        -: 5890:
        -: 5891:            /* first check if we have leftovers in the conn_read buffer */
    #####: 5892:            if (c->rbytes > 0) {
    #####: 5893:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
    #####: 5894:                c->sbytes -= tocopy;
    #####: 5895:                c->rcurr += tocopy;
    #####: 5896:                c->rbytes -= tocopy;
    #####: 5897:                break;
        -: 5898:            }
        -: 5899:
        -: 5900:            /*  now try reading from the socket */
    #####: 5901:            res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
    #####: 5902:            if (res > 0) {
    #####: 5903:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5904:                c->thread->stats.bytes_read += res;
    #####: 5905:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5906:                c->sbytes -= res;
    #####: 5907:                break;
        -: 5908:            }
    #####: 5909:            if (res == 0) { /* end of stream */
    #####: 5910:                conn_set_state(c, conn_closing);
    #####: 5911:                break;
        -: 5912:            }
    #####: 5913:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5914:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5915:                    if (settings.verbose > 0)
    #####: 5916:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5917:                    conn_set_state(c, conn_closing);
    #####: 5918:                    break;
        -: 5919:                }
        -: 5920:                stop = true;
        -: 5921:                break;
        -: 5922:            }
        -: 5923:            /* otherwise we have a real error, on which we close the connection */
    #####: 5924:            if (settings.verbose > 0)
    #####: 5925:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 5926:            conn_set_state(c, conn_closing);
    #####: 5927:            break;
        -: 5928:
    #####: 5929:        case conn_write:
        -: 5930:            /*
        -: 5931:             * We want to write out a simple response. If we haven't already,
        -: 5932:             * assemble it into a msgbuf list (this will be a single-entry
        -: 5933:             * list for TCP or a two-entry list for UDP).
        -: 5934:             */
    #####: 5935:            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
    #####: 5936:                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
    #####: 5937:                    if (settings.verbose > 0)
    #####: 5938:                        fprintf(stderr, "Couldn't build response\n");
    #####: 5939:                    conn_set_state(c, conn_closing);
    #####: 5940:                    break;
        -: 5941:                }
        -: 5942:            }
        -: 5943:
        -: 5944:            /* fall through... */
        -: 5945:
        -: 5946:        case conn_mwrite:
        -: 5947:#ifdef EXTSTORE
        -: 5948:            /* have side IO's that must process before transmit() can run.
        -: 5949:             * remove the connection from the worker thread and dispatch the
        -: 5950:             * IO queue
        -: 5951:             */
        -: 5952:            if (c->io_wrapleft) {
        -: 5953:                assert(c->io_queued == false);
        -: 5954:                assert(c->io_wraplist != NULL);
        -: 5955:                // TODO: create proper state for this condition
        -: 5956:                conn_set_state(c, conn_watch);
        -: 5957:                event_del(&c->event);
        -: 5958:                c->io_queued = true;
        -: 5959:                extstore_submit(c->thread->storage, &c->io_wraplist->io);
        -: 5960:                stop = true;
        -: 5961:                break;
        -: 5962:            }
        -: 5963:#endif
  200000*: 5964:          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
    #####: 5965:            if (settings.verbose > 0)
    #####: 5966:              fprintf(stderr, "Failed to build UDP headers\n");
    #####: 5967:            conn_set_state(c, conn_closing);
    #####: 5968:            break;
        -: 5969:          }
   200000: 5970:            switch (transmit(c)) {
   100000: 5971:            case TRANSMIT_COMPLETE:
   100000: 5972:                if (c->state == conn_mwrite) {
   100000: 5973:                    conn_release_items(c);
        -: 5974:                    /* XXX:  I don't know why this wasn't the general case */
   100000: 5975:                    if(c->protocol == binary_prot) {
   100000: 5976:                        conn_set_state(c, c->write_and_go);
        -: 5977:                    } else {
    #####: 5978:                        conn_set_state(c, conn_new_cmd);
        -: 5979:                    }
    #####: 5980:                } else if (c->state == conn_write) {
    #####: 5981:                    if (c->write_and_free) {
    #####: 5982:                        free(c->write_and_free);
    #####: 5983:                        c->write_and_free = 0;
        -: 5984:                    }
    #####: 5985:                    conn_set_state(c, c->write_and_go);
        -: 5986:                } else {
    #####: 5987:                    if (settings.verbose > 0)
    #####: 5988:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 5989:                    conn_set_state(c, conn_closing);
        -: 5990:                }
        -: 5991:                break;
        -: 5992:
        -: 5993:            case TRANSMIT_INCOMPLETE:
        -: 5994:            case TRANSMIT_HARD_ERROR:
        -: 5995:                break;                   /* Continue in state machine. */
        -: 5996:
    #####: 5997:            case TRANSMIT_SOFT_ERROR:
    #####: 5998:                stop = true;
    #####: 5999:                break;
        -: 6000:            }
        -: 6001:            break;
        -: 6002:
      200: 6003:        case conn_closing:
      200: 6004:            if (IS_UDP(c->transport))
    #####: 6005:                conn_cleanup(c);
        -: 6006:            else
      200: 6007:                conn_close(c);
        -: 6008:            stop = true;
        -: 6009:            break;
        -: 6010:
    #####: 6011:        case conn_closed:
        -: 6012:            /* This only happens if dormando is an idiot. */
    #####: 6013:            abort();
        -: 6014:            break;
        -: 6015:
        -: 6016:        case conn_watch:
        -: 6017:            /* We handed off our connection to the logger thread. */
        -: 6018:            stop = true;
        -: 6019:            break;
        -: 6020:        case conn_max_state:
    #####: 6021:            assert(false);
        -: 6022:            break;
        -: 6023:        }
  109200*: 6024:    }
        -: 6025:
   100600: 6026:    return;
        -: 6027:}
------------------
drive_machine:
   100600: 5618:static void drive_machine(conn *c) {
   100600: 5619:    bool stop = false;
   100600: 5620:    int sfd;
   100600: 5621:    socklen_t addrlen;
   100600: 5622:    struct sockaddr_storage addr;
   100600: 5623:    int nreqs = settings.reqs_per_event;
   100600: 5624:    int res;
   100600: 5625:    const char *str;
        -: 5626:#ifdef HAVE_ACCEPT4
   100600: 5627:    static int  use_accept4 = 1;
        -: 5628:#else
        -: 5629:    static int  use_accept4 = 0;
        -: 5630:#endif
        -: 5631:
  100600*: 5632:    assert(c != NULL);
        -: 5633:
   920000: 5634:    while (!stop) {
        -: 5635:
   819400: 5636:        switch(c->state) {
      200: 5637:        case conn_listening:
      200: 5638:            addrlen = sizeof(addr);
        -: 5639:#ifdef HAVE_ACCEPT4
      200: 5640:            if (use_accept4) {
      200: 5641:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 5642:            } else {
    #####: 5643:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5644:            }
        -: 5645:#else
        -: 5646:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5647:#endif
      200: 5648:            if (sfd == -1) {
    #####: 5649:                if (use_accept4 && errno == ENOSYS) {
    #####: 5650:                    use_accept4 = 0;
    #####: 5651:                    continue;
        -: 5652:                }
    #####: 5653:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 5654:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5655:                    /* these are transient, so don't log anything */
        -: 5656:                    stop = true;
    #####: 5657:                } else if (errno == EMFILE) {
    #####: 5658:                    if (settings.verbose > 0)
    #####: 5659:                        fprintf(stderr, "Too many open connections\n");
    #####: 5660:                    accept_new_conns(false);
    #####: 5661:                    stop = true;
        -: 5662:                } else {
    #####: 5663:                    perror("accept()");
    #####: 5664:                    stop = true;
        -: 5665:                }
        -: 5666:                break;
        -: 5667:            }
      200: 5668:            if (!use_accept4) {
    #####: 5669:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 5670:                    perror("setting O_NONBLOCK");
    #####: 5671:                    close(sfd);
    #####: 5672:                    break;
        -: 5673:                }
        -: 5674:            }
        -: 5675:
      200: 5676:            if (settings.maxconns_fast &&
      200: 5677:                stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 5678:                str = "ERROR Too many open connections\r\n";
    #####: 5679:                res = write(sfd, str, strlen(str));
    #####: 5680:                close(sfd);
    #####: 5681:                STATS_LOCK();
    #####: 5682:                stats.rejected_conns++;
    #####: 5683:                STATS_UNLOCK();
        -: 5684:            } else {
      200: 5685:                void *ssl_v = NULL;
        -: 5686:#ifdef TLS
        -: 5687:                SSL *ssl = NULL;
        -: 5688:                if (c->ssl_enabled) {
        -: 5689:                    assert(IS_TCP(c->transport) && settings.ssl_enabled);
        -: 5690:
        -: 5691:                    if (settings.ssl_ctx == NULL) {
        -: 5692:                        if (settings.verbose) {
        -: 5693:                            fprintf(stderr, "SSL context is not initialized\n");
        -: 5694:                        }
        -: 5695:                        close(sfd);
        -: 5696:                        break;
        -: 5697:                    }
        -: 5698:                    SSL_LOCK();
        -: 5699:                    ssl = SSL_new(settings.ssl_ctx);
        -: 5700:                    SSL_UNLOCK();
        -: 5701:                    if (ssl == NULL) {
        -: 5702:                        if (settings.verbose) {
        -: 5703:                            fprintf(stderr, "Failed to created the SSL object\n");
        -: 5704:                        }
        -: 5705:                        close(sfd);
        -: 5706:                        break;
        -: 5707:                    }
        -: 5708:                    SSL_set_fd(ssl, sfd);
        -: 5709:                    int ret = SSL_accept(ssl);
        -: 5710:                    if (ret < 0) {
        -: 5711:                        int err = SSL_get_error(ssl, ret);
        -: 5712:                        if (err == SSL_ERROR_SYSCALL || err == SSL_ERROR_SSL) {
        -: 5713:                            if (settings.verbose) {
        -: 5714:                                fprintf(stderr, "SSL connection failed with error code : %d : %s\n", err, strerror(errno));
        -: 5715:                            }
        -: 5716:                            close(sfd);
        -: 5717:                            break;
        -: 5718:                        }
        -: 5719:                    }
        -: 5720:                }
        -: 5721:                ssl_v = (void*) ssl;
        -: 5722:#endif
        -: 5723:
      200: 5724:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 5725:                                     DATA_BUFFER_SIZE, c->transport, ssl_v);
        -: 5726:            }
        -: 5727:
        -: 5728:            stop = true;
        -: 5729:            break;
        -: 5730:
   100200: 5731:        case conn_waiting:
   100200: 5732:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5733:                if (settings.verbose > 0)
    #####: 5734:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5735:                conn_set_state(c, conn_closing);
    #####: 5736:                break;
        -: 5737:            }
        -: 5738:
   100200: 5739:            conn_set_state(c, conn_read);
   100200: 5740:            stop = true;
   100200: 5741:            break;
        -: 5742:
   100200: 5743:        case conn_read:
  100200*: 5744:            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
        -: 5745:
   100200: 5746:            switch (res) {
    #####: 5747:            case READ_NO_DATA_RECEIVED:
    #####: 5748:                conn_set_state(c, conn_waiting);
    #####: 5749:                break;
   100000: 5750:            case READ_DATA_RECEIVED:
   100000: 5751:                conn_set_state(c, conn_parse_cmd);
   100000: 5752:                break;
      200: 5753:            case READ_ERROR:
      200: 5754:                conn_set_state(c, conn_closing);
      200: 5755:                break;
        -: 5756:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 5757:                /* State already set by try_read_network */
        -: 5758:                break;
        -: 5759:            }
        -: 5760:            break;
        -: 5761:
   100000: 5762:        case conn_parse_cmd :
   100000: 5763:            if (c->try_read_command(c) == 0) {
        -: 5764:                /* wee need more data! */
    #####: 5765:                conn_set_state(c, conn_waiting);
        -: 5766:            }
        -: 5767:
        -: 5768:            break;
        -: 5769:
   100200: 5770:        case conn_new_cmd:
        -: 5771:            /* Only process nreqs at a time to avoid starving other
        -: 5772:               connections */
        -: 5773:
   100200: 5774:            --nreqs;
   100200: 5775:            if (nreqs >= 0) {
   100200: 5776:                reset_cmd_handler(c);
        -: 5777:            } else {
    #####: 5778:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5779:                c->thread->stats.conn_yields++;
    #####: 5780:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5781:                if (c->rbytes > 0) {
        -: 5782:                    /* We have already read in data into the input buffer,
        -: 5783:                       so libevent will most likely not signal read events
        -: 5784:                       on the socket (unless more data is available. As a
        -: 5785:                       hack we should just put in a request to write data,
        -: 5786:                       because that should be possible ;-)
        -: 5787:                    */
    #####: 5788:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5789:                        if (settings.verbose > 0)
    #####: 5790:                            fprintf(stderr, "Couldn't update event\n");
    #####: 5791:                        conn_set_state(c, conn_closing);
    #####: 5792:                        break;
        -: 5793:                    }
        -: 5794:                }
        -: 5795:                stop = true;
        -: 5796:            }
        -: 5797:            break;
        -: 5798:
   218400: 5799:        case conn_nread:
   218400: 5800:            if (c->rlbytes == 0) {
   109200: 5801:                complete_nread(c);
   109200: 5802:                break;
        -: 5803:            }
        -: 5804:
        -: 5805:            /* Check if rbytes < 0, to prevent crash */
   109200: 5806:            if (c->rlbytes < 0) {
    #####: 5807:                if (settings.verbose) {
    #####: 5808:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 5809:                }
    #####: 5810:                conn_set_state(c, conn_closing);
    #####: 5811:                break;
        -: 5812:            }
        -: 5813:
   109200: 5814:            if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
        -: 5815:                /* first check if we have leftovers in the conn_read buffer */
   109200: 5816:                if (c->rbytes > 0) {
   109200: 5817:                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
   109200: 5818:                    if (c->ritem != c->rcurr) {
     9200: 5819:                        memmove(c->ritem, c->rcurr, tocopy);
        -: 5820:                    }
   109200: 5821:                    c->ritem += tocopy;
   109200: 5822:                    c->rlbytes -= tocopy;
   109200: 5823:                    c->rcurr += tocopy;
   109200: 5824:                    c->rbytes -= tocopy;
   109200: 5825:                    if (c->rlbytes == 0) {
        -: 5826:                        break;
        -: 5827:                    }
        -: 5828:                }
        -: 5829:
        -: 5830:                /*  now try reading from the socket */
    #####: 5831:                res = c->read(c, c->ritem, c->rlbytes);
    #####: 5832:                if (res > 0) {
    #####: 5833:                    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5834:                    c->thread->stats.bytes_read += res;
    #####: 5835:                    pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5836:                    if (c->rcurr == c->ritem) {
    #####: 5837:                        c->rcurr += res;
        -: 5838:                    }
    #####: 5839:                    c->ritem += res;
    #####: 5840:                    c->rlbytes -= res;
    #####: 5841:                    break;
        -: 5842:                }
        -: 5843:            } else {
    #####: 5844:                res = read_into_chunked_item(c);
    #####: 5845:                if (res > 0)
        -: 5846:                    break;
        -: 5847:            }
        -: 5848:
    #####: 5849:            if (res == 0) { /* end of stream */
    #####: 5850:                conn_set_state(c, conn_closing);
    #####: 5851:                break;
        -: 5852:            }
        -: 5853:
    #####: 5854:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5855:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5856:                    if (settings.verbose > 0)
    #####: 5857:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5858:                    conn_set_state(c, conn_closing);
    #####: 5859:                    break;
        -: 5860:                }
        -: 5861:                stop = true;
        -: 5862:                break;
        -: 5863:            }
        -: 5864:
        -: 5865:            /* Memory allocation failure */
    #####: 5866:            if (res == -2) {
    #####: 5867:                out_of_memory(c, "SERVER_ERROR Out of memory during read");
    #####: 5868:                c->sbytes = c->rlbytes;
    #####: 5869:                c->write_and_go = conn_swallow;
    #####: 5870:                break;
        -: 5871:            }
        -: 5872:            /* otherwise we have a real error, on which we close the connection */
    #####: 5873:            if (settings.verbose > 0) {
    #####: 5874:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 5875:                        "errno: %d %s \n"
        -: 5876:                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
    #####: 5877:                        errno, strerror(errno),
    #####: 5878:                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
        -: 5879:                        (int)c->rlbytes, (int)c->rsize);
        -: 5880:            }
    #####: 5881:            conn_set_state(c, conn_closing);
    #####: 5882:            break;
        -: 5883:
    #####: 5884:        case conn_swallow:
        -: 5885:            /* we are reading sbytes and throwing them away */
    #####: 5886:            if (c->sbytes <= 0) {
    #####: 5887:                conn_set_state(c, conn_new_cmd);
    #####: 5888:                break;
        -: 5889:            }
        -: 5890:
        -: 5891:            /* first check if we have leftovers in the conn_read buffer */
    #####: 5892:            if (c->rbytes > 0) {
    #####: 5893:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
    #####: 5894:                c->sbytes -= tocopy;
    #####: 5895:                c->rcurr += tocopy;
    #####: 5896:                c->rbytes -= tocopy;
    #####: 5897:                break;
        -: 5898:            }
        -: 5899:
        -: 5900:            /*  now try reading from the socket */
    #####: 5901:            res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
    #####: 5902:            if (res > 0) {
    #####: 5903:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5904:                c->thread->stats.bytes_read += res;
    #####: 5905:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5906:                c->sbytes -= res;
    #####: 5907:                break;
        -: 5908:            }
    #####: 5909:            if (res == 0) { /* end of stream */
    #####: 5910:                conn_set_state(c, conn_closing);
    #####: 5911:                break;
        -: 5912:            }
    #####: 5913:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5914:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5915:                    if (settings.verbose > 0)
    #####: 5916:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5917:                    conn_set_state(c, conn_closing);
    #####: 5918:                    break;
        -: 5919:                }
        -: 5920:                stop = true;
        -: 5921:                break;
        -: 5922:            }
        -: 5923:            /* otherwise we have a real error, on which we close the connection */
    #####: 5924:            if (settings.verbose > 0)
    #####: 5925:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 5926:            conn_set_state(c, conn_closing);
    #####: 5927:            break;
        -: 5928:
    #####: 5929:        case conn_write:
        -: 5930:            /*
        -: 5931:             * We want to write out a simple response. If we haven't already,
        -: 5932:             * assemble it into a msgbuf list (this will be a single-entry
        -: 5933:             * list for TCP or a two-entry list for UDP).
        -: 5934:             */
    #####: 5935:            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
    #####: 5936:                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
    #####: 5937:                    if (settings.verbose > 0)
    #####: 5938:                        fprintf(stderr, "Couldn't build response\n");
    #####: 5939:                    conn_set_state(c, conn_closing);
    #####: 5940:                    break;
        -: 5941:                }
        -: 5942:            }
        -: 5943:
        -: 5944:            /* fall through... */
        -: 5945:
        -: 5946:        case conn_mwrite:
        -: 5947:#ifdef EXTSTORE
        -: 5948:            /* have side IO's that must process before transmit() can run.
        -: 5949:             * remove the connection from the worker thread and dispatch the
        -: 5950:             * IO queue
        -: 5951:             */
        -: 5952:            if (c->io_wrapleft) {
        -: 5953:                assert(c->io_queued == false);
        -: 5954:                assert(c->io_wraplist != NULL);
        -: 5955:                // TODO: create proper state for this condition
        -: 5956:                conn_set_state(c, conn_watch);
        -: 5957:                event_del(&c->event);
        -: 5958:                c->io_queued = true;
        -: 5959:                extstore_submit(c->thread->storage, &c->io_wraplist->io);
        -: 5960:                stop = true;
        -: 5961:                break;
        -: 5962:            }
        -: 5963:#endif
  200000*: 5964:          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
    #####: 5965:            if (settings.verbose > 0)
    #####: 5966:              fprintf(stderr, "Failed to build UDP headers\n");
    #####: 5967:            conn_set_state(c, conn_closing);
    #####: 5968:            break;
        -: 5969:          }
   200000: 5970:            switch (transmit(c)) {
   100000: 5971:            case TRANSMIT_COMPLETE:
   100000: 5972:                if (c->state == conn_mwrite) {
   100000: 5973:                    conn_release_items(c);
        -: 5974:                    /* XXX:  I don't know why this wasn't the general case */
   100000: 5975:                    if(c->protocol == binary_prot) {
   100000: 5976:                        conn_set_state(c, c->write_and_go);
        -: 5977:                    } else {
    #####: 5978:                        conn_set_state(c, conn_new_cmd);
        -: 5979:                    }
    #####: 5980:                } else if (c->state == conn_write) {
    #####: 5981:                    if (c->write_and_free) {
    #####: 5982:                        free(c->write_and_free);
    #####: 5983:                        c->write_and_free = 0;
        -: 5984:                    }
    #####: 5985:                    conn_set_state(c, c->write_and_go);
        -: 5986:                } else {
    #####: 5987:                    if (settings.verbose > 0)
    #####: 5988:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 5989:                    conn_set_state(c, conn_closing);
        -: 5990:                }
        -: 5991:                break;
        -: 5992:
        -: 5993:            case TRANSMIT_INCOMPLETE:
        -: 5994:            case TRANSMIT_HARD_ERROR:
        -: 5995:                break;                   /* Continue in state machine. */
        -: 5996:
    #####: 5997:            case TRANSMIT_SOFT_ERROR:
    #####: 5998:                stop = true;
    #####: 5999:                break;
        -: 6000:            }
        -: 6001:            break;
        -: 6002:
      200: 6003:        case conn_closing:
      200: 6004:            if (IS_UDP(c->transport))
    #####: 6005:                conn_cleanup(c);
        -: 6006:            else
      200: 6007:                conn_close(c);
        -: 6008:            stop = true;
        -: 6009:            break;
        -: 6010:
    #####: 6011:        case conn_closed:
        -: 6012:            /* This only happens if dormando is an idiot. */
    #####: 6013:            abort();
        -: 6014:            break;
        -: 6015:
        -: 6016:        case conn_watch:
        -: 6017:            /* We handed off our connection to the logger thread. */
        -: 6018:            stop = true;
        -: 6019:            break;
        -: 6020:        case conn_max_state:
    #####: 6021:            assert(false);
        -: 6022:            break;
        -: 6023:        }
  109200*: 6024:    }
        -: 6025:
   100600: 6026:    return;
        -: 6027:}
------------------
drive_machine:
   100600: 5618:static void drive_machine(conn *c) {
   100600: 5619:    bool stop = false;
   100600: 5620:    int sfd;
   100600: 5621:    socklen_t addrlen;
   100600: 5622:    struct sockaddr_storage addr;
   100600: 5623:    int nreqs = settings.reqs_per_event;
   100600: 5624:    int res;
   100600: 5625:    const char *str;
        -: 5626:#ifdef HAVE_ACCEPT4
   100600: 5627:    static int  use_accept4 = 1;
        -: 5628:#else
        -: 5629:    static int  use_accept4 = 0;
        -: 5630:#endif
        -: 5631:
  100600*: 5632:    assert(c != NULL);
        -: 5633:
   920000: 5634:    while (!stop) {
        -: 5635:
   819400: 5636:        switch(c->state) {
      200: 5637:        case conn_listening:
      200: 5638:            addrlen = sizeof(addr);
        -: 5639:#ifdef HAVE_ACCEPT4
      200: 5640:            if (use_accept4) {
      200: 5641:                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
        -: 5642:            } else {
    #####: 5643:                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5644:            }
        -: 5645:#else
        -: 5646:            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
        -: 5647:#endif
      200: 5648:            if (sfd == -1) {
    #####: 5649:                if (use_accept4 && errno == ENOSYS) {
    #####: 5650:                    use_accept4 = 0;
    #####: 5651:                    continue;
        -: 5652:                }
    #####: 5653:                perror(use_accept4 ? "accept4()" : "accept()");
    #####: 5654:                if (errno == EAGAIN || errno == EWOULDBLOCK) {
        -: 5655:                    /* these are transient, so don't log anything */
        -: 5656:                    stop = true;
    #####: 5657:                } else if (errno == EMFILE) {
    #####: 5658:                    if (settings.verbose > 0)
    #####: 5659:                        fprintf(stderr, "Too many open connections\n");
    #####: 5660:                    accept_new_conns(false);
    #####: 5661:                    stop = true;
        -: 5662:                } else {
    #####: 5663:                    perror("accept()");
    #####: 5664:                    stop = true;
        -: 5665:                }
        -: 5666:                break;
        -: 5667:            }
      200: 5668:            if (!use_accept4) {
    #####: 5669:                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
    #####: 5670:                    perror("setting O_NONBLOCK");
    #####: 5671:                    close(sfd);
    #####: 5672:                    break;
        -: 5673:                }
        -: 5674:            }
        -: 5675:
      200: 5676:            if (settings.maxconns_fast &&
      200: 5677:                stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 5678:                str = "ERROR Too many open connections\r\n";
    #####: 5679:                res = write(sfd, str, strlen(str));
    #####: 5680:                close(sfd);
    #####: 5681:                STATS_LOCK();
    #####: 5682:                stats.rejected_conns++;
    #####: 5683:                STATS_UNLOCK();
        -: 5684:            } else {
      200: 5685:                void *ssl_v = NULL;
        -: 5686:#ifdef TLS
        -: 5687:                SSL *ssl = NULL;
        -: 5688:                if (c->ssl_enabled) {
        -: 5689:                    assert(IS_TCP(c->transport) && settings.ssl_enabled);
        -: 5690:
        -: 5691:                    if (settings.ssl_ctx == NULL) {
        -: 5692:                        if (settings.verbose) {
        -: 5693:                            fprintf(stderr, "SSL context is not initialized\n");
        -: 5694:                        }
        -: 5695:                        close(sfd);
        -: 5696:                        break;
        -: 5697:                    }
        -: 5698:                    SSL_LOCK();
        -: 5699:                    ssl = SSL_new(settings.ssl_ctx);
        -: 5700:                    SSL_UNLOCK();
        -: 5701:                    if (ssl == NULL) {
        -: 5702:                        if (settings.verbose) {
        -: 5703:                            fprintf(stderr, "Failed to created the SSL object\n");
        -: 5704:                        }
        -: 5705:                        close(sfd);
        -: 5706:                        break;
        -: 5707:                    }
        -: 5708:                    SSL_set_fd(ssl, sfd);
        -: 5709:                    int ret = SSL_accept(ssl);
        -: 5710:                    if (ret < 0) {
        -: 5711:                        int err = SSL_get_error(ssl, ret);
        -: 5712:                        if (err == SSL_ERROR_SYSCALL || err == SSL_ERROR_SSL) {
        -: 5713:                            if (settings.verbose) {
        -: 5714:                                fprintf(stderr, "SSL connection failed with error code : %d : %s\n", err, strerror(errno));
        -: 5715:                            }
        -: 5716:                            close(sfd);
        -: 5717:                            break;
        -: 5718:                        }
        -: 5719:                    }
        -: 5720:                }
        -: 5721:                ssl_v = (void*) ssl;
        -: 5722:#endif
        -: 5723:
      200: 5724:                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,
        -: 5725:                                     DATA_BUFFER_SIZE, c->transport, ssl_v);
        -: 5726:            }
        -: 5727:
        -: 5728:            stop = true;
        -: 5729:            break;
        -: 5730:
   100200: 5731:        case conn_waiting:
   100200: 5732:            if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5733:                if (settings.verbose > 0)
    #####: 5734:                    fprintf(stderr, "Couldn't update event\n");
    #####: 5735:                conn_set_state(c, conn_closing);
    #####: 5736:                break;
        -: 5737:            }
        -: 5738:
   100200: 5739:            conn_set_state(c, conn_read);
   100200: 5740:            stop = true;
   100200: 5741:            break;
        -: 5742:
   100200: 5743:        case conn_read:
  100200*: 5744:            res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
        -: 5745:
   100200: 5746:            switch (res) {
    #####: 5747:            case READ_NO_DATA_RECEIVED:
    #####: 5748:                conn_set_state(c, conn_waiting);
    #####: 5749:                break;
   100000: 5750:            case READ_DATA_RECEIVED:
   100000: 5751:                conn_set_state(c, conn_parse_cmd);
   100000: 5752:                break;
      200: 5753:            case READ_ERROR:
      200: 5754:                conn_set_state(c, conn_closing);
      200: 5755:                break;
        -: 5756:            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
        -: 5757:                /* State already set by try_read_network */
        -: 5758:                break;
        -: 5759:            }
        -: 5760:            break;
        -: 5761:
   100000: 5762:        case conn_parse_cmd :
   100000: 5763:            if (c->try_read_command(c) == 0) {
        -: 5764:                /* wee need more data! */
    #####: 5765:                conn_set_state(c, conn_waiting);
        -: 5766:            }
        -: 5767:
        -: 5768:            break;
        -: 5769:
   100200: 5770:        case conn_new_cmd:
        -: 5771:            /* Only process nreqs at a time to avoid starving other
        -: 5772:               connections */
        -: 5773:
   100200: 5774:            --nreqs;
   100200: 5775:            if (nreqs >= 0) {
   100200: 5776:                reset_cmd_handler(c);
        -: 5777:            } else {
    #####: 5778:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5779:                c->thread->stats.conn_yields++;
    #####: 5780:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5781:                if (c->rbytes > 0) {
        -: 5782:                    /* We have already read in data into the input buffer,
        -: 5783:                       so libevent will most likely not signal read events
        -: 5784:                       on the socket (unless more data is available. As a
        -: 5785:                       hack we should just put in a request to write data,
        -: 5786:                       because that should be possible ;-)
        -: 5787:                    */
    #####: 5788:                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
    #####: 5789:                        if (settings.verbose > 0)
    #####: 5790:                            fprintf(stderr, "Couldn't update event\n");
    #####: 5791:                        conn_set_state(c, conn_closing);
    #####: 5792:                        break;
        -: 5793:                    }
        -: 5794:                }
        -: 5795:                stop = true;
        -: 5796:            }
        -: 5797:            break;
        -: 5798:
   218400: 5799:        case conn_nread:
   218400: 5800:            if (c->rlbytes == 0) {
   109200: 5801:                complete_nread(c);
   109200: 5802:                break;
        -: 5803:            }
        -: 5804:
        -: 5805:            /* Check if rbytes < 0, to prevent crash */
   109200: 5806:            if (c->rlbytes < 0) {
    #####: 5807:                if (settings.verbose) {
    #####: 5808:                    fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
        -: 5809:                }
    #####: 5810:                conn_set_state(c, conn_closing);
    #####: 5811:                break;
        -: 5812:            }
        -: 5813:
   109200: 5814:            if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
        -: 5815:                /* first check if we have leftovers in the conn_read buffer */
   109200: 5816:                if (c->rbytes > 0) {
   109200: 5817:                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
   109200: 5818:                    if (c->ritem != c->rcurr) {
     9200: 5819:                        memmove(c->ritem, c->rcurr, tocopy);
        -: 5820:                    }
   109200: 5821:                    c->ritem += tocopy;
   109200: 5822:                    c->rlbytes -= tocopy;
   109200: 5823:                    c->rcurr += tocopy;
   109200: 5824:                    c->rbytes -= tocopy;
   109200: 5825:                    if (c->rlbytes == 0) {
        -: 5826:                        break;
        -: 5827:                    }
        -: 5828:                }
        -: 5829:
        -: 5830:                /*  now try reading from the socket */
    #####: 5831:                res = c->read(c, c->ritem, c->rlbytes);
    #####: 5832:                if (res > 0) {
    #####: 5833:                    pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5834:                    c->thread->stats.bytes_read += res;
    #####: 5835:                    pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5836:                    if (c->rcurr == c->ritem) {
    #####: 5837:                        c->rcurr += res;
        -: 5838:                    }
    #####: 5839:                    c->ritem += res;
    #####: 5840:                    c->rlbytes -= res;
    #####: 5841:                    break;
        -: 5842:                }
        -: 5843:            } else {
    #####: 5844:                res = read_into_chunked_item(c);
    #####: 5845:                if (res > 0)
        -: 5846:                    break;
        -: 5847:            }
        -: 5848:
    #####: 5849:            if (res == 0) { /* end of stream */
    #####: 5850:                conn_set_state(c, conn_closing);
    #####: 5851:                break;
        -: 5852:            }
        -: 5853:
    #####: 5854:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5855:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5856:                    if (settings.verbose > 0)
    #####: 5857:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5858:                    conn_set_state(c, conn_closing);
    #####: 5859:                    break;
        -: 5860:                }
        -: 5861:                stop = true;
        -: 5862:                break;
        -: 5863:            }
        -: 5864:
        -: 5865:            /* Memory allocation failure */
    #####: 5866:            if (res == -2) {
    #####: 5867:                out_of_memory(c, "SERVER_ERROR Out of memory during read");
    #####: 5868:                c->sbytes = c->rlbytes;
    #####: 5869:                c->write_and_go = conn_swallow;
    #####: 5870:                break;
        -: 5871:            }
        -: 5872:            /* otherwise we have a real error, on which we close the connection */
    #####: 5873:            if (settings.verbose > 0) {
    #####: 5874:                fprintf(stderr, "Failed to read, and not due to blocking:\n"
        -: 5875:                        "errno: %d %s \n"
        -: 5876:                        "rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
    #####: 5877:                        errno, strerror(errno),
    #####: 5878:                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,
        -: 5879:                        (int)c->rlbytes, (int)c->rsize);
        -: 5880:            }
    #####: 5881:            conn_set_state(c, conn_closing);
    #####: 5882:            break;
        -: 5883:
    #####: 5884:        case conn_swallow:
        -: 5885:            /* we are reading sbytes and throwing them away */
    #####: 5886:            if (c->sbytes <= 0) {
    #####: 5887:                conn_set_state(c, conn_new_cmd);
    #####: 5888:                break;
        -: 5889:            }
        -: 5890:
        -: 5891:            /* first check if we have leftovers in the conn_read buffer */
    #####: 5892:            if (c->rbytes > 0) {
    #####: 5893:                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
    #####: 5894:                c->sbytes -= tocopy;
    #####: 5895:                c->rcurr += tocopy;
    #####: 5896:                c->rbytes -= tocopy;
    #####: 5897:                break;
        -: 5898:            }
        -: 5899:
        -: 5900:            /*  now try reading from the socket */
    #####: 5901:            res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
    #####: 5902:            if (res > 0) {
    #####: 5903:                pthread_mutex_lock(&c->thread->stats.mutex);
    #####: 5904:                c->thread->stats.bytes_read += res;
    #####: 5905:                pthread_mutex_unlock(&c->thread->stats.mutex);
    #####: 5906:                c->sbytes -= res;
    #####: 5907:                break;
        -: 5908:            }
    #####: 5909:            if (res == 0) { /* end of stream */
    #####: 5910:                conn_set_state(c, conn_closing);
    #####: 5911:                break;
        -: 5912:            }
    #####: 5913:            if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    #####: 5914:                if (!update_event(c, EV_READ | EV_PERSIST)) {
    #####: 5915:                    if (settings.verbose > 0)
    #####: 5916:                        fprintf(stderr, "Couldn't update event\n");
    #####: 5917:                    conn_set_state(c, conn_closing);
    #####: 5918:                    break;
        -: 5919:                }
        -: 5920:                stop = true;
        -: 5921:                break;
        -: 5922:            }
        -: 5923:            /* otherwise we have a real error, on which we close the connection */
    #####: 5924:            if (settings.verbose > 0)
    #####: 5925:                fprintf(stderr, "Failed to read, and not due to blocking\n");
    #####: 5926:            conn_set_state(c, conn_closing);
    #####: 5927:            break;
        -: 5928:
    #####: 5929:        case conn_write:
        -: 5930:            /*
        -: 5931:             * We want to write out a simple response. If we haven't already,
        -: 5932:             * assemble it into a msgbuf list (this will be a single-entry
        -: 5933:             * list for TCP or a two-entry list for UDP).
        -: 5934:             */
    #####: 5935:            if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
    #####: 5936:                if (add_iov(c, c->wcurr, c->wbytes) != 0) {
    #####: 5937:                    if (settings.verbose > 0)
    #####: 5938:                        fprintf(stderr, "Couldn't build response\n");
    #####: 5939:                    conn_set_state(c, conn_closing);
    #####: 5940:                    break;
        -: 5941:                }
        -: 5942:            }
        -: 5943:
        -: 5944:            /* fall through... */
        -: 5945:
        -: 5946:        case conn_mwrite:
        -: 5947:#ifdef EXTSTORE
        -: 5948:            /* have side IO's that must process before transmit() can run.
        -: 5949:             * remove the connection from the worker thread and dispatch the
        -: 5950:             * IO queue
        -: 5951:             */
        -: 5952:            if (c->io_wrapleft) {
        -: 5953:                assert(c->io_queued == false);
        -: 5954:                assert(c->io_wraplist != NULL);
        -: 5955:                // TODO: create proper state for this condition
        -: 5956:                conn_set_state(c, conn_watch);
        -: 5957:                event_del(&c->event);
        -: 5958:                c->io_queued = true;
        -: 5959:                extstore_submit(c->thread->storage, &c->io_wraplist->io);
        -: 5960:                stop = true;
        -: 5961:                break;
        -: 5962:            }
        -: 5963:#endif
  200000*: 5964:          if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
    #####: 5965:            if (settings.verbose > 0)
    #####: 5966:              fprintf(stderr, "Failed to build UDP headers\n");
    #####: 5967:            conn_set_state(c, conn_closing);
    #####: 5968:            break;
        -: 5969:          }
   200000: 5970:            switch (transmit(c)) {
   100000: 5971:            case TRANSMIT_COMPLETE:
   100000: 5972:                if (c->state == conn_mwrite) {
   100000: 5973:                    conn_release_items(c);
        -: 5974:                    /* XXX:  I don't know why this wasn't the general case */
   100000: 5975:                    if(c->protocol == binary_prot) {
   100000: 5976:                        conn_set_state(c, c->write_and_go);
        -: 5977:                    } else {
    #####: 5978:                        conn_set_state(c, conn_new_cmd);
        -: 5979:                    }
    #####: 5980:                } else if (c->state == conn_write) {
    #####: 5981:                    if (c->write_and_free) {
    #####: 5982:                        free(c->write_and_free);
    #####: 5983:                        c->write_and_free = 0;
        -: 5984:                    }
    #####: 5985:                    conn_set_state(c, c->write_and_go);
        -: 5986:                } else {
    #####: 5987:                    if (settings.verbose > 0)
    #####: 5988:                        fprintf(stderr, "Unexpected state %d\n", c->state);
    #####: 5989:                    conn_set_state(c, conn_closing);
        -: 5990:                }
        -: 5991:                break;
        -: 5992:
        -: 5993:            case TRANSMIT_INCOMPLETE:
        -: 5994:            case TRANSMIT_HARD_ERROR:
        -: 5995:                break;                   /* Continue in state machine. */
        -: 5996:
    #####: 5997:            case TRANSMIT_SOFT_ERROR:
    #####: 5998:                stop = true;
    #####: 5999:                break;
        -: 6000:            }
        -: 6001:            break;
        -: 6002:
      200: 6003:        case conn_closing:
      200: 6004:            if (IS_UDP(c->transport))
    #####: 6005:                conn_cleanup(c);
        -: 6006:            else
      200: 6007:                conn_close(c);
        -: 6008:            stop = true;
        -: 6009:            break;
        -: 6010:
    #####: 6011:        case conn_closed:
        -: 6012:            /* This only happens if dormando is an idiot. */
    #####: 6013:            abort();
        -: 6014:            break;
        -: 6015:
        -: 6016:        case conn_watch:
        -: 6017:            /* We handed off our connection to the logger thread. */
        -: 6018:            stop = true;
        -: 6019:            break;
        -: 6020:        case conn_max_state:
    #####: 6021:            assert(false);
        -: 6022:            break;
        -: 6023:        }
  109200*: 6024:    }
        -: 6025:
   100600: 6026:    return;
        -: 6027:}
------------------
        -: 6028:
   301800: 6029:void event_handler(const int fd, const short which, void *arg) {
   301800: 6030:    conn *c;
        -: 6031:
   301800: 6032:    c = (conn *)arg;
  301800*: 6033:    assert(c != NULL);
        -: 6034:
   301800: 6035:    c->which = which;
        -: 6036:
        -: 6037:    /* sanity */
   301800: 6038:    if (fd != c->sfd) {
    #####: 6039:        if (settings.verbose > 0)
    #####: 6040:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 6041:        conn_close(c);
    #####: 6042:        return;
        -: 6043:    }
        -: 6044:
   301800: 6045:    drive_machine(c);
        -: 6046:
        -: 6047:    /* wait for next event */
   301800: 6048:    return;
        -: 6049:}
------------------
event_handler:
   100600: 6029:void event_handler(const int fd, const short which, void *arg) {
   100600: 6030:    conn *c;
        -: 6031:
   100600: 6032:    c = (conn *)arg;
  100600*: 6033:    assert(c != NULL);
        -: 6034:
   100600: 6035:    c->which = which;
        -: 6036:
        -: 6037:    /* sanity */
   100600: 6038:    if (fd != c->sfd) {
    #####: 6039:        if (settings.verbose > 0)
    #####: 6040:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 6041:        conn_close(c);
    #####: 6042:        return;
        -: 6043:    }
        -: 6044:
   100600: 6045:    drive_machine(c);
        -: 6046:
        -: 6047:    /* wait for next event */
   100600: 6048:    return;
        -: 6049:}
------------------
event_handler:
   100600: 6029:void event_handler(const int fd, const short which, void *arg) {
   100600: 6030:    conn *c;
        -: 6031:
   100600: 6032:    c = (conn *)arg;
  100600*: 6033:    assert(c != NULL);
        -: 6034:
   100600: 6035:    c->which = which;
        -: 6036:
        -: 6037:    /* sanity */
   100600: 6038:    if (fd != c->sfd) {
    #####: 6039:        if (settings.verbose > 0)
    #####: 6040:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 6041:        conn_close(c);
    #####: 6042:        return;
        -: 6043:    }
        -: 6044:
   100600: 6045:    drive_machine(c);
        -: 6046:
        -: 6047:    /* wait for next event */
   100600: 6048:    return;
        -: 6049:}
------------------
event_handler:
   100600: 6029:void event_handler(const int fd, const short which, void *arg) {
   100600: 6030:    conn *c;
        -: 6031:
   100600: 6032:    c = (conn *)arg;
  100600*: 6033:    assert(c != NULL);
        -: 6034:
   100600: 6035:    c->which = which;
        -: 6036:
        -: 6037:    /* sanity */
   100600: 6038:    if (fd != c->sfd) {
    #####: 6039:        if (settings.verbose > 0)
    #####: 6040:            fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
    #####: 6041:        conn_close(c);
    #####: 6042:        return;
        -: 6043:    }
        -: 6044:
   100600: 6045:    drive_machine(c);
        -: 6046:
        -: 6047:    /* wait for next event */
   100600: 6048:    return;
        -: 6049:}
------------------
        -: 6050:
        6: 6051:static int new_socket(struct addrinfo *ai) {
        6: 6052:    int sfd;
        6: 6053:    int flags;
        -: 6054:
        6: 6055:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 6056:        return -1;
        -: 6057:    }
        -: 6058:
       12: 6059:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        6: 6060:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6061:        perror("setting O_NONBLOCK");
    #####: 6062:        close(sfd);
    #####: 6063:        return -1;
        -: 6064:    }
        -: 6065:    return sfd;
        -: 6066:}
------------------
new_socket:
        2: 6051:static int new_socket(struct addrinfo *ai) {
        2: 6052:    int sfd;
        2: 6053:    int flags;
        -: 6054:
        2: 6055:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 6056:        return -1;
        -: 6057:    }
        -: 6058:
        4: 6059:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        2: 6060:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6061:        perror("setting O_NONBLOCK");
    #####: 6062:        close(sfd);
    #####: 6063:        return -1;
        -: 6064:    }
        -: 6065:    return sfd;
        -: 6066:}
------------------
new_socket:
        2: 6051:static int new_socket(struct addrinfo *ai) {
        2: 6052:    int sfd;
        2: 6053:    int flags;
        -: 6054:
        2: 6055:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 6056:        return -1;
        -: 6057:    }
        -: 6058:
        4: 6059:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        2: 6060:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6061:        perror("setting O_NONBLOCK");
    #####: 6062:        close(sfd);
    #####: 6063:        return -1;
        -: 6064:    }
        -: 6065:    return sfd;
        -: 6066:}
------------------
new_socket:
        2: 6051:static int new_socket(struct addrinfo *ai) {
        2: 6052:    int sfd;
        2: 6053:    int flags;
        -: 6054:
        2: 6055:    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        -: 6056:        return -1;
        -: 6057:    }
        -: 6058:
        4: 6059:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        2: 6060:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6061:        perror("setting O_NONBLOCK");
    #####: 6062:        close(sfd);
    #####: 6063:        return -1;
        -: 6064:    }
        -: 6065:    return sfd;
        -: 6066:}
------------------
        -: 6067:
        -: 6068:
        -: 6069:/*
        -: 6070: * Sets a socket's send buffer size to the maximum allowed by the system.
        -: 6071: */
    #####: 6072:static void maximize_sndbuf(const int sfd) {
    #####: 6073:    socklen_t intsize = sizeof(int);
    #####: 6074:    int last_good = 0;
    #####: 6075:    int min, max, avg;
    #####: 6076:    int old_size;
        -: 6077:
        -: 6078:    /* Start with the default size. */
    #####: 6079:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
    #####: 6080:        if (settings.verbose > 0)
    #####: 6081:            perror("getsockopt(SO_SNDBUF)");
    #####: 6082:        return;
        -: 6083:    }
        -: 6084:
        -: 6085:    /* Binary-search for the real maximum. */
    #####: 6086:    min = old_size;
    #####: 6087:    max = MAX_SENDBUF_SIZE;
        -: 6088:
    #####: 6089:    while (min <= max) {
    #####: 6090:        avg = ((unsigned int)(min + max)) / 2;
    #####: 6091:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
    #####: 6092:            last_good = avg;
    #####: 6093:            min = avg + 1;
        -: 6094:        } else {
    #####: 6095:            max = avg - 1;
        -: 6096:        }
        -: 6097:    }
        -: 6098:
    #####: 6099:    if (settings.verbose > 1)
    #####: 6100:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 6101:}
------------------
maximize_sndbuf:
    #####: 6072:static void maximize_sndbuf(const int sfd) {
    #####: 6073:    socklen_t intsize = sizeof(int);
    #####: 6074:    int last_good = 0;
    #####: 6075:    int min, max, avg;
    #####: 6076:    int old_size;
        -: 6077:
        -: 6078:    /* Start with the default size. */
    #####: 6079:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
    #####: 6080:        if (settings.verbose > 0)
    #####: 6081:            perror("getsockopt(SO_SNDBUF)");
    #####: 6082:        return;
        -: 6083:    }
        -: 6084:
        -: 6085:    /* Binary-search for the real maximum. */
    #####: 6086:    min = old_size;
    #####: 6087:    max = MAX_SENDBUF_SIZE;
        -: 6088:
    #####: 6089:    while (min <= max) {
    #####: 6090:        avg = ((unsigned int)(min + max)) / 2;
    #####: 6091:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
    #####: 6092:            last_good = avg;
    #####: 6093:            min = avg + 1;
        -: 6094:        } else {
    #####: 6095:            max = avg - 1;
        -: 6096:        }
        -: 6097:    }
        -: 6098:
    #####: 6099:    if (settings.verbose > 1)
    #####: 6100:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 6101:}
------------------
maximize_sndbuf:
    #####: 6072:static void maximize_sndbuf(const int sfd) {
    #####: 6073:    socklen_t intsize = sizeof(int);
    #####: 6074:    int last_good = 0;
    #####: 6075:    int min, max, avg;
    #####: 6076:    int old_size;
        -: 6077:
        -: 6078:    /* Start with the default size. */
    #####: 6079:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
    #####: 6080:        if (settings.verbose > 0)
    #####: 6081:            perror("getsockopt(SO_SNDBUF)");
    #####: 6082:        return;
        -: 6083:    }
        -: 6084:
        -: 6085:    /* Binary-search for the real maximum. */
    #####: 6086:    min = old_size;
    #####: 6087:    max = MAX_SENDBUF_SIZE;
        -: 6088:
    #####: 6089:    while (min <= max) {
    #####: 6090:        avg = ((unsigned int)(min + max)) / 2;
    #####: 6091:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
    #####: 6092:            last_good = avg;
    #####: 6093:            min = avg + 1;
        -: 6094:        } else {
    #####: 6095:            max = avg - 1;
        -: 6096:        }
        -: 6097:    }
        -: 6098:
    #####: 6099:    if (settings.verbose > 1)
    #####: 6100:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 6101:}
------------------
maximize_sndbuf:
    #####: 6072:static void maximize_sndbuf(const int sfd) {
    #####: 6073:    socklen_t intsize = sizeof(int);
    #####: 6074:    int last_good = 0;
    #####: 6075:    int min, max, avg;
    #####: 6076:    int old_size;
        -: 6077:
        -: 6078:    /* Start with the default size. */
    #####: 6079:    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
    #####: 6080:        if (settings.verbose > 0)
    #####: 6081:            perror("getsockopt(SO_SNDBUF)");
    #####: 6082:        return;
        -: 6083:    }
        -: 6084:
        -: 6085:    /* Binary-search for the real maximum. */
    #####: 6086:    min = old_size;
    #####: 6087:    max = MAX_SENDBUF_SIZE;
        -: 6088:
    #####: 6089:    while (min <= max) {
    #####: 6090:        avg = ((unsigned int)(min + max)) / 2;
    #####: 6091:        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
    #####: 6092:            last_good = avg;
    #####: 6093:            min = avg + 1;
        -: 6094:        } else {
    #####: 6095:            max = avg - 1;
        -: 6096:        }
        -: 6097:    }
        -: 6098:
    #####: 6099:    if (settings.verbose > 1)
    #####: 6100:        fprintf(stderr, "<%d send buffer was %d, now %d\n", sfd, old_size, last_good);
        -: 6101:}
------------------
        -: 6102:
        -: 6103:/**
        -: 6104: * Create a socket and bind it to a specific port number
        -: 6105: * @param interface the interface to bind to
        -: 6106: * @param port the port number to bind to
        -: 6107: * @param transport the transport protocol (TCP / UDP)
        -: 6108: * @param portnumber_file A filepointer to write the port numbers to
        -: 6109: *        when they are successfully added to the list of ports we
        -: 6110: *        listen on.
        -: 6111: */
        3: 6112:static int server_socket(const char *interface,
        -: 6113:                         int port,
        -: 6114:                         enum network_transport transport,
        -: 6115:                         FILE *portnumber_file, bool ssl_enabled) {
        3: 6116:    int sfd;
        3: 6117:    struct linger ling = {0, 0};
        3: 6118:    struct addrinfo *ai;
        3: 6119:    struct addrinfo *next;
        3: 6120:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 6121:                              .ai_family = AF_UNSPEC };
        3: 6122:    char port_buf[NI_MAXSERV];
        3: 6123:    int error;
        3: 6124:    int success = 0;
        3: 6125:    int flags =1;
        -: 6126:
        3: 6127:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 6128:
        3: 6129:    if (port == -1) {
    #####: 6130:        port = 0;
        -: 6131:    }
        3: 6132:    snprintf(port_buf, sizeof(port_buf), "%d", port);
        3: 6133:    error= getaddrinfo(interface, port_buf, &hints, &ai);
        3: 6134:    if (error != 0) {
    #####: 6135:        if (error != EAI_SYSTEM)
    #####: 6136:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 6137:        else
    #####: 6138:          perror("getaddrinfo()");
    #####: 6139:        return 1;
        -: 6140:    }
        -: 6141:
        9: 6142:    for (next= ai; next; next= next->ai_next) {
        6: 6143:        conn *listen_conn_add;
        6: 6144:        if ((sfd = new_socket(next)) == -1) {
        -: 6145:            /* getaddrinfo can return "junk" addresses,
        -: 6146:             * we make sure at least one works before erroring.
        -: 6147:             */
    #####: 6148:            if (errno == EMFILE) {
        -: 6149:                /* ...unless we're out of fds */
    #####: 6150:                perror("server_socket");
    #####: 6151:                exit(EX_OSERR);
        -: 6152:            }
        -: 6153:            continue;
        -: 6154:        }
        -: 6155:
        -: 6156:#ifdef IPV6_V6ONLY
        6: 6157:        if (next->ai_family == AF_INET6) {
        3: 6158:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
        3: 6159:            if (error != 0) {
    #####: 6160:                perror("setsockopt");
    #####: 6161:                close(sfd);
    #####: 6162:                continue;
        -: 6163:            }
        -: 6164:        }
        -: 6165:#endif
        -: 6166:
        6: 6167:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
        6: 6168:        if (IS_UDP(transport)) {
    #####: 6169:            maximize_sndbuf(sfd);
        -: 6170:        } else {
        6: 6171:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
        6: 6172:            if (error != 0)
    #####: 6173:                perror("setsockopt");
        -: 6174:
        6: 6175:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        6: 6176:            if (error != 0)
    #####: 6177:                perror("setsockopt");
        -: 6178:
        6: 6179:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
        6: 6180:            if (error != 0)
    #####: 6181:                perror("setsockopt");
        -: 6182:        }
        -: 6183:
        6: 6184:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 6185:            if (errno != EADDRINUSE) {
    #####: 6186:                perror("bind()");
    #####: 6187:                close(sfd);
    #####: 6188:                freeaddrinfo(ai);
    #####: 6189:                return 1;
        -: 6190:            }
    #####: 6191:            close(sfd);
    #####: 6192:            continue;
        -: 6193:        } else {
        6: 6194:            success++;
        6: 6195:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 6196:                perror("listen()");
    #####: 6197:                close(sfd);
    #####: 6198:                freeaddrinfo(ai);
    #####: 6199:                return 1;
        -: 6200:            }
       6*: 6201:            if (portnumber_file != NULL &&
    #####: 6202:                (next->ai_addr->sa_family == AF_INET ||
        -: 6203:                 next->ai_addr->sa_family == AF_INET6)) {
    #####: 6204:                union {
        -: 6205:                    struct sockaddr_in in;
        -: 6206:                    struct sockaddr_in6 in6;
        -: 6207:                } my_sockaddr;
    #####: 6208:                socklen_t len = sizeof(my_sockaddr);
    #####: 6209:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
    #####: 6210:                    if (next->ai_addr->sa_family == AF_INET) {
    #####: 6211:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 6212:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6213:                                ntohs(my_sockaddr.in.sin_port));
        -: 6214:                    } else {
    #####: 6215:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 6216:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6217:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 6218:                    }
        -: 6219:                }
        -: 6220:            }
        -: 6221:        }
        -: 6222:
        6: 6223:        if (IS_UDP(transport)) {
        -: 6224:            int c;
        -: 6225:
    #####: 6226:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 6227:                /* Allocate one UDP file descriptor per worker thread;
        -: 6228:                 * this allows "stats conns" to separately list multiple
        -: 6229:                 * parallel UDP requests in progress.
        -: 6230:                 *
        -: 6231:                 * The dispatch code round-robins new connection requests
        -: 6232:                 * among threads, so this is guaranteed to assign one
        -: 6233:                 * FD to each thread.
        -: 6234:                 */
    #####: 6235:                int per_thread_fd = c ? dup(sfd) : sfd;
    #####: 6236:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 6237:                                  EV_READ | EV_PERSIST,
        -: 6238:                                  UDP_READ_BUFFER_SIZE, transport, NULL);
        -: 6239:            }
        -: 6240:        } else {
        6: 6241:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 6242:                                             EV_READ | EV_PERSIST, 1,
        -: 6243:                                             transport, main_base, NULL))) {
    #####: 6244:                fprintf(stderr, "failed to create listening connection\n");
    #####: 6245:                exit(EXIT_FAILURE);
        -: 6246:            }
        -: 6247:#ifdef TLS
        -: 6248:            listen_conn_add->ssl_enabled = ssl_enabled;
        -: 6249:#else
       6*: 6250:            assert(ssl_enabled == false);
        -: 6251:#endif
        6: 6252:            listen_conn_add->next = listen_conn;
        6: 6253:            listen_conn = listen_conn_add;
        -: 6254:        }
        -: 6255:    }
        -: 6256:
        3: 6257:    freeaddrinfo(ai);
        -: 6258:
        -: 6259:    /* Return zero iff we detected no errors in starting up connections */
        3: 6260:    return success == 0;
        -: 6261:}
------------------
server_socket:
        1: 6112:static int server_socket(const char *interface,
        -: 6113:                         int port,
        -: 6114:                         enum network_transport transport,
        -: 6115:                         FILE *portnumber_file, bool ssl_enabled) {
        1: 6116:    int sfd;
        1: 6117:    struct linger ling = {0, 0};
        1: 6118:    struct addrinfo *ai;
        1: 6119:    struct addrinfo *next;
        1: 6120:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 6121:                              .ai_family = AF_UNSPEC };
        1: 6122:    char port_buf[NI_MAXSERV];
        1: 6123:    int error;
        1: 6124:    int success = 0;
        1: 6125:    int flags =1;
        -: 6126:
        1: 6127:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 6128:
        1: 6129:    if (port == -1) {
    #####: 6130:        port = 0;
        -: 6131:    }
        1: 6132:    snprintf(port_buf, sizeof(port_buf), "%d", port);
        1: 6133:    error= getaddrinfo(interface, port_buf, &hints, &ai);
        1: 6134:    if (error != 0) {
    #####: 6135:        if (error != EAI_SYSTEM)
    #####: 6136:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 6137:        else
    #####: 6138:          perror("getaddrinfo()");
    #####: 6139:        return 1;
        -: 6140:    }
        -: 6141:
        3: 6142:    for (next= ai; next; next= next->ai_next) {
        2: 6143:        conn *listen_conn_add;
        2: 6144:        if ((sfd = new_socket(next)) == -1) {
        -: 6145:            /* getaddrinfo can return "junk" addresses,
        -: 6146:             * we make sure at least one works before erroring.
        -: 6147:             */
    #####: 6148:            if (errno == EMFILE) {
        -: 6149:                /* ...unless we're out of fds */
    #####: 6150:                perror("server_socket");
    #####: 6151:                exit(EX_OSERR);
        -: 6152:            }
        -: 6153:            continue;
        -: 6154:        }
        -: 6155:
        -: 6156:#ifdef IPV6_V6ONLY
        2: 6157:        if (next->ai_family == AF_INET6) {
        1: 6158:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
        1: 6159:            if (error != 0) {
    #####: 6160:                perror("setsockopt");
    #####: 6161:                close(sfd);
    #####: 6162:                continue;
        -: 6163:            }
        -: 6164:        }
        -: 6165:#endif
        -: 6166:
        2: 6167:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
        2: 6168:        if (IS_UDP(transport)) {
    #####: 6169:            maximize_sndbuf(sfd);
        -: 6170:        } else {
        2: 6171:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
        2: 6172:            if (error != 0)
    #####: 6173:                perror("setsockopt");
        -: 6174:
        2: 6175:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        2: 6176:            if (error != 0)
    #####: 6177:                perror("setsockopt");
        -: 6178:
        2: 6179:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
        2: 6180:            if (error != 0)
    #####: 6181:                perror("setsockopt");
        -: 6182:        }
        -: 6183:
        2: 6184:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 6185:            if (errno != EADDRINUSE) {
    #####: 6186:                perror("bind()");
    #####: 6187:                close(sfd);
    #####: 6188:                freeaddrinfo(ai);
    #####: 6189:                return 1;
        -: 6190:            }
    #####: 6191:            close(sfd);
    #####: 6192:            continue;
        -: 6193:        } else {
        2: 6194:            success++;
        2: 6195:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 6196:                perror("listen()");
    #####: 6197:                close(sfd);
    #####: 6198:                freeaddrinfo(ai);
    #####: 6199:                return 1;
        -: 6200:            }
       2*: 6201:            if (portnumber_file != NULL &&
    #####: 6202:                (next->ai_addr->sa_family == AF_INET ||
        -: 6203:                 next->ai_addr->sa_family == AF_INET6)) {
    #####: 6204:                union {
        -: 6205:                    struct sockaddr_in in;
        -: 6206:                    struct sockaddr_in6 in6;
        -: 6207:                } my_sockaddr;
    #####: 6208:                socklen_t len = sizeof(my_sockaddr);
    #####: 6209:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
    #####: 6210:                    if (next->ai_addr->sa_family == AF_INET) {
    #####: 6211:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 6212:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6213:                                ntohs(my_sockaddr.in.sin_port));
        -: 6214:                    } else {
    #####: 6215:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 6216:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6217:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 6218:                    }
        -: 6219:                }
        -: 6220:            }
        -: 6221:        }
        -: 6222:
        2: 6223:        if (IS_UDP(transport)) {
        -: 6224:            int c;
        -: 6225:
    #####: 6226:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 6227:                /* Allocate one UDP file descriptor per worker thread;
        -: 6228:                 * this allows "stats conns" to separately list multiple
        -: 6229:                 * parallel UDP requests in progress.
        -: 6230:                 *
        -: 6231:                 * The dispatch code round-robins new connection requests
        -: 6232:                 * among threads, so this is guaranteed to assign one
        -: 6233:                 * FD to each thread.
        -: 6234:                 */
    #####: 6235:                int per_thread_fd = c ? dup(sfd) : sfd;
    #####: 6236:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 6237:                                  EV_READ | EV_PERSIST,
        -: 6238:                                  UDP_READ_BUFFER_SIZE, transport, NULL);
        -: 6239:            }
        -: 6240:        } else {
        2: 6241:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 6242:                                             EV_READ | EV_PERSIST, 1,
        -: 6243:                                             transport, main_base, NULL))) {
    #####: 6244:                fprintf(stderr, "failed to create listening connection\n");
    #####: 6245:                exit(EXIT_FAILURE);
        -: 6246:            }
        -: 6247:#ifdef TLS
        -: 6248:            listen_conn_add->ssl_enabled = ssl_enabled;
        -: 6249:#else
       2*: 6250:            assert(ssl_enabled == false);
        -: 6251:#endif
        2: 6252:            listen_conn_add->next = listen_conn;
        2: 6253:            listen_conn = listen_conn_add;
        -: 6254:        }
        -: 6255:    }
        -: 6256:
        1: 6257:    freeaddrinfo(ai);
        -: 6258:
        -: 6259:    /* Return zero iff we detected no errors in starting up connections */
        1: 6260:    return success == 0;
        -: 6261:}
------------------
server_socket:
        1: 6112:static int server_socket(const char *interface,
        -: 6113:                         int port,
        -: 6114:                         enum network_transport transport,
        -: 6115:                         FILE *portnumber_file, bool ssl_enabled) {
        1: 6116:    int sfd;
        1: 6117:    struct linger ling = {0, 0};
        1: 6118:    struct addrinfo *ai;
        1: 6119:    struct addrinfo *next;
        1: 6120:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 6121:                              .ai_family = AF_UNSPEC };
        1: 6122:    char port_buf[NI_MAXSERV];
        1: 6123:    int error;
        1: 6124:    int success = 0;
        1: 6125:    int flags =1;
        -: 6126:
        1: 6127:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 6128:
        1: 6129:    if (port == -1) {
    #####: 6130:        port = 0;
        -: 6131:    }
        1: 6132:    snprintf(port_buf, sizeof(port_buf), "%d", port);
        1: 6133:    error= getaddrinfo(interface, port_buf, &hints, &ai);
        1: 6134:    if (error != 0) {
    #####: 6135:        if (error != EAI_SYSTEM)
    #####: 6136:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 6137:        else
    #####: 6138:          perror("getaddrinfo()");
    #####: 6139:        return 1;
        -: 6140:    }
        -: 6141:
        3: 6142:    for (next= ai; next; next= next->ai_next) {
        2: 6143:        conn *listen_conn_add;
        2: 6144:        if ((sfd = new_socket(next)) == -1) {
        -: 6145:            /* getaddrinfo can return "junk" addresses,
        -: 6146:             * we make sure at least one works before erroring.
        -: 6147:             */
    #####: 6148:            if (errno == EMFILE) {
        -: 6149:                /* ...unless we're out of fds */
    #####: 6150:                perror("server_socket");
    #####: 6151:                exit(EX_OSERR);
        -: 6152:            }
        -: 6153:            continue;
        -: 6154:        }
        -: 6155:
        -: 6156:#ifdef IPV6_V6ONLY
        2: 6157:        if (next->ai_family == AF_INET6) {
        1: 6158:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
        1: 6159:            if (error != 0) {
    #####: 6160:                perror("setsockopt");
    #####: 6161:                close(sfd);
    #####: 6162:                continue;
        -: 6163:            }
        -: 6164:        }
        -: 6165:#endif
        -: 6166:
        2: 6167:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
        2: 6168:        if (IS_UDP(transport)) {
    #####: 6169:            maximize_sndbuf(sfd);
        -: 6170:        } else {
        2: 6171:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
        2: 6172:            if (error != 0)
    #####: 6173:                perror("setsockopt");
        -: 6174:
        2: 6175:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        2: 6176:            if (error != 0)
    #####: 6177:                perror("setsockopt");
        -: 6178:
        2: 6179:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
        2: 6180:            if (error != 0)
    #####: 6181:                perror("setsockopt");
        -: 6182:        }
        -: 6183:
        2: 6184:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 6185:            if (errno != EADDRINUSE) {
    #####: 6186:                perror("bind()");
    #####: 6187:                close(sfd);
    #####: 6188:                freeaddrinfo(ai);
    #####: 6189:                return 1;
        -: 6190:            }
    #####: 6191:            close(sfd);
    #####: 6192:            continue;
        -: 6193:        } else {
        2: 6194:            success++;
        2: 6195:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 6196:                perror("listen()");
    #####: 6197:                close(sfd);
    #####: 6198:                freeaddrinfo(ai);
    #####: 6199:                return 1;
        -: 6200:            }
       2*: 6201:            if (portnumber_file != NULL &&
    #####: 6202:                (next->ai_addr->sa_family == AF_INET ||
        -: 6203:                 next->ai_addr->sa_family == AF_INET6)) {
    #####: 6204:                union {
        -: 6205:                    struct sockaddr_in in;
        -: 6206:                    struct sockaddr_in6 in6;
        -: 6207:                } my_sockaddr;
    #####: 6208:                socklen_t len = sizeof(my_sockaddr);
    #####: 6209:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
    #####: 6210:                    if (next->ai_addr->sa_family == AF_INET) {
    #####: 6211:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 6212:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6213:                                ntohs(my_sockaddr.in.sin_port));
        -: 6214:                    } else {
    #####: 6215:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 6216:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6217:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 6218:                    }
        -: 6219:                }
        -: 6220:            }
        -: 6221:        }
        -: 6222:
        2: 6223:        if (IS_UDP(transport)) {
        -: 6224:            int c;
        -: 6225:
    #####: 6226:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 6227:                /* Allocate one UDP file descriptor per worker thread;
        -: 6228:                 * this allows "stats conns" to separately list multiple
        -: 6229:                 * parallel UDP requests in progress.
        -: 6230:                 *
        -: 6231:                 * The dispatch code round-robins new connection requests
        -: 6232:                 * among threads, so this is guaranteed to assign one
        -: 6233:                 * FD to each thread.
        -: 6234:                 */
    #####: 6235:                int per_thread_fd = c ? dup(sfd) : sfd;
    #####: 6236:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 6237:                                  EV_READ | EV_PERSIST,
        -: 6238:                                  UDP_READ_BUFFER_SIZE, transport, NULL);
        -: 6239:            }
        -: 6240:        } else {
        2: 6241:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 6242:                                             EV_READ | EV_PERSIST, 1,
        -: 6243:                                             transport, main_base, NULL))) {
    #####: 6244:                fprintf(stderr, "failed to create listening connection\n");
    #####: 6245:                exit(EXIT_FAILURE);
        -: 6246:            }
        -: 6247:#ifdef TLS
        -: 6248:            listen_conn_add->ssl_enabled = ssl_enabled;
        -: 6249:#else
       2*: 6250:            assert(ssl_enabled == false);
        -: 6251:#endif
        2: 6252:            listen_conn_add->next = listen_conn;
        2: 6253:            listen_conn = listen_conn_add;
        -: 6254:        }
        -: 6255:    }
        -: 6256:
        1: 6257:    freeaddrinfo(ai);
        -: 6258:
        -: 6259:    /* Return zero iff we detected no errors in starting up connections */
        1: 6260:    return success == 0;
        -: 6261:}
------------------
server_socket:
        1: 6112:static int server_socket(const char *interface,
        -: 6113:                         int port,
        -: 6114:                         enum network_transport transport,
        -: 6115:                         FILE *portnumber_file, bool ssl_enabled) {
        1: 6116:    int sfd;
        1: 6117:    struct linger ling = {0, 0};
        1: 6118:    struct addrinfo *ai;
        1: 6119:    struct addrinfo *next;
        1: 6120:    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
        -: 6121:                              .ai_family = AF_UNSPEC };
        1: 6122:    char port_buf[NI_MAXSERV];
        1: 6123:    int error;
        1: 6124:    int success = 0;
        1: 6125:    int flags =1;
        -: 6126:
        1: 6127:    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;
        -: 6128:
        1: 6129:    if (port == -1) {
    #####: 6130:        port = 0;
        -: 6131:    }
        1: 6132:    snprintf(port_buf, sizeof(port_buf), "%d", port);
        1: 6133:    error= getaddrinfo(interface, port_buf, &hints, &ai);
        1: 6134:    if (error != 0) {
    #####: 6135:        if (error != EAI_SYSTEM)
    #####: 6136:          fprintf(stderr, "getaddrinfo(): %s\n", gai_strerror(error));
        -: 6137:        else
    #####: 6138:          perror("getaddrinfo()");
    #####: 6139:        return 1;
        -: 6140:    }
        -: 6141:
        3: 6142:    for (next= ai; next; next= next->ai_next) {
        2: 6143:        conn *listen_conn_add;
        2: 6144:        if ((sfd = new_socket(next)) == -1) {
        -: 6145:            /* getaddrinfo can return "junk" addresses,
        -: 6146:             * we make sure at least one works before erroring.
        -: 6147:             */
    #####: 6148:            if (errno == EMFILE) {
        -: 6149:                /* ...unless we're out of fds */
    #####: 6150:                perror("server_socket");
    #####: 6151:                exit(EX_OSERR);
        -: 6152:            }
        -: 6153:            continue;
        -: 6154:        }
        -: 6155:
        -: 6156:#ifdef IPV6_V6ONLY
        2: 6157:        if (next->ai_family == AF_INET6) {
        1: 6158:            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
        1: 6159:            if (error != 0) {
    #####: 6160:                perror("setsockopt");
    #####: 6161:                close(sfd);
    #####: 6162:                continue;
        -: 6163:            }
        -: 6164:        }
        -: 6165:#endif
        -: 6166:
        2: 6167:        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
        2: 6168:        if (IS_UDP(transport)) {
    #####: 6169:            maximize_sndbuf(sfd);
        -: 6170:        } else {
        2: 6171:            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
        2: 6172:            if (error != 0)
    #####: 6173:                perror("setsockopt");
        -: 6174:
        2: 6175:            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        2: 6176:            if (error != 0)
    #####: 6177:                perror("setsockopt");
        -: 6178:
        2: 6179:            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
        2: 6180:            if (error != 0)
    #####: 6181:                perror("setsockopt");
        -: 6182:        }
        -: 6183:
        2: 6184:        if (bind(sfd, next->ai_addr, next->ai_addrlen) == -1) {
    #####: 6185:            if (errno != EADDRINUSE) {
    #####: 6186:                perror("bind()");
    #####: 6187:                close(sfd);
    #####: 6188:                freeaddrinfo(ai);
    #####: 6189:                return 1;
        -: 6190:            }
    #####: 6191:            close(sfd);
    #####: 6192:            continue;
        -: 6193:        } else {
        2: 6194:            success++;
        2: 6195:            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
    #####: 6196:                perror("listen()");
    #####: 6197:                close(sfd);
    #####: 6198:                freeaddrinfo(ai);
    #####: 6199:                return 1;
        -: 6200:            }
       2*: 6201:            if (portnumber_file != NULL &&
    #####: 6202:                (next->ai_addr->sa_family == AF_INET ||
        -: 6203:                 next->ai_addr->sa_family == AF_INET6)) {
    #####: 6204:                union {
        -: 6205:                    struct sockaddr_in in;
        -: 6206:                    struct sockaddr_in6 in6;
        -: 6207:                } my_sockaddr;
    #####: 6208:                socklen_t len = sizeof(my_sockaddr);
    #####: 6209:                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
    #####: 6210:                    if (next->ai_addr->sa_family == AF_INET) {
    #####: 6211:                        fprintf(portnumber_file, "%s INET: %u\n",
        -: 6212:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6213:                                ntohs(my_sockaddr.in.sin_port));
        -: 6214:                    } else {
    #####: 6215:                        fprintf(portnumber_file, "%s INET6: %u\n",
        -: 6216:                                IS_UDP(transport) ? "UDP" : "TCP",
    #####: 6217:                                ntohs(my_sockaddr.in6.sin6_port));
        -: 6218:                    }
        -: 6219:                }
        -: 6220:            }
        -: 6221:        }
        -: 6222:
        2: 6223:        if (IS_UDP(transport)) {
        -: 6224:            int c;
        -: 6225:
    #####: 6226:            for (c = 0; c < settings.num_threads_per_udp; c++) {
        -: 6227:                /* Allocate one UDP file descriptor per worker thread;
        -: 6228:                 * this allows "stats conns" to separately list multiple
        -: 6229:                 * parallel UDP requests in progress.
        -: 6230:                 *
        -: 6231:                 * The dispatch code round-robins new connection requests
        -: 6232:                 * among threads, so this is guaranteed to assign one
        -: 6233:                 * FD to each thread.
        -: 6234:                 */
    #####: 6235:                int per_thread_fd = c ? dup(sfd) : sfd;
    #####: 6236:                dispatch_conn_new(per_thread_fd, conn_read,
        -: 6237:                                  EV_READ | EV_PERSIST,
        -: 6238:                                  UDP_READ_BUFFER_SIZE, transport, NULL);
        -: 6239:            }
        -: 6240:        } else {
        2: 6241:            if (!(listen_conn_add = conn_new(sfd, conn_listening,
        -: 6242:                                             EV_READ | EV_PERSIST, 1,
        -: 6243:                                             transport, main_base, NULL))) {
    #####: 6244:                fprintf(stderr, "failed to create listening connection\n");
    #####: 6245:                exit(EXIT_FAILURE);
        -: 6246:            }
        -: 6247:#ifdef TLS
        -: 6248:            listen_conn_add->ssl_enabled = ssl_enabled;
        -: 6249:#else
       2*: 6250:            assert(ssl_enabled == false);
        -: 6251:#endif
        2: 6252:            listen_conn_add->next = listen_conn;
        2: 6253:            listen_conn = listen_conn_add;
        -: 6254:        }
        -: 6255:    }
        -: 6256:
        1: 6257:    freeaddrinfo(ai);
        -: 6258:
        -: 6259:    /* Return zero iff we detected no errors in starting up connections */
        1: 6260:    return success == 0;
        -: 6261:}
------------------
        -: 6262:
        3: 6263:static int server_sockets(int port, enum network_transport transport,
        -: 6264:                          FILE *portnumber_file) {
        3: 6265:    bool ssl_enabled = false;
        -: 6266:
        -: 6267:#ifdef TLS
        -: 6268:    const char *notls = "notls";
        -: 6269:    ssl_enabled = settings.ssl_enabled;
        -: 6270:#endif
        -: 6271:
        3: 6272:    if (settings.inter == NULL) {
        3: 6273:        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled);
        -: 6274:    } else {
        -: 6275:        // tokenize them and bind to each one of them..
    #####: 6276:        char *b;
    #####: 6277:        int ret = 0;
    #####: 6278:        char *list = strdup(settings.inter);
        -: 6279:
    #####: 6280:        if (list == NULL) {
    #####: 6281:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 6282:            return 1;
        -: 6283:        }
    #####: 6284:        for (char *p = strtok_r(list, ";,", &b);
        -: 6285:            p != NULL;
    #####: 6286:            p = strtok_r(NULL, ";,", &b)) {
    #####: 6287:            int the_port = port;
        -: 6288:#ifdef TLS
        -: 6289:            ssl_enabled = settings.ssl_enabled;
        -: 6290:            // "notls" option is valid only when memcached is run with SSL enabled.
        -: 6291:            if (strncmp(p, notls, strlen(notls)) == 0) {
        -: 6292:                if (!settings.ssl_enabled) {
        -: 6293:                    fprintf(stderr, "'notls' option is valid only when SSL is enabled\n");
        -: 6294:                    return 1;
        -: 6295:                }
        -: 6296:                ssl_enabled = false;
        -: 6297:                p += strlen(notls) + 1;
        -: 6298:            }
        -: 6299:#endif
        -: 6300:
    #####: 6301:            char *h = NULL;
    #####: 6302:            if (*p == '[') {
        -: 6303:                // expecting it to be an IPv6 address enclosed in []
        -: 6304:                // i.e. RFC3986 style recommended by RFC5952
    #####: 6305:                char *e = strchr(p, ']');
    #####: 6306:                if (e == NULL) {
    #####: 6307:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 6308:                    free(list);
    #####: 6309:                    return 1;
        -: 6310:                }
    #####: 6311:                h = ++p; // skip the opening '['
    #####: 6312:                *e = '\0';
    #####: 6313:                p = ++e; // skip the closing ']'
        -: 6314:            }
        -: 6315:
    #####: 6316:            char *s = strchr(p, ':');
    #####: 6317:            if (s != NULL) {
        -: 6318:                // If no more semicolons - attempt to treat as port number.
        -: 6319:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 6320:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 6321:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 6322:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 6323:                    *s = '\0';
    #####: 6324:                    ++s;
    #####: 6325:                    if (!safe_strtol(s, &the_port)) {
    #####: 6326:                        fprintf(stderr, "Invalid port number: \"%s\"", s);
    #####: 6327:                        free(list);
    #####: 6328:                        return 1;
        -: 6329:                    }
        -: 6330:                }
        -: 6331:            }
        -: 6332:
    #####: 6333:            if (h != NULL)
    #####: 6334:                p = h;
        -: 6335:
    #####: 6336:            if (strcmp(p, "*") == 0) {
    #####: 6337:                p = NULL;
        -: 6338:            }
    #####: 6339:            ret |= server_socket(p, the_port, transport, portnumber_file, ssl_enabled);
        -: 6340:        }
    #####: 6341:        free(list);
    #####: 6342:        return ret;
        -: 6343:    }
        -: 6344:}
------------------
server_sockets:
        1: 6263:static int server_sockets(int port, enum network_transport transport,
        -: 6264:                          FILE *portnumber_file) {
        1: 6265:    bool ssl_enabled = false;
        -: 6266:
        -: 6267:#ifdef TLS
        -: 6268:    const char *notls = "notls";
        -: 6269:    ssl_enabled = settings.ssl_enabled;
        -: 6270:#endif
        -: 6271:
        1: 6272:    if (settings.inter == NULL) {
        1: 6273:        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled);
        -: 6274:    } else {
        -: 6275:        // tokenize them and bind to each one of them..
    #####: 6276:        char *b;
    #####: 6277:        int ret = 0;
    #####: 6278:        char *list = strdup(settings.inter);
        -: 6279:
    #####: 6280:        if (list == NULL) {
    #####: 6281:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 6282:            return 1;
        -: 6283:        }
    #####: 6284:        for (char *p = strtok_r(list, ";,", &b);
        -: 6285:            p != NULL;
    #####: 6286:            p = strtok_r(NULL, ";,", &b)) {
    #####: 6287:            int the_port = port;
        -: 6288:#ifdef TLS
        -: 6289:            ssl_enabled = settings.ssl_enabled;
        -: 6290:            // "notls" option is valid only when memcached is run with SSL enabled.
        -: 6291:            if (strncmp(p, notls, strlen(notls)) == 0) {
        -: 6292:                if (!settings.ssl_enabled) {
        -: 6293:                    fprintf(stderr, "'notls' option is valid only when SSL is enabled\n");
        -: 6294:                    return 1;
        -: 6295:                }
        -: 6296:                ssl_enabled = false;
        -: 6297:                p += strlen(notls) + 1;
        -: 6298:            }
        -: 6299:#endif
        -: 6300:
    #####: 6301:            char *h = NULL;
    #####: 6302:            if (*p == '[') {
        -: 6303:                // expecting it to be an IPv6 address enclosed in []
        -: 6304:                // i.e. RFC3986 style recommended by RFC5952
    #####: 6305:                char *e = strchr(p, ']');
    #####: 6306:                if (e == NULL) {
    #####: 6307:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 6308:                    free(list);
    #####: 6309:                    return 1;
        -: 6310:                }
    #####: 6311:                h = ++p; // skip the opening '['
    #####: 6312:                *e = '\0';
    #####: 6313:                p = ++e; // skip the closing ']'
        -: 6314:            }
        -: 6315:
    #####: 6316:            char *s = strchr(p, ':');
    #####: 6317:            if (s != NULL) {
        -: 6318:                // If no more semicolons - attempt to treat as port number.
        -: 6319:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 6320:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 6321:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 6322:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 6323:                    *s = '\0';
    #####: 6324:                    ++s;
    #####: 6325:                    if (!safe_strtol(s, &the_port)) {
    #####: 6326:                        fprintf(stderr, "Invalid port number: \"%s\"", s);
    #####: 6327:                        free(list);
    #####: 6328:                        return 1;
        -: 6329:                    }
        -: 6330:                }
        -: 6331:            }
        -: 6332:
    #####: 6333:            if (h != NULL)
    #####: 6334:                p = h;
        -: 6335:
    #####: 6336:            if (strcmp(p, "*") == 0) {
    #####: 6337:                p = NULL;
        -: 6338:            }
    #####: 6339:            ret |= server_socket(p, the_port, transport, portnumber_file, ssl_enabled);
        -: 6340:        }
    #####: 6341:        free(list);
    #####: 6342:        return ret;
        -: 6343:    }
        -: 6344:}
------------------
server_sockets:
        1: 6263:static int server_sockets(int port, enum network_transport transport,
        -: 6264:                          FILE *portnumber_file) {
        1: 6265:    bool ssl_enabled = false;
        -: 6266:
        -: 6267:#ifdef TLS
        -: 6268:    const char *notls = "notls";
        -: 6269:    ssl_enabled = settings.ssl_enabled;
        -: 6270:#endif
        -: 6271:
        1: 6272:    if (settings.inter == NULL) {
        1: 6273:        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled);
        -: 6274:    } else {
        -: 6275:        // tokenize them and bind to each one of them..
    #####: 6276:        char *b;
    #####: 6277:        int ret = 0;
    #####: 6278:        char *list = strdup(settings.inter);
        -: 6279:
    #####: 6280:        if (list == NULL) {
    #####: 6281:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 6282:            return 1;
        -: 6283:        }
    #####: 6284:        for (char *p = strtok_r(list, ";,", &b);
        -: 6285:            p != NULL;
    #####: 6286:            p = strtok_r(NULL, ";,", &b)) {
    #####: 6287:            int the_port = port;
        -: 6288:#ifdef TLS
        -: 6289:            ssl_enabled = settings.ssl_enabled;
        -: 6290:            // "notls" option is valid only when memcached is run with SSL enabled.
        -: 6291:            if (strncmp(p, notls, strlen(notls)) == 0) {
        -: 6292:                if (!settings.ssl_enabled) {
        -: 6293:                    fprintf(stderr, "'notls' option is valid only when SSL is enabled\n");
        -: 6294:                    return 1;
        -: 6295:                }
        -: 6296:                ssl_enabled = false;
        -: 6297:                p += strlen(notls) + 1;
        -: 6298:            }
        -: 6299:#endif
        -: 6300:
    #####: 6301:            char *h = NULL;
    #####: 6302:            if (*p == '[') {
        -: 6303:                // expecting it to be an IPv6 address enclosed in []
        -: 6304:                // i.e. RFC3986 style recommended by RFC5952
    #####: 6305:                char *e = strchr(p, ']');
    #####: 6306:                if (e == NULL) {
    #####: 6307:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 6308:                    free(list);
    #####: 6309:                    return 1;
        -: 6310:                }
    #####: 6311:                h = ++p; // skip the opening '['
    #####: 6312:                *e = '\0';
    #####: 6313:                p = ++e; // skip the closing ']'
        -: 6314:            }
        -: 6315:
    #####: 6316:            char *s = strchr(p, ':');
    #####: 6317:            if (s != NULL) {
        -: 6318:                // If no more semicolons - attempt to treat as port number.
        -: 6319:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 6320:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 6321:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 6322:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 6323:                    *s = '\0';
    #####: 6324:                    ++s;
    #####: 6325:                    if (!safe_strtol(s, &the_port)) {
    #####: 6326:                        fprintf(stderr, "Invalid port number: \"%s\"", s);
    #####: 6327:                        free(list);
    #####: 6328:                        return 1;
        -: 6329:                    }
        -: 6330:                }
        -: 6331:            }
        -: 6332:
    #####: 6333:            if (h != NULL)
    #####: 6334:                p = h;
        -: 6335:
    #####: 6336:            if (strcmp(p, "*") == 0) {
    #####: 6337:                p = NULL;
        -: 6338:            }
    #####: 6339:            ret |= server_socket(p, the_port, transport, portnumber_file, ssl_enabled);
        -: 6340:        }
    #####: 6341:        free(list);
    #####: 6342:        return ret;
        -: 6343:    }
        -: 6344:}
------------------
server_sockets:
        1: 6263:static int server_sockets(int port, enum network_transport transport,
        -: 6264:                          FILE *portnumber_file) {
        1: 6265:    bool ssl_enabled = false;
        -: 6266:
        -: 6267:#ifdef TLS
        -: 6268:    const char *notls = "notls";
        -: 6269:    ssl_enabled = settings.ssl_enabled;
        -: 6270:#endif
        -: 6271:
        1: 6272:    if (settings.inter == NULL) {
        1: 6273:        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled);
        -: 6274:    } else {
        -: 6275:        // tokenize them and bind to each one of them..
    #####: 6276:        char *b;
    #####: 6277:        int ret = 0;
    #####: 6278:        char *list = strdup(settings.inter);
        -: 6279:
    #####: 6280:        if (list == NULL) {
    #####: 6281:            fprintf(stderr, "Failed to allocate memory for parsing server interface string\n");
    #####: 6282:            return 1;
        -: 6283:        }
    #####: 6284:        for (char *p = strtok_r(list, ";,", &b);
        -: 6285:            p != NULL;
    #####: 6286:            p = strtok_r(NULL, ";,", &b)) {
    #####: 6287:            int the_port = port;
        -: 6288:#ifdef TLS
        -: 6289:            ssl_enabled = settings.ssl_enabled;
        -: 6290:            // "notls" option is valid only when memcached is run with SSL enabled.
        -: 6291:            if (strncmp(p, notls, strlen(notls)) == 0) {
        -: 6292:                if (!settings.ssl_enabled) {
        -: 6293:                    fprintf(stderr, "'notls' option is valid only when SSL is enabled\n");
        -: 6294:                    return 1;
        -: 6295:                }
        -: 6296:                ssl_enabled = false;
        -: 6297:                p += strlen(notls) + 1;
        -: 6298:            }
        -: 6299:#endif
        -: 6300:
    #####: 6301:            char *h = NULL;
    #####: 6302:            if (*p == '[') {
        -: 6303:                // expecting it to be an IPv6 address enclosed in []
        -: 6304:                // i.e. RFC3986 style recommended by RFC5952
    #####: 6305:                char *e = strchr(p, ']');
    #####: 6306:                if (e == NULL) {
    #####: 6307:                    fprintf(stderr, "Invalid IPV6 address: \"%s\"", p);
    #####: 6308:                    free(list);
    #####: 6309:                    return 1;
        -: 6310:                }
    #####: 6311:                h = ++p; // skip the opening '['
    #####: 6312:                *e = '\0';
    #####: 6313:                p = ++e; // skip the closing ']'
        -: 6314:            }
        -: 6315:
    #####: 6316:            char *s = strchr(p, ':');
    #####: 6317:            if (s != NULL) {
        -: 6318:                // If no more semicolons - attempt to treat as port number.
        -: 6319:                // Otherwise the only valid option is an unenclosed IPv6 without port, until
        -: 6320:                // of course there was an RFC3986 IPv6 address previously specified -
        -: 6321:                // in such a case there is no good option, will just send it to fail as port number.
    #####: 6322:                if (strchr(s + 1, ':') == NULL || h != NULL) {
    #####: 6323:                    *s = '\0';
    #####: 6324:                    ++s;
    #####: 6325:                    if (!safe_strtol(s, &the_port)) {
    #####: 6326:                        fprintf(stderr, "Invalid port number: \"%s\"", s);
    #####: 6327:                        free(list);
    #####: 6328:                        return 1;
        -: 6329:                    }
        -: 6330:                }
        -: 6331:            }
        -: 6332:
    #####: 6333:            if (h != NULL)
    #####: 6334:                p = h;
        -: 6335:
    #####: 6336:            if (strcmp(p, "*") == 0) {
    #####: 6337:                p = NULL;
        -: 6338:            }
    #####: 6339:            ret |= server_socket(p, the_port, transport, portnumber_file, ssl_enabled);
        -: 6340:        }
    #####: 6341:        free(list);
    #####: 6342:        return ret;
        -: 6343:    }
        -: 6344:}
------------------
        -: 6345:
    #####: 6346:static int new_socket_unix(void) {
    #####: 6347:    int sfd;
    #####: 6348:    int flags;
        -: 6349:
    #####: 6350:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 6351:        perror("socket()");
    #####: 6352:        return -1;
        -: 6353:    }
        -: 6354:
    #####: 6355:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
    #####: 6356:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6357:        perror("setting O_NONBLOCK");
    #####: 6358:        close(sfd);
    #####: 6359:        return -1;
        -: 6360:    }
        -: 6361:    return sfd;
        -: 6362:}
------------------
new_socket_unix:
    #####: 6346:static int new_socket_unix(void) {
    #####: 6347:    int sfd;
    #####: 6348:    int flags;
        -: 6349:
    #####: 6350:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 6351:        perror("socket()");
    #####: 6352:        return -1;
        -: 6353:    }
        -: 6354:
    #####: 6355:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
    #####: 6356:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6357:        perror("setting O_NONBLOCK");
    #####: 6358:        close(sfd);
    #####: 6359:        return -1;
        -: 6360:    }
        -: 6361:    return sfd;
        -: 6362:}
------------------
new_socket_unix:
    #####: 6346:static int new_socket_unix(void) {
    #####: 6347:    int sfd;
    #####: 6348:    int flags;
        -: 6349:
    #####: 6350:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 6351:        perror("socket()");
    #####: 6352:        return -1;
        -: 6353:    }
        -: 6354:
    #####: 6355:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
    #####: 6356:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6357:        perror("setting O_NONBLOCK");
    #####: 6358:        close(sfd);
    #####: 6359:        return -1;
        -: 6360:    }
        -: 6361:    return sfd;
        -: 6362:}
------------------
new_socket_unix:
    #####: 6346:static int new_socket_unix(void) {
    #####: 6347:    int sfd;
    #####: 6348:    int flags;
        -: 6349:
    #####: 6350:    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    #####: 6351:        perror("socket()");
    #####: 6352:        return -1;
        -: 6353:    }
        -: 6354:
    #####: 6355:    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
    #####: 6356:        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
    #####: 6357:        perror("setting O_NONBLOCK");
    #####: 6358:        close(sfd);
    #####: 6359:        return -1;
        -: 6360:    }
        -: 6361:    return sfd;
        -: 6362:}
------------------
        -: 6363:
    #####: 6364:static int server_socket_unix(const char *path, int access_mask) {
    #####: 6365:    int sfd;
    #####: 6366:    struct linger ling = {0, 0};
    #####: 6367:    struct sockaddr_un addr;
    #####: 6368:    struct stat tstat;
    #####: 6369:    int flags =1;
    #####: 6370:    int old_umask;
        -: 6371:
    #####: 6372:    if (!path) {
        -: 6373:        return 1;
        -: 6374:    }
        -: 6375:
    #####: 6376:    if ((sfd = new_socket_unix()) == -1) {
        -: 6377:        return 1;
        -: 6378:    }
        -: 6379:
        -: 6380:    /*
        -: 6381:     * Clean up a previous socket file if we left it around
        -: 6382:     */
    #####: 6383:    if (lstat(path, &tstat) == 0) {
    #####: 6384:        if (S_ISSOCK(tstat.st_mode))
    #####: 6385:            unlink(path);
        -: 6386:    }
        -: 6387:
    #####: 6388:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    #####: 6389:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    #####: 6390:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 6391:
        -: 6392:    /*
        -: 6393:     * the memset call clears nonstandard fields in some implementations
        -: 6394:     * that otherwise mess things up.
        -: 6395:     */
    #####: 6396:    memset(&addr, 0, sizeof(addr));
        -: 6397:
    #####: 6398:    addr.sun_family = AF_UNIX;
    #####: 6399:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    #####: 6400:    assert(strcmp(addr.sun_path, path) == 0);
    #####: 6401:    old_umask = umask( ~(access_mask&0777));
    #####: 6402:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 6403:        perror("bind()");
    #####: 6404:        close(sfd);
    #####: 6405:        umask(old_umask);
    #####: 6406:        return 1;
        -: 6407:    }
    #####: 6408:    umask(old_umask);
    #####: 6409:    if (listen(sfd, settings.backlog) == -1) {
    #####: 6410:        perror("listen()");
    #####: 6411:        close(sfd);
    #####: 6412:        return 1;
        -: 6413:    }
    #####: 6414:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 6415:                                 EV_READ | EV_PERSIST, 1,
        -: 6416:                                 local_transport, main_base, NULL))) {
    #####: 6417:        fprintf(stderr, "failed to create listening connection\n");
    #####: 6418:        exit(EXIT_FAILURE);
        -: 6419:    }
        -: 6420:
        -: 6421:    return 0;
        -: 6422:}
------------------
server_socket_unix:
    #####: 6364:static int server_socket_unix(const char *path, int access_mask) {
    #####: 6365:    int sfd;
    #####: 6366:    struct linger ling = {0, 0};
    #####: 6367:    struct sockaddr_un addr;
    #####: 6368:    struct stat tstat;
    #####: 6369:    int flags =1;
    #####: 6370:    int old_umask;
        -: 6371:
    #####: 6372:    if (!path) {
        -: 6373:        return 1;
        -: 6374:    }
        -: 6375:
    #####: 6376:    if ((sfd = new_socket_unix()) == -1) {
        -: 6377:        return 1;
        -: 6378:    }
        -: 6379:
        -: 6380:    /*
        -: 6381:     * Clean up a previous socket file if we left it around
        -: 6382:     */
    #####: 6383:    if (lstat(path, &tstat) == 0) {
    #####: 6384:        if (S_ISSOCK(tstat.st_mode))
    #####: 6385:            unlink(path);
        -: 6386:    }
        -: 6387:
    #####: 6388:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    #####: 6389:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    #####: 6390:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 6391:
        -: 6392:    /*
        -: 6393:     * the memset call clears nonstandard fields in some implementations
        -: 6394:     * that otherwise mess things up.
        -: 6395:     */
    #####: 6396:    memset(&addr, 0, sizeof(addr));
        -: 6397:
    #####: 6398:    addr.sun_family = AF_UNIX;
    #####: 6399:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    #####: 6400:    assert(strcmp(addr.sun_path, path) == 0);
    #####: 6401:    old_umask = umask( ~(access_mask&0777));
    #####: 6402:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 6403:        perror("bind()");
    #####: 6404:        close(sfd);
    #####: 6405:        umask(old_umask);
    #####: 6406:        return 1;
        -: 6407:    }
    #####: 6408:    umask(old_umask);
    #####: 6409:    if (listen(sfd, settings.backlog) == -1) {
    #####: 6410:        perror("listen()");
    #####: 6411:        close(sfd);
    #####: 6412:        return 1;
        -: 6413:    }
    #####: 6414:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 6415:                                 EV_READ | EV_PERSIST, 1,
        -: 6416:                                 local_transport, main_base, NULL))) {
    #####: 6417:        fprintf(stderr, "failed to create listening connection\n");
    #####: 6418:        exit(EXIT_FAILURE);
        -: 6419:    }
        -: 6420:
        -: 6421:    return 0;
        -: 6422:}
------------------
server_socket_unix:
    #####: 6364:static int server_socket_unix(const char *path, int access_mask) {
    #####: 6365:    int sfd;
    #####: 6366:    struct linger ling = {0, 0};
    #####: 6367:    struct sockaddr_un addr;
    #####: 6368:    struct stat tstat;
    #####: 6369:    int flags =1;
    #####: 6370:    int old_umask;
        -: 6371:
    #####: 6372:    if (!path) {
        -: 6373:        return 1;
        -: 6374:    }
        -: 6375:
    #####: 6376:    if ((sfd = new_socket_unix()) == -1) {
        -: 6377:        return 1;
        -: 6378:    }
        -: 6379:
        -: 6380:    /*
        -: 6381:     * Clean up a previous socket file if we left it around
        -: 6382:     */
    #####: 6383:    if (lstat(path, &tstat) == 0) {
    #####: 6384:        if (S_ISSOCK(tstat.st_mode))
    #####: 6385:            unlink(path);
        -: 6386:    }
        -: 6387:
    #####: 6388:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    #####: 6389:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    #####: 6390:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 6391:
        -: 6392:    /*
        -: 6393:     * the memset call clears nonstandard fields in some implementations
        -: 6394:     * that otherwise mess things up.
        -: 6395:     */
    #####: 6396:    memset(&addr, 0, sizeof(addr));
        -: 6397:
    #####: 6398:    addr.sun_family = AF_UNIX;
    #####: 6399:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    #####: 6400:    assert(strcmp(addr.sun_path, path) == 0);
    #####: 6401:    old_umask = umask( ~(access_mask&0777));
    #####: 6402:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 6403:        perror("bind()");
    #####: 6404:        close(sfd);
    #####: 6405:        umask(old_umask);
    #####: 6406:        return 1;
        -: 6407:    }
    #####: 6408:    umask(old_umask);
    #####: 6409:    if (listen(sfd, settings.backlog) == -1) {
    #####: 6410:        perror("listen()");
    #####: 6411:        close(sfd);
    #####: 6412:        return 1;
        -: 6413:    }
    #####: 6414:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 6415:                                 EV_READ | EV_PERSIST, 1,
        -: 6416:                                 local_transport, main_base, NULL))) {
    #####: 6417:        fprintf(stderr, "failed to create listening connection\n");
    #####: 6418:        exit(EXIT_FAILURE);
        -: 6419:    }
        -: 6420:
        -: 6421:    return 0;
        -: 6422:}
------------------
server_socket_unix:
    #####: 6364:static int server_socket_unix(const char *path, int access_mask) {
    #####: 6365:    int sfd;
    #####: 6366:    struct linger ling = {0, 0};
    #####: 6367:    struct sockaddr_un addr;
    #####: 6368:    struct stat tstat;
    #####: 6369:    int flags =1;
    #####: 6370:    int old_umask;
        -: 6371:
    #####: 6372:    if (!path) {
        -: 6373:        return 1;
        -: 6374:    }
        -: 6375:
    #####: 6376:    if ((sfd = new_socket_unix()) == -1) {
        -: 6377:        return 1;
        -: 6378:    }
        -: 6379:
        -: 6380:    /*
        -: 6381:     * Clean up a previous socket file if we left it around
        -: 6382:     */
    #####: 6383:    if (lstat(path, &tstat) == 0) {
    #####: 6384:        if (S_ISSOCK(tstat.st_mode))
    #####: 6385:            unlink(path);
        -: 6386:    }
        -: 6387:
    #####: 6388:    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    #####: 6389:    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    #####: 6390:    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
        -: 6391:
        -: 6392:    /*
        -: 6393:     * the memset call clears nonstandard fields in some implementations
        -: 6394:     * that otherwise mess things up.
        -: 6395:     */
    #####: 6396:    memset(&addr, 0, sizeof(addr));
        -: 6397:
    #####: 6398:    addr.sun_family = AF_UNIX;
    #####: 6399:    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    #####: 6400:    assert(strcmp(addr.sun_path, path) == 0);
    #####: 6401:    old_umask = umask( ~(access_mask&0777));
    #####: 6402:    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    #####: 6403:        perror("bind()");
    #####: 6404:        close(sfd);
    #####: 6405:        umask(old_umask);
    #####: 6406:        return 1;
        -: 6407:    }
    #####: 6408:    umask(old_umask);
    #####: 6409:    if (listen(sfd, settings.backlog) == -1) {
    #####: 6410:        perror("listen()");
    #####: 6411:        close(sfd);
    #####: 6412:        return 1;
        -: 6413:    }
    #####: 6414:    if (!(listen_conn = conn_new(sfd, conn_listening,
        -: 6415:                                 EV_READ | EV_PERSIST, 1,
        -: 6416:                                 local_transport, main_base, NULL))) {
    #####: 6417:        fprintf(stderr, "failed to create listening connection\n");
    #####: 6418:        exit(EXIT_FAILURE);
        -: 6419:    }
        -: 6420:
        -: 6421:    return 0;
        -: 6422:}
------------------
        -: 6423:
        -: 6424:/*
        -: 6425: * We keep the current time of day in a global variable that's updated by a
        -: 6426: * timer event. This saves us a bunch of time() system calls (we really only
        -: 6427: * need to get the time once a second, whereas there can be tens of thousands
        -: 6428: * of requests a second) and allows us to use server-start-relative timestamps
        -: 6429: * rather than absolute UNIX timestamps, a space savings on systems where
        -: 6430: * sizeof(time_t) > sizeof(unsigned int).
        -: 6431: */
        -: 6432:volatile rel_time_t current_time;
        -: 6433:static struct event clockevent;
        -: 6434:
        -: 6435:/* libevent uses a monotonic clock when available for event scheduling. Aside
        -: 6436: * from jitter, simply ticking our internal timer here is accurate enough.
        -: 6437: * Note that users who are setting explicit dates for expiration times *must*
        -: 6438: * ensure their clocks are correct before starting memcached. */
       12: 6439:static void clock_handler(const int fd, const short which, void *arg) {
       12: 6440:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
       12: 6441:    static bool initialized = false;
        -: 6442:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
       12: 6443:    static bool monotonic = false;
       12: 6444:    static time_t monotonic_start;
        -: 6445:#endif
        -: 6446:
       12: 6447:    if (initialized) {
        -: 6448:        /* only delete the event if it's actually there. */
        9: 6449:        evtimer_del(&clockevent);
        -: 6450:    } else {
        3: 6451:        initialized = true;
        -: 6452:        /* process_started is initialized to time() - 2. We initialize to 1 so
        -: 6453:         * flush_all won't underflow during tests. */
        -: 6454:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        3: 6455:        struct timespec ts;
        3: 6456:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
        3: 6457:            monotonic = true;
        3: 6458:            monotonic_start = ts.tv_sec - ITEM_UPDATE_INTERVAL - 2;
        -: 6459:        }
        -: 6460:#endif
        -: 6461:    }
        -: 6462:
        -: 6463:    // While we're here, check for hash table expansion.
        -: 6464:    // This function should be quick to avoid delaying the timer.
       12: 6465:    assoc_start_expand(stats_state.curr_items);
        -: 6466:    // also, if HUP'ed we need to do some maintenance.
        -: 6467:    // for now that's just the authfile reload.
       12: 6468:    if (settings.sig_hup) {
    #####: 6469:        settings.sig_hup = false;
        -: 6470:
    #####: 6471:        authfile_load(settings.auth_file);
        -: 6472:    }
        -: 6473:
       12: 6474:    evtimer_set(&clockevent, clock_handler, 0);
       12: 6475:    event_base_set(main_base, &clockevent);
       12: 6476:    evtimer_add(&clockevent, &t);
        -: 6477:
        -: 6478:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
       12: 6479:    if (monotonic) {
       12: 6480:        struct timespec ts;
       12: 6481:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 6482:            return;
       12: 6483:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
       12: 6484:        return;
        -: 6485:    }
        -: 6486:#endif
        -: 6487:    {
    #####: 6488:        struct timeval tv;
    #####: 6489:        gettimeofday(&tv, NULL);
    #####: 6490:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 6491:    }
        -: 6492:}
------------------
clock_handler:
        4: 6439:static void clock_handler(const int fd, const short which, void *arg) {
        4: 6440:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
        4: 6441:    static bool initialized = false;
        -: 6442:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        4: 6443:    static bool monotonic = false;
        4: 6444:    static time_t monotonic_start;
        -: 6445:#endif
        -: 6446:
        4: 6447:    if (initialized) {
        -: 6448:        /* only delete the event if it's actually there. */
        3: 6449:        evtimer_del(&clockevent);
        -: 6450:    } else {
        1: 6451:        initialized = true;
        -: 6452:        /* process_started is initialized to time() - 2. We initialize to 1 so
        -: 6453:         * flush_all won't underflow during tests. */
        -: 6454:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        1: 6455:        struct timespec ts;
        1: 6456:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
        1: 6457:            monotonic = true;
        1: 6458:            monotonic_start = ts.tv_sec - ITEM_UPDATE_INTERVAL - 2;
        -: 6459:        }
        -: 6460:#endif
        -: 6461:    }
        -: 6462:
        -: 6463:    // While we're here, check for hash table expansion.
        -: 6464:    // This function should be quick to avoid delaying the timer.
        4: 6465:    assoc_start_expand(stats_state.curr_items);
        -: 6466:    // also, if HUP'ed we need to do some maintenance.
        -: 6467:    // for now that's just the authfile reload.
        4: 6468:    if (settings.sig_hup) {
    #####: 6469:        settings.sig_hup = false;
        -: 6470:
    #####: 6471:        authfile_load(settings.auth_file);
        -: 6472:    }
        -: 6473:
        4: 6474:    evtimer_set(&clockevent, clock_handler, 0);
        4: 6475:    event_base_set(main_base, &clockevent);
        4: 6476:    evtimer_add(&clockevent, &t);
        -: 6477:
        -: 6478:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        4: 6479:    if (monotonic) {
        4: 6480:        struct timespec ts;
        4: 6481:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 6482:            return;
        4: 6483:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
        4: 6484:        return;
        -: 6485:    }
        -: 6486:#endif
        -: 6487:    {
    #####: 6488:        struct timeval tv;
    #####: 6489:        gettimeofday(&tv, NULL);
    #####: 6490:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 6491:    }
        -: 6492:}
------------------
clock_handler:
        4: 6439:static void clock_handler(const int fd, const short which, void *arg) {
        4: 6440:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
        4: 6441:    static bool initialized = false;
        -: 6442:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        4: 6443:    static bool monotonic = false;
        4: 6444:    static time_t monotonic_start;
        -: 6445:#endif
        -: 6446:
        4: 6447:    if (initialized) {
        -: 6448:        /* only delete the event if it's actually there. */
        3: 6449:        evtimer_del(&clockevent);
        -: 6450:    } else {
        1: 6451:        initialized = true;
        -: 6452:        /* process_started is initialized to time() - 2. We initialize to 1 so
        -: 6453:         * flush_all won't underflow during tests. */
        -: 6454:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        1: 6455:        struct timespec ts;
        1: 6456:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
        1: 6457:            monotonic = true;
        1: 6458:            monotonic_start = ts.tv_sec - ITEM_UPDATE_INTERVAL - 2;
        -: 6459:        }
        -: 6460:#endif
        -: 6461:    }
        -: 6462:
        -: 6463:    // While we're here, check for hash table expansion.
        -: 6464:    // This function should be quick to avoid delaying the timer.
        4: 6465:    assoc_start_expand(stats_state.curr_items);
        -: 6466:    // also, if HUP'ed we need to do some maintenance.
        -: 6467:    // for now that's just the authfile reload.
        4: 6468:    if (settings.sig_hup) {
    #####: 6469:        settings.sig_hup = false;
        -: 6470:
    #####: 6471:        authfile_load(settings.auth_file);
        -: 6472:    }
        -: 6473:
        4: 6474:    evtimer_set(&clockevent, clock_handler, 0);
        4: 6475:    event_base_set(main_base, &clockevent);
        4: 6476:    evtimer_add(&clockevent, &t);
        -: 6477:
        -: 6478:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        4: 6479:    if (monotonic) {
        4: 6480:        struct timespec ts;
        4: 6481:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 6482:            return;
        4: 6483:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
        4: 6484:        return;
        -: 6485:    }
        -: 6486:#endif
        -: 6487:    {
    #####: 6488:        struct timeval tv;
    #####: 6489:        gettimeofday(&tv, NULL);
    #####: 6490:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 6491:    }
        -: 6492:}
------------------
clock_handler:
        4: 6439:static void clock_handler(const int fd, const short which, void *arg) {
        4: 6440:    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
        4: 6441:    static bool initialized = false;
        -: 6442:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        4: 6443:    static bool monotonic = false;
        4: 6444:    static time_t monotonic_start;
        -: 6445:#endif
        -: 6446:
        4: 6447:    if (initialized) {
        -: 6448:        /* only delete the event if it's actually there. */
        3: 6449:        evtimer_del(&clockevent);
        -: 6450:    } else {
        1: 6451:        initialized = true;
        -: 6452:        /* process_started is initialized to time() - 2. We initialize to 1 so
        -: 6453:         * flush_all won't underflow during tests. */
        -: 6454:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        1: 6455:        struct timespec ts;
        1: 6456:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
        1: 6457:            monotonic = true;
        1: 6458:            monotonic_start = ts.tv_sec - ITEM_UPDATE_INTERVAL - 2;
        -: 6459:        }
        -: 6460:#endif
        -: 6461:    }
        -: 6462:
        -: 6463:    // While we're here, check for hash table expansion.
        -: 6464:    // This function should be quick to avoid delaying the timer.
        4: 6465:    assoc_start_expand(stats_state.curr_items);
        -: 6466:    // also, if HUP'ed we need to do some maintenance.
        -: 6467:    // for now that's just the authfile reload.
        4: 6468:    if (settings.sig_hup) {
    #####: 6469:        settings.sig_hup = false;
        -: 6470:
    #####: 6471:        authfile_load(settings.auth_file);
        -: 6472:    }
        -: 6473:
        4: 6474:    evtimer_set(&clockevent, clock_handler, 0);
        4: 6475:    event_base_set(main_base, &clockevent);
        4: 6476:    evtimer_add(&clockevent, &t);
        -: 6477:
        -: 6478:#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
        4: 6479:    if (monotonic) {
        4: 6480:        struct timespec ts;
        4: 6481:        if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
        -: 6482:            return;
        4: 6483:        current_time = (rel_time_t) (ts.tv_sec - monotonic_start);
        4: 6484:        return;
        -: 6485:    }
        -: 6486:#endif
        -: 6487:    {
    #####: 6488:        struct timeval tv;
    #####: 6489:        gettimeofday(&tv, NULL);
    #####: 6490:        current_time = (rel_time_t) (tv.tv_sec - process_started);
        -: 6491:    }
        -: 6492:}
------------------
        -: 6493:
    #####: 6494:static void usage(void) {
    #####: 6495:    printf(PACKAGE " " VERSION "\n");
    #####: 6496:    printf("-p, --port=<num>          TCP port to listen on (default: 11211)\n"
        -: 6497:           "-U, --udp-port=<num>      UDP port to listen on (default: 0, off)\n"
        -: 6498:           "-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n"
        -: 6499:           "-A, --enable-shutdown     enable ascii \"shutdown\" command\n"
        -: 6500:           "-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: 0700)\n"
        -: 6501:           "-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n"
        -: 6502:#ifdef TLS
        -: 6503:           "                          if TLS/SSL is enabled, 'notls' prefix can be used to\n"
        -: 6504:           "                          disable for specific listeners (-l notls:<ip>:<port>) \n"
        -: 6505:#endif
        -: 6506:           "-d, --daemon              run as a daemon\n"
        -: 6507:           "-r, --enable-coredumps    maximize core file limit\n"
        -: 6508:           "-u, --user=<user>         assume identity of <username> (only when run as root)\n"
        -: 6509:           "-m, --memory-limit=<num>  item memory in megabytes (default: 64 MB)\n"
        -: 6510:           "-M, --disable-evictions   return error on memory exhausted instead of evicting\n"
        -: 6511:           "-c, --conn-limit=<num>    max simultaneous connections (default: 1024)\n"
        -: 6512:           "-k, --lock-memory         lock down all paged memory\n"
        -: 6513:           "-v, --verbose             verbose (print errors/warnings while in event loop)\n"
        -: 6514:           "-vv                       very verbose (also print client commands/responses)\n"
        -: 6515:           "-vvv                      extremely verbose (internal state transitions)\n"
        -: 6516:           "-h, --help                print this help and exit\n"
        -: 6517:           "-i, --license             print memcached and libevent license\n"
        -: 6518:           "-V, --version             print version and exit\n"
        -: 6519:           "-P, --pidfile=<file>      save PID in <file>, only used with -d option\n"
        -: 6520:           "-f, --slab-growth-factor=<num> chunk size growth factor (default: 1.25)\n"
        -: 6521:           "-n, --slab-min-size=<bytes> min space used for key+value+flags (default: 48)\n");
    #####: 6522:    printf("-L, --enable-largepages  try to use large memory pages (if available)\n");
    #####: 6523:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 6524:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 6525:           "              \":\" (colon). If this option is specified, stats collection\n"
        -: 6526:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 6527:           "              by sending the \"stats detail on\" command to the server.\n");
    #####: 6528:    printf("-t, --threads=<num>       number of threads to use (default: 4)\n");
    #####: 6529:    printf("-R, --max-reqs-per-event  maximum number of requests per event, limits the\n"
        -: 6530:           "                          requests processed per connection to prevent \n"
        -: 6531:           "                          starvation (default: 20)\n");
    #####: 6532:    printf("-C, --disable-cas         disable use of CAS\n");
    #####: 6533:    printf("-b, --listen-backlog=<num> set the backlog queue limit (default: 1024)\n");
    #####: 6534:    printf("-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default)\n");
    #####: 6535:    printf("-I, --max-item-size=<num> adjusts max item size\n"
        -: 6536:           "                          (default: 1mb, min: 1k, max: 1024m)\n");
        -: 6537:#ifdef ENABLE_SASL
        -: 6538:    printf("-S, --enable-sasl         turn on Sasl authentication\n");
        -: 6539:#endif
    #####: 6540:    printf("-F, --disable-flush-all   disable flush_all command\n");
    #####: 6541:    printf("-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\n");
    #####: 6542:    printf("-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\n"
        -: 6543:           "                          user:pass\\nuser2:pass2\\n\n");
        -: 6544:#ifdef TLS
        -: 6545:    printf("-Z, --enable-ssl          enable TLS/SSL\n");
        -: 6546:#endif
    #####: 6547:    printf("-o, --extended            comma separated list of extended options\n"
        -: 6548:           "                          most options have a 'no_' prefix to disable\n"
        -: 6549:           "   - maxconns_fast:       immediately close new connections after limit\n"
        -: 6550:           "   - hashpower:           an integer multiplier for how large the hash\n"
        -: 6551:           "                          table should be. normally grows at runtime.\n"
        -: 6552:           "                          set based on \"STAT hash_power_level\"\n"
        -: 6553:           "   - tail_repair_time:    time in seconds for how long to wait before\n"
        -: 6554:           "                          forcefully killing LRU tail item.\n"
        -: 6555:           "                          disabled by default; very dangerous option.\n"
        -: 6556:           "   - hash_algorithm:      the hash table algorithm\n"
        -: 6557:           "                          default is murmur3 hash. options: jenkins, murmur3\n"
        -: 6558:           "   - lru_crawler:         enable LRU Crawler background thread\n"
        -: 6559:           "   - lru_crawler_sleep:   microseconds to sleep between items\n"
        -: 6560:           "                          default is 100.\n"
        -: 6561:           "   - lru_crawler_tocrawl: max items to crawl per slab per run\n"
        -: 6562:           "                          default is 0 (unlimited)\n"
        -: 6563:           "   - lru_maintainer:      enable new LRU system + background thread\n"
        -: 6564:           "   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\n"
        -: 6565:           "                          (requires lru_maintainer)\n"
        -: 6566:           "   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\n"
        -: 6567:           "                          (requires lru_maintainer)\n"
        -: 6568:           "   - hot_max_factor:      items idle > cold lru age * drop from hot lru.\n"
        -: 6569:           "   - warm_max_factor:     items idle > cold lru age * this drop from warm.\n"
        -: 6570:           "   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\n"
        -: 6571:           "                          (requires lru_maintainer)\n"
        -: 6572:           "   - idle_timeout:        timeout for idle connections\n"
        -: 6573:           "   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size. use extreme care.\n"
        -: 6574:           "   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer.\n"
        -: 6575:           "   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\n"
        -: 6576:           "                          read by background thread, then written to watchers.\n"
        -: 6577:           "   - track_sizes:         enable dynamic reports for 'stats sizes' command.\n"
        -: 6578:           "   - no_hashexpand:       disables hash table expansion (dangerous)\n"
        -: 6579:           "   - modern:              enables options which will be default in future.\n"
        -: 6580:           "             currently: nothing\n"
        -: 6581:           "   - no_modern:           uses defaults of previous major version (1.4.x)\n"
        -: 6582:#ifdef HAVE_DROP_PRIVILEGES
        -: 6583:           "   - drop_privileges:     enable dropping extra syscall privileges\n"
        -: 6584:           "   - no_drop_privileges:  disable drop_privileges in case it causes issues with\n"
        -: 6585:           "                          some customisation.\n"
        -: 6586:#ifdef MEMCACHED_DEBUG
        -: 6587:           "   - relaxed_privileges: Running tests requires extra privileges.\n"
        -: 6588:#endif
        -: 6589:#endif
        -: 6590:#ifdef EXTSTORE
        -: 6591:           "   - ext_path:            file to write to for external storage.\n"
        -: 6592:           "                          ie: ext_path=/mnt/d1/extstore:1G\n"
        -: 6593:           "   - ext_page_size:       size in megabytes of storage pages.\n"
        -: 6594:           "   - ext_wbuf_size:       size in megabytes of page write buffers.\n"
        -: 6595:           "   - ext_threads:         number of IO threads to run.\n"
        -: 6596:           "   - ext_item_size:       store items larger than this (bytes)\n"
        -: 6597:           "   - ext_item_age:        store items idle at least this long\n"
        -: 6598:           "   - ext_low_ttl:         consider TTLs lower than this specially\n"
        -: 6599:           "   - ext_drop_unread:     don't re-write unread values during compaction\n"
        -: 6600:           "   - ext_recache_rate:    recache an item every N accesses\n"
        -: 6601:           "   - ext_compact_under:   compact when fewer than this many free pages\n"
        -: 6602:           "   - ext_drop_under:      drop COLD items when fewer than this many free pages\n"
        -: 6603:           "   - ext_max_frag:        max page fragmentation to tolerage\n"
        -: 6604:           "   - slab_automove_freeratio: ratio of memory to hold free as buffer.\n"
        -: 6605:           "                          (see doc/storage.txt for more info)\n"
        -: 6606:#endif
        -: 6607:#ifdef TLS
        -: 6608:           "   - ssl_chain_cert:      certificate chain file in PEM format\n"
        -: 6609:           "   - ssl_key:             private key, if not part of the -ssl_chain_cert\n"
        -: 6610:           "   - ssl_keyformat:         private key format (PEM, DER or ENGINE) PEM default\n"
        -: 6611:           "   - ssl_verify_mode:     peer certificate verification mode, default is 0(None).\n"
        -: 6612:           "                          valid values are 0(None), 1(Request), 2(Require)\n"
        -: 6613:           "                          or 3(Once)\n"
        -: 6614:           "   - ssl_ciphers:         specify cipher list to be used\n"
        -: 6615:           "   - ssl_ca_cert:         PEM format file of acceptable client CA's\n"
        -: 6616:           "   - ssl_wbuf_size:       size in kilobytes of per-connection SSL output buffer\n"
        -: 6617:#endif
        -: 6618:           );
    #####: 6619:    return;
        -: 6620:}
------------------
usage:
    #####: 6494:static void usage(void) {
    #####: 6495:    printf(PACKAGE " " VERSION "\n");
    #####: 6496:    printf("-p, --port=<num>          TCP port to listen on (default: 11211)\n"
        -: 6497:           "-U, --udp-port=<num>      UDP port to listen on (default: 0, off)\n"
        -: 6498:           "-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n"
        -: 6499:           "-A, --enable-shutdown     enable ascii \"shutdown\" command\n"
        -: 6500:           "-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: 0700)\n"
        -: 6501:           "-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n"
        -: 6502:#ifdef TLS
        -: 6503:           "                          if TLS/SSL is enabled, 'notls' prefix can be used to\n"
        -: 6504:           "                          disable for specific listeners (-l notls:<ip>:<port>) \n"
        -: 6505:#endif
        -: 6506:           "-d, --daemon              run as a daemon\n"
        -: 6507:           "-r, --enable-coredumps    maximize core file limit\n"
        -: 6508:           "-u, --user=<user>         assume identity of <username> (only when run as root)\n"
        -: 6509:           "-m, --memory-limit=<num>  item memory in megabytes (default: 64 MB)\n"
        -: 6510:           "-M, --disable-evictions   return error on memory exhausted instead of evicting\n"
        -: 6511:           "-c, --conn-limit=<num>    max simultaneous connections (default: 1024)\n"
        -: 6512:           "-k, --lock-memory         lock down all paged memory\n"
        -: 6513:           "-v, --verbose             verbose (print errors/warnings while in event loop)\n"
        -: 6514:           "-vv                       very verbose (also print client commands/responses)\n"
        -: 6515:           "-vvv                      extremely verbose (internal state transitions)\n"
        -: 6516:           "-h, --help                print this help and exit\n"
        -: 6517:           "-i, --license             print memcached and libevent license\n"
        -: 6518:           "-V, --version             print version and exit\n"
        -: 6519:           "-P, --pidfile=<file>      save PID in <file>, only used with -d option\n"
        -: 6520:           "-f, --slab-growth-factor=<num> chunk size growth factor (default: 1.25)\n"
        -: 6521:           "-n, --slab-min-size=<bytes> min space used for key+value+flags (default: 48)\n");
    #####: 6522:    printf("-L, --enable-largepages  try to use large memory pages (if available)\n");
    #####: 6523:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 6524:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 6525:           "              \":\" (colon). If this option is specified, stats collection\n"
        -: 6526:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 6527:           "              by sending the \"stats detail on\" command to the server.\n");
    #####: 6528:    printf("-t, --threads=<num>       number of threads to use (default: 4)\n");
    #####: 6529:    printf("-R, --max-reqs-per-event  maximum number of requests per event, limits the\n"
        -: 6530:           "                          requests processed per connection to prevent \n"
        -: 6531:           "                          starvation (default: 20)\n");
    #####: 6532:    printf("-C, --disable-cas         disable use of CAS\n");
    #####: 6533:    printf("-b, --listen-backlog=<num> set the backlog queue limit (default: 1024)\n");
    #####: 6534:    printf("-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default)\n");
    #####: 6535:    printf("-I, --max-item-size=<num> adjusts max item size\n"
        -: 6536:           "                          (default: 1mb, min: 1k, max: 1024m)\n");
        -: 6537:#ifdef ENABLE_SASL
        -: 6538:    printf("-S, --enable-sasl         turn on Sasl authentication\n");
        -: 6539:#endif
    #####: 6540:    printf("-F, --disable-flush-all   disable flush_all command\n");
    #####: 6541:    printf("-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\n");
    #####: 6542:    printf("-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\n"
        -: 6543:           "                          user:pass\\nuser2:pass2\\n\n");
        -: 6544:#ifdef TLS
        -: 6545:    printf("-Z, --enable-ssl          enable TLS/SSL\n");
        -: 6546:#endif
    #####: 6547:    printf("-o, --extended            comma separated list of extended options\n"
        -: 6548:           "                          most options have a 'no_' prefix to disable\n"
        -: 6549:           "   - maxconns_fast:       immediately close new connections after limit\n"
        -: 6550:           "   - hashpower:           an integer multiplier for how large the hash\n"
        -: 6551:           "                          table should be. normally grows at runtime.\n"
        -: 6552:           "                          set based on \"STAT hash_power_level\"\n"
        -: 6553:           "   - tail_repair_time:    time in seconds for how long to wait before\n"
        -: 6554:           "                          forcefully killing LRU tail item.\n"
        -: 6555:           "                          disabled by default; very dangerous option.\n"
        -: 6556:           "   - hash_algorithm:      the hash table algorithm\n"
        -: 6557:           "                          default is murmur3 hash. options: jenkins, murmur3\n"
        -: 6558:           "   - lru_crawler:         enable LRU Crawler background thread\n"
        -: 6559:           "   - lru_crawler_sleep:   microseconds to sleep between items\n"
        -: 6560:           "                          default is 100.\n"
        -: 6561:           "   - lru_crawler_tocrawl: max items to crawl per slab per run\n"
        -: 6562:           "                          default is 0 (unlimited)\n"
        -: 6563:           "   - lru_maintainer:      enable new LRU system + background thread\n"
        -: 6564:           "   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\n"
        -: 6565:           "                          (requires lru_maintainer)\n"
        -: 6566:           "   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\n"
        -: 6567:           "                          (requires lru_maintainer)\n"
        -: 6568:           "   - hot_max_factor:      items idle > cold lru age * drop from hot lru.\n"
        -: 6569:           "   - warm_max_factor:     items idle > cold lru age * this drop from warm.\n"
        -: 6570:           "   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\n"
        -: 6571:           "                          (requires lru_maintainer)\n"
        -: 6572:           "   - idle_timeout:        timeout for idle connections\n"
        -: 6573:           "   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size. use extreme care.\n"
        -: 6574:           "   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer.\n"
        -: 6575:           "   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\n"
        -: 6576:           "                          read by background thread, then written to watchers.\n"
        -: 6577:           "   - track_sizes:         enable dynamic reports for 'stats sizes' command.\n"
        -: 6578:           "   - no_hashexpand:       disables hash table expansion (dangerous)\n"
        -: 6579:           "   - modern:              enables options which will be default in future.\n"
        -: 6580:           "             currently: nothing\n"
        -: 6581:           "   - no_modern:           uses defaults of previous major version (1.4.x)\n"
        -: 6582:#ifdef HAVE_DROP_PRIVILEGES
        -: 6583:           "   - drop_privileges:     enable dropping extra syscall privileges\n"
        -: 6584:           "   - no_drop_privileges:  disable drop_privileges in case it causes issues with\n"
        -: 6585:           "                          some customisation.\n"
        -: 6586:#ifdef MEMCACHED_DEBUG
        -: 6587:           "   - relaxed_privileges: Running tests requires extra privileges.\n"
        -: 6588:#endif
        -: 6589:#endif
        -: 6590:#ifdef EXTSTORE
        -: 6591:           "   - ext_path:            file to write to for external storage.\n"
        -: 6592:           "                          ie: ext_path=/mnt/d1/extstore:1G\n"
        -: 6593:           "   - ext_page_size:       size in megabytes of storage pages.\n"
        -: 6594:           "   - ext_wbuf_size:       size in megabytes of page write buffers.\n"
        -: 6595:           "   - ext_threads:         number of IO threads to run.\n"
        -: 6596:           "   - ext_item_size:       store items larger than this (bytes)\n"
        -: 6597:           "   - ext_item_age:        store items idle at least this long\n"
        -: 6598:           "   - ext_low_ttl:         consider TTLs lower than this specially\n"
        -: 6599:           "   - ext_drop_unread:     don't re-write unread values during compaction\n"
        -: 6600:           "   - ext_recache_rate:    recache an item every N accesses\n"
        -: 6601:           "   - ext_compact_under:   compact when fewer than this many free pages\n"
        -: 6602:           "   - ext_drop_under:      drop COLD items when fewer than this many free pages\n"
        -: 6603:           "   - ext_max_frag:        max page fragmentation to tolerage\n"
        -: 6604:           "   - slab_automove_freeratio: ratio of memory to hold free as buffer.\n"
        -: 6605:           "                          (see doc/storage.txt for more info)\n"
        -: 6606:#endif
        -: 6607:#ifdef TLS
        -: 6608:           "   - ssl_chain_cert:      certificate chain file in PEM format\n"
        -: 6609:           "   - ssl_key:             private key, if not part of the -ssl_chain_cert\n"
        -: 6610:           "   - ssl_keyformat:         private key format (PEM, DER or ENGINE) PEM default\n"
        -: 6611:           "   - ssl_verify_mode:     peer certificate verification mode, default is 0(None).\n"
        -: 6612:           "                          valid values are 0(None), 1(Request), 2(Require)\n"
        -: 6613:           "                          or 3(Once)\n"
        -: 6614:           "   - ssl_ciphers:         specify cipher list to be used\n"
        -: 6615:           "   - ssl_ca_cert:         PEM format file of acceptable client CA's\n"
        -: 6616:           "   - ssl_wbuf_size:       size in kilobytes of per-connection SSL output buffer\n"
        -: 6617:#endif
        -: 6618:           );
    #####: 6619:    return;
        -: 6620:}
------------------
usage:
    #####: 6494:static void usage(void) {
    #####: 6495:    printf(PACKAGE " " VERSION "\n");
    #####: 6496:    printf("-p, --port=<num>          TCP port to listen on (default: 11211)\n"
        -: 6497:           "-U, --udp-port=<num>      UDP port to listen on (default: 0, off)\n"
        -: 6498:           "-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n"
        -: 6499:           "-A, --enable-shutdown     enable ascii \"shutdown\" command\n"
        -: 6500:           "-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: 0700)\n"
        -: 6501:           "-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n"
        -: 6502:#ifdef TLS
        -: 6503:           "                          if TLS/SSL is enabled, 'notls' prefix can be used to\n"
        -: 6504:           "                          disable for specific listeners (-l notls:<ip>:<port>) \n"
        -: 6505:#endif
        -: 6506:           "-d, --daemon              run as a daemon\n"
        -: 6507:           "-r, --enable-coredumps    maximize core file limit\n"
        -: 6508:           "-u, --user=<user>         assume identity of <username> (only when run as root)\n"
        -: 6509:           "-m, --memory-limit=<num>  item memory in megabytes (default: 64 MB)\n"
        -: 6510:           "-M, --disable-evictions   return error on memory exhausted instead of evicting\n"
        -: 6511:           "-c, --conn-limit=<num>    max simultaneous connections (default: 1024)\n"
        -: 6512:           "-k, --lock-memory         lock down all paged memory\n"
        -: 6513:           "-v, --verbose             verbose (print errors/warnings while in event loop)\n"
        -: 6514:           "-vv                       very verbose (also print client commands/responses)\n"
        -: 6515:           "-vvv                      extremely verbose (internal state transitions)\n"
        -: 6516:           "-h, --help                print this help and exit\n"
        -: 6517:           "-i, --license             print memcached and libevent license\n"
        -: 6518:           "-V, --version             print version and exit\n"
        -: 6519:           "-P, --pidfile=<file>      save PID in <file>, only used with -d option\n"
        -: 6520:           "-f, --slab-growth-factor=<num> chunk size growth factor (default: 1.25)\n"
        -: 6521:           "-n, --slab-min-size=<bytes> min space used for key+value+flags (default: 48)\n");
    #####: 6522:    printf("-L, --enable-largepages  try to use large memory pages (if available)\n");
    #####: 6523:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 6524:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 6525:           "              \":\" (colon). If this option is specified, stats collection\n"
        -: 6526:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 6527:           "              by sending the \"stats detail on\" command to the server.\n");
    #####: 6528:    printf("-t, --threads=<num>       number of threads to use (default: 4)\n");
    #####: 6529:    printf("-R, --max-reqs-per-event  maximum number of requests per event, limits the\n"
        -: 6530:           "                          requests processed per connection to prevent \n"
        -: 6531:           "                          starvation (default: 20)\n");
    #####: 6532:    printf("-C, --disable-cas         disable use of CAS\n");
    #####: 6533:    printf("-b, --listen-backlog=<num> set the backlog queue limit (default: 1024)\n");
    #####: 6534:    printf("-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default)\n");
    #####: 6535:    printf("-I, --max-item-size=<num> adjusts max item size\n"
        -: 6536:           "                          (default: 1mb, min: 1k, max: 1024m)\n");
        -: 6537:#ifdef ENABLE_SASL
        -: 6538:    printf("-S, --enable-sasl         turn on Sasl authentication\n");
        -: 6539:#endif
    #####: 6540:    printf("-F, --disable-flush-all   disable flush_all command\n");
    #####: 6541:    printf("-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\n");
    #####: 6542:    printf("-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\n"
        -: 6543:           "                          user:pass\\nuser2:pass2\\n\n");
        -: 6544:#ifdef TLS
        -: 6545:    printf("-Z, --enable-ssl          enable TLS/SSL\n");
        -: 6546:#endif
    #####: 6547:    printf("-o, --extended            comma separated list of extended options\n"
        -: 6548:           "                          most options have a 'no_' prefix to disable\n"
        -: 6549:           "   - maxconns_fast:       immediately close new connections after limit\n"
        -: 6550:           "   - hashpower:           an integer multiplier for how large the hash\n"
        -: 6551:           "                          table should be. normally grows at runtime.\n"
        -: 6552:           "                          set based on \"STAT hash_power_level\"\n"
        -: 6553:           "   - tail_repair_time:    time in seconds for how long to wait before\n"
        -: 6554:           "                          forcefully killing LRU tail item.\n"
        -: 6555:           "                          disabled by default; very dangerous option.\n"
        -: 6556:           "   - hash_algorithm:      the hash table algorithm\n"
        -: 6557:           "                          default is murmur3 hash. options: jenkins, murmur3\n"
        -: 6558:           "   - lru_crawler:         enable LRU Crawler background thread\n"
        -: 6559:           "   - lru_crawler_sleep:   microseconds to sleep between items\n"
        -: 6560:           "                          default is 100.\n"
        -: 6561:           "   - lru_crawler_tocrawl: max items to crawl per slab per run\n"
        -: 6562:           "                          default is 0 (unlimited)\n"
        -: 6563:           "   - lru_maintainer:      enable new LRU system + background thread\n"
        -: 6564:           "   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\n"
        -: 6565:           "                          (requires lru_maintainer)\n"
        -: 6566:           "   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\n"
        -: 6567:           "                          (requires lru_maintainer)\n"
        -: 6568:           "   - hot_max_factor:      items idle > cold lru age * drop from hot lru.\n"
        -: 6569:           "   - warm_max_factor:     items idle > cold lru age * this drop from warm.\n"
        -: 6570:           "   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\n"
        -: 6571:           "                          (requires lru_maintainer)\n"
        -: 6572:           "   - idle_timeout:        timeout for idle connections\n"
        -: 6573:           "   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size. use extreme care.\n"
        -: 6574:           "   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer.\n"
        -: 6575:           "   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\n"
        -: 6576:           "                          read by background thread, then written to watchers.\n"
        -: 6577:           "   - track_sizes:         enable dynamic reports for 'stats sizes' command.\n"
        -: 6578:           "   - no_hashexpand:       disables hash table expansion (dangerous)\n"
        -: 6579:           "   - modern:              enables options which will be default in future.\n"
        -: 6580:           "             currently: nothing\n"
        -: 6581:           "   - no_modern:           uses defaults of previous major version (1.4.x)\n"
        -: 6582:#ifdef HAVE_DROP_PRIVILEGES
        -: 6583:           "   - drop_privileges:     enable dropping extra syscall privileges\n"
        -: 6584:           "   - no_drop_privileges:  disable drop_privileges in case it causes issues with\n"
        -: 6585:           "                          some customisation.\n"
        -: 6586:#ifdef MEMCACHED_DEBUG
        -: 6587:           "   - relaxed_privileges: Running tests requires extra privileges.\n"
        -: 6588:#endif
        -: 6589:#endif
        -: 6590:#ifdef EXTSTORE
        -: 6591:           "   - ext_path:            file to write to for external storage.\n"
        -: 6592:           "                          ie: ext_path=/mnt/d1/extstore:1G\n"
        -: 6593:           "   - ext_page_size:       size in megabytes of storage pages.\n"
        -: 6594:           "   - ext_wbuf_size:       size in megabytes of page write buffers.\n"
        -: 6595:           "   - ext_threads:         number of IO threads to run.\n"
        -: 6596:           "   - ext_item_size:       store items larger than this (bytes)\n"
        -: 6597:           "   - ext_item_age:        store items idle at least this long\n"
        -: 6598:           "   - ext_low_ttl:         consider TTLs lower than this specially\n"
        -: 6599:           "   - ext_drop_unread:     don't re-write unread values during compaction\n"
        -: 6600:           "   - ext_recache_rate:    recache an item every N accesses\n"
        -: 6601:           "   - ext_compact_under:   compact when fewer than this many free pages\n"
        -: 6602:           "   - ext_drop_under:      drop COLD items when fewer than this many free pages\n"
        -: 6603:           "   - ext_max_frag:        max page fragmentation to tolerage\n"
        -: 6604:           "   - slab_automove_freeratio: ratio of memory to hold free as buffer.\n"
        -: 6605:           "                          (see doc/storage.txt for more info)\n"
        -: 6606:#endif
        -: 6607:#ifdef TLS
        -: 6608:           "   - ssl_chain_cert:      certificate chain file in PEM format\n"
        -: 6609:           "   - ssl_key:             private key, if not part of the -ssl_chain_cert\n"
        -: 6610:           "   - ssl_keyformat:         private key format (PEM, DER or ENGINE) PEM default\n"
        -: 6611:           "   - ssl_verify_mode:     peer certificate verification mode, default is 0(None).\n"
        -: 6612:           "                          valid values are 0(None), 1(Request), 2(Require)\n"
        -: 6613:           "                          or 3(Once)\n"
        -: 6614:           "   - ssl_ciphers:         specify cipher list to be used\n"
        -: 6615:           "   - ssl_ca_cert:         PEM format file of acceptable client CA's\n"
        -: 6616:           "   - ssl_wbuf_size:       size in kilobytes of per-connection SSL output buffer\n"
        -: 6617:#endif
        -: 6618:           );
    #####: 6619:    return;
        -: 6620:}
------------------
usage:
    #####: 6494:static void usage(void) {
    #####: 6495:    printf(PACKAGE " " VERSION "\n");
    #####: 6496:    printf("-p, --port=<num>          TCP port to listen on (default: 11211)\n"
        -: 6497:           "-U, --udp-port=<num>      UDP port to listen on (default: 0, off)\n"
        -: 6498:           "-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n"
        -: 6499:           "-A, --enable-shutdown     enable ascii \"shutdown\" command\n"
        -: 6500:           "-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: 0700)\n"
        -: 6501:           "-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n"
        -: 6502:#ifdef TLS
        -: 6503:           "                          if TLS/SSL is enabled, 'notls' prefix can be used to\n"
        -: 6504:           "                          disable for specific listeners (-l notls:<ip>:<port>) \n"
        -: 6505:#endif
        -: 6506:           "-d, --daemon              run as a daemon\n"
        -: 6507:           "-r, --enable-coredumps    maximize core file limit\n"
        -: 6508:           "-u, --user=<user>         assume identity of <username> (only when run as root)\n"
        -: 6509:           "-m, --memory-limit=<num>  item memory in megabytes (default: 64 MB)\n"
        -: 6510:           "-M, --disable-evictions   return error on memory exhausted instead of evicting\n"
        -: 6511:           "-c, --conn-limit=<num>    max simultaneous connections (default: 1024)\n"
        -: 6512:           "-k, --lock-memory         lock down all paged memory\n"
        -: 6513:           "-v, --verbose             verbose (print errors/warnings while in event loop)\n"
        -: 6514:           "-vv                       very verbose (also print client commands/responses)\n"
        -: 6515:           "-vvv                      extremely verbose (internal state transitions)\n"
        -: 6516:           "-h, --help                print this help and exit\n"
        -: 6517:           "-i, --license             print memcached and libevent license\n"
        -: 6518:           "-V, --version             print version and exit\n"
        -: 6519:           "-P, --pidfile=<file>      save PID in <file>, only used with -d option\n"
        -: 6520:           "-f, --slab-growth-factor=<num> chunk size growth factor (default: 1.25)\n"
        -: 6521:           "-n, --slab-min-size=<bytes> min space used for key+value+flags (default: 48)\n");
    #####: 6522:    printf("-L, --enable-largepages  try to use large memory pages (if available)\n");
    #####: 6523:    printf("-D <char>     Use <char> as the delimiter between key prefixes and IDs.\n"
        -: 6524:           "              This is used for per-prefix stats reporting. The default is\n"
        -: 6525:           "              \":\" (colon). If this option is specified, stats collection\n"
        -: 6526:           "              is turned on automatically; if not, then it may be turned on\n"
        -: 6527:           "              by sending the \"stats detail on\" command to the server.\n");
    #####: 6528:    printf("-t, --threads=<num>       number of threads to use (default: 4)\n");
    #####: 6529:    printf("-R, --max-reqs-per-event  maximum number of requests per event, limits the\n"
        -: 6530:           "                          requests processed per connection to prevent \n"
        -: 6531:           "                          starvation (default: 20)\n");
    #####: 6532:    printf("-C, --disable-cas         disable use of CAS\n");
    #####: 6533:    printf("-b, --listen-backlog=<num> set the backlog queue limit (default: 1024)\n");
    #####: 6534:    printf("-B, --protocol=<name>     protocol - one of ascii, binary, or auto (default)\n");
    #####: 6535:    printf("-I, --max-item-size=<num> adjusts max item size\n"
        -: 6536:           "                          (default: 1mb, min: 1k, max: 1024m)\n");
        -: 6537:#ifdef ENABLE_SASL
        -: 6538:    printf("-S, --enable-sasl         turn on Sasl authentication\n");
        -: 6539:#endif
    #####: 6540:    printf("-F, --disable-flush-all   disable flush_all command\n");
    #####: 6541:    printf("-X, --disable-dumping     disable stats cachedump and lru_crawler metadump\n");
    #####: 6542:    printf("-Y, --auth-file=<file>    (EXPERIMENTAL) enable ASCII protocol authentication. format:\n"
        -: 6543:           "                          user:pass\\nuser2:pass2\\n\n");
        -: 6544:#ifdef TLS
        -: 6545:    printf("-Z, --enable-ssl          enable TLS/SSL\n");
        -: 6546:#endif
    #####: 6547:    printf("-o, --extended            comma separated list of extended options\n"
        -: 6548:           "                          most options have a 'no_' prefix to disable\n"
        -: 6549:           "   - maxconns_fast:       immediately close new connections after limit\n"
        -: 6550:           "   - hashpower:           an integer multiplier for how large the hash\n"
        -: 6551:           "                          table should be. normally grows at runtime.\n"
        -: 6552:           "                          set based on \"STAT hash_power_level\"\n"
        -: 6553:           "   - tail_repair_time:    time in seconds for how long to wait before\n"
        -: 6554:           "                          forcefully killing LRU tail item.\n"
        -: 6555:           "                          disabled by default; very dangerous option.\n"
        -: 6556:           "   - hash_algorithm:      the hash table algorithm\n"
        -: 6557:           "                          default is murmur3 hash. options: jenkins, murmur3\n"
        -: 6558:           "   - lru_crawler:         enable LRU Crawler background thread\n"
        -: 6559:           "   - lru_crawler_sleep:   microseconds to sleep between items\n"
        -: 6560:           "                          default is 100.\n"
        -: 6561:           "   - lru_crawler_tocrawl: max items to crawl per slab per run\n"
        -: 6562:           "                          default is 0 (unlimited)\n"
        -: 6563:           "   - lru_maintainer:      enable new LRU system + background thread\n"
        -: 6564:           "   - hot_lru_pct:         pct of slab memory to reserve for hot lru.\n"
        -: 6565:           "                          (requires lru_maintainer)\n"
        -: 6566:           "   - warm_lru_pct:        pct of slab memory to reserve for warm lru.\n"
        -: 6567:           "                          (requires lru_maintainer)\n"
        -: 6568:           "   - hot_max_factor:      items idle > cold lru age * drop from hot lru.\n"
        -: 6569:           "   - warm_max_factor:     items idle > cold lru age * this drop from warm.\n"
        -: 6570:           "   - temporary_ttl:       TTL's below get separate LRU, can't be evicted.\n"
        -: 6571:           "                          (requires lru_maintainer)\n"
        -: 6572:           "   - idle_timeout:        timeout for idle connections\n"
        -: 6573:           "   - slab_chunk_max:      (EXPERIMENTAL) maximum slab size. use extreme care.\n"
        -: 6574:           "   - watcher_logbuf_size: size in kilobytes of per-watcher write buffer.\n"
        -: 6575:           "   - worker_logbuf_size:  size in kilobytes of per-worker-thread buffer\n"
        -: 6576:           "                          read by background thread, then written to watchers.\n"
        -: 6577:           "   - track_sizes:         enable dynamic reports for 'stats sizes' command.\n"
        -: 6578:           "   - no_hashexpand:       disables hash table expansion (dangerous)\n"
        -: 6579:           "   - modern:              enables options which will be default in future.\n"
        -: 6580:           "             currently: nothing\n"
        -: 6581:           "   - no_modern:           uses defaults of previous major version (1.4.x)\n"
        -: 6582:#ifdef HAVE_DROP_PRIVILEGES
        -: 6583:           "   - drop_privileges:     enable dropping extra syscall privileges\n"
        -: 6584:           "   - no_drop_privileges:  disable drop_privileges in case it causes issues with\n"
        -: 6585:           "                          some customisation.\n"
        -: 6586:#ifdef MEMCACHED_DEBUG
        -: 6587:           "   - relaxed_privileges: Running tests requires extra privileges.\n"
        -: 6588:#endif
        -: 6589:#endif
        -: 6590:#ifdef EXTSTORE
        -: 6591:           "   - ext_path:            file to write to for external storage.\n"
        -: 6592:           "                          ie: ext_path=/mnt/d1/extstore:1G\n"
        -: 6593:           "   - ext_page_size:       size in megabytes of storage pages.\n"
        -: 6594:           "   - ext_wbuf_size:       size in megabytes of page write buffers.\n"
        -: 6595:           "   - ext_threads:         number of IO threads to run.\n"
        -: 6596:           "   - ext_item_size:       store items larger than this (bytes)\n"
        -: 6597:           "   - ext_item_age:        store items idle at least this long\n"
        -: 6598:           "   - ext_low_ttl:         consider TTLs lower than this specially\n"
        -: 6599:           "   - ext_drop_unread:     don't re-write unread values during compaction\n"
        -: 6600:           "   - ext_recache_rate:    recache an item every N accesses\n"
        -: 6601:           "   - ext_compact_under:   compact when fewer than this many free pages\n"
        -: 6602:           "   - ext_drop_under:      drop COLD items when fewer than this many free pages\n"
        -: 6603:           "   - ext_max_frag:        max page fragmentation to tolerage\n"
        -: 6604:           "   - slab_automove_freeratio: ratio of memory to hold free as buffer.\n"
        -: 6605:           "                          (see doc/storage.txt for more info)\n"
        -: 6606:#endif
        -: 6607:#ifdef TLS
        -: 6608:           "   - ssl_chain_cert:      certificate chain file in PEM format\n"
        -: 6609:           "   - ssl_key:             private key, if not part of the -ssl_chain_cert\n"
        -: 6610:           "   - ssl_keyformat:         private key format (PEM, DER or ENGINE) PEM default\n"
        -: 6611:           "   - ssl_verify_mode:     peer certificate verification mode, default is 0(None).\n"
        -: 6612:           "                          valid values are 0(None), 1(Request), 2(Require)\n"
        -: 6613:           "                          or 3(Once)\n"
        -: 6614:           "   - ssl_ciphers:         specify cipher list to be used\n"
        -: 6615:           "   - ssl_ca_cert:         PEM format file of acceptable client CA's\n"
        -: 6616:           "   - ssl_wbuf_size:       size in kilobytes of per-connection SSL output buffer\n"
        -: 6617:#endif
        -: 6618:           );
    #####: 6619:    return;
        -: 6620:}
------------------
        -: 6621:
    #####: 6622:static void usage_license(void) {
    #####: 6623:    printf(PACKAGE " " VERSION "\n\n");
    #####: 6624:    printf(
        -: 6625:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 6626:    "All rights reserved.\n"
        -: 6627:    "\n"
        -: 6628:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6629:    "modification, are permitted provided that the following conditions are\n"
        -: 6630:    "met:\n"
        -: 6631:    "\n"
        -: 6632:    "    * Redistributions of source code must retain the above copyright\n"
        -: 6633:    "notice, this list of conditions and the following disclaimer.\n"
        -: 6634:    "\n"
        -: 6635:    "    * Redistributions in binary form must reproduce the above\n"
        -: 6636:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 6637:    "in the documentation and/or other materials provided with the\n"
        -: 6638:    "distribution.\n"
        -: 6639:    "\n"
        -: 6640:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 6641:    "contributors may be used to endorse or promote products derived from\n"
        -: 6642:    "this software without specific prior written permission.\n"
        -: 6643:    "\n"
        -: 6644:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 6645:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 6646:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 6647:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 6648:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 6649:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 6650:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6651:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6652:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6653:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 6654:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6655:    "\n"
        -: 6656:    "\n"
        -: 6657:    "This product includes software developed by Niels Provos.\n"
        -: 6658:    "\n"
        -: 6659:    "[ libevent ]\n"
        -: 6660:    "\n"
        -: 6661:    "Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\n"
        -: 6662:    "All rights reserved.\n"
        -: 6663:    "\n"
        -: 6664:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6665:    "modification, are permitted provided that the following conditions\n"
        -: 6666:    "are met:\n"
        -: 6667:    "1. Redistributions of source code must retain the above copyright\n"
        -: 6668:    "   notice, this list of conditions and the following disclaimer.\n"
        -: 6669:    "2. Redistributions in binary form must reproduce the above copyright\n"
        -: 6670:    "   notice, this list of conditions and the following disclaimer in the\n"
        -: 6671:    "   documentation and/or other materials provided with the distribution.\n"
        -: 6672:    "3. All advertising materials mentioning features or use of this software\n"
        -: 6673:    "   must display the following acknowledgement:\n"
        -: 6674:    "      This product includes software developed by Niels Provos.\n"
        -: 6675:    "4. The name of the author may not be used to endorse or promote products\n"
        -: 6676:    "   derived from this software without specific prior written permission.\n"
        -: 6677:    "\n"
        -: 6678:    "THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
        -: 6679:    "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
        -: 6680:    "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
        -: 6681:    "IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
        -: 6682:    "INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n"
        -: 6683:    "NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6684:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6685:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6686:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n"
        -: 6687:    "THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6688:    );
        -: 6689:
    #####: 6690:    return;
        -: 6691:}
------------------
usage_license:
    #####: 6622:static void usage_license(void) {
    #####: 6623:    printf(PACKAGE " " VERSION "\n\n");
    #####: 6624:    printf(
        -: 6625:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 6626:    "All rights reserved.\n"
        -: 6627:    "\n"
        -: 6628:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6629:    "modification, are permitted provided that the following conditions are\n"
        -: 6630:    "met:\n"
        -: 6631:    "\n"
        -: 6632:    "    * Redistributions of source code must retain the above copyright\n"
        -: 6633:    "notice, this list of conditions and the following disclaimer.\n"
        -: 6634:    "\n"
        -: 6635:    "    * Redistributions in binary form must reproduce the above\n"
        -: 6636:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 6637:    "in the documentation and/or other materials provided with the\n"
        -: 6638:    "distribution.\n"
        -: 6639:    "\n"
        -: 6640:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 6641:    "contributors may be used to endorse or promote products derived from\n"
        -: 6642:    "this software without specific prior written permission.\n"
        -: 6643:    "\n"
        -: 6644:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 6645:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 6646:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 6647:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 6648:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 6649:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 6650:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6651:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6652:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6653:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 6654:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6655:    "\n"
        -: 6656:    "\n"
        -: 6657:    "This product includes software developed by Niels Provos.\n"
        -: 6658:    "\n"
        -: 6659:    "[ libevent ]\n"
        -: 6660:    "\n"
        -: 6661:    "Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\n"
        -: 6662:    "All rights reserved.\n"
        -: 6663:    "\n"
        -: 6664:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6665:    "modification, are permitted provided that the following conditions\n"
        -: 6666:    "are met:\n"
        -: 6667:    "1. Redistributions of source code must retain the above copyright\n"
        -: 6668:    "   notice, this list of conditions and the following disclaimer.\n"
        -: 6669:    "2. Redistributions in binary form must reproduce the above copyright\n"
        -: 6670:    "   notice, this list of conditions and the following disclaimer in the\n"
        -: 6671:    "   documentation and/or other materials provided with the distribution.\n"
        -: 6672:    "3. All advertising materials mentioning features or use of this software\n"
        -: 6673:    "   must display the following acknowledgement:\n"
        -: 6674:    "      This product includes software developed by Niels Provos.\n"
        -: 6675:    "4. The name of the author may not be used to endorse or promote products\n"
        -: 6676:    "   derived from this software without specific prior written permission.\n"
        -: 6677:    "\n"
        -: 6678:    "THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
        -: 6679:    "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
        -: 6680:    "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
        -: 6681:    "IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
        -: 6682:    "INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n"
        -: 6683:    "NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6684:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6685:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6686:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n"
        -: 6687:    "THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6688:    );
        -: 6689:
    #####: 6690:    return;
        -: 6691:}
------------------
usage_license:
    #####: 6622:static void usage_license(void) {
    #####: 6623:    printf(PACKAGE " " VERSION "\n\n");
    #####: 6624:    printf(
        -: 6625:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 6626:    "All rights reserved.\n"
        -: 6627:    "\n"
        -: 6628:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6629:    "modification, are permitted provided that the following conditions are\n"
        -: 6630:    "met:\n"
        -: 6631:    "\n"
        -: 6632:    "    * Redistributions of source code must retain the above copyright\n"
        -: 6633:    "notice, this list of conditions and the following disclaimer.\n"
        -: 6634:    "\n"
        -: 6635:    "    * Redistributions in binary form must reproduce the above\n"
        -: 6636:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 6637:    "in the documentation and/or other materials provided with the\n"
        -: 6638:    "distribution.\n"
        -: 6639:    "\n"
        -: 6640:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 6641:    "contributors may be used to endorse or promote products derived from\n"
        -: 6642:    "this software without specific prior written permission.\n"
        -: 6643:    "\n"
        -: 6644:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 6645:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 6646:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 6647:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 6648:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 6649:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 6650:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6651:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6652:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6653:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 6654:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6655:    "\n"
        -: 6656:    "\n"
        -: 6657:    "This product includes software developed by Niels Provos.\n"
        -: 6658:    "\n"
        -: 6659:    "[ libevent ]\n"
        -: 6660:    "\n"
        -: 6661:    "Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\n"
        -: 6662:    "All rights reserved.\n"
        -: 6663:    "\n"
        -: 6664:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6665:    "modification, are permitted provided that the following conditions\n"
        -: 6666:    "are met:\n"
        -: 6667:    "1. Redistributions of source code must retain the above copyright\n"
        -: 6668:    "   notice, this list of conditions and the following disclaimer.\n"
        -: 6669:    "2. Redistributions in binary form must reproduce the above copyright\n"
        -: 6670:    "   notice, this list of conditions and the following disclaimer in the\n"
        -: 6671:    "   documentation and/or other materials provided with the distribution.\n"
        -: 6672:    "3. All advertising materials mentioning features or use of this software\n"
        -: 6673:    "   must display the following acknowledgement:\n"
        -: 6674:    "      This product includes software developed by Niels Provos.\n"
        -: 6675:    "4. The name of the author may not be used to endorse or promote products\n"
        -: 6676:    "   derived from this software without specific prior written permission.\n"
        -: 6677:    "\n"
        -: 6678:    "THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
        -: 6679:    "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
        -: 6680:    "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
        -: 6681:    "IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
        -: 6682:    "INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n"
        -: 6683:    "NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6684:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6685:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6686:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n"
        -: 6687:    "THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6688:    );
        -: 6689:
    #####: 6690:    return;
        -: 6691:}
------------------
usage_license:
    #####: 6622:static void usage_license(void) {
    #####: 6623:    printf(PACKAGE " " VERSION "\n\n");
    #####: 6624:    printf(
        -: 6625:    "Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n"
        -: 6626:    "All rights reserved.\n"
        -: 6627:    "\n"
        -: 6628:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6629:    "modification, are permitted provided that the following conditions are\n"
        -: 6630:    "met:\n"
        -: 6631:    "\n"
        -: 6632:    "    * Redistributions of source code must retain the above copyright\n"
        -: 6633:    "notice, this list of conditions and the following disclaimer.\n"
        -: 6634:    "\n"
        -: 6635:    "    * Redistributions in binary form must reproduce the above\n"
        -: 6636:    "copyright notice, this list of conditions and the following disclaimer\n"
        -: 6637:    "in the documentation and/or other materials provided with the\n"
        -: 6638:    "distribution.\n"
        -: 6639:    "\n"
        -: 6640:    "    * Neither the name of the Danga Interactive nor the names of its\n"
        -: 6641:    "contributors may be used to endorse or promote products derived from\n"
        -: 6642:    "this software without specific prior written permission.\n"
        -: 6643:    "\n"
        -: 6644:    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"
        -: 6645:    "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n"
        -: 6646:    "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
        -: 6647:    "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n"
        -: 6648:    "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
        -: 6649:    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n"
        -: 6650:    "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6651:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6652:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6653:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
        -: 6654:    "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6655:    "\n"
        -: 6656:    "\n"
        -: 6657:    "This product includes software developed by Niels Provos.\n"
        -: 6658:    "\n"
        -: 6659:    "[ libevent ]\n"
        -: 6660:    "\n"
        -: 6661:    "Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\n"
        -: 6662:    "All rights reserved.\n"
        -: 6663:    "\n"
        -: 6664:    "Redistribution and use in source and binary forms, with or without\n"
        -: 6665:    "modification, are permitted provided that the following conditions\n"
        -: 6666:    "are met:\n"
        -: 6667:    "1. Redistributions of source code must retain the above copyright\n"
        -: 6668:    "   notice, this list of conditions and the following disclaimer.\n"
        -: 6669:    "2. Redistributions in binary form must reproduce the above copyright\n"
        -: 6670:    "   notice, this list of conditions and the following disclaimer in the\n"
        -: 6671:    "   documentation and/or other materials provided with the distribution.\n"
        -: 6672:    "3. All advertising materials mentioning features or use of this software\n"
        -: 6673:    "   must display the following acknowledgement:\n"
        -: 6674:    "      This product includes software developed by Niels Provos.\n"
        -: 6675:    "4. The name of the author may not be used to endorse or promote products\n"
        -: 6676:    "   derived from this software without specific prior written permission.\n"
        -: 6677:    "\n"
        -: 6678:    "THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
        -: 6679:    "IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
        -: 6680:    "OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
        -: 6681:    "IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
        -: 6682:    "INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n"
        -: 6683:    "NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n"
        -: 6684:    "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
        -: 6685:    "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n"
        -: 6686:    "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n"
        -: 6687:    "THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        -: 6688:    );
        -: 6689:
    #####: 6690:    return;
        -: 6691:}
------------------
        -: 6692:
    #####: 6693:static void save_pid(const char *pid_file) {
    #####: 6694:    FILE *fp;
    #####: 6695:    if (access(pid_file, F_OK) == 0) {
    #####: 6696:        if ((fp = fopen(pid_file, "r")) != NULL) {
    #####: 6697:            char buffer[1024];
    #####: 6698:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
    #####: 6699:                unsigned int pid;
    #####: 6700:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 6701:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 6702:                }
        -: 6703:            }
    #####: 6704:            fclose(fp);
        -: 6705:        }
        -: 6706:    }
        -: 6707:
        -: 6708:    /* Create the pid file first with a temporary name, then
        -: 6709:     * atomically move the file to the real name to avoid a race with
        -: 6710:     * another process opening the file to read the pid, but finding
        -: 6711:     * it empty.
        -: 6712:     */
    #####: 6713:    char tmp_pid_file[1024];
    #####: 6714:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 6715:
    #####: 6716:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 6717:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
    #####: 6718:        return;
        -: 6719:    }
        -: 6720:
    #####: 6721:    fprintf(fp,"%ld\n", (long)getpid());
    #####: 6722:    if (fclose(fp) == -1) {
    #####: 6723:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 6724:    }
        -: 6725:
    #####: 6726:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 6727:        vperror("Could not rename the pid file from %s to %s",
        -: 6728:                tmp_pid_file, pid_file);
        -: 6729:    }
        -: 6730:}
------------------
save_pid:
    #####: 6693:static void save_pid(const char *pid_file) {
    #####: 6694:    FILE *fp;
    #####: 6695:    if (access(pid_file, F_OK) == 0) {
    #####: 6696:        if ((fp = fopen(pid_file, "r")) != NULL) {
    #####: 6697:            char buffer[1024];
    #####: 6698:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
    #####: 6699:                unsigned int pid;
    #####: 6700:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 6701:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 6702:                }
        -: 6703:            }
    #####: 6704:            fclose(fp);
        -: 6705:        }
        -: 6706:    }
        -: 6707:
        -: 6708:    /* Create the pid file first with a temporary name, then
        -: 6709:     * atomically move the file to the real name to avoid a race with
        -: 6710:     * another process opening the file to read the pid, but finding
        -: 6711:     * it empty.
        -: 6712:     */
    #####: 6713:    char tmp_pid_file[1024];
    #####: 6714:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 6715:
    #####: 6716:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 6717:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
    #####: 6718:        return;
        -: 6719:    }
        -: 6720:
    #####: 6721:    fprintf(fp,"%ld\n", (long)getpid());
    #####: 6722:    if (fclose(fp) == -1) {
    #####: 6723:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 6724:    }
        -: 6725:
    #####: 6726:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 6727:        vperror("Could not rename the pid file from %s to %s",
        -: 6728:                tmp_pid_file, pid_file);
        -: 6729:    }
        -: 6730:}
------------------
save_pid:
    #####: 6693:static void save_pid(const char *pid_file) {
    #####: 6694:    FILE *fp;
    #####: 6695:    if (access(pid_file, F_OK) == 0) {
    #####: 6696:        if ((fp = fopen(pid_file, "r")) != NULL) {
    #####: 6697:            char buffer[1024];
    #####: 6698:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
    #####: 6699:                unsigned int pid;
    #####: 6700:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 6701:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 6702:                }
        -: 6703:            }
    #####: 6704:            fclose(fp);
        -: 6705:        }
        -: 6706:    }
        -: 6707:
        -: 6708:    /* Create the pid file first with a temporary name, then
        -: 6709:     * atomically move the file to the real name to avoid a race with
        -: 6710:     * another process opening the file to read the pid, but finding
        -: 6711:     * it empty.
        -: 6712:     */
    #####: 6713:    char tmp_pid_file[1024];
    #####: 6714:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 6715:
    #####: 6716:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 6717:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
    #####: 6718:        return;
        -: 6719:    }
        -: 6720:
    #####: 6721:    fprintf(fp,"%ld\n", (long)getpid());
    #####: 6722:    if (fclose(fp) == -1) {
    #####: 6723:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 6724:    }
        -: 6725:
    #####: 6726:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 6727:        vperror("Could not rename the pid file from %s to %s",
        -: 6728:                tmp_pid_file, pid_file);
        -: 6729:    }
        -: 6730:}
------------------
save_pid:
    #####: 6693:static void save_pid(const char *pid_file) {
    #####: 6694:    FILE *fp;
    #####: 6695:    if (access(pid_file, F_OK) == 0) {
    #####: 6696:        if ((fp = fopen(pid_file, "r")) != NULL) {
    #####: 6697:            char buffer[1024];
    #####: 6698:            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
    #####: 6699:                unsigned int pid;
    #####: 6700:                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
    #####: 6701:                    fprintf(stderr, "WARNING: The pid file contained the following (running) pid: %u\n", pid);
        -: 6702:                }
        -: 6703:            }
    #####: 6704:            fclose(fp);
        -: 6705:        }
        -: 6706:    }
        -: 6707:
        -: 6708:    /* Create the pid file first with a temporary name, then
        -: 6709:     * atomically move the file to the real name to avoid a race with
        -: 6710:     * another process opening the file to read the pid, but finding
        -: 6711:     * it empty.
        -: 6712:     */
    #####: 6713:    char tmp_pid_file[1024];
    #####: 6714:    snprintf(tmp_pid_file, sizeof(tmp_pid_file), "%s.tmp", pid_file);
        -: 6715:
    #####: 6716:    if ((fp = fopen(tmp_pid_file, "w")) == NULL) {
    #####: 6717:        vperror("Could not open the pid file %s for writing", tmp_pid_file);
    #####: 6718:        return;
        -: 6719:    }
        -: 6720:
    #####: 6721:    fprintf(fp,"%ld\n", (long)getpid());
    #####: 6722:    if (fclose(fp) == -1) {
    #####: 6723:        vperror("Could not close the pid file %s", tmp_pid_file);
        -: 6724:    }
        -: 6725:
    #####: 6726:    if (rename(tmp_pid_file, pid_file) != 0) {
    #####: 6727:        vperror("Could not rename the pid file from %s to %s",
        -: 6728:                tmp_pid_file, pid_file);
        -: 6729:    }
        -: 6730:}
------------------
        -: 6731:
    #####: 6732:static void remove_pidfile(const char *pid_file) {
    #####: 6733:  if (pid_file == NULL)
        -: 6734:      return;
        -: 6735:
    #####: 6736:  if (unlink(pid_file) != 0) {
    #####: 6737:      vperror("Could not remove the pid file %s", pid_file);
        -: 6738:  }
        -: 6739:
        -: 6740:}
------------------
remove_pidfile:
    #####: 6732:static void remove_pidfile(const char *pid_file) {
    #####: 6733:  if (pid_file == NULL)
        -: 6734:      return;
        -: 6735:
    #####: 6736:  if (unlink(pid_file) != 0) {
    #####: 6737:      vperror("Could not remove the pid file %s", pid_file);
        -: 6738:  }
        -: 6739:
        -: 6740:}
------------------
remove_pidfile:
    #####: 6732:static void remove_pidfile(const char *pid_file) {
    #####: 6733:  if (pid_file == NULL)
        -: 6734:      return;
        -: 6735:
    #####: 6736:  if (unlink(pid_file) != 0) {
    #####: 6737:      vperror("Could not remove the pid file %s", pid_file);
        -: 6738:  }
        -: 6739:
        -: 6740:}
------------------
remove_pidfile:
    #####: 6732:static void remove_pidfile(const char *pid_file) {
    #####: 6733:  if (pid_file == NULL)
        -: 6734:      return;
        -: 6735:
    #####: 6736:  if (unlink(pid_file) != 0) {
    #####: 6737:      vperror("Could not remove the pid file %s", pid_file);
        -: 6738:  }
        -: 6739:
        -: 6740:}
------------------
        -: 6741:
        3: 6742:static void sig_handler(const int sig) {
        3: 6743:    printf("Signal handled: %s.\n", strsignal(sig));
        3: 6744:    exit(EXIT_SUCCESS);
        -: 6745:}
------------------
sig_handler:
        1: 6742:static void sig_handler(const int sig) {
        1: 6743:    printf("Signal handled: %s.\n", strsignal(sig));
        1: 6744:    exit(EXIT_SUCCESS);
        -: 6745:}
------------------
sig_handler:
        1: 6742:static void sig_handler(const int sig) {
        1: 6743:    printf("Signal handled: %s.\n", strsignal(sig));
        1: 6744:    exit(EXIT_SUCCESS);
        -: 6745:}
------------------
sig_handler:
        1: 6742:static void sig_handler(const int sig) {
        1: 6743:    printf("Signal handled: %s.\n", strsignal(sig));
        1: 6744:    exit(EXIT_SUCCESS);
        -: 6745:}
------------------
        -: 6746:
    #####: 6747:static void sighup_handler(const int sig) {
    #####: 6748:    settings.sig_hup = true;
    #####: 6749:}
------------------
sighup_handler:
    #####: 6747:static void sighup_handler(const int sig) {
    #####: 6748:    settings.sig_hup = true;
    #####: 6749:}
------------------
sighup_handler:
    #####: 6747:static void sighup_handler(const int sig) {
    #####: 6748:    settings.sig_hup = true;
    #####: 6749:}
------------------
sighup_handler:
    #####: 6747:static void sighup_handler(const int sig) {
    #####: 6748:    settings.sig_hup = true;
    #####: 6749:}
------------------
        -: 6750:
        -: 6751:#ifndef HAVE_SIGIGNORE
        -: 6752:static int sigignore(int sig) {
        -: 6753:    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };
        -: 6754:
        -: 6755:    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {
        -: 6756:        return -1;
        -: 6757:    }
        -: 6758:    return 0;
        -: 6759:}
        -: 6760:#endif
        -: 6761:
        -: 6762:
        -: 6763:/*
        -: 6764: * On systems that supports multiple page sizes we may reduce the
        -: 6765: * number of TLB-misses by using the biggest available page size
        -: 6766: */
    #####: 6767:static int enable_large_pages(void) {
        -: 6768:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 6769:    int ret = -1;
        -: 6770:    size_t sizes[32];
        -: 6771:    int avail = getpagesizes(sizes, 32);
        -: 6772:    if (avail != -1) {
        -: 6773:        size_t max = sizes[0];
        -: 6774:        struct memcntl_mha arg = {0};
        -: 6775:        int ii;
        -: 6776:
        -: 6777:        for (ii = 1; ii < avail; ++ii) {
        -: 6778:            if (max < sizes[ii]) {
        -: 6779:                max = sizes[ii];
        -: 6780:            }
        -: 6781:        }
        -: 6782:
        -: 6783:        arg.mha_flags   = 0;
        -: 6784:        arg.mha_pagesize = max;
        -: 6785:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 6786:
        -: 6787:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 6788:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 6789:                    strerror(errno));
        -: 6790:            fprintf(stderr, "Will use default page size\n");
        -: 6791:        } else {
        -: 6792:            ret = 0;
        -: 6793:        }
        -: 6794:    } else {
        -: 6795:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 6796:                strerror(errno));
        -: 6797:        fprintf(stderr, "Will use default page size\n");
        -: 6798:    }
        -: 6799:
        -: 6800:    return ret;
        -: 6801:#elif defined(__linux__) && defined(MADV_HUGEPAGE)
        -: 6802:    /* check if transparent hugepages is compiled into the kernel */
    #####: 6803:    struct stat st;
    #####: 6804:    int ret = stat("/sys/kernel/mm/transparent_hugepage/enabled", &st);
    #####: 6805:    if (ret || !(st.st_mode & S_IFREG)) {
    #####: 6806:        fprintf(stderr, "Transparent huge pages support not detected.\n");
    #####: 6807:        fprintf(stderr, "Will use default page size.\n");
    #####: 6808:        return -1;
        -: 6809:    }
        -: 6810:    return 0;
        -: 6811:#elif defined(__FreeBSD__)
        -: 6812:    int spages;
        -: 6813:    size_t spagesl = sizeof(spages);
        -: 6814:
        -: 6815:    if (sysctlbyname("vm.pmap.pg_ps_enabled", &spages,
        -: 6816:    &spagesl, NULL, 0) != 0) {
        -: 6817:        fprintf(stderr, "Could not evaluate the presence of superpages features.");
        -: 6818:        return -1;
        -: 6819:    }
        -: 6820:    if (spages != 1) {
        -: 6821:        fprintf(stderr, "Superpages support not detected.\n");
        -: 6822:        fprintf(stderr, "Will use default page size.\n");
        -: 6823:        return -1;
        -: 6824:    }
        -: 6825:    return 0;
        -: 6826:#else
        -: 6827:    return -1;
        -: 6828:#endif
        -: 6829:}
------------------
enable_large_pages:
    #####: 6767:static int enable_large_pages(void) {
        -: 6768:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 6769:    int ret = -1;
        -: 6770:    size_t sizes[32];
        -: 6771:    int avail = getpagesizes(sizes, 32);
        -: 6772:    if (avail != -1) {
        -: 6773:        size_t max = sizes[0];
        -: 6774:        struct memcntl_mha arg = {0};
        -: 6775:        int ii;
        -: 6776:
        -: 6777:        for (ii = 1; ii < avail; ++ii) {
        -: 6778:            if (max < sizes[ii]) {
        -: 6779:                max = sizes[ii];
        -: 6780:            }
        -: 6781:        }
        -: 6782:
        -: 6783:        arg.mha_flags   = 0;
        -: 6784:        arg.mha_pagesize = max;
        -: 6785:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 6786:
        -: 6787:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 6788:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 6789:                    strerror(errno));
        -: 6790:            fprintf(stderr, "Will use default page size\n");
        -: 6791:        } else {
        -: 6792:            ret = 0;
        -: 6793:        }
        -: 6794:    } else {
        -: 6795:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 6796:                strerror(errno));
        -: 6797:        fprintf(stderr, "Will use default page size\n");
        -: 6798:    }
        -: 6799:
        -: 6800:    return ret;
        -: 6801:#elif defined(__linux__) && defined(MADV_HUGEPAGE)
        -: 6802:    /* check if transparent hugepages is compiled into the kernel */
    #####: 6803:    struct stat st;
    #####: 6804:    int ret = stat("/sys/kernel/mm/transparent_hugepage/enabled", &st);
    #####: 6805:    if (ret || !(st.st_mode & S_IFREG)) {
    #####: 6806:        fprintf(stderr, "Transparent huge pages support not detected.\n");
    #####: 6807:        fprintf(stderr, "Will use default page size.\n");
    #####: 6808:        return -1;
        -: 6809:    }
        -: 6810:    return 0;
        -: 6811:#elif defined(__FreeBSD__)
        -: 6812:    int spages;
        -: 6813:    size_t spagesl = sizeof(spages);
        -: 6814:
        -: 6815:    if (sysctlbyname("vm.pmap.pg_ps_enabled", &spages,
        -: 6816:    &spagesl, NULL, 0) != 0) {
        -: 6817:        fprintf(stderr, "Could not evaluate the presence of superpages features.");
        -: 6818:        return -1;
        -: 6819:    }
        -: 6820:    if (spages != 1) {
        -: 6821:        fprintf(stderr, "Superpages support not detected.\n");
        -: 6822:        fprintf(stderr, "Will use default page size.\n");
        -: 6823:        return -1;
        -: 6824:    }
        -: 6825:    return 0;
        -: 6826:#else
        -: 6827:    return -1;
        -: 6828:#endif
        -: 6829:}
------------------
enable_large_pages:
    #####: 6767:static int enable_large_pages(void) {
        -: 6768:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 6769:    int ret = -1;
        -: 6770:    size_t sizes[32];
        -: 6771:    int avail = getpagesizes(sizes, 32);
        -: 6772:    if (avail != -1) {
        -: 6773:        size_t max = sizes[0];
        -: 6774:        struct memcntl_mha arg = {0};
        -: 6775:        int ii;
        -: 6776:
        -: 6777:        for (ii = 1; ii < avail; ++ii) {
        -: 6778:            if (max < sizes[ii]) {
        -: 6779:                max = sizes[ii];
        -: 6780:            }
        -: 6781:        }
        -: 6782:
        -: 6783:        arg.mha_flags   = 0;
        -: 6784:        arg.mha_pagesize = max;
        -: 6785:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 6786:
        -: 6787:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 6788:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 6789:                    strerror(errno));
        -: 6790:            fprintf(stderr, "Will use default page size\n");
        -: 6791:        } else {
        -: 6792:            ret = 0;
        -: 6793:        }
        -: 6794:    } else {
        -: 6795:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 6796:                strerror(errno));
        -: 6797:        fprintf(stderr, "Will use default page size\n");
        -: 6798:    }
        -: 6799:
        -: 6800:    return ret;
        -: 6801:#elif defined(__linux__) && defined(MADV_HUGEPAGE)
        -: 6802:    /* check if transparent hugepages is compiled into the kernel */
    #####: 6803:    struct stat st;
    #####: 6804:    int ret = stat("/sys/kernel/mm/transparent_hugepage/enabled", &st);
    #####: 6805:    if (ret || !(st.st_mode & S_IFREG)) {
    #####: 6806:        fprintf(stderr, "Transparent huge pages support not detected.\n");
    #####: 6807:        fprintf(stderr, "Will use default page size.\n");
    #####: 6808:        return -1;
        -: 6809:    }
        -: 6810:    return 0;
        -: 6811:#elif defined(__FreeBSD__)
        -: 6812:    int spages;
        -: 6813:    size_t spagesl = sizeof(spages);
        -: 6814:
        -: 6815:    if (sysctlbyname("vm.pmap.pg_ps_enabled", &spages,
        -: 6816:    &spagesl, NULL, 0) != 0) {
        -: 6817:        fprintf(stderr, "Could not evaluate the presence of superpages features.");
        -: 6818:        return -1;
        -: 6819:    }
        -: 6820:    if (spages != 1) {
        -: 6821:        fprintf(stderr, "Superpages support not detected.\n");
        -: 6822:        fprintf(stderr, "Will use default page size.\n");
        -: 6823:        return -1;
        -: 6824:    }
        -: 6825:    return 0;
        -: 6826:#else
        -: 6827:    return -1;
        -: 6828:#endif
        -: 6829:}
------------------
enable_large_pages:
    #####: 6767:static int enable_large_pages(void) {
        -: 6768:#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
        -: 6769:    int ret = -1;
        -: 6770:    size_t sizes[32];
        -: 6771:    int avail = getpagesizes(sizes, 32);
        -: 6772:    if (avail != -1) {
        -: 6773:        size_t max = sizes[0];
        -: 6774:        struct memcntl_mha arg = {0};
        -: 6775:        int ii;
        -: 6776:
        -: 6777:        for (ii = 1; ii < avail; ++ii) {
        -: 6778:            if (max < sizes[ii]) {
        -: 6779:                max = sizes[ii];
        -: 6780:            }
        -: 6781:        }
        -: 6782:
        -: 6783:        arg.mha_flags   = 0;
        -: 6784:        arg.mha_pagesize = max;
        -: 6785:        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;
        -: 6786:
        -: 6787:        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
        -: 6788:            fprintf(stderr, "Failed to set large pages: %s\n",
        -: 6789:                    strerror(errno));
        -: 6790:            fprintf(stderr, "Will use default page size\n");
        -: 6791:        } else {
        -: 6792:            ret = 0;
        -: 6793:        }
        -: 6794:    } else {
        -: 6795:        fprintf(stderr, "Failed to get supported pagesizes: %s\n",
        -: 6796:                strerror(errno));
        -: 6797:        fprintf(stderr, "Will use default page size\n");
        -: 6798:    }
        -: 6799:
        -: 6800:    return ret;
        -: 6801:#elif defined(__linux__) && defined(MADV_HUGEPAGE)
        -: 6802:    /* check if transparent hugepages is compiled into the kernel */
    #####: 6803:    struct stat st;
    #####: 6804:    int ret = stat("/sys/kernel/mm/transparent_hugepage/enabled", &st);
    #####: 6805:    if (ret || !(st.st_mode & S_IFREG)) {
    #####: 6806:        fprintf(stderr, "Transparent huge pages support not detected.\n");
    #####: 6807:        fprintf(stderr, "Will use default page size.\n");
    #####: 6808:        return -1;
        -: 6809:    }
        -: 6810:    return 0;
        -: 6811:#elif defined(__FreeBSD__)
        -: 6812:    int spages;
        -: 6813:    size_t spagesl = sizeof(spages);
        -: 6814:
        -: 6815:    if (sysctlbyname("vm.pmap.pg_ps_enabled", &spages,
        -: 6816:    &spagesl, NULL, 0) != 0) {
        -: 6817:        fprintf(stderr, "Could not evaluate the presence of superpages features.");
        -: 6818:        return -1;
        -: 6819:    }
        -: 6820:    if (spages != 1) {
        -: 6821:        fprintf(stderr, "Superpages support not detected.\n");
        -: 6822:        fprintf(stderr, "Will use default page size.\n");
        -: 6823:        return -1;
        -: 6824:    }
        -: 6825:    return 0;
        -: 6826:#else
        -: 6827:    return -1;
        -: 6828:#endif
        -: 6829:}
------------------
        -: 6830:
        -: 6831:/**
        -: 6832: * Do basic sanity check of the runtime environment
        -: 6833: * @return true if no errors found, false if we can't use this env
        -: 6834: */
        3: 6835:static bool sanitycheck(void) {
        -: 6836:    /* One of our biggest problems is old and bogus libevents */
        3: 6837:    const char *ever = event_get_version();
        3: 6838:    if (ever != NULL) {
        3: 6839:        if (strncmp(ever, "1.", 2) == 0) {
        -: 6840:            /* Require at least 1.3 (that's still a couple of years old) */
    #####: 6841:            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {
    #####: 6842:                fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
        -: 6843:                        " a more recent version (1.3 or newer)\n",
        -: 6844:                        event_get_version());
    #####: 6845:                return false;
        -: 6846:            }
        -: 6847:        }
        -: 6848:    }
        -: 6849:
        -: 6850:    return true;
        -: 6851:}
------------------
sanitycheck:
        1: 6835:static bool sanitycheck(void) {
        -: 6836:    /* One of our biggest problems is old and bogus libevents */
        1: 6837:    const char *ever = event_get_version();
        1: 6838:    if (ever != NULL) {
        1: 6839:        if (strncmp(ever, "1.", 2) == 0) {
        -: 6840:            /* Require at least 1.3 (that's still a couple of years old) */
    #####: 6841:            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {
    #####: 6842:                fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
        -: 6843:                        " a more recent version (1.3 or newer)\n",
        -: 6844:                        event_get_version());
    #####: 6845:                return false;
        -: 6846:            }
        -: 6847:        }
        -: 6848:    }
        -: 6849:
        -: 6850:    return true;
        -: 6851:}
------------------
sanitycheck:
        1: 6835:static bool sanitycheck(void) {
        -: 6836:    /* One of our biggest problems is old and bogus libevents */
        1: 6837:    const char *ever = event_get_version();
        1: 6838:    if (ever != NULL) {
        1: 6839:        if (strncmp(ever, "1.", 2) == 0) {
        -: 6840:            /* Require at least 1.3 (that's still a couple of years old) */
    #####: 6841:            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {
    #####: 6842:                fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
        -: 6843:                        " a more recent version (1.3 or newer)\n",
        -: 6844:                        event_get_version());
    #####: 6845:                return false;
        -: 6846:            }
        -: 6847:        }
        -: 6848:    }
        -: 6849:
        -: 6850:    return true;
        -: 6851:}
------------------
sanitycheck:
        1: 6835:static bool sanitycheck(void) {
        -: 6836:    /* One of our biggest problems is old and bogus libevents */
        1: 6837:    const char *ever = event_get_version();
        1: 6838:    if (ever != NULL) {
        1: 6839:        if (strncmp(ever, "1.", 2) == 0) {
        -: 6840:            /* Require at least 1.3 (that's still a couple of years old) */
    #####: 6841:            if (('0' <= ever[2] && ever[2] < '3') && !isdigit(ever[3])) {
    #####: 6842:                fprintf(stderr, "You are using libevent %s.\nPlease upgrade to"
        -: 6843:                        " a more recent version (1.3 or newer)\n",
        -: 6844:                        event_get_version());
    #####: 6845:                return false;
        -: 6846:            }
        -: 6847:        }
        -: 6848:    }
        -: 6849:
        -: 6850:    return true;
        -: 6851:}
------------------
        -: 6852:
    #####: 6853:static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    #####: 6854:    char *b = NULL;
    #####: 6855:    uint32_t size = 0;
    #####: 6856:    int i = 0;
    #####: 6857:    uint32_t last_size = 0;
        -: 6858:
    #####: 6859:    if (strlen(s) < 1)
        -: 6860:        return false;
        -: 6861:
    #####: 6862:    for (char *p = strtok_r(s, "-", &b);
        -: 6863:         p != NULL;
    #####: 6864:         p = strtok_r(NULL, "-", &b)) {
    #####: 6865:        if (!safe_strtoul(p, &size) || size < settings.chunk_size
    #####: 6866:             || size > settings.slab_chunk_size_max) {
    #####: 6867:            fprintf(stderr, "slab size %u is out of valid range\n", size);
    #####: 6868:            return false;
        -: 6869:        }
    #####: 6870:        if (last_size >= size) {
    #####: 6871:            fprintf(stderr, "slab size %u cannot be lower than or equal to a previous class size\n", size);
    #####: 6872:            return false;
        -: 6873:        }
    #####: 6874:        if (size <= last_size + CHUNK_ALIGN_BYTES) {
    #####: 6875:            fprintf(stderr, "slab size %u must be at least %d bytes larger than previous class\n",
        -: 6876:                    size, CHUNK_ALIGN_BYTES);
    #####: 6877:            return false;
        -: 6878:        }
    #####: 6879:        slab_sizes[i++] = size;
    #####: 6880:        last_size = size;
    #####: 6881:        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
    #####: 6882:            fprintf(stderr, "too many slab classes specified\n");
    #####: 6883:            return false;
        -: 6884:        }
        -: 6885:    }
        -: 6886:
    #####: 6887:    slab_sizes[i] = 0;
    #####: 6888:    return true;
        -: 6889:}
------------------
_parse_slab_sizes:
    #####: 6853:static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    #####: 6854:    char *b = NULL;
    #####: 6855:    uint32_t size = 0;
    #####: 6856:    int i = 0;
    #####: 6857:    uint32_t last_size = 0;
        -: 6858:
    #####: 6859:    if (strlen(s) < 1)
        -: 6860:        return false;
        -: 6861:
    #####: 6862:    for (char *p = strtok_r(s, "-", &b);
        -: 6863:         p != NULL;
    #####: 6864:         p = strtok_r(NULL, "-", &b)) {
    #####: 6865:        if (!safe_strtoul(p, &size) || size < settings.chunk_size
    #####: 6866:             || size > settings.slab_chunk_size_max) {
    #####: 6867:            fprintf(stderr, "slab size %u is out of valid range\n", size);
    #####: 6868:            return false;
        -: 6869:        }
    #####: 6870:        if (last_size >= size) {
    #####: 6871:            fprintf(stderr, "slab size %u cannot be lower than or equal to a previous class size\n", size);
    #####: 6872:            return false;
        -: 6873:        }
    #####: 6874:        if (size <= last_size + CHUNK_ALIGN_BYTES) {
    #####: 6875:            fprintf(stderr, "slab size %u must be at least %d bytes larger than previous class\n",
        -: 6876:                    size, CHUNK_ALIGN_BYTES);
    #####: 6877:            return false;
        -: 6878:        }
    #####: 6879:        slab_sizes[i++] = size;
    #####: 6880:        last_size = size;
    #####: 6881:        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
    #####: 6882:            fprintf(stderr, "too many slab classes specified\n");
    #####: 6883:            return false;
        -: 6884:        }
        -: 6885:    }
        -: 6886:
    #####: 6887:    slab_sizes[i] = 0;
    #####: 6888:    return true;
        -: 6889:}
------------------
_parse_slab_sizes:
    #####: 6853:static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    #####: 6854:    char *b = NULL;
    #####: 6855:    uint32_t size = 0;
    #####: 6856:    int i = 0;
    #####: 6857:    uint32_t last_size = 0;
        -: 6858:
    #####: 6859:    if (strlen(s) < 1)
        -: 6860:        return false;
        -: 6861:
    #####: 6862:    for (char *p = strtok_r(s, "-", &b);
        -: 6863:         p != NULL;
    #####: 6864:         p = strtok_r(NULL, "-", &b)) {
    #####: 6865:        if (!safe_strtoul(p, &size) || size < settings.chunk_size
    #####: 6866:             || size > settings.slab_chunk_size_max) {
    #####: 6867:            fprintf(stderr, "slab size %u is out of valid range\n", size);
    #####: 6868:            return false;
        -: 6869:        }
    #####: 6870:        if (last_size >= size) {
    #####: 6871:            fprintf(stderr, "slab size %u cannot be lower than or equal to a previous class size\n", size);
    #####: 6872:            return false;
        -: 6873:        }
    #####: 6874:        if (size <= last_size + CHUNK_ALIGN_BYTES) {
    #####: 6875:            fprintf(stderr, "slab size %u must be at least %d bytes larger than previous class\n",
        -: 6876:                    size, CHUNK_ALIGN_BYTES);
    #####: 6877:            return false;
        -: 6878:        }
    #####: 6879:        slab_sizes[i++] = size;
    #####: 6880:        last_size = size;
    #####: 6881:        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
    #####: 6882:            fprintf(stderr, "too many slab classes specified\n");
    #####: 6883:            return false;
        -: 6884:        }
        -: 6885:    }
        -: 6886:
    #####: 6887:    slab_sizes[i] = 0;
    #####: 6888:    return true;
        -: 6889:}
------------------
_parse_slab_sizes:
    #####: 6853:static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    #####: 6854:    char *b = NULL;
    #####: 6855:    uint32_t size = 0;
    #####: 6856:    int i = 0;
    #####: 6857:    uint32_t last_size = 0;
        -: 6858:
    #####: 6859:    if (strlen(s) < 1)
        -: 6860:        return false;
        -: 6861:
    #####: 6862:    for (char *p = strtok_r(s, "-", &b);
        -: 6863:         p != NULL;
    #####: 6864:         p = strtok_r(NULL, "-", &b)) {
    #####: 6865:        if (!safe_strtoul(p, &size) || size < settings.chunk_size
    #####: 6866:             || size > settings.slab_chunk_size_max) {
    #####: 6867:            fprintf(stderr, "slab size %u is out of valid range\n", size);
    #####: 6868:            return false;
        -: 6869:        }
    #####: 6870:        if (last_size >= size) {
    #####: 6871:            fprintf(stderr, "slab size %u cannot be lower than or equal to a previous class size\n", size);
    #####: 6872:            return false;
        -: 6873:        }
    #####: 6874:        if (size <= last_size + CHUNK_ALIGN_BYTES) {
    #####: 6875:            fprintf(stderr, "slab size %u must be at least %d bytes larger than previous class\n",
        -: 6876:                    size, CHUNK_ALIGN_BYTES);
    #####: 6877:            return false;
        -: 6878:        }
    #####: 6879:        slab_sizes[i++] = size;
    #####: 6880:        last_size = size;
    #####: 6881:        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
    #####: 6882:            fprintf(stderr, "too many slab classes specified\n");
    #####: 6883:            return false;
        -: 6884:        }
        -: 6885:    }
        -: 6886:
    #####: 6887:    slab_sizes[i] = 0;
    #####: 6888:    return true;
        -: 6889:}
------------------
        -: 6890:
        3: 6891:int main (int argc, char **argv) {
        3: 6892:    int c;
        3: 6893:    bool lock_memory = false;
        3: 6894:    bool do_daemonize = false;
        3: 6895:    bool preallocate = false;
        3: 6896:    int maxcore = 0;
        3: 6897:    char *username = NULL;
        3: 6898:    char *pid_file = NULL;
        3: 6899:    struct passwd *pw;
        3: 6900:    struct rlimit rlim;
        3: 6901:    char *buf;
        3: 6902:    char unit = '\0';
        3: 6903:    int size_max = 0;
        3: 6904:    int retval = EXIT_SUCCESS;
        3: 6905:    bool protocol_specified = false;
        3: 6906:    bool tcp_specified = false;
        3: 6907:    bool udp_specified = false;
        3: 6908:    bool start_lru_maintainer = true;
        3: 6909:    bool start_lru_crawler = true;
        3: 6910:    bool start_assoc_maint = true;
        3: 6911:    enum hashfunc_type hash_type = MURMUR3_HASH;
        3: 6912:    uint32_t tocrawl;
        3: 6913:    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];
        3: 6914:    bool use_slab_sizes = false;
        3: 6915:    char *slab_sizes_unparsed = NULL;
        3: 6916:    bool slab_chunk_size_changed = false;
        -: 6917:#ifdef EXTSTORE
        -: 6918:    void *storage = NULL;
        -: 6919:    struct extstore_conf_file *storage_file = NULL;
        -: 6920:    struct extstore_conf ext_cf;
        -: 6921:#endif
        3: 6922:    char *subopts, *subopts_orig;
        3: 6923:    char *subopts_value;
        3: 6924:    enum {
        -: 6925:        MAXCONNS_FAST = 0,
        -: 6926:        HASHPOWER_INIT,
        -: 6927:        NO_HASHEXPAND,
        -: 6928:        SLAB_REASSIGN,
        -: 6929:        SLAB_AUTOMOVE,
        -: 6930:        SLAB_AUTOMOVE_RATIO,
        -: 6931:        SLAB_AUTOMOVE_WINDOW,
        -: 6932:        TAIL_REPAIR_TIME,
        -: 6933:        HASH_ALGORITHM,
        -: 6934:        LRU_CRAWLER,
        -: 6935:        LRU_CRAWLER_SLEEP,
        -: 6936:        LRU_CRAWLER_TOCRAWL,
        -: 6937:        LRU_MAINTAINER,
        -: 6938:        HOT_LRU_PCT,
        -: 6939:        WARM_LRU_PCT,
        -: 6940:        HOT_MAX_FACTOR,
        -: 6941:        WARM_MAX_FACTOR,
        -: 6942:        TEMPORARY_TTL,
        -: 6943:        IDLE_TIMEOUT,
        -: 6944:        WATCHER_LOGBUF_SIZE,
        -: 6945:        WORKER_LOGBUF_SIZE,
        -: 6946:        SLAB_SIZES,
        -: 6947:        SLAB_CHUNK_MAX,
        -: 6948:        TRACK_SIZES,
        -: 6949:        NO_INLINE_ASCII_RESP,
        -: 6950:        MODERN,
        -: 6951:        NO_MODERN,
        -: 6952:        NO_CHUNKED_ITEMS,
        -: 6953:        NO_SLAB_REASSIGN,
        -: 6954:        NO_SLAB_AUTOMOVE,
        -: 6955:        NO_MAXCONNS_FAST,
        -: 6956:        INLINE_ASCII_RESP,
        -: 6957:        NO_LRU_CRAWLER,
        -: 6958:        NO_LRU_MAINTAINER,
        -: 6959:        NO_DROP_PRIVILEGES,
        -: 6960:        DROP_PRIVILEGES,
        -: 6961:#ifdef TLS
        -: 6962:        SSL_CERT,
        -: 6963:        SSL_KEY,
        -: 6964:        SSL_VERIFY_MODE,
        -: 6965:        SSL_KEYFORM,
        -: 6966:        SSL_CIPHERS,
        -: 6967:        SSL_CA_CERT,
        -: 6968:        SSL_WBUF_SIZE,
        -: 6969:#endif
        -: 6970:#ifdef MEMCACHED_DEBUG
        -: 6971:        RELAXED_PRIVILEGES,
        -: 6972:#endif
        -: 6973:#ifdef EXTSTORE
        -: 6974:        EXT_PAGE_SIZE,
        -: 6975:        EXT_WBUF_SIZE,
        -: 6976:        EXT_THREADS,
        -: 6977:        EXT_IO_DEPTH,
        -: 6978:        EXT_PATH,
        -: 6979:        EXT_ITEM_SIZE,
        -: 6980:        EXT_ITEM_AGE,
        -: 6981:        EXT_LOW_TTL,
        -: 6982:        EXT_RECACHE_RATE,
        -: 6983:        EXT_COMPACT_UNDER,
        -: 6984:        EXT_DROP_UNDER,
        -: 6985:        EXT_MAX_FRAG,
        -: 6986:        EXT_DROP_UNREAD,
        -: 6987:        SLAB_AUTOMOVE_FREERATIO,
        -: 6988:#endif
        -: 6989:    };
        3: 6990:    char *const subopts_tokens[] = {
        -: 6991:        [MAXCONNS_FAST] = "maxconns_fast",
        -: 6992:        [HASHPOWER_INIT] = "hashpower",
        -: 6993:        [NO_HASHEXPAND] = "no_hashexpand",
        -: 6994:        [SLAB_REASSIGN] = "slab_reassign",
        -: 6995:        [SLAB_AUTOMOVE] = "slab_automove",
        -: 6996:        [SLAB_AUTOMOVE_RATIO] = "slab_automove_ratio",
        -: 6997:        [SLAB_AUTOMOVE_WINDOW] = "slab_automove_window",
        -: 6998:        [TAIL_REPAIR_TIME] = "tail_repair_time",
        -: 6999:        [HASH_ALGORITHM] = "hash_algorithm",
        -: 7000:        [LRU_CRAWLER] = "lru_crawler",
        -: 7001:        [LRU_CRAWLER_SLEEP] = "lru_crawler_sleep",
        -: 7002:        [LRU_CRAWLER_TOCRAWL] = "lru_crawler_tocrawl",
        -: 7003:        [LRU_MAINTAINER] = "lru_maintainer",
        -: 7004:        [HOT_LRU_PCT] = "hot_lru_pct",
        -: 7005:        [WARM_LRU_PCT] = "warm_lru_pct",
        -: 7006:        [HOT_MAX_FACTOR] = "hot_max_factor",
        -: 7007:        [WARM_MAX_FACTOR] = "warm_max_factor",
        -: 7008:        [TEMPORARY_TTL] = "temporary_ttl",
        -: 7009:        [IDLE_TIMEOUT] = "idle_timeout",
        -: 7010:        [WATCHER_LOGBUF_SIZE] = "watcher_logbuf_size",
        -: 7011:        [WORKER_LOGBUF_SIZE] = "worker_logbuf_size",
        -: 7012:        [SLAB_SIZES] = "slab_sizes",
        -: 7013:        [SLAB_CHUNK_MAX] = "slab_chunk_max",
        -: 7014:        [TRACK_SIZES] = "track_sizes",
        -: 7015:        [NO_INLINE_ASCII_RESP] = "no_inline_ascii_resp",
        -: 7016:        [MODERN] = "modern",
        -: 7017:        [NO_MODERN] = "no_modern",
        -: 7018:        [NO_CHUNKED_ITEMS] = "no_chunked_items",
        -: 7019:        [NO_SLAB_REASSIGN] = "no_slab_reassign",
        -: 7020:        [NO_SLAB_AUTOMOVE] = "no_slab_automove",
        -: 7021:        [NO_MAXCONNS_FAST] = "no_maxconns_fast",
        -: 7022:        [INLINE_ASCII_RESP] = "inline_ascii_resp",
        -: 7023:        [NO_LRU_CRAWLER] = "no_lru_crawler",
        -: 7024:        [NO_LRU_MAINTAINER] = "no_lru_maintainer",
        -: 7025:        [NO_DROP_PRIVILEGES] = "no_drop_privileges",
        -: 7026:        [DROP_PRIVILEGES] = "drop_privileges",
        -: 7027:#ifdef TLS
        -: 7028:        [SSL_CERT] = "ssl_chain_cert",
        -: 7029:        [SSL_KEY] = "ssl_key",
        -: 7030:        [SSL_VERIFY_MODE] = "ssl_verify_mode",
        -: 7031:        [SSL_KEYFORM] = "ssl_keyformat",
        -: 7032:        [SSL_CIPHERS] = "ssl_ciphers",
        -: 7033:        [SSL_CA_CERT] = "ssl_ca_cert",
        -: 7034:        [SSL_WBUF_SIZE] = "ssl_wbuf_size",
        -: 7035:#endif
        -: 7036:#ifdef MEMCACHED_DEBUG
        -: 7037:        [RELAXED_PRIVILEGES] = "relaxed_privileges",
        -: 7038:#endif
        -: 7039:#ifdef EXTSTORE
        -: 7040:        [EXT_PAGE_SIZE] = "ext_page_size",
        -: 7041:        [EXT_WBUF_SIZE] = "ext_wbuf_size",
        -: 7042:        [EXT_THREADS] = "ext_threads",
        -: 7043:        [EXT_IO_DEPTH] = "ext_io_depth",
        -: 7044:        [EXT_PATH] = "ext_path",
        -: 7045:        [EXT_ITEM_SIZE] = "ext_item_size",
        -: 7046:        [EXT_ITEM_AGE] = "ext_item_age",
        -: 7047:        [EXT_LOW_TTL] = "ext_low_ttl",
        -: 7048:        [EXT_RECACHE_RATE] = "ext_recache_rate",
        -: 7049:        [EXT_COMPACT_UNDER] = "ext_compact_under",
        -: 7050:        [EXT_DROP_UNDER] = "ext_drop_under",
        -: 7051:        [EXT_MAX_FRAG] = "ext_max_frag",
        -: 7052:        [EXT_DROP_UNREAD] = "ext_drop_unread",
        -: 7053:        [SLAB_AUTOMOVE_FREERATIO] = "slab_automove_freeratio",
        -: 7054:#endif
        -: 7055:        NULL
        -: 7056:    };
        -: 7057:
        3: 7058:    if (!sanitycheck()) {
        -: 7059:        return EX_OSERR;
        -: 7060:    }
        -: 7061:
        -: 7062:    /* handle SIGINT, SIGTERM */
        3: 7063:    signal(SIGINT, sig_handler);
        3: 7064:    signal(SIGTERM, sig_handler);
        3: 7065:    signal(SIGHUP, sighup_handler);
        -: 7066:
        -: 7067:    /* init settings */
        3: 7068:    settings_init();
        -: 7069:#ifdef EXTSTORE
        -: 7070:    settings.ext_item_size = 512;
        -: 7071:    settings.ext_item_age = UINT_MAX;
        -: 7072:    settings.ext_low_ttl = 0;
        -: 7073:    settings.ext_recache_rate = 2000;
        -: 7074:    settings.ext_max_frag = 0.8;
        -: 7075:    settings.ext_drop_unread = false;
        -: 7076:    settings.ext_wbuf_size = 1024 * 1024 * 4;
        -: 7077:    settings.ext_compact_under = 0;
        -: 7078:    settings.ext_drop_under = 0;
        -: 7079:    settings.slab_automove_freeratio = 0.01;
        -: 7080:    ext_cf.page_size = 1024 * 1024 * 64;
        -: 7081:    ext_cf.wbuf_size = settings.ext_wbuf_size;
        -: 7082:    ext_cf.io_threadcount = 1;
        -: 7083:    ext_cf.io_depth = 1;
        -: 7084:    ext_cf.page_buckets = 4;
        -: 7085:    ext_cf.wbuf_count = ext_cf.page_buckets;
        -: 7086:#endif
        -: 7087:
        -: 7088:    /* Run regardless of initializing it later */
        3: 7089:    init_lru_maintainer();
        -: 7090:
        -: 7091:    /* set stderr non-buffering (for running under, say, daemontools) */
        3: 7092:    setbuf(stderr, NULL);
        -: 7093:
        3: 7094:    char *shortopts =
        -: 7095:          "a:"  /* access mask for unix socket */
        -: 7096:          "A"  /* enable admin shutdown command */
        -: 7097:          "Z"   /* enable SSL */
        -: 7098:          "p:"  /* TCP port number to listen on */
        -: 7099:          "s:"  /* unix socket path to listen on */
        -: 7100:          "U:"  /* UDP port number to listen on */
        -: 7101:          "m:"  /* max memory to use for items in megabytes */
        -: 7102:          "M"   /* return error on memory exhausted */
        -: 7103:          "c:"  /* max simultaneous connections */
        -: 7104:          "k"   /* lock down all paged memory */
        -: 7105:          "hiV" /* help, licence info, version */
        -: 7106:          "r"   /* maximize core file limit */
        -: 7107:          "v"   /* verbose */
        -: 7108:          "d"   /* daemon mode */
        -: 7109:          "l:"  /* interface to listen on */
        -: 7110:          "u:"  /* user identity to run as */
        -: 7111:          "P:"  /* save PID in file */
        -: 7112:          "f:"  /* factor? */
        -: 7113:          "n:"  /* minimum space allocated for key+value+flags */
        -: 7114:          "t:"  /* threads */
        -: 7115:          "D:"  /* prefix delimiter? */
        -: 7116:          "L"   /* Large memory pages */
        -: 7117:          "R:"  /* max requests per event */
        -: 7118:          "C"   /* Disable use of CAS */
        -: 7119:          "b:"  /* backlog queue limit */
        -: 7120:          "B:"  /* Binding protocol */
        -: 7121:          "I:"  /* Max item size */
        -: 7122:          "S"   /* Sasl ON */
        -: 7123:          "F"   /* Disable flush_all */
        -: 7124:          "X"   /* Disable dump commands */
        -: 7125:          "Y:"   /* Enable token auth */
        -: 7126:          "o:"  /* Extended generic options */
        -: 7127:          ;
        -: 7128:
        -: 7129:    /* process arguments */
        -: 7130:#ifdef HAVE_GETOPT_LONG
        3: 7131:    const struct option longopts[] = {
        -: 7132:        {"unix-mask", required_argument, 0, 'a'},
        -: 7133:        {"enable-shutdown", no_argument, 0, 'A'},
        -: 7134:        {"enable-ssl", no_argument, 0, 'Z'},
        -: 7135:        {"port", required_argument, 0, 'p'},
        -: 7136:        {"unix-socket", required_argument, 0, 's'},
        -: 7137:        {"udp-port", required_argument, 0, 'U'},
        -: 7138:        {"memory-limit", required_argument, 0, 'm'},
        -: 7139:        {"disable-evictions", no_argument, 0, 'M'},
        -: 7140:        {"conn-limit", required_argument, 0, 'c'},
        -: 7141:        {"lock-memory", no_argument, 0, 'k'},
        -: 7142:        {"help", no_argument, 0, 'h'},
        -: 7143:        {"license", no_argument, 0, 'i'},
        -: 7144:        {"version", no_argument, 0, 'V'},
        -: 7145:        {"enable-coredumps", no_argument, 0, 'r'},
        -: 7146:        {"verbose", optional_argument, 0, 'v'},
        -: 7147:        {"daemon", no_argument, 0, 'd'},
        -: 7148:        {"listen", required_argument, 0, 'l'},
        -: 7149:        {"user", required_argument, 0, 'u'},
        -: 7150:        {"pidfile", required_argument, 0, 'P'},
        -: 7151:        {"slab-growth-factor", required_argument, 0, 'f'},
        -: 7152:        {"slab-min-size", required_argument, 0, 'n'},
        -: 7153:        {"threads", required_argument, 0, 't'},
        -: 7154:        {"enable-largepages", no_argument, 0, 'L'},
        -: 7155:        {"max-reqs-per-event", required_argument, 0, 'R'},
        -: 7156:        {"disable-cas", no_argument, 0, 'C'},
        -: 7157:        {"listen-backlog", required_argument, 0, 'b'},
        -: 7158:        {"protocol", required_argument, 0, 'B'},
        -: 7159:        {"max-item-size", required_argument, 0, 'I'},
        -: 7160:        {"enable-sasl", no_argument, 0, 'S'},
        -: 7161:        {"disable-flush-all", no_argument, 0, 'F'},
        -: 7162:        {"disable-dumping", no_argument, 0, 'X'},
        -: 7163:        {"auth-file", required_argument, 0, 'Y'},
        -: 7164:        {"extended", required_argument, 0, 'o'},
        -: 7165:        {0, 0, 0, 0}
        -: 7166:    };
        3: 7167:    int optindex;
        9: 7168:    while (-1 != (c = getopt_long(argc, argv, shortopts,
        -: 7169:                    longopts, &optindex))) {
        -: 7170:#else
        -: 7171:    while (-1 != (c = getopt(argc, argv, shortopts))) {
        -: 7172:#endif
        6: 7173:        switch (c) {
    #####: 7174:        case 'A':
        -: 7175:            /* enables "shutdown" command */
    #####: 7176:            settings.shutdown_command = true;
    #####: 7177:            break;
    #####: 7178:        case 'Z':
        -: 7179:            /* enable secure communication*/
        -: 7180:#ifdef TLS
        -: 7181:            settings.ssl_enabled = true;
        -: 7182:#else
    #####: 7183:            fprintf(stderr, "This server is not built with TLS support.\n");
    #####: 7184:            exit(EX_USAGE);
        -: 7185:#endif
    #####: 7186:            break;
    #####: 7187:        case 'a':
        -: 7188:            /* access for unix domain socket, as octal mask (like chmod)*/
    #####: 7189:            settings.access= strtol(optarg,NULL,8);
    #####: 7190:            break;
    #####: 7191:        case 'U':
    #####: 7192:            settings.udpport = atoi(optarg);
    #####: 7193:            udp_specified = true;
    #####: 7194:            break;
        3: 7195:        case 'p':
        3: 7196:            settings.port = atoi(optarg);
        3: 7197:            tcp_specified = true;
        3: 7198:            break;
    #####: 7199:        case 's':
    #####: 7200:            settings.socketpath = optarg;
    #####: 7201:            break;
    #####: 7202:        case 'm':
    #####: 7203:            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;
    #####: 7204:            break;
    #####: 7205:        case 'M':
    #####: 7206:            settings.evict_to_free = 0;
    #####: 7207:            break;
    #####: 7208:        case 'c':
    #####: 7209:            settings.maxconns = atoi(optarg);
    #####: 7210:            if (settings.maxconns <= 0) {
    #####: 7211:                fprintf(stderr, "Maximum connections must be greater than 0\n");
    #####: 7212:                return 1;
        -: 7213:            }
        -: 7214:            break;
    #####: 7215:        case 'h':
    #####: 7216:            usage();
    #####: 7217:            exit(EXIT_SUCCESS);
    #####: 7218:        case 'i':
    #####: 7219:            usage_license();
    #####: 7220:            exit(EXIT_SUCCESS);
        -: 7221:        case 'V':
    #####: 7222:            printf(PACKAGE " " VERSION "\n");
    #####: 7223:            exit(EXIT_SUCCESS);
        -: 7224:        case 'k':
        -: 7225:            lock_memory = true;
        -: 7226:            break;
    #####: 7227:        case 'v':
    #####: 7228:            settings.verbose++;
    #####: 7229:            break;
    #####: 7230:        case 'l':
    #####: 7231:            if (settings.inter != NULL) {
    #####: 7232:                if (strstr(settings.inter, optarg) != NULL) {
        -: 7233:                    break;
        -: 7234:                }
    #####: 7235:                size_t len = strlen(settings.inter) + strlen(optarg) + 2;
    #####: 7236:                char *p = malloc(len);
    #####: 7237:                if (p == NULL) {
    #####: 7238:                    fprintf(stderr, "Failed to allocate memory\n");
    #####: 7239:                    return 1;
        -: 7240:                }
    #####: 7241:                snprintf(p, len, "%s,%s", settings.inter, optarg);
    #####: 7242:                free(settings.inter);
    #####: 7243:                settings.inter = p;
        -: 7244:            } else {
    #####: 7245:                settings.inter= strdup(optarg);
        -: 7246:            }
        -: 7247:            break;
    #####: 7248:        case 'd':
    #####: 7249:            do_daemonize = true;
    #####: 7250:            break;
    #####: 7251:        case 'r':
    #####: 7252:            maxcore = 1;
    #####: 7253:            break;
    #####: 7254:        case 'R':
    #####: 7255:            settings.reqs_per_event = atoi(optarg);
    #####: 7256:            if (settings.reqs_per_event == 0) {
    #####: 7257:                fprintf(stderr, "Number of requests per event must be greater than 0\n");
    #####: 7258:                return 1;
        -: 7259:            }
        -: 7260:            break;
        3: 7261:        case 'u':
        3: 7262:            username = optarg;
        3: 7263:            break;
    #####: 7264:        case 'P':
    #####: 7265:            pid_file = optarg;
    #####: 7266:            break;
    #####: 7267:        case 'f':
    #####: 7268:            settings.factor = atof(optarg);
    #####: 7269:            if (settings.factor <= 1.0) {
    #####: 7270:                fprintf(stderr, "Factor must be greater than 1\n");
    #####: 7271:                return 1;
        -: 7272:            }
        -: 7273:            break;
    #####: 7274:        case 'n':
    #####: 7275:            settings.chunk_size = atoi(optarg);
    #####: 7276:            if (settings.chunk_size == 0) {
    #####: 7277:                fprintf(stderr, "Chunk size must be greater than 0\n");
    #####: 7278:                return 1;
        -: 7279:            }
        -: 7280:            break;
    #####: 7281:        case 't':
    #####: 7282:            settings.num_threads = atoi(optarg);
    #####: 7283:            if (settings.num_threads <= 0) {
    #####: 7284:                fprintf(stderr, "Number of threads must be greater than 0\n");
    #####: 7285:                return 1;
        -: 7286:            }
        -: 7287:            /* There're other problems when you get above 64 threads.
        -: 7288:             * In the future we should portably detect # of cores for the
        -: 7289:             * default.
        -: 7290:             */
    #####: 7291:            if (settings.num_threads > 64) {
    #####: 7292:                fprintf(stderr, "WARNING: Setting a high number of worker"
        -: 7293:                                "threads is not recommended.\n"
        -: 7294:                                " Set this value to the number of cores in"
        -: 7295:                                " your machine or less.\n");
        -: 7296:            }
        -: 7297:            break;
    #####: 7298:        case 'D':
    #####: 7299:            if (! optarg || ! optarg[0]) {
    #####: 7300:                fprintf(stderr, "No delimiter specified\n");
    #####: 7301:                return 1;
        -: 7302:            }
    #####: 7303:            settings.prefix_delimiter = optarg[0];
    #####: 7304:            settings.detail_enabled = 1;
    #####: 7305:            break;
    #####: 7306:        case 'L' :
    #####: 7307:            if (enable_large_pages() == 0) {
        -: 7308:                preallocate = true;
        -: 7309:            } else {
    #####: 7310:                fprintf(stderr, "Cannot enable large pages on this system\n"
        -: 7311:                    "(There is no support as of this version)\n");
    #####: 7312:                return 1;
        -: 7313:            }
        -: 7314:            break;
    #####: 7315:        case 'C' :
    #####: 7316:            settings.use_cas = false;
    #####: 7317:            break;
    #####: 7318:        case 'b' :
    #####: 7319:            settings.backlog = atoi(optarg);
    #####: 7320:            break;
    #####: 7321:        case 'B':
    #####: 7322:            protocol_specified = true;
    #####: 7323:            if (strcmp(optarg, "auto") == 0) {
    #####: 7324:                settings.binding_protocol = negotiating_prot;
    #####: 7325:            } else if (strcmp(optarg, "binary") == 0) {
    #####: 7326:                settings.binding_protocol = binary_prot;
    #####: 7327:            } else if (strcmp(optarg, "ascii") == 0) {
    #####: 7328:                settings.binding_protocol = ascii_prot;
        -: 7329:            } else {
    #####: 7330:                fprintf(stderr, "Invalid value for binding protocol: %s\n"
        -: 7331:                        " -- should be one of auto, binary, or ascii\n", optarg);
    #####: 7332:                exit(EX_USAGE);
        -: 7333:            }
        -: 7334:            break;
    #####: 7335:        case 'I':
    #####: 7336:            buf = strdup(optarg);
    #####: 7337:            unit = buf[strlen(buf)-1];
    #####: 7338:            if (unit == 'k' || unit == 'm' ||
    #####: 7339:                unit == 'K' || unit == 'M') {
    #####: 7340:                buf[strlen(buf)-1] = '\0';
    #####: 7341:                size_max = atoi(buf);
    #####: 7342:                if (unit == 'k' || unit == 'K')
    #####: 7343:                    size_max *= 1024;
    #####: 7344:                if (unit == 'm' || unit == 'M')
    #####: 7345:                    size_max *= 1024 * 1024;
    #####: 7346:                settings.item_size_max = size_max;
        -: 7347:            } else {
    #####: 7348:                settings.item_size_max = atoi(buf);
        -: 7349:            }
    #####: 7350:            free(buf);
    #####: 7351:            break;
    #####: 7352:        case 'S': /* set Sasl authentication to true. Default is false */
        -: 7353:#ifndef ENABLE_SASL
    #####: 7354:            fprintf(stderr, "This server is not built with SASL support.\n");
    #####: 7355:            exit(EX_USAGE);
        -: 7356:#endif
        -: 7357:            settings.sasl = true;
        -: 7358:            break;
    #####: 7359:       case 'F' :
    #####: 7360:            settings.flush_enabled = false;
    #####: 7361:            break;
    #####: 7362:       case 'X' :
    #####: 7363:            settings.dump_enabled = false;
    #####: 7364:            break;
    #####: 7365:       case 'Y' :
        -: 7366:            // dupe the file path now just in case the options get mangled.
    #####: 7367:            settings.auth_file = strdup(optarg);
    #####: 7368:            break;
    #####: 7369:        case 'o': /* It's sub-opts time! */
    #####: 7370:            subopts_orig = subopts = strdup(optarg); /* getsubopt() changes the original args */
        -: 7371:
    #####: 7372:            while (*subopts != '\0') {
        -: 7373:
    #####: 7374:            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
    #####: 7375:            case MAXCONNS_FAST:
    #####: 7376:                settings.maxconns_fast = true;
    #####: 7377:                break;
    #####: 7378:            case HASHPOWER_INIT:
    #####: 7379:                if (subopts_value == NULL) {
    #####: 7380:                    fprintf(stderr, "Missing numeric argument for hashpower\n");
    #####: 7381:                    return 1;
        -: 7382:                }
    #####: 7383:                settings.hashpower_init = atoi(subopts_value);
    #####: 7384:                if (settings.hashpower_init < 12) {
    #####: 7385:                    fprintf(stderr, "Initial hashtable multiplier of %d is too low\n",
        -: 7386:                        settings.hashpower_init);
    #####: 7387:                    return 1;
    #####: 7388:                } else if (settings.hashpower_init > 32) {
    #####: 7389:                    fprintf(stderr, "Initial hashtable multiplier of %d is too high\n"
        -: 7390:                        "Choose a value based on \"STAT hash_power_level\" from a running instance\n",
        -: 7391:                        settings.hashpower_init);
    #####: 7392:                    return 1;
        -: 7393:                }
        -: 7394:                break;
    #####: 7395:            case NO_HASHEXPAND:
    #####: 7396:                start_assoc_maint = false;
    #####: 7397:                break;
    #####: 7398:            case SLAB_REASSIGN:
    #####: 7399:                settings.slab_reassign = true;
    #####: 7400:                break;
    #####: 7401:            case SLAB_AUTOMOVE:
    #####: 7402:                if (subopts_value == NULL) {
    #####: 7403:                    settings.slab_automove = 1;
    #####: 7404:                    break;
        -: 7405:                }
    #####: 7406:                settings.slab_automove = atoi(subopts_value);
    #####: 7407:                if (settings.slab_automove < 0 || settings.slab_automove > 2) {
    #####: 7408:                    fprintf(stderr, "slab_automove must be between 0 and 2\n");
    #####: 7409:                    return 1;
        -: 7410:                }
        -: 7411:                break;
    #####: 7412:            case SLAB_AUTOMOVE_RATIO:
    #####: 7413:                if (subopts_value == NULL) {
    #####: 7414:                    fprintf(stderr, "Missing slab_automove_ratio argument\n");
    #####: 7415:                    return 1;
        -: 7416:                }
    #####: 7417:                settings.slab_automove_ratio = atof(subopts_value);
    #####: 7418:                if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {
    #####: 7419:                    fprintf(stderr, "slab_automove_ratio must be > 0 and < 1\n");
    #####: 7420:                    return 1;
        -: 7421:                }
        -: 7422:                break;
    #####: 7423:            case SLAB_AUTOMOVE_WINDOW:
    #####: 7424:                if (subopts_value == NULL) {
    #####: 7425:                    fprintf(stderr, "Missing slab_automove_window argument\n");
    #####: 7426:                    return 1;
        -: 7427:                }
    #####: 7428:                settings.slab_automove_window = atoi(subopts_value);
    #####: 7429:                if (settings.slab_automove_window < 3) {
    #####: 7430:                    fprintf(stderr, "slab_automove_window must be > 2\n");
    #####: 7431:                    return 1;
        -: 7432:                }
        -: 7433:                break;
    #####: 7434:            case TAIL_REPAIR_TIME:
    #####: 7435:                if (subopts_value == NULL) {
    #####: 7436:                    fprintf(stderr, "Missing numeric argument for tail_repair_time\n");
    #####: 7437:                    return 1;
        -: 7438:                }
    #####: 7439:                settings.tail_repair_time = atoi(subopts_value);
    #####: 7440:                if (settings.tail_repair_time < 10) {
    #####: 7441:                    fprintf(stderr, "Cannot set tail_repair_time to less than 10 seconds\n");
    #####: 7442:                    return 1;
        -: 7443:                }
        -: 7444:                break;
    #####: 7445:            case HASH_ALGORITHM:
    #####: 7446:                if (subopts_value == NULL) {
    #####: 7447:                    fprintf(stderr, "Missing hash_algorithm argument\n");
    #####: 7448:                    return 1;
    #####: 7449:                };
    #####: 7450:                if (strcmp(subopts_value, "jenkins") == 0) {
        -: 7451:                    hash_type = JENKINS_HASH;
    #####: 7452:                } else if (strcmp(subopts_value, "murmur3") == 0) {
        -: 7453:                    hash_type = MURMUR3_HASH;
        -: 7454:                } else {
    #####: 7455:                    fprintf(stderr, "Unknown hash_algorithm option (jenkins, murmur3)\n");
    #####: 7456:                    return 1;
        -: 7457:                }
        -: 7458:                break;
    #####: 7459:            case LRU_CRAWLER:
    #####: 7460:                start_lru_crawler = true;
    #####: 7461:                break;
    #####: 7462:            case LRU_CRAWLER_SLEEP:
    #####: 7463:                if (subopts_value == NULL) {
    #####: 7464:                    fprintf(stderr, "Missing lru_crawler_sleep value\n");
    #####: 7465:                    return 1;
        -: 7466:                }
    #####: 7467:                settings.lru_crawler_sleep = atoi(subopts_value);
    #####: 7468:                if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {
    #####: 7469:                    fprintf(stderr, "LRU crawler sleep must be between 0 and 1 second\n");
    #####: 7470:                    return 1;
        -: 7471:                }
        -: 7472:                break;
    #####: 7473:            case LRU_CRAWLER_TOCRAWL:
    #####: 7474:                if (subopts_value == NULL) {
    #####: 7475:                    fprintf(stderr, "Missing lru_crawler_tocrawl value\n");
    #####: 7476:                    return 1;
        -: 7477:                }
    #####: 7478:                if (!safe_strtoul(subopts_value, &tocrawl)) {
    #####: 7479:                    fprintf(stderr, "lru_crawler_tocrawl takes a numeric 32bit value\n");
    #####: 7480:                    return 1;
        -: 7481:                }
    #####: 7482:                settings.lru_crawler_tocrawl = tocrawl;
    #####: 7483:                break;
    #####: 7484:            case LRU_MAINTAINER:
    #####: 7485:                start_lru_maintainer = true;
    #####: 7486:                settings.lru_segmented = true;
    #####: 7487:                break;
    #####: 7488:            case HOT_LRU_PCT:
    #####: 7489:                if (subopts_value == NULL) {
    #####: 7490:                    fprintf(stderr, "Missing hot_lru_pct argument\n");
    #####: 7491:                    return 1;
        -: 7492:                }
    #####: 7493:                settings.hot_lru_pct = atoi(subopts_value);
    #####: 7494:                if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {
    #####: 7495:                    fprintf(stderr, "hot_lru_pct must be > 1 and < 80\n");
    #####: 7496:                    return 1;
        -: 7497:                }
        -: 7498:                break;
    #####: 7499:            case WARM_LRU_PCT:
    #####: 7500:                if (subopts_value == NULL) {
    #####: 7501:                    fprintf(stderr, "Missing warm_lru_pct argument\n");
    #####: 7502:                    return 1;
        -: 7503:                }
    #####: 7504:                settings.warm_lru_pct = atoi(subopts_value);
    #####: 7505:                if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {
    #####: 7506:                    fprintf(stderr, "warm_lru_pct must be > 1 and < 80\n");
    #####: 7507:                    return 1;
        -: 7508:                }
        -: 7509:                break;
    #####: 7510:            case HOT_MAX_FACTOR:
    #####: 7511:                if (subopts_value == NULL) {
    #####: 7512:                    fprintf(stderr, "Missing hot_max_factor argument\n");
    #####: 7513:                    return 1;
        -: 7514:                }
    #####: 7515:                settings.hot_max_factor = atof(subopts_value);
    #####: 7516:                if (settings.hot_max_factor <= 0) {
    #####: 7517:                    fprintf(stderr, "hot_max_factor must be > 0\n");
    #####: 7518:                    return 1;
        -: 7519:                }
        -: 7520:                break;
    #####: 7521:            case WARM_MAX_FACTOR:
    #####: 7522:                if (subopts_value == NULL) {
    #####: 7523:                    fprintf(stderr, "Missing warm_max_factor argument\n");
    #####: 7524:                    return 1;
        -: 7525:                }
    #####: 7526:                settings.warm_max_factor = atof(subopts_value);
    #####: 7527:                if (settings.warm_max_factor <= 0) {
    #####: 7528:                    fprintf(stderr, "warm_max_factor must be > 0\n");
    #####: 7529:                    return 1;
        -: 7530:                }
        -: 7531:                break;
    #####: 7532:            case TEMPORARY_TTL:
    #####: 7533:                if (subopts_value == NULL) {
    #####: 7534:                    fprintf(stderr, "Missing temporary_ttl argument\n");
    #####: 7535:                    return 1;
        -: 7536:                }
    #####: 7537:                settings.temp_lru = true;
    #####: 7538:                settings.temporary_ttl = atoi(subopts_value);
    #####: 7539:                break;
    #####: 7540:            case IDLE_TIMEOUT:
    #####: 7541:                if (subopts_value == NULL) {
    #####: 7542:                    fprintf(stderr, "Missing numeric argument for idle_timeout\n");
    #####: 7543:                    return 1;
        -: 7544:                }
    #####: 7545:                settings.idle_timeout = atoi(subopts_value);
    #####: 7546:                break;
    #####: 7547:            case WATCHER_LOGBUF_SIZE:
    #####: 7548:                if (subopts_value == NULL) {
    #####: 7549:                    fprintf(stderr, "Missing watcher_logbuf_size argument\n");
    #####: 7550:                    return 1;
        -: 7551:                }
    #####: 7552:                if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {
    #####: 7553:                    fprintf(stderr, "could not parse argument to watcher_logbuf_size\n");
    #####: 7554:                    return 1;
        -: 7555:                }
    #####: 7556:                settings.logger_watcher_buf_size *= 1024; /* kilobytes */
    #####: 7557:                break;
    #####: 7558:            case WORKER_LOGBUF_SIZE:
    #####: 7559:                if (subopts_value == NULL) {
    #####: 7560:                    fprintf(stderr, "Missing worker_logbuf_size argument\n");
    #####: 7561:                    return 1;
        -: 7562:                }
    #####: 7563:                if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {
    #####: 7564:                    fprintf(stderr, "could not parse argument to worker_logbuf_size\n");
    #####: 7565:                    return 1;
        -: 7566:                }
    #####: 7567:                settings.logger_buf_size *= 1024; /* kilobytes */
    #####: 7568:            case SLAB_SIZES:
    #####: 7569:                slab_sizes_unparsed = subopts_value;
    #####: 7570:                break;
    #####: 7571:            case SLAB_CHUNK_MAX:
    #####: 7572:                if (subopts_value == NULL) {
    #####: 7573:                    fprintf(stderr, "Missing slab_chunk_max argument\n");
        -: 7574:                }
    #####: 7575:                if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {
    #####: 7576:                    fprintf(stderr, "could not parse argument to slab_chunk_max\n");
        -: 7577:                }
        -: 7578:                slab_chunk_size_changed = true;
        -: 7579:                break;
    #####: 7580:            case TRACK_SIZES:
    #####: 7581:                item_stats_sizes_init();
    #####: 7582:                break;
        -: 7583:            case NO_INLINE_ASCII_RESP:
        -: 7584:                break;
        -: 7585:            case INLINE_ASCII_RESP:
        -: 7586:                break;
    #####: 7587:            case NO_CHUNKED_ITEMS:
    #####: 7588:                settings.slab_chunk_size_max = settings.slab_page_size;
    #####: 7589:                break;
    #####: 7590:            case NO_SLAB_REASSIGN:
    #####: 7591:                settings.slab_reassign = false;
    #####: 7592:                break;
    #####: 7593:            case NO_SLAB_AUTOMOVE:
    #####: 7594:                settings.slab_automove = 0;
    #####: 7595:                break;
    #####: 7596:            case NO_MAXCONNS_FAST:
    #####: 7597:                settings.maxconns_fast = false;
    #####: 7598:                break;
    #####: 7599:            case NO_LRU_CRAWLER:
    #####: 7600:                settings.lru_crawler = false;
    #####: 7601:                start_lru_crawler = false;
    #####: 7602:                break;
    #####: 7603:            case NO_LRU_MAINTAINER:
    #####: 7604:                start_lru_maintainer = false;
    #####: 7605:                settings.lru_segmented = false;
    #####: 7606:                break;
        -: 7607:#ifdef TLS
        -: 7608:            case SSL_CERT:
        -: 7609:                if (subopts_value == NULL) {
        -: 7610:                    fprintf(stderr, "Missing ssl_chain_cert argument\n");
        -: 7611:                    return 1;
        -: 7612:                }
        -: 7613:                settings.ssl_chain_cert = strdup(subopts_value);
        -: 7614:                break;
        -: 7615:            case SSL_KEY:
        -: 7616:                if (subopts_value == NULL) {
        -: 7617:                    fprintf(stderr, "Missing ssl_key argument\n");
        -: 7618:                    return 1;
        -: 7619:                }
        -: 7620:                settings.ssl_key = strdup(subopts_value);
        -: 7621:                break;
        -: 7622:            case SSL_VERIFY_MODE:
        -: 7623:            {
        -: 7624:                if (subopts_value == NULL) {
        -: 7625:                    fprintf(stderr, "Missing ssl_verify_mode argument\n");
        -: 7626:                    return 1;
        -: 7627:                }
        -: 7628:                int verify  = 0;
        -: 7629:                if (!safe_strtol(subopts_value, &verify)) {
        -: 7630:                    fprintf(stderr, "could not parse argument to ssl_verify_mode\n");
        -: 7631:                    return 1;
        -: 7632:                }
        -: 7633:                switch(verify) {
        -: 7634:                    case 0:
        -: 7635:                        settings.ssl_verify_mode = SSL_VERIFY_NONE;
        -: 7636:                        break;
        -: 7637:                    case 1:
        -: 7638:                        settings.ssl_verify_mode = SSL_VERIFY_PEER;
        -: 7639:                        break;
        -: 7640:                    case 2:
        -: 7641:                        settings.ssl_verify_mode = SSL_VERIFY_PEER |
        -: 7642:                                                    SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
        -: 7643:                        break;
        -: 7644:                    case 3:
        -: 7645:                        settings.ssl_verify_mode = SSL_VERIFY_PEER |
        -: 7646:                                                    SSL_VERIFY_FAIL_IF_NO_PEER_CERT |
        -: 7647:                                                    SSL_VERIFY_CLIENT_ONCE;
        -: 7648:                        break;
        -: 7649:                    default:
        -: 7650:                        fprintf(stderr, "Invalid ssl_verify_mode. Use help to see valid options.\n");
        -: 7651:                        return 1;
        -: 7652:                }
        -: 7653:                break;
        -: 7654:            }
        -: 7655:            case SSL_KEYFORM:
        -: 7656:                if (subopts_value == NULL) {
        -: 7657:                    fprintf(stderr, "Missing ssl_keyformat argument\n");
        -: 7658:                    return 1;
        -: 7659:                }
        -: 7660:                if (!safe_strtol(subopts_value, &settings.ssl_keyformat)) {
        -: 7661:                    fprintf(stderr, "could not parse argument to ssl_keyformat\n");
        -: 7662:                    return 1;
        -: 7663:                }
        -: 7664:                break;
        -: 7665:            case SSL_CIPHERS:
        -: 7666:                if (subopts_value == NULL) {
        -: 7667:                    fprintf(stderr, "Missing ssl_ciphers argument\n");
        -: 7668:                    return 1;
        -: 7669:                }
        -: 7670:                settings.ssl_ciphers = strdup(subopts_value);
        -: 7671:                break;
        -: 7672:            case SSL_CA_CERT:
        -: 7673:                if (subopts_value == NULL) {
        -: 7674:                    fprintf(stderr, "Missing ssl_ca_cert argument\n");
        -: 7675:                    return 1;
        -: 7676:                }
        -: 7677:                settings.ssl_ca_cert = strdup(subopts_value);
        -: 7678:                break;
        -: 7679:            case SSL_WBUF_SIZE:
        -: 7680:                if (subopts_value == NULL) {
        -: 7681:                    fprintf(stderr, "Missing ssl_wbuf_size argument\n");
        -: 7682:                    return 1;
        -: 7683:                }
        -: 7684:                if (!safe_strtoul(subopts_value, &settings.ssl_wbuf_size)) {
        -: 7685:                    fprintf(stderr, "could not parse argument to ssl_wbuf_size\n");
        -: 7686:                    return 1;
        -: 7687:                }
        -: 7688:                settings.ssl_wbuf_size *= 1024; /* kilobytes */
        -: 7689:                break;
        -: 7690:#endif
        -: 7691:#ifdef EXTSTORE
        -: 7692:            case EXT_PAGE_SIZE:
        -: 7693:                if (storage_file) {
        -: 7694:                    fprintf(stderr, "Must specify ext_page_size before any ext_path arguments\n");
        -: 7695:                    return 1;
        -: 7696:                }
        -: 7697:                if (subopts_value == NULL) {
        -: 7698:                    fprintf(stderr, "Missing ext_page_size argument\n");
        -: 7699:                    return 1;
        -: 7700:                }
        -: 7701:                if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {
        -: 7702:                    fprintf(stderr, "could not parse argument to ext_page_size\n");
        -: 7703:                    return 1;
        -: 7704:                }
        -: 7705:                ext_cf.page_size *= 1024 * 1024; /* megabytes */
        -: 7706:                break;
        -: 7707:            case EXT_WBUF_SIZE:
        -: 7708:                if (subopts_value == NULL) {
        -: 7709:                    fprintf(stderr, "Missing ext_wbuf_size argument\n");
        -: 7710:                    return 1;
        -: 7711:                }
        -: 7712:                if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {
        -: 7713:                    fprintf(stderr, "could not parse argument to ext_wbuf_size\n");
        -: 7714:                    return 1;
        -: 7715:                }
        -: 7716:                ext_cf.wbuf_size *= 1024 * 1024; /* megabytes */
        -: 7717:                settings.ext_wbuf_size = ext_cf.wbuf_size;
        -: 7718:                break;
        -: 7719:            case EXT_THREADS:
        -: 7720:                if (subopts_value == NULL) {
        -: 7721:                    fprintf(stderr, "Missing ext_threads argument\n");
        -: 7722:                    return 1;
        -: 7723:                }
        -: 7724:                if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {
        -: 7725:                    fprintf(stderr, "could not parse argument to ext_threads\n");
        -: 7726:                    return 1;
        -: 7727:                }
        -: 7728:                break;
        -: 7729:            case EXT_IO_DEPTH:
        -: 7730:                if (subopts_value == NULL) {
        -: 7731:                    fprintf(stderr, "Missing ext_io_depth argument\n");
        -: 7732:                    return 1;
        -: 7733:                }
        -: 7734:                if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {
        -: 7735:                    fprintf(stderr, "could not parse argument to ext_io_depth\n");
        -: 7736:                    return 1;
        -: 7737:                }
        -: 7738:                break;
        -: 7739:            case EXT_ITEM_SIZE:
        -: 7740:                if (subopts_value == NULL) {
        -: 7741:                    fprintf(stderr, "Missing ext_item_size argument\n");
        -: 7742:                    return 1;
        -: 7743:                }
        -: 7744:                if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {
        -: 7745:                    fprintf(stderr, "could not parse argument to ext_item_size\n");
        -: 7746:                    return 1;
        -: 7747:                }
        -: 7748:                break;
        -: 7749:            case EXT_ITEM_AGE:
        -: 7750:                if (subopts_value == NULL) {
        -: 7751:                    fprintf(stderr, "Missing ext_item_age argument\n");
        -: 7752:                    return 1;
        -: 7753:                }
        -: 7754:                if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {
        -: 7755:                    fprintf(stderr, "could not parse argument to ext_item_age\n");
        -: 7756:                    return 1;
        -: 7757:                }
        -: 7758:                break;
        -: 7759:            case EXT_LOW_TTL:
        -: 7760:                if (subopts_value == NULL) {
        -: 7761:                    fprintf(stderr, "Missing ext_low_ttl argument\n");
        -: 7762:                    return 1;
        -: 7763:                }
        -: 7764:                if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {
        -: 7765:                    fprintf(stderr, "could not parse argument to ext_low_ttl\n");
        -: 7766:                    return 1;
        -: 7767:                }
        -: 7768:                break;
        -: 7769:            case EXT_RECACHE_RATE:
        -: 7770:                if (subopts_value == NULL) {
        -: 7771:                    fprintf(stderr, "Missing ext_recache_rate argument\n");
        -: 7772:                    return 1;
        -: 7773:                }
        -: 7774:                if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {
        -: 7775:                    fprintf(stderr, "could not parse argument to ext_recache_rate\n");
        -: 7776:                    return 1;
        -: 7777:                }
        -: 7778:                break;
        -: 7779:            case EXT_COMPACT_UNDER:
        -: 7780:                if (subopts_value == NULL) {
        -: 7781:                    fprintf(stderr, "Missing ext_compact_under argument\n");
        -: 7782:                    return 1;
        -: 7783:                }
        -: 7784:                if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {
        -: 7785:                    fprintf(stderr, "could not parse argument to ext_compact_under\n");
        -: 7786:                    return 1;
        -: 7787:                }
        -: 7788:                break;
        -: 7789:            case EXT_DROP_UNDER:
        -: 7790:                if (subopts_value == NULL) {
        -: 7791:                    fprintf(stderr, "Missing ext_drop_under argument\n");
        -: 7792:                    return 1;
        -: 7793:                }
        -: 7794:                if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {
        -: 7795:                    fprintf(stderr, "could not parse argument to ext_drop_under\n");
        -: 7796:                    return 1;
        -: 7797:                }
        -: 7798:                break;
        -: 7799:            case EXT_MAX_FRAG:
        -: 7800:                if (subopts_value == NULL) {
        -: 7801:                    fprintf(stderr, "Missing ext_max_frag argument\n");
        -: 7802:                    return 1;
        -: 7803:                }
        -: 7804:                if (!safe_strtod(subopts_value, &settings.ext_max_frag)) {
        -: 7805:                    fprintf(stderr, "could not parse argument to ext_max_frag\n");
        -: 7806:                    return 1;
        -: 7807:                }
        -: 7808:                break;
        -: 7809:            case SLAB_AUTOMOVE_FREERATIO:
        -: 7810:                if (subopts_value == NULL) {
        -: 7811:                    fprintf(stderr, "Missing slab_automove_freeratio argument\n");
        -: 7812:                    return 1;
        -: 7813:                }
        -: 7814:                if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {
        -: 7815:                    fprintf(stderr, "could not parse argument to slab_automove_freeratio\n");
        -: 7816:                    return 1;
        -: 7817:                }
        -: 7818:                break;
        -: 7819:            case EXT_DROP_UNREAD:
        -: 7820:                settings.ext_drop_unread = true;
        -: 7821:                break;
        -: 7822:            case EXT_PATH:
        -: 7823:                if (subopts_value) {
        -: 7824:                    struct extstore_conf_file *tmp = storage_conf_parse(subopts_value, ext_cf.page_size);
        -: 7825:                    if (tmp == NULL) {
        -: 7826:                        fprintf(stderr, "failed to parse ext_path argument\n");
        -: 7827:                        return 1;
        -: 7828:                    }
        -: 7829:                    if (storage_file != NULL) {
        -: 7830:                        tmp->next = storage_file;
        -: 7831:                    }
        -: 7832:                    storage_file = tmp;
        -: 7833:                } else {
        -: 7834:                    fprintf(stderr, "missing argument to ext_path, ie: ext_path=/d/file:5G\n");
        -: 7835:                    return 1;
        -: 7836:                }
        -: 7837:                break;
        -: 7838:#endif
        -: 7839:            case MODERN:
        -: 7840:                /* currently no new defaults */
        -: 7841:                break;
    #####: 7842:            case NO_MODERN:
    #####: 7843:                if (!slab_chunk_size_changed) {
    #####: 7844:                    settings.slab_chunk_size_max = settings.slab_page_size;
        -: 7845:                }
    #####: 7846:                settings.slab_reassign = false;
    #####: 7847:                settings.slab_automove = 0;
    #####: 7848:                settings.maxconns_fast = false;
    #####: 7849:                settings.lru_segmented = false;
    #####: 7850:                hash_type = JENKINS_HASH;
    #####: 7851:                start_lru_crawler = false;
    #####: 7852:                start_lru_maintainer = false;
    #####: 7853:                break;
    #####: 7854:            case NO_DROP_PRIVILEGES:
    #####: 7855:                settings.drop_privileges = false;
    #####: 7856:                break;
    #####: 7857:            case DROP_PRIVILEGES:
    #####: 7858:                settings.drop_privileges = true;
    #####: 7859:                break;
        -: 7860:#ifdef MEMCACHED_DEBUG
    #####: 7861:            case RELAXED_PRIVILEGES:
    #####: 7862:                settings.relaxed_privileges = true;
    #####: 7863:                break;
        -: 7864:#endif
    #####: 7865:            default:
    #####: 7866:                printf("Illegal suboption \"%s\"\n", subopts_value);
    #####: 7867:                return 1;
        -: 7868:            }
        -: 7869:
        -: 7870:            }
    #####: 7871:            free(subopts_orig);
    #####: 7872:            break;
    #####: 7873:        default:
    #####: 7874:            fprintf(stderr, "Illegal argument \"%c\"\n", c);
    #####: 7875:            return 1;
        -: 7876:        }
    #####: 7877:    }
        -: 7878:
        3: 7879:    if (settings.item_size_max < 1024) {
    #####: 7880:        fprintf(stderr, "Item max size cannot be less than 1024 bytes.\n");
    #####: 7881:        exit(EX_USAGE);
        -: 7882:    }
        3: 7883:    if (settings.item_size_max > (settings.maxbytes / 2)) {
    #####: 7884:        fprintf(stderr, "Cannot set item size limit higher than 1/2 of memory max.\n");
    #####: 7885:        exit(EX_USAGE);
        -: 7886:    }
        3: 7887:    if (settings.item_size_max > (1024 * 1024 * 1024)) {
    #####: 7888:        fprintf(stderr, "Cannot set item size limit higher than a gigabyte.\n");
    #####: 7889:        exit(EX_USAGE);
        -: 7890:    }
        3: 7891:    if (settings.item_size_max > 1024 * 1024) {
    #####: 7892:        if (!slab_chunk_size_changed) {
        -: 7893:            // Ideal new default is 16k, but needs stitching.
    #####: 7894:            settings.slab_chunk_size_max = settings.slab_page_size / 2;
        -: 7895:        }
        -: 7896:    }
        -: 7897:
        3: 7898:    if (settings.slab_chunk_size_max > settings.item_size_max) {
    #####: 7899:        fprintf(stderr, "slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\n",
        -: 7900:                settings.slab_chunk_size_max, settings.item_size_max);
    #####: 7901:        exit(EX_USAGE);
        -: 7902:    }
        -: 7903:
        3: 7904:    if (settings.item_size_max % settings.slab_chunk_size_max != 0) {
    #####: 7905:        fprintf(stderr, "-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\n",
        -: 7906:                settings.item_size_max, settings.slab_chunk_size_max);
    #####: 7907:        exit(EX_USAGE);
        -: 7908:    }
        -: 7909:
        3: 7910:    if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {
    #####: 7911:        fprintf(stderr, "slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\n",
        -: 7912:                settings.slab_chunk_size_max, settings.slab_page_size);
    #####: 7913:        exit(EX_USAGE);
        -: 7914:    }
        -: 7915:#ifdef EXTSTORE
        -: 7916:    if (storage_file) {
        -: 7917:        if (settings.item_size_max > ext_cf.wbuf_size) {
        -: 7918:            fprintf(stderr, "-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\n",
        -: 7919:                settings.item_size_max, ext_cf.wbuf_size);
        -: 7920:            exit(EX_USAGE);
        -: 7921:        }
        -: 7922:
        -: 7923:        if (settings.udpport) {
        -: 7924:            fprintf(stderr, "Cannot use UDP with extstore enabled (-U 0 to disable)\n");
        -: 7925:            exit(EX_USAGE);
        -: 7926:        }
        -: 7927:    }
        -: 7928:#endif
        -: 7929:    // Reserve this for the new default. If factor size hasn't changed, use
        -: 7930:    // new default.
        -: 7931:    /*if (settings.slab_chunk_size_max == 16384 && settings.factor == 1.25) {
        -: 7932:        settings.factor = 1.08;
        -: 7933:    }*/
        -: 7934:
        3: 7935:    if (slab_sizes_unparsed != NULL) {
    #####: 7936:        if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {
        -: 7937:            use_slab_sizes = true;
        -: 7938:        } else {
    #####: 7939:            exit(EX_USAGE);
        -: 7940:        }
        -: 7941:    }
        -: 7942:
        3: 7943:    if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {
    #####: 7944:        fprintf(stderr, "hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\n");
    #####: 7945:        exit(EX_USAGE);
        -: 7946:    }
        -: 7947:
       3*: 7948:    if (settings.temp_lru && !start_lru_maintainer) {
    #####: 7949:        fprintf(stderr, "temporary_ttl requires lru_maintainer to be enabled\n");
    #####: 7950:        exit(EX_USAGE);
        -: 7951:    }
        -: 7952:
        3: 7953:    if (hash_init(hash_type) != 0) {
    #####: 7954:        fprintf(stderr, "Failed to initialize hash_algorithm!\n");
    #####: 7955:        exit(EX_USAGE);
        -: 7956:    }
        -: 7957:
        -: 7958:    /*
        -: 7959:     * Use one workerthread to serve each UDP port if the user specified
        -: 7960:     * multiple ports
        -: 7961:     */
       3*: 7962:    if (settings.inter != NULL && strchr(settings.inter, ',')) {
    #####: 7963:        settings.num_threads_per_udp = 1;
        -: 7964:    } else {
        3: 7965:        settings.num_threads_per_udp = settings.num_threads;
        -: 7966:    }
        -: 7967:
        3: 7968:    if (settings.sasl) {
    #####: 7969:        if (!protocol_specified) {
    #####: 7970:            settings.binding_protocol = binary_prot;
        -: 7971:        } else {
    #####: 7972:            if (settings.binding_protocol != binary_prot) {
    #####: 7973:                fprintf(stderr, "ERROR: You cannot allow the ASCII protocol while using SASL.\n");
    #####: 7974:                exit(EX_USAGE);
        -: 7975:            }
        -: 7976:        }
        -: 7977:    }
        -: 7978:
        3: 7979:    if (settings.auth_file) {
    #####: 7980:        if (!protocol_specified) {
    #####: 7981:            settings.binding_protocol = ascii_prot;
        -: 7982:        } else {
    #####: 7983:            if (settings.binding_protocol != ascii_prot) {
    #####: 7984:                fprintf(stderr, "ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\n");
    #####: 7985:                exit(EX_USAGE);
        -: 7986:            }
        -: 7987:        }
        -: 7988:    }
        -: 7989:
       3*: 7990:    if (udp_specified && settings.udpport != 0 && !tcp_specified) {
    #####: 7991:        settings.port = settings.udpport;
        -: 7992:    }
        -: 7993:
        -: 7994:
        -: 7995:#ifdef TLS
        -: 7996:    /*
        -: 7997:     * Setup SSL if enabled
        -: 7998:     */
        -: 7999:    if (settings.ssl_enabled) {
        -: 8000:        if (!settings.port) {
        -: 8001:            fprintf(stderr, "ERROR: You cannot enable SSL without a TCP port.\n");
        -: 8002:            exit(EX_USAGE);
        -: 8003:        }
        -: 8004:        // openssl init methods.
        -: 8005:        SSL_load_error_strings();
        -: 8006:        SSLeay_add_ssl_algorithms();
        -: 8007:        // Initiate the SSL context.
        -: 8008:        ssl_init();
        -: 8009:    }
        -: 8010:#endif
        -: 8011:
        3: 8012:    if (maxcore != 0) {
    #####: 8013:        struct rlimit rlim_new;
        -: 8014:        /*
        -: 8015:         * First try raising to infinity; if that fails, try bringing
        -: 8016:         * the soft limit to the hard.
        -: 8017:         */
    #####: 8018:        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
    #####: 8019:            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
    #####: 8020:            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
        -: 8021:                /* failed. try raising just to the old max */
    #####: 8022:                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
    #####: 8023:                (void)setrlimit(RLIMIT_CORE, &rlim_new);
        -: 8024:            }
        -: 8025:        }
        -: 8026:        /*
        -: 8027:         * getrlimit again to see what we ended up with. Only fail if
        -: 8028:         * the soft limit ends up 0, because then no core files will be
        -: 8029:         * created at all.
        -: 8030:         */
        -: 8031:
    #####: 8032:        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
    #####: 8033:            fprintf(stderr, "failed to ensure corefile creation\n");
    #####: 8034:            exit(EX_OSERR);
        -: 8035:        }
        -: 8036:    }
        -: 8037:
        -: 8038:    /*
        -: 8039:     * If needed, increase rlimits to allow as many connections
        -: 8040:     * as needed.
        -: 8041:     */
        -: 8042:
        3: 8043:    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 8044:        fprintf(stderr, "failed to getrlimit number of files\n");
    #####: 8045:        exit(EX_OSERR);
        -: 8046:    } else {
        3: 8047:        rlim.rlim_cur = settings.maxconns;
        3: 8048:        rlim.rlim_max = settings.maxconns;
        3: 8049:        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
    #####: 8050:            fprintf(stderr, "failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n");
    #####: 8051:            exit(EX_OSERR);
        -: 8052:        }
        -: 8053:    }
        -: 8054:
        -: 8055:    /* lose root privileges if we have them */
       3*: 8056:    if (getuid() == 0 || geteuid() == 0) {
        3: 8057:        if (username == 0 || *username == '\0') {
    #####: 8058:            fprintf(stderr, "can't run as root without the -u switch\n");
    #####: 8059:            exit(EX_USAGE);
        -: 8060:        }
        3: 8061:        if ((pw = getpwnam(username)) == 0) {
    #####: 8062:            fprintf(stderr, "can't find the user %s to switch to\n", username);
    #####: 8063:            exit(EX_NOUSER);
        -: 8064:        }
        3: 8065:        if (setgroups(0, NULL) < 0) {
    #####: 8066:            fprintf(stderr, "failed to drop supplementary groups\n");
    #####: 8067:            exit(EX_OSERR);
        -: 8068:        }
        3: 8069:        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
    #####: 8070:            fprintf(stderr, "failed to assume identity of user %s\n", username);
    #####: 8071:            exit(EX_OSERR);
        -: 8072:        }
        -: 8073:    }
        -: 8074:
        -: 8075:    /* Initialize Sasl if -S was specified */
        3: 8076:    if (settings.sasl) {
        3: 8077:        init_sasl();
        -: 8078:    }
        -: 8079:
        -: 8080:    /* daemonize if requested */
        -: 8081:    /* if we want to ensure our ability to dump core, don't chdir to / */
        3: 8082:    if (do_daemonize) {
    #####: 8083:        if (sigignore(SIGHUP) == -1) {
    #####: 8084:            perror("Failed to ignore SIGHUP");
        -: 8085:        }
    #####: 8086:        if (daemonize(maxcore, settings.verbose) == -1) {
    #####: 8087:            fprintf(stderr, "failed to daemon() in order to daemonize\n");
    #####: 8088:            exit(EXIT_FAILURE);
        -: 8089:        }
        -: 8090:    }
        -: 8091:
        -: 8092:    /* lock paged memory if needed */
        3: 8093:    if (lock_memory) {
        -: 8094:#ifdef HAVE_MLOCKALL
    #####: 8095:        int res = mlockall(MCL_CURRENT | MCL_FUTURE);
    #####: 8096:        if (res != 0) {
    #####: 8097:            fprintf(stderr, "warning: -k invalid, mlockall() failed: %s\n",
    #####: 8098:                    strerror(errno));
        -: 8099:        }
        -: 8100:#else
        -: 8101:        fprintf(stderr, "warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n");
        -: 8102:#endif
        -: 8103:    }
        -: 8104:
        -: 8105:    /* initialize main thread libevent instance */
        -: 8106:#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
        -: 8107:    /* If libevent version is larger/equal to 2.0.2-alpha, use newer version */
        3: 8108:    struct event_config *ev_config;
        3: 8109:    ev_config = event_config_new();
        3: 8110:    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
        3: 8111:    main_base = event_base_new_with_config(ev_config);
        3: 8112:    event_config_free(ev_config);
        -: 8113:#else
        -: 8114:    /* Otherwise, use older API */
        -: 8115:    main_base = event_init();
        -: 8116:#endif
        -: 8117:
        -: 8118:    /* Load initial auth file if required */
        3: 8119:    if (settings.auth_file) {
    #####: 8120:        if (settings.udpport) {
    #####: 8121:            fprintf(stderr, "Cannot use UDP with ascii authentication enabled (-U 0 to disable)\n");
    #####: 8122:            exit(EX_USAGE);
        -: 8123:        }
        -: 8124:
    #####: 8125:        switch (authfile_load(settings.auth_file)) {
    #####: 8126:            case AUTHFILE_MISSING: // fall through.
        -: 8127:            case AUTHFILE_OPENFAIL:
    #####: 8128:                vperror("Could not open authfile [%s] for reading", settings.auth_file);
    #####: 8129:                exit(EXIT_FAILURE);
    #####: 8130:                break;
    #####: 8131:            case AUTHFILE_OOM:
    #####: 8132:                fprintf(stderr, "Out of memory reading password file: %s", settings.auth_file);
    #####: 8133:                exit(EXIT_FAILURE);
    #####: 8134:                break;
    #####: 8135:            case AUTHFILE_MALFORMED:
    #####: 8136:                fprintf(stderr, "Authfile [%s] has a malformed entry. Should be 'user:password'", settings.auth_file);
    #####: 8137:                exit(EXIT_FAILURE);
        -: 8138:                break;
        -: 8139:            case AUTHFILE_OK:
        -: 8140:                break;
        -: 8141:        }
        3: 8142:    }
        -: 8143:
        -: 8144:    /* initialize other stuff */
        3: 8145:    logger_init();
        3: 8146:    stats_init();
        3: 8147:    assoc_init(settings.hashpower_init);
        3: 8148:    conn_init();
        6: 8149:    slabs_init(settings.maxbytes, settings.factor, preallocate,
        -: 8150:            use_slab_sizes ? slab_sizes : NULL);
        -: 8151:#ifdef EXTSTORE
        -: 8152:    if (storage_file) {
        -: 8153:        enum extstore_res eres;
        -: 8154:        if (settings.ext_compact_under == 0) {
        -: 8155:            settings.ext_compact_under = storage_file->page_count / 4;
        -: 8156:            /* Only rescues non-COLD items if below this threshold */
        -: 8157:            settings.ext_drop_under = storage_file->page_count / 4;
        -: 8158:        }
        -: 8159:        crc32c_init();
        -: 8160:        /* Init free chunks to zero. */
        -: 8161:        for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {
        -: 8162:            settings.ext_free_memchunks[x] = 0;
        -: 8163:        }
        -: 8164:        storage = extstore_init(storage_file, &ext_cf, &eres);
        -: 8165:        if (storage == NULL) {
        -: 8166:            fprintf(stderr, "Failed to initialize external storage: %s\n",
        -: 8167:                    extstore_err(eres));
        -: 8168:            if (eres == EXTSTORE_INIT_OPEN_FAIL) {
        -: 8169:                perror("extstore open");
        -: 8170:            }
        -: 8171:            exit(EXIT_FAILURE);
        -: 8172:        }
        -: 8173:        ext_storage = storage;
        -: 8174:        /* page mover algorithm for extstore needs memory prefilled */
        -: 8175:        slabs_prefill_global();
        -: 8176:    }
        -: 8177:#endif
        -: 8178:    /*
        -: 8179:     * ignore SIGPIPE signals; we can use errno == EPIPE if we
        -: 8180:     * need that information
        -: 8181:     */
        3: 8182:    if (sigignore(SIGPIPE) == -1) {
    #####: 8183:        perror("failed to ignore SIGPIPE; sigaction");
    #####: 8184:        exit(EX_OSERR);
        -: 8185:    }
        -: 8186:    /* start up worker threads if MT mode */
        -: 8187:#ifdef EXTSTORE
        -: 8188:    slabs_set_storage(storage);
        -: 8189:    memcached_thread_init(settings.num_threads, storage);
        -: 8190:    init_lru_crawler(storage);
        -: 8191:#else
        3: 8192:    memcached_thread_init(settings.num_threads, NULL);
        3: 8193:    init_lru_crawler(NULL);
        -: 8194:#endif
        -: 8195:
        3: 8196:    if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {
    #####: 8197:        exit(EXIT_FAILURE);
        -: 8198:    }
        3: 8199:    if (start_lru_crawler && start_item_crawler_thread() != 0) {
    #####: 8200:        fprintf(stderr, "Failed to enable LRU crawler thread\n");
    #####: 8201:        exit(EXIT_FAILURE);
        -: 8202:    }
        -: 8203:#ifdef EXTSTORE
        -: 8204:    if (storage && start_storage_compact_thread(storage) != 0) {
        -: 8205:        fprintf(stderr, "Failed to start storage compaction thread\n");
        -: 8206:        exit(EXIT_FAILURE);
        -: 8207:    }
        -: 8208:    if (storage && start_storage_write_thread(storage) != 0) {
        -: 8209:        fprintf(stderr, "Failed to start storage writer thread\n");
        -: 8210:        exit(EXIT_FAILURE);
        -: 8211:    }
        -: 8212:
        -: 8213:    if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {
        -: 8214:#else
        3: 8215:    if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {
        -: 8216:#endif
    #####: 8217:        fprintf(stderr, "Failed to enable LRU maintainer thread\n");
    #####: 8218:        return 1;
        -: 8219:    }
        -: 8220:
        6: 8221:    if (settings.slab_reassign &&
        3: 8222:        start_slab_maintenance_thread() == -1) {
    #####: 8223:        exit(EXIT_FAILURE);
        -: 8224:    }
        -: 8225:
       3*: 8226:    if (settings.idle_timeout && start_conn_timeout_thread() == -1) {
    #####: 8227:        exit(EXIT_FAILURE);
        -: 8228:    }
        -: 8229:
        -: 8230:    /* initialise clock event */
        3: 8231:    clock_handler(0, 0, 0);
        -: 8232:
        -: 8233:    /* create unix mode sockets after dropping privileges */
        3: 8234:    if (settings.socketpath != NULL) {
    #####: 8235:        errno = 0;
    #####: 8236:        if (server_socket_unix(settings.socketpath,settings.access)) {
    #####: 8237:            vperror("failed to listen on UNIX socket: %s", settings.socketpath);
    #####: 8238:            exit(EX_OSERR);
        -: 8239:        }
        -: 8240:    }
        -: 8241:
        -: 8242:    /* create the listening socket, bind it, and init */
        3: 8243:    if (settings.socketpath == NULL) {
        3: 8244:        const char *portnumber_filename = getenv("MEMCACHED_PORT_FILENAME");
        3: 8245:        char *temp_portnumber_filename = NULL;
        3: 8246:        size_t len;
        3: 8247:        FILE *portnumber_file = NULL;
        -: 8248:
        3: 8249:        if (portnumber_filename != NULL) {
    #####: 8250:            len = strlen(portnumber_filename)+4+1;
    #####: 8251:            temp_portnumber_filename = malloc(len);
    #####: 8252:            snprintf(temp_portnumber_filename,
        -: 8253:                     len,
        -: 8254:                     "%s.lck", portnumber_filename);
        -: 8255:
    #####: 8256:            portnumber_file = fopen(temp_portnumber_filename, "a");
    #####: 8257:            if (portnumber_file == NULL) {
    #####: 8258:                fprintf(stderr, "Failed to open \"%s\": %s\n",
    #####: 8259:                        temp_portnumber_filename, strerror(errno));
        -: 8260:            }
        -: 8261:        }
        -: 8262:
        3: 8263:        errno = 0;
        3: 8264:        if (settings.port && server_sockets(settings.port, tcp_transport,
        -: 8265:                                           portnumber_file)) {
    #####: 8266:            vperror("failed to listen on TCP port %d", settings.port);
    #####: 8267:            exit(EX_OSERR);
        -: 8268:        }
        -: 8269:
        -: 8270:        /*
        -: 8271:         * initialization order: first create the listening sockets
        -: 8272:         * (may need root on low ports), then drop root if needed,
        -: 8273:         * then daemonize if needed, then init libevent (in some cases
        -: 8274:         * descriptors created by libevent wouldn't survive forking).
        -: 8275:         */
        -: 8276:
        -: 8277:        /* create the UDP listening socket and bind it */
        3: 8278:        errno = 0;
       3*: 8279:        if (settings.udpport && server_sockets(settings.udpport, udp_transport,
        -: 8280:                                              portnumber_file)) {
    #####: 8281:            vperror("failed to listen on UDP port %d", settings.udpport);
    #####: 8282:            exit(EX_OSERR);
        -: 8283:        }
        -: 8284:
        3: 8285:        if (portnumber_file) {
    #####: 8286:            fclose(portnumber_file);
    #####: 8287:            rename(temp_portnumber_filename, portnumber_filename);
        -: 8288:        }
        3: 8289:        if (temp_portnumber_filename)
    #####: 8290:            free(temp_portnumber_filename);
        -: 8291:    }
        -: 8292:
        -: 8293:    /* Give the sockets a moment to open. I know this is dumb, but the error
        -: 8294:     * is only an advisory.
        -: 8295:     */
        3: 8296:    usleep(1000);
        3: 8297:    if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {
    #####: 8298:        fprintf(stderr, "Maxconns setting is too low, use -c to increase.\n");
    #####: 8299:        exit(EXIT_FAILURE);
        -: 8300:    }
        -: 8301:
        3: 8302:    if (pid_file != NULL) {
    #####: 8303:        save_pid(pid_file);
        -: 8304:    }
        -: 8305:
        -: 8306:    /* Drop privileges no longer needed */
        3: 8307:    if (settings.drop_privileges) {
        3: 8308:        drop_privileges();
        -: 8309:    }
        -: 8310:
        -: 8311:    /* Initialize the uriencode lookup table. */
        3: 8312:    uriencode_init();
        -: 8313:
        -: 8314:    /* enter the event loop */
       3*: 8315:    if (event_base_loop(main_base, 0) != 0) {
    #####: 8316:        retval = EXIT_FAILURE;
        -: 8317:    }
        -: 8318:
    #####: 8319:    stop_assoc_maintenance_thread();
        -: 8320:
        -: 8321:    /* remove the PID file if we're a daemon */
    #####: 8322:    if (do_daemonize)
    #####: 8323:        remove_pidfile(pid_file);
        -: 8324:    /* Clean up strdup() call for bind() address */
    #####: 8325:    if (settings.inter)
    #####: 8326:      free(settings.inter);
        -: 8327:
        -: 8328:    /* cleanup base */
    #####: 8329:    event_base_free(main_base);
        -: 8330:
    #####: 8331:    return retval;
        -: 8332:}
