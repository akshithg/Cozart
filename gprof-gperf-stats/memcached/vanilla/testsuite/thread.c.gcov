        -:    0:Source:thread.c
        -:    0:Programs:72
        -:    0:Source is newer than graph
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:/*
        -:    3: * Thread management for memcached.
        -:    4: */
        -:    5:#include "memcached.h"
        -:    6:#ifdef EXTSTORE
        -:    7:#include "storage.h"
        -:    8:#endif
        -:    9:#include <assert.h>
        -:   10:#include <stdio.h>
        -:   11:#include <errno.h>
        -:   12:#include <stdlib.h>
        -:   13:#include <string.h>
        -:   14:#include <pthread.h>
        -:   15:
        -:   16:#ifdef __sun
        -:   17:#include <atomic.h>
        -:   18:#endif
        -:   19:
        -:   20:#ifdef TLS
        -:   21:#include <openssl/ssl.h>
        -:   22:#endif
        -:   23:
        -:   24:#define ITEMS_PER_ALLOC 64
        -:   25:
        -:   26:/* An item in the connection queue. */
        -:   27:enum conn_queue_item_modes {
        -:   28:    queue_new_conn,   /* brand new connection. */
        -:   29:    queue_redispatch, /* redispatching from side thread */
        -:   30:};
        -:   31:typedef struct conn_queue_item CQ_ITEM;
        -:   32:struct conn_queue_item {
        -:   33:    int               sfd;
        -:   34:    enum conn_states  init_state;
        -:   35:    int               event_flags;
        -:   36:    int               read_buffer_size;
        -:   37:    enum network_transport     transport;
        -:   38:    enum conn_queue_item_modes mode;
        -:   39:    conn *c;
        -:   40:    void    *ssl;
        -:   41:    CQ_ITEM          *next;
        -:   42:};
        -:   43:
        -:   44:/* A connection queue. */
        -:   45:typedef struct conn_queue CQ;
        -:   46:struct conn_queue {
        -:   47:    CQ_ITEM *head;
        -:   48:    CQ_ITEM *tail;
        -:   49:    pthread_mutex_t lock;
        -:   50:};
        -:   51:
        -:   52:/* Locks for cache LRU operations */
        -:   53:pthread_mutex_t lru_locks[POWER_LARGEST];
        -:   54:
        -:   55:/* Connection lock around accepting new connections */
        -:   56:pthread_mutex_t conn_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   57:
        -:   58:#if !defined(HAVE_GCC_ATOMICS) && !defined(__sun)
        -:   59:pthread_mutex_t atomics_mutex = PTHREAD_MUTEX_INITIALIZER;
        -:   60:#endif
        -:   61:
        -:   62:/* Lock for global stats */
        -:   63:static pthread_mutex_t stats_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   64:
        -:   65:/* Lock to cause worker threads to hang up after being woken */
        -:   66:static pthread_mutex_t worker_hang_lock;
        -:   67:
        -:   68:/* Free list of CQ_ITEM structs */
        -:   69:static CQ_ITEM *cqi_freelist;
        -:   70:static pthread_mutex_t cqi_freelist_lock;
        -:   71:
        -:   72:static pthread_mutex_t *item_locks;
        -:   73:/* size of the item lock hash table */
        -:   74:static uint32_t item_lock_count;
        -:   75:unsigned int item_lock_hashpower;
        -:   76:#define hashsize(n) ((unsigned long int)1<<(n))
        -:   77:#define hashmask(n) (hashsize(n)-1)
        -:   78:
        -:   79:/*
        -:   80: * Each libevent instance has a wakeup pipe, which other threads
        -:   81: * can use to signal that they've put a new connection on its queue.
        -:   82: */
        -:   83:static LIBEVENT_THREAD *threads;
        -:   84:
        -:   85:/*
        -:   86: * Number of worker threads that have finished setting themselves up.
        -:   87: */
        -:   88:static int init_count = 0;
        -:   89:static pthread_mutex_t init_lock;
        -:   90:static pthread_cond_t init_cond;
        -:   91:
        -:   92:
        -:   93:static void thread_libevent_process(int fd, short which, void *arg);
        -:   94:
        -:   95:/* item_lock() must be held for an item before any modifications to either its
        -:   96: * associated hash bucket, or the structure itself.
        -:   97: * LRU modifications must hold the item lock, and the LRU lock.
        -:   98: * LRU's accessing items must item_trylock() before modifying an item.
        -:   99: * Items accessible from an LRU must not be freed or modified
        -:  100: * without first locking and removing from the LRU.
        -:  101: */
        -:  102:
       18:  103:void item_lock(uint32_t hv) {
 1065312*:  104:    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
       18:  105:}
------------------
item_lock:
        6:  103:void item_lock(uint32_t hv) {
        6:  104:    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
        6:  105:}
------------------
item_lock:
        6:  103:void item_lock(uint32_t hv) {
        6:  104:    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
        6:  105:}
------------------
item_lock:
        6:  103:void item_lock(uint32_t hv) {
        6:  104:    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
        6:  105:}
------------------
        -:  106:
   360204:  107:void *item_trylock(uint32_t hv) {
   360204:  108:    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
   360204:  109:    if (pthread_mutex_trylock(lock) == 0) {
   358464:  110:        return lock;
        -:  111:    }
        -:  112:    return NULL;
        -:  113:}
------------------
item_trylock:
   120068:  107:void *item_trylock(uint32_t hv) {
   120068:  108:    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
   120068:  109:    if (pthread_mutex_trylock(lock) == 0) {
   119488:  110:        return lock;
        -:  111:    }
        -:  112:    return NULL;
        -:  113:}
------------------
item_trylock:
   120068:  107:void *item_trylock(uint32_t hv) {
   120068:  108:    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
   120068:  109:    if (pthread_mutex_trylock(lock) == 0) {
   119488:  110:        return lock;
        -:  111:    }
        -:  112:    return NULL;
        -:  113:}
------------------
item_trylock:
   120068:  107:void *item_trylock(uint32_t hv) {
   120068:  108:    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
   120068:  109:    if (pthread_mutex_trylock(lock) == 0) {
   119488:  110:        return lock;
        -:  111:    }
        -:  112:    return NULL;
        -:  113:}
------------------
        -:  114:
   358464:  115:void item_trylock_unlock(void *lock) {
   358464:  116:    mutex_unlock((pthread_mutex_t *) lock);
   358464:  117:}
------------------
item_trylock_unlock:
   119488:  115:void item_trylock_unlock(void *lock) {
   119488:  116:    mutex_unlock((pthread_mutex_t *) lock);
   119488:  117:}
------------------
item_trylock_unlock:
   119488:  115:void item_trylock_unlock(void *lock) {
   119488:  116:    mutex_unlock((pthread_mutex_t *) lock);
   119488:  117:}
------------------
item_trylock_unlock:
   119488:  115:void item_trylock_unlock(void *lock) {
   119488:  116:    mutex_unlock((pthread_mutex_t *) lock);
   119488:  117:}
------------------
        -:  118:
     8133:  119:void item_unlock(uint32_t hv) {
 1065312*:  120:    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
     8133:  121:}
------------------
item_unlock:
     2711:  119:void item_unlock(uint32_t hv) {
     2711:  120:    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
     2711:  121:}
------------------
item_unlock:
     2711:  119:void item_unlock(uint32_t hv) {
     2711:  120:    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
     2711:  121:}
------------------
item_unlock:
     2711:  119:void item_unlock(uint32_t hv) {
     2711:  120:    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
     2711:  121:}
------------------
        -:  122:
        -:  123:static void wait_for_thread_registration(int nthreads) {
    1044*:  124:    while (init_count < nthreads) {
     756*:  125:        pthread_cond_wait(&init_cond, &init_lock);
        -:  126:    }
        -:  127:}
        -:  128:
     1152:  129:static void register_thread_initialized(void) {
     1152:  130:    pthread_mutex_lock(&init_lock);
     1152:  131:    init_count++;
     1152:  132:    pthread_cond_signal(&init_cond);
     1152:  133:    pthread_mutex_unlock(&init_lock);
        -:  134:    /* Force worker threads to pile up if someone wants us to */
     1152:  135:    pthread_mutex_lock(&worker_hang_lock);
     1152:  136:    pthread_mutex_unlock(&worker_hang_lock);
     1152:  137:}
------------------
register_thread_initialized:
      384:  129:static void register_thread_initialized(void) {
      384:  130:    pthread_mutex_lock(&init_lock);
      384:  131:    init_count++;
      384:  132:    pthread_cond_signal(&init_cond);
      384:  133:    pthread_mutex_unlock(&init_lock);
        -:  134:    /* Force worker threads to pile up if someone wants us to */
      384:  135:    pthread_mutex_lock(&worker_hang_lock);
      384:  136:    pthread_mutex_unlock(&worker_hang_lock);
      384:  137:}
------------------
register_thread_initialized:
      384:  129:static void register_thread_initialized(void) {
      384:  130:    pthread_mutex_lock(&init_lock);
      384:  131:    init_count++;
      384:  132:    pthread_cond_signal(&init_cond);
      384:  133:    pthread_mutex_unlock(&init_lock);
        -:  134:    /* Force worker threads to pile up if someone wants us to */
      384:  135:    pthread_mutex_lock(&worker_hang_lock);
      384:  136:    pthread_mutex_unlock(&worker_hang_lock);
      384:  137:}
------------------
register_thread_initialized:
      384:  129:static void register_thread_initialized(void) {
      384:  130:    pthread_mutex_lock(&init_lock);
      384:  131:    init_count++;
      384:  132:    pthread_cond_signal(&init_cond);
      384:  133:    pthread_mutex_unlock(&init_lock);
        -:  134:    /* Force worker threads to pile up if someone wants us to */
      384:  135:    pthread_mutex_lock(&worker_hang_lock);
      384:  136:    pthread_mutex_unlock(&worker_hang_lock);
      384:  137:}
------------------
        -:  138:
        -:  139:/* Must not be called with any deeper locks held */
    #####:  140:void pause_threads(enum pause_thread_types type) {
    #####:  141:    char buf[1];
    #####:  142:    int i;
        -:  143:
    #####:  144:    buf[0] = 0;
    #####:  145:    switch (type) {
    #####:  146:        case PAUSE_ALL_THREADS:
    #####:  147:            slabs_rebalancer_pause();
    #####:  148:            lru_maintainer_pause();
    #####:  149:            lru_crawler_pause();
        -:  150:#ifdef EXTSTORE
        -:  151:            storage_compact_pause();
        -:  152:            storage_write_pause();
        -:  153:#endif
    #####:  154:        case PAUSE_WORKER_THREADS:
    #####:  155:            buf[0] = 'p';
    #####:  156:            pthread_mutex_lock(&worker_hang_lock);
    #####:  157:            break;
    #####:  158:        case RESUME_ALL_THREADS:
    #####:  159:            slabs_rebalancer_resume();
    #####:  160:            lru_maintainer_resume();
    #####:  161:            lru_crawler_resume();
        -:  162:#ifdef EXTSTORE
        -:  163:            storage_compact_resume();
        -:  164:            storage_write_resume();
        -:  165:#endif
    #####:  166:        case RESUME_WORKER_THREADS:
    #####:  167:            pthread_mutex_unlock(&worker_hang_lock);
    #####:  168:            break;
    #####:  169:        default:
    #####:  170:            fprintf(stderr, "Unknown lock type: %d\n", type);
    #####:  171:            assert(1 == 0);
        -:  172:            break;
        -:  173:    }
        -:  174:
        -:  175:    /* Only send a message if we have one. */
    #####:  176:    if (buf[0] == 0) {
    #####:  177:        return;
        -:  178:    }
        -:  179:
    #####:  180:    pthread_mutex_lock(&init_lock);
    #####:  181:    init_count = 0;
    #####:  182:    for (i = 0; i < settings.num_threads; i++) {
    #####:  183:        if (write(threads[i].notify_send_fd, buf, 1) != 1) {
    #####:  184:            perror("Failed writing to notify pipe");
        -:  185:            /* TODO: This is a fatal problem. Can it ever happen temporarily? */
        -:  186:        }
        -:  187:    }
    #####:  188:    wait_for_thread_registration(settings.num_threads);
    #####:  189:    pthread_mutex_unlock(&init_lock);
        -:  190:}
------------------
pause_threads:
    #####:  140:void pause_threads(enum pause_thread_types type) {
    #####:  141:    char buf[1];
    #####:  142:    int i;
        -:  143:
    #####:  144:    buf[0] = 0;
    #####:  145:    switch (type) {
    #####:  146:        case PAUSE_ALL_THREADS:
    #####:  147:            slabs_rebalancer_pause();
    #####:  148:            lru_maintainer_pause();
    #####:  149:            lru_crawler_pause();
        -:  150:#ifdef EXTSTORE
        -:  151:            storage_compact_pause();
        -:  152:            storage_write_pause();
        -:  153:#endif
    #####:  154:        case PAUSE_WORKER_THREADS:
    #####:  155:            buf[0] = 'p';
    #####:  156:            pthread_mutex_lock(&worker_hang_lock);
    #####:  157:            break;
    #####:  158:        case RESUME_ALL_THREADS:
    #####:  159:            slabs_rebalancer_resume();
    #####:  160:            lru_maintainer_resume();
    #####:  161:            lru_crawler_resume();
        -:  162:#ifdef EXTSTORE
        -:  163:            storage_compact_resume();
        -:  164:            storage_write_resume();
        -:  165:#endif
    #####:  166:        case RESUME_WORKER_THREADS:
    #####:  167:            pthread_mutex_unlock(&worker_hang_lock);
    #####:  168:            break;
    #####:  169:        default:
    #####:  170:            fprintf(stderr, "Unknown lock type: %d\n", type);
    #####:  171:            assert(1 == 0);
        -:  172:            break;
        -:  173:    }
        -:  174:
        -:  175:    /* Only send a message if we have one. */
    #####:  176:    if (buf[0] == 0) {
    #####:  177:        return;
        -:  178:    }
        -:  179:
    #####:  180:    pthread_mutex_lock(&init_lock);
    #####:  181:    init_count = 0;
    #####:  182:    for (i = 0; i < settings.num_threads; i++) {
    #####:  183:        if (write(threads[i].notify_send_fd, buf, 1) != 1) {
    #####:  184:            perror("Failed writing to notify pipe");
        -:  185:            /* TODO: This is a fatal problem. Can it ever happen temporarily? */
        -:  186:        }
        -:  187:    }
    #####:  188:    wait_for_thread_registration(settings.num_threads);
    #####:  189:    pthread_mutex_unlock(&init_lock);
        -:  190:}
------------------
pause_threads:
    #####:  140:void pause_threads(enum pause_thread_types type) {
    #####:  141:    char buf[1];
    #####:  142:    int i;
        -:  143:
    #####:  144:    buf[0] = 0;
    #####:  145:    switch (type) {
    #####:  146:        case PAUSE_ALL_THREADS:
    #####:  147:            slabs_rebalancer_pause();
    #####:  148:            lru_maintainer_pause();
    #####:  149:            lru_crawler_pause();
        -:  150:#ifdef EXTSTORE
        -:  151:            storage_compact_pause();
        -:  152:            storage_write_pause();
        -:  153:#endif
    #####:  154:        case PAUSE_WORKER_THREADS:
    #####:  155:            buf[0] = 'p';
    #####:  156:            pthread_mutex_lock(&worker_hang_lock);
    #####:  157:            break;
    #####:  158:        case RESUME_ALL_THREADS:
    #####:  159:            slabs_rebalancer_resume();
    #####:  160:            lru_maintainer_resume();
    #####:  161:            lru_crawler_resume();
        -:  162:#ifdef EXTSTORE
        -:  163:            storage_compact_resume();
        -:  164:            storage_write_resume();
        -:  165:#endif
    #####:  166:        case RESUME_WORKER_THREADS:
    #####:  167:            pthread_mutex_unlock(&worker_hang_lock);
    #####:  168:            break;
    #####:  169:        default:
    #####:  170:            fprintf(stderr, "Unknown lock type: %d\n", type);
    #####:  171:            assert(1 == 0);
        -:  172:            break;
        -:  173:    }
        -:  174:
        -:  175:    /* Only send a message if we have one. */
    #####:  176:    if (buf[0] == 0) {
    #####:  177:        return;
        -:  178:    }
        -:  179:
    #####:  180:    pthread_mutex_lock(&init_lock);
    #####:  181:    init_count = 0;
    #####:  182:    for (i = 0; i < settings.num_threads; i++) {
    #####:  183:        if (write(threads[i].notify_send_fd, buf, 1) != 1) {
    #####:  184:            perror("Failed writing to notify pipe");
        -:  185:            /* TODO: This is a fatal problem. Can it ever happen temporarily? */
        -:  186:        }
        -:  187:    }
    #####:  188:    wait_for_thread_registration(settings.num_threads);
    #####:  189:    pthread_mutex_unlock(&init_lock);
        -:  190:}
------------------
pause_threads:
    #####:  140:void pause_threads(enum pause_thread_types type) {
    #####:  141:    char buf[1];
    #####:  142:    int i;
        -:  143:
    #####:  144:    buf[0] = 0;
    #####:  145:    switch (type) {
    #####:  146:        case PAUSE_ALL_THREADS:
    #####:  147:            slabs_rebalancer_pause();
    #####:  148:            lru_maintainer_pause();
    #####:  149:            lru_crawler_pause();
        -:  150:#ifdef EXTSTORE
        -:  151:            storage_compact_pause();
        -:  152:            storage_write_pause();
        -:  153:#endif
    #####:  154:        case PAUSE_WORKER_THREADS:
    #####:  155:            buf[0] = 'p';
    #####:  156:            pthread_mutex_lock(&worker_hang_lock);
    #####:  157:            break;
    #####:  158:        case RESUME_ALL_THREADS:
    #####:  159:            slabs_rebalancer_resume();
    #####:  160:            lru_maintainer_resume();
    #####:  161:            lru_crawler_resume();
        -:  162:#ifdef EXTSTORE
        -:  163:            storage_compact_resume();
        -:  164:            storage_write_resume();
        -:  165:#endif
    #####:  166:        case RESUME_WORKER_THREADS:
    #####:  167:            pthread_mutex_unlock(&worker_hang_lock);
    #####:  168:            break;
    #####:  169:        default:
    #####:  170:            fprintf(stderr, "Unknown lock type: %d\n", type);
    #####:  171:            assert(1 == 0);
        -:  172:            break;
        -:  173:    }
        -:  174:
        -:  175:    /* Only send a message if we have one. */
    #####:  176:    if (buf[0] == 0) {
    #####:  177:        return;
        -:  178:    }
        -:  179:
    #####:  180:    pthread_mutex_lock(&init_lock);
    #####:  181:    init_count = 0;
    #####:  182:    for (i = 0; i < settings.num_threads; i++) {
    #####:  183:        if (write(threads[i].notify_send_fd, buf, 1) != 1) {
    #####:  184:            perror("Failed writing to notify pipe");
        -:  185:            /* TODO: This is a fatal problem. Can it ever happen temporarily? */
        -:  186:        }
        -:  187:    }
    #####:  188:    wait_for_thread_registration(settings.num_threads);
    #####:  189:    pthread_mutex_unlock(&init_lock);
        -:  190:}
------------------
        -:  191:
        -:  192:/*
        -:  193: * Initializes a connection queue.
        -:  194: */
        -:  195:static void cq_init(CQ *cq) {
     1152:  196:    pthread_mutex_init(&cq->lock, NULL);
     1152:  197:    cq->head = NULL;
     1152:  198:    cq->tail = NULL;
        -:  199:}
        -:  200:
        -:  201:/*
        -:  202: * Looks for an item on a connection queue, but doesn't block if there isn't
        -:  203: * one.
        -:  204: * Returns the item, or NULL if no item is available
        -:  205: */
      564:  206:static CQ_ITEM *cq_pop(CQ *cq) {
      564:  207:    CQ_ITEM *item;
        -:  208:
      564:  209:    pthread_mutex_lock(&cq->lock);
      564:  210:    item = cq->head;
      564:  211:    if (NULL != item) {
      564:  212:        cq->head = item->next;
      564:  213:        if (NULL == cq->head)
      561:  214:            cq->tail = NULL;
        -:  215:    }
      564:  216:    pthread_mutex_unlock(&cq->lock);
        -:  217:
      564:  218:    return item;
        -:  219:}
------------------
cq_pop:
      188:  206:static CQ_ITEM *cq_pop(CQ *cq) {
      188:  207:    CQ_ITEM *item;
        -:  208:
      188:  209:    pthread_mutex_lock(&cq->lock);
      188:  210:    item = cq->head;
      188:  211:    if (NULL != item) {
      188:  212:        cq->head = item->next;
      188:  213:        if (NULL == cq->head)
      187:  214:            cq->tail = NULL;
        -:  215:    }
      188:  216:    pthread_mutex_unlock(&cq->lock);
        -:  217:
      188:  218:    return item;
        -:  219:}
------------------
cq_pop:
      188:  206:static CQ_ITEM *cq_pop(CQ *cq) {
      188:  207:    CQ_ITEM *item;
        -:  208:
      188:  209:    pthread_mutex_lock(&cq->lock);
      188:  210:    item = cq->head;
      188:  211:    if (NULL != item) {
      188:  212:        cq->head = item->next;
      188:  213:        if (NULL == cq->head)
      187:  214:            cq->tail = NULL;
        -:  215:    }
      188:  216:    pthread_mutex_unlock(&cq->lock);
        -:  217:
      188:  218:    return item;
        -:  219:}
------------------
cq_pop:
      188:  206:static CQ_ITEM *cq_pop(CQ *cq) {
      188:  207:    CQ_ITEM *item;
        -:  208:
      188:  209:    pthread_mutex_lock(&cq->lock);
      188:  210:    item = cq->head;
      188:  211:    if (NULL != item) {
      188:  212:        cq->head = item->next;
      188:  213:        if (NULL == cq->head)
      187:  214:            cq->tail = NULL;
        -:  215:    }
      188:  216:    pthread_mutex_unlock(&cq->lock);
        -:  217:
      188:  218:    return item;
        -:  219:}
------------------
        -:  220:
        -:  221:/*
        -:  222: * Adds an item to a connection queue.
        -:  223: */
      567:  224:static void cq_push(CQ *cq, CQ_ITEM *item) {
      567:  225:    item->next = NULL;
        -:  226:
      567:  227:    pthread_mutex_lock(&cq->lock);
      567:  228:    if (NULL == cq->tail)
      564:  229:        cq->head = item;
        -:  230:    else
        3:  231:        cq->tail->next = item;
      567:  232:    cq->tail = item;
      567:  233:    pthread_mutex_unlock(&cq->lock);
      567:  234:}
------------------
cq_push:
      189:  224:static void cq_push(CQ *cq, CQ_ITEM *item) {
      189:  225:    item->next = NULL;
        -:  226:
      189:  227:    pthread_mutex_lock(&cq->lock);
      189:  228:    if (NULL == cq->tail)
      188:  229:        cq->head = item;
        -:  230:    else
        1:  231:        cq->tail->next = item;
      189:  232:    cq->tail = item;
      189:  233:    pthread_mutex_unlock(&cq->lock);
      189:  234:}
------------------
cq_push:
      189:  224:static void cq_push(CQ *cq, CQ_ITEM *item) {
      189:  225:    item->next = NULL;
        -:  226:
      189:  227:    pthread_mutex_lock(&cq->lock);
      189:  228:    if (NULL == cq->tail)
      188:  229:        cq->head = item;
        -:  230:    else
        1:  231:        cq->tail->next = item;
      189:  232:    cq->tail = item;
      189:  233:    pthread_mutex_unlock(&cq->lock);
      189:  234:}
------------------
cq_push:
      189:  224:static void cq_push(CQ *cq, CQ_ITEM *item) {
      189:  225:    item->next = NULL;
        -:  226:
      189:  227:    pthread_mutex_lock(&cq->lock);
      189:  228:    if (NULL == cq->tail)
      188:  229:        cq->head = item;
        -:  230:    else
        1:  231:        cq->tail->next = item;
      189:  232:    cq->tail = item;
      189:  233:    pthread_mutex_unlock(&cq->lock);
      189:  234:}
------------------
        -:  235:
        -:  236:/*
        -:  237: * Returns a fresh connection queue item.
        -:  238: */
      567:  239:static CQ_ITEM *cqi_new(void) {
      567:  240:    CQ_ITEM *item = NULL;
      567:  241:    pthread_mutex_lock(&cqi_freelist_lock);
      567:  242:    if (cqi_freelist) {
      303:  243:        item = cqi_freelist;
      303:  244:        cqi_freelist = item->next;
        -:  245:    }
      567:  246:    pthread_mutex_unlock(&cqi_freelist_lock);
        -:  247:
      567:  248:    if (NULL == item) {
      264:  249:        int i;
        -:  250:
        -:  251:        /* Allocate a bunch of items at once to reduce fragmentation */
      264:  252:        item = malloc(sizeof(CQ_ITEM) * ITEMS_PER_ALLOC);
      264:  253:        if (NULL == item) {
    #####:  254:            STATS_LOCK();
    #####:  255:            stats.malloc_fails++;
    #####:  256:            STATS_UNLOCK();
    #####:  257:            return NULL;
        -:  258:        }
        -:  259:
        -:  260:        /*
        -:  261:         * Link together all the new items except the first one
        -:  262:         * (which we'll return to the caller) for placement on
        -:  263:         * the freelist.
        -:  264:         */
    16632:  265:        for (i = 2; i < ITEMS_PER_ALLOC; i++)
    16368:  266:            item[i - 1].next = &item[i];
        -:  267:
      264:  268:        pthread_mutex_lock(&cqi_freelist_lock);
      264:  269:        item[ITEMS_PER_ALLOC - 1].next = cqi_freelist;
      264:  270:        cqi_freelist = &item[1];
      264:  271:        pthread_mutex_unlock(&cqi_freelist_lock);
        -:  272:    }
        -:  273:
        -:  274:    return item;
        -:  275:}
------------------
cqi_new:
      189:  239:static CQ_ITEM *cqi_new(void) {
      189:  240:    CQ_ITEM *item = NULL;
      189:  241:    pthread_mutex_lock(&cqi_freelist_lock);
      189:  242:    if (cqi_freelist) {
      101:  243:        item = cqi_freelist;
      101:  244:        cqi_freelist = item->next;
        -:  245:    }
      189:  246:    pthread_mutex_unlock(&cqi_freelist_lock);
        -:  247:
      189:  248:    if (NULL == item) {
       88:  249:        int i;
        -:  250:
        -:  251:        /* Allocate a bunch of items at once to reduce fragmentation */
       88:  252:        item = malloc(sizeof(CQ_ITEM) * ITEMS_PER_ALLOC);
       88:  253:        if (NULL == item) {
    #####:  254:            STATS_LOCK();
    #####:  255:            stats.malloc_fails++;
    #####:  256:            STATS_UNLOCK();
    #####:  257:            return NULL;
        -:  258:        }
        -:  259:
        -:  260:        /*
        -:  261:         * Link together all the new items except the first one
        -:  262:         * (which we'll return to the caller) for placement on
        -:  263:         * the freelist.
        -:  264:         */
     5544:  265:        for (i = 2; i < ITEMS_PER_ALLOC; i++)
     5456:  266:            item[i - 1].next = &item[i];
        -:  267:
       88:  268:        pthread_mutex_lock(&cqi_freelist_lock);
       88:  269:        item[ITEMS_PER_ALLOC - 1].next = cqi_freelist;
       88:  270:        cqi_freelist = &item[1];
       88:  271:        pthread_mutex_unlock(&cqi_freelist_lock);
        -:  272:    }
        -:  273:
        -:  274:    return item;
        -:  275:}
------------------
cqi_new:
      189:  239:static CQ_ITEM *cqi_new(void) {
      189:  240:    CQ_ITEM *item = NULL;
      189:  241:    pthread_mutex_lock(&cqi_freelist_lock);
      189:  242:    if (cqi_freelist) {
      101:  243:        item = cqi_freelist;
      101:  244:        cqi_freelist = item->next;
        -:  245:    }
      189:  246:    pthread_mutex_unlock(&cqi_freelist_lock);
        -:  247:
      189:  248:    if (NULL == item) {
       88:  249:        int i;
        -:  250:
        -:  251:        /* Allocate a bunch of items at once to reduce fragmentation */
       88:  252:        item = malloc(sizeof(CQ_ITEM) * ITEMS_PER_ALLOC);
       88:  253:        if (NULL == item) {
    #####:  254:            STATS_LOCK();
    #####:  255:            stats.malloc_fails++;
    #####:  256:            STATS_UNLOCK();
    #####:  257:            return NULL;
        -:  258:        }
        -:  259:
        -:  260:        /*
        -:  261:         * Link together all the new items except the first one
        -:  262:         * (which we'll return to the caller) for placement on
        -:  263:         * the freelist.
        -:  264:         */
     5544:  265:        for (i = 2; i < ITEMS_PER_ALLOC; i++)
     5456:  266:            item[i - 1].next = &item[i];
        -:  267:
       88:  268:        pthread_mutex_lock(&cqi_freelist_lock);
       88:  269:        item[ITEMS_PER_ALLOC - 1].next = cqi_freelist;
       88:  270:        cqi_freelist = &item[1];
       88:  271:        pthread_mutex_unlock(&cqi_freelist_lock);
        -:  272:    }
        -:  273:
        -:  274:    return item;
        -:  275:}
------------------
cqi_new:
      189:  239:static CQ_ITEM *cqi_new(void) {
      189:  240:    CQ_ITEM *item = NULL;
      189:  241:    pthread_mutex_lock(&cqi_freelist_lock);
      189:  242:    if (cqi_freelist) {
      101:  243:        item = cqi_freelist;
      101:  244:        cqi_freelist = item->next;
        -:  245:    }
      189:  246:    pthread_mutex_unlock(&cqi_freelist_lock);
        -:  247:
      189:  248:    if (NULL == item) {
       88:  249:        int i;
        -:  250:
        -:  251:        /* Allocate a bunch of items at once to reduce fragmentation */
       88:  252:        item = malloc(sizeof(CQ_ITEM) * ITEMS_PER_ALLOC);
       88:  253:        if (NULL == item) {
    #####:  254:            STATS_LOCK();
    #####:  255:            stats.malloc_fails++;
    #####:  256:            STATS_UNLOCK();
    #####:  257:            return NULL;
        -:  258:        }
        -:  259:
        -:  260:        /*
        -:  261:         * Link together all the new items except the first one
        -:  262:         * (which we'll return to the caller) for placement on
        -:  263:         * the freelist.
        -:  264:         */
     5544:  265:        for (i = 2; i < ITEMS_PER_ALLOC; i++)
     5456:  266:            item[i - 1].next = &item[i];
        -:  267:
       88:  268:        pthread_mutex_lock(&cqi_freelist_lock);
       88:  269:        item[ITEMS_PER_ALLOC - 1].next = cqi_freelist;
       88:  270:        cqi_freelist = &item[1];
       88:  271:        pthread_mutex_unlock(&cqi_freelist_lock);
        -:  272:    }
        -:  273:
        -:  274:    return item;
        -:  275:}
------------------
        -:  276:
        -:  277:
        -:  278:/*
        -:  279: * Frees a connection queue item (adds it to the freelist.)
        -:  280: */
      564:  281:static void cqi_free(CQ_ITEM *item) {
      564:  282:    pthread_mutex_lock(&cqi_freelist_lock);
      564:  283:    item->next = cqi_freelist;
      564:  284:    cqi_freelist = item;
      564:  285:    pthread_mutex_unlock(&cqi_freelist_lock);
      564:  286:}
------------------
cqi_free:
      188:  281:static void cqi_free(CQ_ITEM *item) {
      188:  282:    pthread_mutex_lock(&cqi_freelist_lock);
      188:  283:    item->next = cqi_freelist;
      188:  284:    cqi_freelist = item;
      188:  285:    pthread_mutex_unlock(&cqi_freelist_lock);
      188:  286:}
------------------
cqi_free:
      188:  281:static void cqi_free(CQ_ITEM *item) {
      188:  282:    pthread_mutex_lock(&cqi_freelist_lock);
      188:  283:    item->next = cqi_freelist;
      188:  284:    cqi_freelist = item;
      188:  285:    pthread_mutex_unlock(&cqi_freelist_lock);
      188:  286:}
------------------
cqi_free:
      188:  281:static void cqi_free(CQ_ITEM *item) {
      188:  282:    pthread_mutex_lock(&cqi_freelist_lock);
      188:  283:    item->next = cqi_freelist;
      188:  284:    cqi_freelist = item;
      188:  285:    pthread_mutex_unlock(&cqi_freelist_lock);
      188:  286:}
------------------
        -:  287:
        -:  288:
        -:  289:/*
        -:  290: * Creates a worker thread.
        -:  291: */
     1152:  292:static void create_worker(void *(*func)(void *), void *arg) {
     1152:  293:    pthread_attr_t  attr;
     1152:  294:    int             ret;
        -:  295:
     1152:  296:    pthread_attr_init(&attr);
        -:  297:
     1152:  298:    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
    #####:  299:        fprintf(stderr, "Can't create thread: %s\n",
        -:  300:                strerror(ret));
    #####:  301:        exit(1);
        -:  302:    }
     1152:  303:}
------------------
create_worker:
      384:  292:static void create_worker(void *(*func)(void *), void *arg) {
      384:  293:    pthread_attr_t  attr;
      384:  294:    int             ret;
        -:  295:
      384:  296:    pthread_attr_init(&attr);
        -:  297:
      384:  298:    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
    #####:  299:        fprintf(stderr, "Can't create thread: %s\n",
        -:  300:                strerror(ret));
    #####:  301:        exit(1);
        -:  302:    }
      384:  303:}
------------------
create_worker:
      384:  292:static void create_worker(void *(*func)(void *), void *arg) {
      384:  293:    pthread_attr_t  attr;
      384:  294:    int             ret;
        -:  295:
      384:  296:    pthread_attr_init(&attr);
        -:  297:
      384:  298:    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
    #####:  299:        fprintf(stderr, "Can't create thread: %s\n",
        -:  300:                strerror(ret));
    #####:  301:        exit(1);
        -:  302:    }
      384:  303:}
------------------
create_worker:
      384:  292:static void create_worker(void *(*func)(void *), void *arg) {
      384:  293:    pthread_attr_t  attr;
      384:  294:    int             ret;
        -:  295:
      384:  296:    pthread_attr_init(&attr);
        -:  297:
      384:  298:    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
    #####:  299:        fprintf(stderr, "Can't create thread: %s\n",
        -:  300:                strerror(ret));
    #####:  301:        exit(1);
        -:  302:    }
      384:  303:}
------------------
        -:  304:
        -:  305:/*
        -:  306: * Sets whether or not we accept new connections.
        -:  307: */
    #####:  308:void accept_new_conns(const bool do_accept) {
    #####:  309:    pthread_mutex_lock(&conn_lock);
    #####:  310:    do_accept_new_conns(do_accept);
    #####:  311:    pthread_mutex_unlock(&conn_lock);
    #####:  312:}
------------------
accept_new_conns:
    #####:  308:void accept_new_conns(const bool do_accept) {
    #####:  309:    pthread_mutex_lock(&conn_lock);
    #####:  310:    do_accept_new_conns(do_accept);
    #####:  311:    pthread_mutex_unlock(&conn_lock);
    #####:  312:}
------------------
accept_new_conns:
    #####:  308:void accept_new_conns(const bool do_accept) {
    #####:  309:    pthread_mutex_lock(&conn_lock);
    #####:  310:    do_accept_new_conns(do_accept);
    #####:  311:    pthread_mutex_unlock(&conn_lock);
    #####:  312:}
------------------
accept_new_conns:
    #####:  308:void accept_new_conns(const bool do_accept) {
    #####:  309:    pthread_mutex_lock(&conn_lock);
    #####:  310:    do_accept_new_conns(do_accept);
    #####:  311:    pthread_mutex_unlock(&conn_lock);
    #####:  312:}
------------------
        -:  313:/****************************** LIBEVENT THREADS *****************************/
        -:  314:
        -:  315:/*
        -:  316: * Set up a thread's information.
        -:  317: */
     1152:  318:static void setup_thread(LIBEVENT_THREAD *me) {
        -:  319:#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
     1152:  320:    struct event_config *ev_config;
     1152:  321:    ev_config = event_config_new();
     1152:  322:    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
     1152:  323:    me->base = event_base_new_with_config(ev_config);
     1152:  324:    event_config_free(ev_config);
        -:  325:#else
        -:  326:    me->base = event_init();
        -:  327:#endif
        -:  328:
     1152:  329:    if (! me->base) {
    #####:  330:        fprintf(stderr, "Can't allocate event base\n");
    #####:  331:        exit(1);
        -:  332:    }
        -:  333:
        -:  334:    /* Listen for notifications from other threads */
     1152:  335:    event_set(&me->notify_event, me->notify_receive_fd,
        -:  336:              EV_READ | EV_PERSIST, thread_libevent_process, me);
     1152:  337:    event_base_set(me->base, &me->notify_event);
        -:  338:
     1152:  339:    if (event_add(&me->notify_event, 0) == -1) {
    #####:  340:        fprintf(stderr, "Can't monitor libevent notify pipe\n");
    #####:  341:        exit(1);
        -:  342:    }
        -:  343:
     1152:  344:    me->new_conn_queue = malloc(sizeof(struct conn_queue));
     1152:  345:    if (me->new_conn_queue == NULL) {
    #####:  346:        perror("Failed to allocate memory for connection queue");
    #####:  347:        exit(EXIT_FAILURE);
        -:  348:    }
     1152:  349:    cq_init(me->new_conn_queue);
        -:  350:
     1152:  351:    if (pthread_mutex_init(&me->stats.mutex, NULL) != 0) {
    #####:  352:        perror("Failed to initialize mutex");
    #####:  353:        exit(EXIT_FAILURE);
        -:  354:    }
        -:  355:
     1152:  356:    me->suffix_cache = cache_create("suffix", SUFFIX_SIZE, sizeof(char*),
        -:  357:                                    NULL, NULL);
     1152:  358:    if (me->suffix_cache == NULL) {
    #####:  359:        fprintf(stderr, "Failed to create suffix cache\n");
    #####:  360:        exit(EXIT_FAILURE);
        -:  361:    }
        -:  362:#ifdef EXTSTORE
        -:  363:    me->io_cache = cache_create("io", sizeof(io_wrap), sizeof(char*), NULL, NULL);
        -:  364:    if (me->io_cache == NULL) {
        -:  365:        fprintf(stderr, "Failed to create IO object cache\n");
        -:  366:        exit(EXIT_FAILURE);
        -:  367:    }
        -:  368:#endif
        -:  369:#ifdef TLS
        -:  370:    if (settings.ssl_enabled) {
        -:  371:        me->ssl_wbuf = (char *)malloc((size_t)settings.ssl_wbuf_size);
        -:  372:        if (me->ssl_wbuf == NULL) {
        -:  373:            fprintf(stderr, "Failed to allocate the SSL write buffer\n");
        -:  374:            exit(EXIT_FAILURE);
        -:  375:        }
        -:  376:    }
        -:  377:#endif
     1152:  378:}
------------------
setup_thread:
      384:  318:static void setup_thread(LIBEVENT_THREAD *me) {
        -:  319:#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
      384:  320:    struct event_config *ev_config;
      384:  321:    ev_config = event_config_new();
      384:  322:    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
      384:  323:    me->base = event_base_new_with_config(ev_config);
      384:  324:    event_config_free(ev_config);
        -:  325:#else
        -:  326:    me->base = event_init();
        -:  327:#endif
        -:  328:
      384:  329:    if (! me->base) {
    #####:  330:        fprintf(stderr, "Can't allocate event base\n");
    #####:  331:        exit(1);
        -:  332:    }
        -:  333:
        -:  334:    /* Listen for notifications from other threads */
      384:  335:    event_set(&me->notify_event, me->notify_receive_fd,
        -:  336:              EV_READ | EV_PERSIST, thread_libevent_process, me);
      384:  337:    event_base_set(me->base, &me->notify_event);
        -:  338:
      384:  339:    if (event_add(&me->notify_event, 0) == -1) {
    #####:  340:        fprintf(stderr, "Can't monitor libevent notify pipe\n");
    #####:  341:        exit(1);
        -:  342:    }
        -:  343:
      384:  344:    me->new_conn_queue = malloc(sizeof(struct conn_queue));
      384:  345:    if (me->new_conn_queue == NULL) {
    #####:  346:        perror("Failed to allocate memory for connection queue");
    #####:  347:        exit(EXIT_FAILURE);
        -:  348:    }
      384:  349:    cq_init(me->new_conn_queue);
        -:  350:
      384:  351:    if (pthread_mutex_init(&me->stats.mutex, NULL) != 0) {
    #####:  352:        perror("Failed to initialize mutex");
    #####:  353:        exit(EXIT_FAILURE);
        -:  354:    }
        -:  355:
      384:  356:    me->suffix_cache = cache_create("suffix", SUFFIX_SIZE, sizeof(char*),
        -:  357:                                    NULL, NULL);
      384:  358:    if (me->suffix_cache == NULL) {
    #####:  359:        fprintf(stderr, "Failed to create suffix cache\n");
    #####:  360:        exit(EXIT_FAILURE);
        -:  361:    }
        -:  362:#ifdef EXTSTORE
        -:  363:    me->io_cache = cache_create("io", sizeof(io_wrap), sizeof(char*), NULL, NULL);
        -:  364:    if (me->io_cache == NULL) {
        -:  365:        fprintf(stderr, "Failed to create IO object cache\n");
        -:  366:        exit(EXIT_FAILURE);
        -:  367:    }
        -:  368:#endif
        -:  369:#ifdef TLS
        -:  370:    if (settings.ssl_enabled) {
        -:  371:        me->ssl_wbuf = (char *)malloc((size_t)settings.ssl_wbuf_size);
        -:  372:        if (me->ssl_wbuf == NULL) {
        -:  373:            fprintf(stderr, "Failed to allocate the SSL write buffer\n");
        -:  374:            exit(EXIT_FAILURE);
        -:  375:        }
        -:  376:    }
        -:  377:#endif
      384:  378:}
------------------
setup_thread:
      384:  318:static void setup_thread(LIBEVENT_THREAD *me) {
        -:  319:#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
      384:  320:    struct event_config *ev_config;
      384:  321:    ev_config = event_config_new();
      384:  322:    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
      384:  323:    me->base = event_base_new_with_config(ev_config);
      384:  324:    event_config_free(ev_config);
        -:  325:#else
        -:  326:    me->base = event_init();
        -:  327:#endif
        -:  328:
      384:  329:    if (! me->base) {
    #####:  330:        fprintf(stderr, "Can't allocate event base\n");
    #####:  331:        exit(1);
        -:  332:    }
        -:  333:
        -:  334:    /* Listen for notifications from other threads */
      384:  335:    event_set(&me->notify_event, me->notify_receive_fd,
        -:  336:              EV_READ | EV_PERSIST, thread_libevent_process, me);
      384:  337:    event_base_set(me->base, &me->notify_event);
        -:  338:
      384:  339:    if (event_add(&me->notify_event, 0) == -1) {
    #####:  340:        fprintf(stderr, "Can't monitor libevent notify pipe\n");
    #####:  341:        exit(1);
        -:  342:    }
        -:  343:
      384:  344:    me->new_conn_queue = malloc(sizeof(struct conn_queue));
      384:  345:    if (me->new_conn_queue == NULL) {
    #####:  346:        perror("Failed to allocate memory for connection queue");
    #####:  347:        exit(EXIT_FAILURE);
        -:  348:    }
      384:  349:    cq_init(me->new_conn_queue);
        -:  350:
      384:  351:    if (pthread_mutex_init(&me->stats.mutex, NULL) != 0) {
    #####:  352:        perror("Failed to initialize mutex");
    #####:  353:        exit(EXIT_FAILURE);
        -:  354:    }
        -:  355:
      384:  356:    me->suffix_cache = cache_create("suffix", SUFFIX_SIZE, sizeof(char*),
        -:  357:                                    NULL, NULL);
      384:  358:    if (me->suffix_cache == NULL) {
    #####:  359:        fprintf(stderr, "Failed to create suffix cache\n");
    #####:  360:        exit(EXIT_FAILURE);
        -:  361:    }
        -:  362:#ifdef EXTSTORE
        -:  363:    me->io_cache = cache_create("io", sizeof(io_wrap), sizeof(char*), NULL, NULL);
        -:  364:    if (me->io_cache == NULL) {
        -:  365:        fprintf(stderr, "Failed to create IO object cache\n");
        -:  366:        exit(EXIT_FAILURE);
        -:  367:    }
        -:  368:#endif
        -:  369:#ifdef TLS
        -:  370:    if (settings.ssl_enabled) {
        -:  371:        me->ssl_wbuf = (char *)malloc((size_t)settings.ssl_wbuf_size);
        -:  372:        if (me->ssl_wbuf == NULL) {
        -:  373:            fprintf(stderr, "Failed to allocate the SSL write buffer\n");
        -:  374:            exit(EXIT_FAILURE);
        -:  375:        }
        -:  376:    }
        -:  377:#endif
      384:  378:}
------------------
setup_thread:
      384:  318:static void setup_thread(LIBEVENT_THREAD *me) {
        -:  319:#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
      384:  320:    struct event_config *ev_config;
      384:  321:    ev_config = event_config_new();
      384:  322:    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
      384:  323:    me->base = event_base_new_with_config(ev_config);
      384:  324:    event_config_free(ev_config);
        -:  325:#else
        -:  326:    me->base = event_init();
        -:  327:#endif
        -:  328:
      384:  329:    if (! me->base) {
    #####:  330:        fprintf(stderr, "Can't allocate event base\n");
    #####:  331:        exit(1);
        -:  332:    }
        -:  333:
        -:  334:    /* Listen for notifications from other threads */
      384:  335:    event_set(&me->notify_event, me->notify_receive_fd,
        -:  336:              EV_READ | EV_PERSIST, thread_libevent_process, me);
      384:  337:    event_base_set(me->base, &me->notify_event);
        -:  338:
      384:  339:    if (event_add(&me->notify_event, 0) == -1) {
    #####:  340:        fprintf(stderr, "Can't monitor libevent notify pipe\n");
    #####:  341:        exit(1);
        -:  342:    }
        -:  343:
      384:  344:    me->new_conn_queue = malloc(sizeof(struct conn_queue));
      384:  345:    if (me->new_conn_queue == NULL) {
    #####:  346:        perror("Failed to allocate memory for connection queue");
    #####:  347:        exit(EXIT_FAILURE);
        -:  348:    }
      384:  349:    cq_init(me->new_conn_queue);
        -:  350:
      384:  351:    if (pthread_mutex_init(&me->stats.mutex, NULL) != 0) {
    #####:  352:        perror("Failed to initialize mutex");
    #####:  353:        exit(EXIT_FAILURE);
        -:  354:    }
        -:  355:
      384:  356:    me->suffix_cache = cache_create("suffix", SUFFIX_SIZE, sizeof(char*),
        -:  357:                                    NULL, NULL);
      384:  358:    if (me->suffix_cache == NULL) {
    #####:  359:        fprintf(stderr, "Failed to create suffix cache\n");
    #####:  360:        exit(EXIT_FAILURE);
        -:  361:    }
        -:  362:#ifdef EXTSTORE
        -:  363:    me->io_cache = cache_create("io", sizeof(io_wrap), sizeof(char*), NULL, NULL);
        -:  364:    if (me->io_cache == NULL) {
        -:  365:        fprintf(stderr, "Failed to create IO object cache\n");
        -:  366:        exit(EXIT_FAILURE);
        -:  367:    }
        -:  368:#endif
        -:  369:#ifdef TLS
        -:  370:    if (settings.ssl_enabled) {
        -:  371:        me->ssl_wbuf = (char *)malloc((size_t)settings.ssl_wbuf_size);
        -:  372:        if (me->ssl_wbuf == NULL) {
        -:  373:            fprintf(stderr, "Failed to allocate the SSL write buffer\n");
        -:  374:            exit(EXIT_FAILURE);
        -:  375:        }
        -:  376:    }
        -:  377:#endif
      384:  378:}
------------------
        -:  379:
        -:  380:/*
        -:  381: * Worker thread: main event loop
        -:  382: */
     1152:  383:static void *worker_libevent(void *arg) {
     1152:  384:    LIBEVENT_THREAD *me = arg;
        -:  385:
        -:  386:    /* Any per-thread setup can happen here; memcached_thread_init() will block until
        -:  387:     * all threads have finished initializing.
        -:  388:     */
     1152:  389:    me->l = logger_create();
     1152:  390:    me->lru_bump_buf = item_lru_bump_buf_create();
     1152:  391:    if (me->l == NULL || me->lru_bump_buf == NULL) {
    #####:  392:        abort();
        -:  393:    }
        -:  394:
     1152:  395:    if (settings.drop_privileges) {
     1152:  396:        drop_worker_privileges();
        -:  397:    }
        -:  398:
     1152:  399:    register_thread_initialized();
        -:  400:
     1152:  401:    event_base_loop(me->base, 0);
        -:  402:
    #####:  403:    event_base_free(me->base);
    #####:  404:    return NULL;
        -:  405:}
------------------
worker_libevent:
      384:  383:static void *worker_libevent(void *arg) {
      384:  384:    LIBEVENT_THREAD *me = arg;
        -:  385:
        -:  386:    /* Any per-thread setup can happen here; memcached_thread_init() will block until
        -:  387:     * all threads have finished initializing.
        -:  388:     */
      384:  389:    me->l = logger_create();
      384:  390:    me->lru_bump_buf = item_lru_bump_buf_create();
      384:  391:    if (me->l == NULL || me->lru_bump_buf == NULL) {
    #####:  392:        abort();
        -:  393:    }
        -:  394:
      384:  395:    if (settings.drop_privileges) {
      384:  396:        drop_worker_privileges();
        -:  397:    }
        -:  398:
      384:  399:    register_thread_initialized();
        -:  400:
      384:  401:    event_base_loop(me->base, 0);
        -:  402:
    #####:  403:    event_base_free(me->base);
    #####:  404:    return NULL;
        -:  405:}
------------------
worker_libevent:
      384:  383:static void *worker_libevent(void *arg) {
      384:  384:    LIBEVENT_THREAD *me = arg;
        -:  385:
        -:  386:    /* Any per-thread setup can happen here; memcached_thread_init() will block until
        -:  387:     * all threads have finished initializing.
        -:  388:     */
      384:  389:    me->l = logger_create();
      384:  390:    me->lru_bump_buf = item_lru_bump_buf_create();
      384:  391:    if (me->l == NULL || me->lru_bump_buf == NULL) {
    #####:  392:        abort();
        -:  393:    }
        -:  394:
      384:  395:    if (settings.drop_privileges) {
      384:  396:        drop_worker_privileges();
        -:  397:    }
        -:  398:
      384:  399:    register_thread_initialized();
        -:  400:
      384:  401:    event_base_loop(me->base, 0);
        -:  402:
    #####:  403:    event_base_free(me->base);
    #####:  404:    return NULL;
        -:  405:}
------------------
worker_libevent:
      384:  383:static void *worker_libevent(void *arg) {
      384:  384:    LIBEVENT_THREAD *me = arg;
        -:  385:
        -:  386:    /* Any per-thread setup can happen here; memcached_thread_init() will block until
        -:  387:     * all threads have finished initializing.
        -:  388:     */
      384:  389:    me->l = logger_create();
      384:  390:    me->lru_bump_buf = item_lru_bump_buf_create();
      384:  391:    if (me->l == NULL || me->lru_bump_buf == NULL) {
    #####:  392:        abort();
        -:  393:    }
        -:  394:
      384:  395:    if (settings.drop_privileges) {
      384:  396:        drop_worker_privileges();
        -:  397:    }
        -:  398:
      384:  399:    register_thread_initialized();
        -:  400:
      384:  401:    event_base_loop(me->base, 0);
        -:  402:
    #####:  403:    event_base_free(me->base);
    #####:  404:    return NULL;
        -:  405:}
------------------
        -:  406:
        -:  407:
        -:  408:/*
        -:  409: * Processes an incoming "handle a new connection" item. This is called when
        -:  410: * input arrives on the libevent wakeup pipe.
        -:  411: */
      570:  412:static void thread_libevent_process(int fd, short which, void *arg) {
      570:  413:    LIBEVENT_THREAD *me = arg;
      570:  414:    CQ_ITEM *item;
      570:  415:    char buf[1];
      570:  416:    conn *c;
      570:  417:    unsigned int timeout_fd;
        -:  418:
      570:  419:    if (read(fd, buf, 1) != 1) {
    #####:  420:        if (settings.verbose > 0)
    #####:  421:            fprintf(stderr, "Can't read from libevent pipe\n");
    #####:  422:        return;
        -:  423:    }
        -:  424:
      567:  425:    switch (buf[0]) {
      564:  426:    case 'c':
      564:  427:        item = cq_pop(me->new_conn_queue);
        -:  428:
      564:  429:        if (NULL == item) {
        -:  430:            break;
        -:  431:        }
      564:  432:        switch (item->mode) {
      561:  433:            case queue_new_conn:
      561:  434:                c = conn_new(item->sfd, item->init_state, item->event_flags,
        -:  435:                                   item->read_buffer_size, item->transport,
        -:  436:                                   me->base, item->ssl);
      561:  437:                if (c == NULL) {
    #####:  438:                    if (IS_UDP(item->transport)) {
    #####:  439:                        fprintf(stderr, "Can't listen for events on UDP socket\n");
    #####:  440:                        exit(1);
        -:  441:                    } else {
    #####:  442:                        if (settings.verbose > 0) {
    #####:  443:                            fprintf(stderr, "Can't listen for events on fd %d\n",
        -:  444:                                item->sfd);
        -:  445:                        }
    #####:  446:                        close(item->sfd);
        -:  447:                    }
        -:  448:                } else {
      561:  449:                    c->thread = me;
        -:  450:#ifdef TLS
        -:  451:                    if (settings.ssl_enabled && c->ssl != NULL) {
        -:  452:                        assert(c->thread && c->thread->ssl_wbuf);
        -:  453:                        c->ssl_wbuf = c->thread->ssl_wbuf;
        -:  454:                    }
        -:  455:#endif
        -:  456:                }
        -:  457:                break;
        -:  458:
        3:  459:            case queue_redispatch:
        3:  460:                conn_worker_readd(item->c);
        3:  461:                break;
        -:  462:        }
      564:  463:        cqi_free(item);
      564:  464:        break;
        -:  465:    /* we were told to pause and report in */
    #####:  466:    case 'p':
    #####:  467:        register_thread_initialized();
    #####:  468:        break;
        -:  469:    /* a client socket timed out */
        -:  470:    case 't':
        3:  471:        if (read(fd, &timeout_fd, sizeof(timeout_fd)) != sizeof(timeout_fd)) {
    #####:  472:            if (settings.verbose > 0)
    #####:  473:                fprintf(stderr, "Can't read timeout fd from libevent pipe\n");
    #####:  474:            return;
        -:  475:        }
        3:  476:        conn_close_idle(conns[timeout_fd]);
        3:  477:        break;
        -:  478:    }
     567*:  479:}
------------------
thread_libevent_process:
      190:  412:static void thread_libevent_process(int fd, short which, void *arg) {
      190:  413:    LIBEVENT_THREAD *me = arg;
      190:  414:    CQ_ITEM *item;
      190:  415:    char buf[1];
      190:  416:    conn *c;
      190:  417:    unsigned int timeout_fd;
        -:  418:
      190:  419:    if (read(fd, buf, 1) != 1) {
    #####:  420:        if (settings.verbose > 0)
    #####:  421:            fprintf(stderr, "Can't read from libevent pipe\n");
    #####:  422:        return;
        -:  423:    }
        -:  424:
      189:  425:    switch (buf[0]) {
      188:  426:    case 'c':
      188:  427:        item = cq_pop(me->new_conn_queue);
        -:  428:
      188:  429:        if (NULL == item) {
        -:  430:            break;
        -:  431:        }
      188:  432:        switch (item->mode) {
      187:  433:            case queue_new_conn:
      187:  434:                c = conn_new(item->sfd, item->init_state, item->event_flags,
        -:  435:                                   item->read_buffer_size, item->transport,
        -:  436:                                   me->base, item->ssl);
      187:  437:                if (c == NULL) {
    #####:  438:                    if (IS_UDP(item->transport)) {
    #####:  439:                        fprintf(stderr, "Can't listen for events on UDP socket\n");
    #####:  440:                        exit(1);
        -:  441:                    } else {
    #####:  442:                        if (settings.verbose > 0) {
    #####:  443:                            fprintf(stderr, "Can't listen for events on fd %d\n",
        -:  444:                                item->sfd);
        -:  445:                        }
    #####:  446:                        close(item->sfd);
        -:  447:                    }
        -:  448:                } else {
      187:  449:                    c->thread = me;
        -:  450:#ifdef TLS
        -:  451:                    if (settings.ssl_enabled && c->ssl != NULL) {
        -:  452:                        assert(c->thread && c->thread->ssl_wbuf);
        -:  453:                        c->ssl_wbuf = c->thread->ssl_wbuf;
        -:  454:                    }
        -:  455:#endif
        -:  456:                }
        -:  457:                break;
        -:  458:
        1:  459:            case queue_redispatch:
        1:  460:                conn_worker_readd(item->c);
        1:  461:                break;
        -:  462:        }
      188:  463:        cqi_free(item);
      188:  464:        break;
        -:  465:    /* we were told to pause and report in */
    #####:  466:    case 'p':
    #####:  467:        register_thread_initialized();
    #####:  468:        break;
        -:  469:    /* a client socket timed out */
        -:  470:    case 't':
        1:  471:        if (read(fd, &timeout_fd, sizeof(timeout_fd)) != sizeof(timeout_fd)) {
    #####:  472:            if (settings.verbose > 0)
    #####:  473:                fprintf(stderr, "Can't read timeout fd from libevent pipe\n");
    #####:  474:            return;
        -:  475:        }
        1:  476:        conn_close_idle(conns[timeout_fd]);
        1:  477:        break;
        -:  478:    }
     189*:  479:}
------------------
thread_libevent_process:
      190:  412:static void thread_libevent_process(int fd, short which, void *arg) {
      190:  413:    LIBEVENT_THREAD *me = arg;
      190:  414:    CQ_ITEM *item;
      190:  415:    char buf[1];
      190:  416:    conn *c;
      190:  417:    unsigned int timeout_fd;
        -:  418:
      190:  419:    if (read(fd, buf, 1) != 1) {
    #####:  420:        if (settings.verbose > 0)
    #####:  421:            fprintf(stderr, "Can't read from libevent pipe\n");
    #####:  422:        return;
        -:  423:    }
        -:  424:
      189:  425:    switch (buf[0]) {
      188:  426:    case 'c':
      188:  427:        item = cq_pop(me->new_conn_queue);
        -:  428:
      188:  429:        if (NULL == item) {
        -:  430:            break;
        -:  431:        }
      188:  432:        switch (item->mode) {
      187:  433:            case queue_new_conn:
      187:  434:                c = conn_new(item->sfd, item->init_state, item->event_flags,
        -:  435:                                   item->read_buffer_size, item->transport,
        -:  436:                                   me->base, item->ssl);
      187:  437:                if (c == NULL) {
    #####:  438:                    if (IS_UDP(item->transport)) {
    #####:  439:                        fprintf(stderr, "Can't listen for events on UDP socket\n");
    #####:  440:                        exit(1);
        -:  441:                    } else {
    #####:  442:                        if (settings.verbose > 0) {
    #####:  443:                            fprintf(stderr, "Can't listen for events on fd %d\n",
        -:  444:                                item->sfd);
        -:  445:                        }
    #####:  446:                        close(item->sfd);
        -:  447:                    }
        -:  448:                } else {
      187:  449:                    c->thread = me;
        -:  450:#ifdef TLS
        -:  451:                    if (settings.ssl_enabled && c->ssl != NULL) {
        -:  452:                        assert(c->thread && c->thread->ssl_wbuf);
        -:  453:                        c->ssl_wbuf = c->thread->ssl_wbuf;
        -:  454:                    }
        -:  455:#endif
        -:  456:                }
        -:  457:                break;
        -:  458:
        1:  459:            case queue_redispatch:
        1:  460:                conn_worker_readd(item->c);
        1:  461:                break;
        -:  462:        }
      188:  463:        cqi_free(item);
      188:  464:        break;
        -:  465:    /* we were told to pause and report in */
    #####:  466:    case 'p':
    #####:  467:        register_thread_initialized();
    #####:  468:        break;
        -:  469:    /* a client socket timed out */
        -:  470:    case 't':
        1:  471:        if (read(fd, &timeout_fd, sizeof(timeout_fd)) != sizeof(timeout_fd)) {
    #####:  472:            if (settings.verbose > 0)
    #####:  473:                fprintf(stderr, "Can't read timeout fd from libevent pipe\n");
    #####:  474:            return;
        -:  475:        }
        1:  476:        conn_close_idle(conns[timeout_fd]);
        1:  477:        break;
        -:  478:    }
     189*:  479:}
------------------
thread_libevent_process:
      190:  412:static void thread_libevent_process(int fd, short which, void *arg) {
      190:  413:    LIBEVENT_THREAD *me = arg;
      190:  414:    CQ_ITEM *item;
      190:  415:    char buf[1];
      190:  416:    conn *c;
      190:  417:    unsigned int timeout_fd;
        -:  418:
      190:  419:    if (read(fd, buf, 1) != 1) {
    #####:  420:        if (settings.verbose > 0)
    #####:  421:            fprintf(stderr, "Can't read from libevent pipe\n");
    #####:  422:        return;
        -:  423:    }
        -:  424:
      189:  425:    switch (buf[0]) {
      188:  426:    case 'c':
      188:  427:        item = cq_pop(me->new_conn_queue);
        -:  428:
      188:  429:        if (NULL == item) {
        -:  430:            break;
        -:  431:        }
      188:  432:        switch (item->mode) {
      187:  433:            case queue_new_conn:
      187:  434:                c = conn_new(item->sfd, item->init_state, item->event_flags,
        -:  435:                                   item->read_buffer_size, item->transport,
        -:  436:                                   me->base, item->ssl);
      187:  437:                if (c == NULL) {
    #####:  438:                    if (IS_UDP(item->transport)) {
    #####:  439:                        fprintf(stderr, "Can't listen for events on UDP socket\n");
    #####:  440:                        exit(1);
        -:  441:                    } else {
    #####:  442:                        if (settings.verbose > 0) {
    #####:  443:                            fprintf(stderr, "Can't listen for events on fd %d\n",
        -:  444:                                item->sfd);
        -:  445:                        }
    #####:  446:                        close(item->sfd);
        -:  447:                    }
        -:  448:                } else {
      187:  449:                    c->thread = me;
        -:  450:#ifdef TLS
        -:  451:                    if (settings.ssl_enabled && c->ssl != NULL) {
        -:  452:                        assert(c->thread && c->thread->ssl_wbuf);
        -:  453:                        c->ssl_wbuf = c->thread->ssl_wbuf;
        -:  454:                    }
        -:  455:#endif
        -:  456:                }
        -:  457:                break;
        -:  458:
        1:  459:            case queue_redispatch:
        1:  460:                conn_worker_readd(item->c);
        1:  461:                break;
        -:  462:        }
      188:  463:        cqi_free(item);
      188:  464:        break;
        -:  465:    /* we were told to pause and report in */
    #####:  466:    case 'p':
    #####:  467:        register_thread_initialized();
    #####:  468:        break;
        -:  469:    /* a client socket timed out */
        -:  470:    case 't':
        1:  471:        if (read(fd, &timeout_fd, sizeof(timeout_fd)) != sizeof(timeout_fd)) {
    #####:  472:            if (settings.verbose > 0)
    #####:  473:                fprintf(stderr, "Can't read timeout fd from libevent pipe\n");
    #####:  474:            return;
        -:  475:        }
        1:  476:        conn_close_idle(conns[timeout_fd]);
        1:  477:        break;
        -:  478:    }
     189*:  479:}
------------------
        -:  480:
        -:  481:/* Which thread we assigned a connection to most recently. */
        -:  482:static int last_thread = -1;
        -:  483:
        -:  484:/*
        -:  485: * Dispatches a new connection to another thread. This is only ever called
        -:  486: * from the main thread, either during initialization (for UDP) or because
        -:  487: * of an incoming connection.
        -:  488: */
      564:  489:void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,
        -:  490:                       int read_buffer_size, enum network_transport transport, void *ssl) {
      564:  491:    CQ_ITEM *item = cqi_new();
      564:  492:    char buf[1];
      564:  493:    if (item == NULL) {
    #####:  494:        close(sfd);
        -:  495:        /* given that malloc failed this may also fail, but let's try */
    #####:  496:        fprintf(stderr, "Failed to allocate memory for connection object\n");
    #####:  497:        return ;
        -:  498:    }
        -:  499:
      564:  500:    int tid = (last_thread + 1) % settings.num_threads;
        -:  501:
      564:  502:    LIBEVENT_THREAD *thread = threads + tid;
        -:  503:
      564:  504:    last_thread = tid;
        -:  505:
      564:  506:    item->sfd = sfd;
      564:  507:    item->init_state = init_state;
      564:  508:    item->event_flags = event_flags;
      564:  509:    item->read_buffer_size = read_buffer_size;
      564:  510:    item->transport = transport;
      564:  511:    item->mode = queue_new_conn;
      564:  512:    item->ssl = ssl;
        -:  513:
      564:  514:    cq_push(thread->new_conn_queue, item);
        -:  515:
      564:  516:    MEMCACHED_CONN_DISPATCH(sfd, thread->thread_id);
      564:  517:    buf[0] = 'c';
      564:  518:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  519:        perror("Writing to thread notify pipe");
        -:  520:    }
        -:  521:}
------------------
dispatch_conn_new:
      188:  489:void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,
        -:  490:                       int read_buffer_size, enum network_transport transport, void *ssl) {
      188:  491:    CQ_ITEM *item = cqi_new();
      188:  492:    char buf[1];
      188:  493:    if (item == NULL) {
    #####:  494:        close(sfd);
        -:  495:        /* given that malloc failed this may also fail, but let's try */
    #####:  496:        fprintf(stderr, "Failed to allocate memory for connection object\n");
    #####:  497:        return ;
        -:  498:    }
        -:  499:
      188:  500:    int tid = (last_thread + 1) % settings.num_threads;
        -:  501:
      188:  502:    LIBEVENT_THREAD *thread = threads + tid;
        -:  503:
      188:  504:    last_thread = tid;
        -:  505:
      188:  506:    item->sfd = sfd;
      188:  507:    item->init_state = init_state;
      188:  508:    item->event_flags = event_flags;
      188:  509:    item->read_buffer_size = read_buffer_size;
      188:  510:    item->transport = transport;
      188:  511:    item->mode = queue_new_conn;
      188:  512:    item->ssl = ssl;
        -:  513:
      188:  514:    cq_push(thread->new_conn_queue, item);
        -:  515:
      188:  516:    MEMCACHED_CONN_DISPATCH(sfd, thread->thread_id);
      188:  517:    buf[0] = 'c';
      188:  518:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  519:        perror("Writing to thread notify pipe");
        -:  520:    }
        -:  521:}
------------------
dispatch_conn_new:
      188:  489:void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,
        -:  490:                       int read_buffer_size, enum network_transport transport, void *ssl) {
      188:  491:    CQ_ITEM *item = cqi_new();
      188:  492:    char buf[1];
      188:  493:    if (item == NULL) {
    #####:  494:        close(sfd);
        -:  495:        /* given that malloc failed this may also fail, but let's try */
    #####:  496:        fprintf(stderr, "Failed to allocate memory for connection object\n");
    #####:  497:        return ;
        -:  498:    }
        -:  499:
      188:  500:    int tid = (last_thread + 1) % settings.num_threads;
        -:  501:
      188:  502:    LIBEVENT_THREAD *thread = threads + tid;
        -:  503:
      188:  504:    last_thread = tid;
        -:  505:
      188:  506:    item->sfd = sfd;
      188:  507:    item->init_state = init_state;
      188:  508:    item->event_flags = event_flags;
      188:  509:    item->read_buffer_size = read_buffer_size;
      188:  510:    item->transport = transport;
      188:  511:    item->mode = queue_new_conn;
      188:  512:    item->ssl = ssl;
        -:  513:
      188:  514:    cq_push(thread->new_conn_queue, item);
        -:  515:
      188:  516:    MEMCACHED_CONN_DISPATCH(sfd, thread->thread_id);
      188:  517:    buf[0] = 'c';
      188:  518:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  519:        perror("Writing to thread notify pipe");
        -:  520:    }
        -:  521:}
------------------
dispatch_conn_new:
      188:  489:void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,
        -:  490:                       int read_buffer_size, enum network_transport transport, void *ssl) {
      188:  491:    CQ_ITEM *item = cqi_new();
      188:  492:    char buf[1];
      188:  493:    if (item == NULL) {
    #####:  494:        close(sfd);
        -:  495:        /* given that malloc failed this may also fail, but let's try */
    #####:  496:        fprintf(stderr, "Failed to allocate memory for connection object\n");
    #####:  497:        return ;
        -:  498:    }
        -:  499:
      188:  500:    int tid = (last_thread + 1) % settings.num_threads;
        -:  501:
      188:  502:    LIBEVENT_THREAD *thread = threads + tid;
        -:  503:
      188:  504:    last_thread = tid;
        -:  505:
      188:  506:    item->sfd = sfd;
      188:  507:    item->init_state = init_state;
      188:  508:    item->event_flags = event_flags;
      188:  509:    item->read_buffer_size = read_buffer_size;
      188:  510:    item->transport = transport;
      188:  511:    item->mode = queue_new_conn;
      188:  512:    item->ssl = ssl;
        -:  513:
      188:  514:    cq_push(thread->new_conn_queue, item);
        -:  515:
      188:  516:    MEMCACHED_CONN_DISPATCH(sfd, thread->thread_id);
      188:  517:    buf[0] = 'c';
      188:  518:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  519:        perror("Writing to thread notify pipe");
        -:  520:    }
        -:  521:}
------------------
        -:  522:
        -:  523:/*
        -:  524: * Re-dispatches a connection back to the original thread. Can be called from
        -:  525: * any side thread borrowing a connection.
        -:  526: */
        3:  527:void redispatch_conn(conn *c) {
        3:  528:    CQ_ITEM *item = cqi_new();
        3:  529:    char buf[1];
        3:  530:    if (item == NULL) {
        -:  531:        /* Can't cleanly redispatch connection. close it forcefully. */
    #####:  532:        c->state = conn_closed;
    #####:  533:        close(c->sfd);
    #####:  534:        return;
        -:  535:    }
        3:  536:    LIBEVENT_THREAD *thread = c->thread;
        3:  537:    item->sfd = c->sfd;
        3:  538:    item->init_state = conn_new_cmd;
        3:  539:    item->c = c;
        3:  540:    item->mode = queue_redispatch;
        -:  541:
        3:  542:    cq_push(thread->new_conn_queue, item);
        -:  543:
        3:  544:    buf[0] = 'c';
        3:  545:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  546:        perror("Writing to thread notify pipe");
        -:  547:    }
        -:  548:}
------------------
redispatch_conn:
        1:  527:void redispatch_conn(conn *c) {
        1:  528:    CQ_ITEM *item = cqi_new();
        1:  529:    char buf[1];
        1:  530:    if (item == NULL) {
        -:  531:        /* Can't cleanly redispatch connection. close it forcefully. */
    #####:  532:        c->state = conn_closed;
    #####:  533:        close(c->sfd);
    #####:  534:        return;
        -:  535:    }
        1:  536:    LIBEVENT_THREAD *thread = c->thread;
        1:  537:    item->sfd = c->sfd;
        1:  538:    item->init_state = conn_new_cmd;
        1:  539:    item->c = c;
        1:  540:    item->mode = queue_redispatch;
        -:  541:
        1:  542:    cq_push(thread->new_conn_queue, item);
        -:  543:
        1:  544:    buf[0] = 'c';
        1:  545:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  546:        perror("Writing to thread notify pipe");
        -:  547:    }
        -:  548:}
------------------
redispatch_conn:
        1:  527:void redispatch_conn(conn *c) {
        1:  528:    CQ_ITEM *item = cqi_new();
        1:  529:    char buf[1];
        1:  530:    if (item == NULL) {
        -:  531:        /* Can't cleanly redispatch connection. close it forcefully. */
    #####:  532:        c->state = conn_closed;
    #####:  533:        close(c->sfd);
    #####:  534:        return;
        -:  535:    }
        1:  536:    LIBEVENT_THREAD *thread = c->thread;
        1:  537:    item->sfd = c->sfd;
        1:  538:    item->init_state = conn_new_cmd;
        1:  539:    item->c = c;
        1:  540:    item->mode = queue_redispatch;
        -:  541:
        1:  542:    cq_push(thread->new_conn_queue, item);
        -:  543:
        1:  544:    buf[0] = 'c';
        1:  545:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  546:        perror("Writing to thread notify pipe");
        -:  547:    }
        -:  548:}
------------------
redispatch_conn:
        1:  527:void redispatch_conn(conn *c) {
        1:  528:    CQ_ITEM *item = cqi_new();
        1:  529:    char buf[1];
        1:  530:    if (item == NULL) {
        -:  531:        /* Can't cleanly redispatch connection. close it forcefully. */
    #####:  532:        c->state = conn_closed;
    #####:  533:        close(c->sfd);
    #####:  534:        return;
        -:  535:    }
        1:  536:    LIBEVENT_THREAD *thread = c->thread;
        1:  537:    item->sfd = c->sfd;
        1:  538:    item->init_state = conn_new_cmd;
        1:  539:    item->c = c;
        1:  540:    item->mode = queue_redispatch;
        -:  541:
        1:  542:    cq_push(thread->new_conn_queue, item);
        -:  543:
        1:  544:    buf[0] = 'c';
        1:  545:    if (write(thread->notify_send_fd, buf, 1) != 1) {
    #####:  546:        perror("Writing to thread notify pipe");
        -:  547:    }
        -:  548:}
------------------
        -:  549:
        -:  550:/* This misses the allow_new_conns flag :( */
        6:  551:void sidethread_conn_close(conn *c) {
        6:  552:    c->state = conn_closed;
        6:  553:    if (settings.verbose > 1)
    #####:  554:        fprintf(stderr, "<%d connection closed from side thread.\n", c->sfd);
        -:  555:#ifdef TLS
        -:  556:    if (c->ssl) {
        -:  557:        c->ssl_wbuf = NULL;
        -:  558:        SSL_shutdown(c->ssl);
        -:  559:        SSL_free(c->ssl);
        -:  560:    }
        -:  561:#endif
        6:  562:    close(c->sfd);
        -:  563:
        6:  564:    STATS_LOCK();
        6:  565:    stats_state.curr_conns--;
        6:  566:    STATS_UNLOCK();
        -:  567:
        6:  568:    return;
        -:  569:}
------------------
sidethread_conn_close:
        2:  551:void sidethread_conn_close(conn *c) {
        2:  552:    c->state = conn_closed;
        2:  553:    if (settings.verbose > 1)
    #####:  554:        fprintf(stderr, "<%d connection closed from side thread.\n", c->sfd);
        -:  555:#ifdef TLS
        -:  556:    if (c->ssl) {
        -:  557:        c->ssl_wbuf = NULL;
        -:  558:        SSL_shutdown(c->ssl);
        -:  559:        SSL_free(c->ssl);
        -:  560:    }
        -:  561:#endif
        2:  562:    close(c->sfd);
        -:  563:
        2:  564:    STATS_LOCK();
        2:  565:    stats_state.curr_conns--;
        2:  566:    STATS_UNLOCK();
        -:  567:
        2:  568:    return;
        -:  569:}
------------------
sidethread_conn_close:
        2:  551:void sidethread_conn_close(conn *c) {
        2:  552:    c->state = conn_closed;
        2:  553:    if (settings.verbose > 1)
    #####:  554:        fprintf(stderr, "<%d connection closed from side thread.\n", c->sfd);
        -:  555:#ifdef TLS
        -:  556:    if (c->ssl) {
        -:  557:        c->ssl_wbuf = NULL;
        -:  558:        SSL_shutdown(c->ssl);
        -:  559:        SSL_free(c->ssl);
        -:  560:    }
        -:  561:#endif
        2:  562:    close(c->sfd);
        -:  563:
        2:  564:    STATS_LOCK();
        2:  565:    stats_state.curr_conns--;
        2:  566:    STATS_UNLOCK();
        -:  567:
        2:  568:    return;
        -:  569:}
------------------
sidethread_conn_close:
        2:  551:void sidethread_conn_close(conn *c) {
        2:  552:    c->state = conn_closed;
        2:  553:    if (settings.verbose > 1)
    #####:  554:        fprintf(stderr, "<%d connection closed from side thread.\n", c->sfd);
        -:  555:#ifdef TLS
        -:  556:    if (c->ssl) {
        -:  557:        c->ssl_wbuf = NULL;
        -:  558:        SSL_shutdown(c->ssl);
        -:  559:        SSL_free(c->ssl);
        -:  560:    }
        -:  561:#endif
        2:  562:    close(c->sfd);
        -:  563:
        2:  564:    STATS_LOCK();
        2:  565:    stats_state.curr_conns--;
        2:  566:    STATS_UNLOCK();
        -:  567:
        2:  568:    return;
        -:  569:}
------------------
        -:  570:
        -:  571:/********************************* ITEM ACCESS *******************************/
        -:  572:
        -:  573:/*
        -:  574: * Allocates a new item.
        -:  575: */
   308745:  576:item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
   308745:  577:    item *it;
        -:  578:    /* do_item_alloc handles its own locks */
   308745:  579:    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
   308745:  580:    return it;
        -:  581:}
------------------
item_alloc:
   102915:  576:item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
   102915:  577:    item *it;
        -:  578:    /* do_item_alloc handles its own locks */
   102915:  579:    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
   102915:  580:    return it;
        -:  581:}
------------------
item_alloc:
   102915:  576:item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
   102915:  577:    item *it;
        -:  578:    /* do_item_alloc handles its own locks */
   102915:  579:    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
   102915:  580:    return it;
        -:  581:}
------------------
item_alloc:
   102915:  576:item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
   102915:  577:    item *it;
        -:  578:    /* do_item_alloc handles its own locks */
   102915:  579:    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
   102915:  580:    return it;
        -:  581:}
------------------
        -:  582:
        -:  583:/*
        -:  584: * Returns an item if it hasn't been marked as expired,
        -:  585: * lazy-expiring as needed.
        -:  586: */
   341568:  587:item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {
   341568:  588:    item *it;
   341568:  589:    uint32_t hv;
   341568:  590:    hv = hash(key, nkey);
   341568:  591:    item_lock(hv);
   341568:  592:    it = do_item_get(key, nkey, hv, c, do_update);
   341568:  593:    item_unlock(hv);
   341568:  594:    return it;
        -:  595:}
------------------
item_get:
   113856:  587:item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {
   113856:  588:    item *it;
   113856:  589:    uint32_t hv;
   113856:  590:    hv = hash(key, nkey);
   113856:  591:    item_lock(hv);
   113856:  592:    it = do_item_get(key, nkey, hv, c, do_update);
   113856:  593:    item_unlock(hv);
   113856:  594:    return it;
        -:  595:}
------------------
item_get:
   113856:  587:item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {
   113856:  588:    item *it;
   113856:  589:    uint32_t hv;
   113856:  590:    hv = hash(key, nkey);
   113856:  591:    item_lock(hv);
   113856:  592:    it = do_item_get(key, nkey, hv, c, do_update);
   113856:  593:    item_unlock(hv);
   113856:  594:    return it;
        -:  595:}
------------------
item_get:
   113856:  587:item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {
   113856:  588:    item *it;
   113856:  589:    uint32_t hv;
   113856:  590:    hv = hash(key, nkey);
   113856:  591:    item_lock(hv);
   113856:  592:    it = do_item_get(key, nkey, hv, c, do_update);
   113856:  593:    item_unlock(hv);
   113856:  594:    return it;
        -:  595:}
------------------
        -:  596:
        -:  597:// returns an item with the item lock held.
        -:  598:// lock will still be held even if return is NULL, allowing caller to replace
        -:  599:// an item atomically if desired.
     8115:  600:item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv) {
     8115:  601:    item *it;
     8115:  602:    *hv = hash(key, nkey);
     8115:  603:    item_lock(*hv);
     8115:  604:    it = do_item_get(key, nkey, *hv, c, do_update);
     8115:  605:    return it;
        -:  606:}
------------------
item_get_locked:
     2705:  600:item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv) {
     2705:  601:    item *it;
     2705:  602:    *hv = hash(key, nkey);
     2705:  603:    item_lock(*hv);
     2705:  604:    it = do_item_get(key, nkey, *hv, c, do_update);
     2705:  605:    return it;
        -:  606:}
------------------
item_get_locked:
     2705:  600:item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv) {
     2705:  601:    item *it;
     2705:  602:    *hv = hash(key, nkey);
     2705:  603:    item_lock(*hv);
     2705:  604:    it = do_item_get(key, nkey, *hv, c, do_update);
     2705:  605:    return it;
        -:  606:}
------------------
item_get_locked:
     2705:  600:item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv) {
     2705:  601:    item *it;
     2705:  602:    *hv = hash(key, nkey);
     2705:  603:    item_lock(*hv);
     2705:  604:    it = do_item_get(key, nkey, *hv, c, do_update);
     2705:  605:    return it;
        -:  606:}
------------------
        -:  607:
      345:  608:item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
      345:  609:    item *it;
      345:  610:    uint32_t hv;
      345:  611:    hv = hash(key, nkey);
      345:  612:    item_lock(hv);
      345:  613:    it = do_item_touch(key, nkey, exptime, hv, c);
      345:  614:    item_unlock(hv);
      345:  615:    return it;
        -:  616:}
------------------
item_touch:
      115:  608:item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
      115:  609:    item *it;
      115:  610:    uint32_t hv;
      115:  611:    hv = hash(key, nkey);
      115:  612:    item_lock(hv);
      115:  613:    it = do_item_touch(key, nkey, exptime, hv, c);
      115:  614:    item_unlock(hv);
      115:  615:    return it;
        -:  616:}
------------------
item_touch:
      115:  608:item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
      115:  609:    item *it;
      115:  610:    uint32_t hv;
      115:  611:    hv = hash(key, nkey);
      115:  612:    item_lock(hv);
      115:  613:    it = do_item_touch(key, nkey, exptime, hv, c);
      115:  614:    item_unlock(hv);
      115:  615:    return it;
        -:  616:}
------------------
item_touch:
      115:  608:item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
      115:  609:    item *it;
      115:  610:    uint32_t hv;
      115:  611:    hv = hash(key, nkey);
      115:  612:    item_lock(hv);
      115:  613:    it = do_item_touch(key, nkey, exptime, hv, c);
      115:  614:    item_unlock(hv);
      115:  615:    return it;
        -:  616:}
------------------
        -:  617:
        -:  618:/*
        -:  619: * Links an item into the LRU and hashtable.
        -:  620: */
    #####:  621:int item_link(item *item) {
    #####:  622:    int ret;
    #####:  623:    uint32_t hv;
        -:  624:
    #####:  625:    hv = hash(ITEM_key(item), item->nkey);
    #####:  626:    item_lock(hv);
    #####:  627:    ret = do_item_link(item, hv);
    #####:  628:    item_unlock(hv);
    #####:  629:    return ret;
        -:  630:}
------------------
item_link:
    #####:  621:int item_link(item *item) {
    #####:  622:    int ret;
    #####:  623:    uint32_t hv;
        -:  624:
    #####:  625:    hv = hash(ITEM_key(item), item->nkey);
    #####:  626:    item_lock(hv);
    #####:  627:    ret = do_item_link(item, hv);
    #####:  628:    item_unlock(hv);
    #####:  629:    return ret;
        -:  630:}
------------------
item_link:
    #####:  621:int item_link(item *item) {
    #####:  622:    int ret;
    #####:  623:    uint32_t hv;
        -:  624:
    #####:  625:    hv = hash(ITEM_key(item), item->nkey);
    #####:  626:    item_lock(hv);
    #####:  627:    ret = do_item_link(item, hv);
    #####:  628:    item_unlock(hv);
    #####:  629:    return ret;
        -:  630:}
------------------
item_link:
    #####:  621:int item_link(item *item) {
    #####:  622:    int ret;
    #####:  623:    uint32_t hv;
        -:  624:
    #####:  625:    hv = hash(ITEM_key(item), item->nkey);
    #####:  626:    item_lock(hv);
    #####:  627:    ret = do_item_link(item, hv);
    #####:  628:    item_unlock(hv);
    #####:  629:    return ret;
        -:  630:}
------------------
        -:  631:
        -:  632:/*
        -:  633: * Decrements the reference count on an item and adds it to the freelist if
        -:  634: * needed.
        -:  635: */
   405360:  636:void item_remove(item *item) {
   405360:  637:    uint32_t hv;
   405360:  638:    hv = hash(ITEM_key(item), item->nkey);
        -:  639:
   405360:  640:    item_lock(hv);
   405360:  641:    do_item_remove(item);
   405360:  642:    item_unlock(hv);
   405360:  643:}
------------------
item_remove:
   135120:  636:void item_remove(item *item) {
   135120:  637:    uint32_t hv;
   135120:  638:    hv = hash(ITEM_key(item), item->nkey);
        -:  639:
   135120:  640:    item_lock(hv);
   135120:  641:    do_item_remove(item);
   135120:  642:    item_unlock(hv);
   135120:  643:}
------------------
item_remove:
   135120:  636:void item_remove(item *item) {
   135120:  637:    uint32_t hv;
   135120:  638:    hv = hash(ITEM_key(item), item->nkey);
        -:  639:
   135120:  640:    item_lock(hv);
   135120:  641:    do_item_remove(item);
   135120:  642:    item_unlock(hv);
   135120:  643:}
------------------
item_remove:
   135120:  636:void item_remove(item *item) {
   135120:  637:    uint32_t hv;
   135120:  638:    hv = hash(ITEM_key(item), item->nkey);
        -:  639:
   135120:  640:    item_lock(hv);
   135120:  641:    do_item_remove(item);
   135120:  642:    item_unlock(hv);
   135120:  643:}
------------------
        -:  644:
        -:  645:/*
        -:  646: * Replaces one item with another in the hashtable.
        -:  647: * Unprotected by a mutex lock since the core server does not require
        -:  648: * it to be thread-safe.
        -:  649: */
   107955:  650:int item_replace(item *old_it, item *new_it, const uint32_t hv) {
   107955:  651:    return do_item_replace(old_it, new_it, hv);
        -:  652:}
------------------
item_replace:
    35985:  650:int item_replace(item *old_it, item *new_it, const uint32_t hv) {
    35985:  651:    return do_item_replace(old_it, new_it, hv);
        -:  652:}
------------------
item_replace:
    35985:  650:int item_replace(item *old_it, item *new_it, const uint32_t hv) {
    35985:  651:    return do_item_replace(old_it, new_it, hv);
        -:  652:}
------------------
item_replace:
    35985:  650:int item_replace(item *old_it, item *new_it, const uint32_t hv) {
    35985:  651:    return do_item_replace(old_it, new_it, hv);
        -:  652:}
------------------
        -:  653:
        -:  654:/*
        -:  655: * Unlinks an item from the LRU and hashtable.
        -:  656: */
        9:  657:void item_unlink(item *item) {
        9:  658:    uint32_t hv;
        9:  659:    hv = hash(ITEM_key(item), item->nkey);
        9:  660:    item_lock(hv);
        9:  661:    do_item_unlink(item, hv);
        9:  662:    item_unlock(hv);
        9:  663:}
------------------
item_unlink:
        3:  657:void item_unlink(item *item) {
        3:  658:    uint32_t hv;
        3:  659:    hv = hash(ITEM_key(item), item->nkey);
        3:  660:    item_lock(hv);
        3:  661:    do_item_unlink(item, hv);
        3:  662:    item_unlock(hv);
        3:  663:}
------------------
item_unlink:
        3:  657:void item_unlink(item *item) {
        3:  658:    uint32_t hv;
        3:  659:    hv = hash(ITEM_key(item), item->nkey);
        3:  660:    item_lock(hv);
        3:  661:    do_item_unlink(item, hv);
        3:  662:    item_unlock(hv);
        3:  663:}
------------------
item_unlink:
        3:  657:void item_unlink(item *item) {
        3:  658:    uint32_t hv;
        3:  659:    hv = hash(ITEM_key(item), item->nkey);
        3:  660:    item_lock(hv);
        3:  661:    do_item_unlink(item, hv);
        3:  662:    item_unlock(hv);
        3:  663:}
------------------
        -:  664:
        -:  665:/*
        -:  666: * Does arithmetic on a numeric item value.
        -:  667: */
     1188:  668:enum delta_result_type add_delta(conn *c, const char *key,
        -:  669:                                 const size_t nkey, bool incr,
        -:  670:                                 const int64_t delta, char *buf,
        -:  671:                                 uint64_t *cas) {
     1188:  672:    enum delta_result_type ret;
     1188:  673:    uint32_t hv;
        -:  674:
     1188:  675:    hv = hash(key, nkey);
     1188:  676:    item_lock(hv);
     1188:  677:    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);
     1188:  678:    item_unlock(hv);
     1188:  679:    return ret;
        -:  680:}
------------------
add_delta:
      396:  668:enum delta_result_type add_delta(conn *c, const char *key,
        -:  669:                                 const size_t nkey, bool incr,
        -:  670:                                 const int64_t delta, char *buf,
        -:  671:                                 uint64_t *cas) {
      396:  672:    enum delta_result_type ret;
      396:  673:    uint32_t hv;
        -:  674:
      396:  675:    hv = hash(key, nkey);
      396:  676:    item_lock(hv);
      396:  677:    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);
      396:  678:    item_unlock(hv);
      396:  679:    return ret;
        -:  680:}
------------------
add_delta:
      396:  668:enum delta_result_type add_delta(conn *c, const char *key,
        -:  669:                                 const size_t nkey, bool incr,
        -:  670:                                 const int64_t delta, char *buf,
        -:  671:                                 uint64_t *cas) {
      396:  672:    enum delta_result_type ret;
      396:  673:    uint32_t hv;
        -:  674:
      396:  675:    hv = hash(key, nkey);
      396:  676:    item_lock(hv);
      396:  677:    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);
      396:  678:    item_unlock(hv);
      396:  679:    return ret;
        -:  680:}
------------------
add_delta:
      396:  668:enum delta_result_type add_delta(conn *c, const char *key,
        -:  669:                                 const size_t nkey, bool incr,
        -:  670:                                 const int64_t delta, char *buf,
        -:  671:                                 uint64_t *cas) {
      396:  672:    enum delta_result_type ret;
      396:  673:    uint32_t hv;
        -:  674:
      396:  675:    hv = hash(key, nkey);
      396:  676:    item_lock(hv);
      396:  677:    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);
      396:  678:    item_unlock(hv);
      396:  679:    return ret;
        -:  680:}
------------------
        -:  681:
        -:  682:/*
        -:  683: * Stores an item in the cache (high level, obeys set/add/replace semantics)
        -:  684: */
   308709:  685:enum store_item_type store_item(item *item, int comm, conn* c) {
   308709:  686:    enum store_item_type ret;
   308709:  687:    uint32_t hv;
        -:  688:
   308709:  689:    hv = hash(ITEM_key(item), item->nkey);
   308709:  690:    item_lock(hv);
   308709:  691:    ret = do_store_item(item, comm, c, hv);
   308709:  692:    item_unlock(hv);
   308709:  693:    return ret;
        -:  694:}
------------------
store_item:
   102903:  685:enum store_item_type store_item(item *item, int comm, conn* c) {
   102903:  686:    enum store_item_type ret;
   102903:  687:    uint32_t hv;
        -:  688:
   102903:  689:    hv = hash(ITEM_key(item), item->nkey);
   102903:  690:    item_lock(hv);
   102903:  691:    ret = do_store_item(item, comm, c, hv);
   102903:  692:    item_unlock(hv);
   102903:  693:    return ret;
        -:  694:}
------------------
store_item:
   102903:  685:enum store_item_type store_item(item *item, int comm, conn* c) {
   102903:  686:    enum store_item_type ret;
   102903:  687:    uint32_t hv;
        -:  688:
   102903:  689:    hv = hash(ITEM_key(item), item->nkey);
   102903:  690:    item_lock(hv);
   102903:  691:    ret = do_store_item(item, comm, c, hv);
   102903:  692:    item_unlock(hv);
   102903:  693:    return ret;
        -:  694:}
------------------
store_item:
   102903:  685:enum store_item_type store_item(item *item, int comm, conn* c) {
   102903:  686:    enum store_item_type ret;
   102903:  687:    uint32_t hv;
        -:  688:
   102903:  689:    hv = hash(ITEM_key(item), item->nkey);
   102903:  690:    item_lock(hv);
   102903:  691:    ret = do_store_item(item, comm, c, hv);
   102903:  692:    item_unlock(hv);
   102903:  693:    return ret;
        -:  694:}
------------------
        -:  695:
        -:  696:/******************************* GLOBAL STATS ******************************/
        -:  697:
   705789:  698:void STATS_LOCK() {
  705795*:  699:    pthread_mutex_lock(&stats_lock);
   705789:  700:}
------------------
STATS_LOCK:
   235263:  698:void STATS_LOCK() {
   235263:  699:    pthread_mutex_lock(&stats_lock);
   235263:  700:}
------------------
STATS_LOCK:
   235263:  698:void STATS_LOCK() {
   235263:  699:    pthread_mutex_lock(&stats_lock);
   235263:  700:}
------------------
STATS_LOCK:
   235263:  698:void STATS_LOCK() {
   235263:  699:    pthread_mutex_lock(&stats_lock);
   235263:  700:}
------------------
        -:  701:
   705789:  702:void STATS_UNLOCK() {
  705795*:  703:    pthread_mutex_unlock(&stats_lock);
   705789:  704:}
------------------
STATS_UNLOCK:
   235263:  702:void STATS_UNLOCK() {
   235263:  703:    pthread_mutex_unlock(&stats_lock);
   235263:  704:}
------------------
STATS_UNLOCK:
   235263:  702:void STATS_UNLOCK() {
   235263:  703:    pthread_mutex_unlock(&stats_lock);
   235263:  704:}
------------------
STATS_UNLOCK:
   235263:  702:void STATS_UNLOCK() {
   235263:  703:    pthread_mutex_unlock(&stats_lock);
   235263:  704:}
------------------
        -:  705:
        9:  706:void threadlocal_stats_reset(void) {
        9:  707:    int ii;
       45:  708:    for (ii = 0; ii < settings.num_threads; ++ii) {
       36:  709:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  710:#define X(name) threads[ii].stats.name = 0;
       36:  711:        THREAD_STATS_FIELDS
        -:  712:#ifdef EXTSTORE
        -:  713:        EXTSTORE_THREAD_STATS_FIELDS
        -:  714:#endif
        -:  715:#undef X
        -:  716:
       36:  717:        memset(&threads[ii].stats.slab_stats, 0,
        -:  718:                sizeof(threads[ii].stats.slab_stats));
       36:  719:        memset(&threads[ii].stats.lru_hits, 0,
        -:  720:                sizeof(uint64_t) * POWER_LARGEST);
        -:  721:
       36:  722:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  723:    }
        9:  724:}
------------------
threadlocal_stats_reset:
        3:  706:void threadlocal_stats_reset(void) {
        3:  707:    int ii;
       15:  708:    for (ii = 0; ii < settings.num_threads; ++ii) {
       12:  709:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  710:#define X(name) threads[ii].stats.name = 0;
       12:  711:        THREAD_STATS_FIELDS
        -:  712:#ifdef EXTSTORE
        -:  713:        EXTSTORE_THREAD_STATS_FIELDS
        -:  714:#endif
        -:  715:#undef X
        -:  716:
       12:  717:        memset(&threads[ii].stats.slab_stats, 0,
        -:  718:                sizeof(threads[ii].stats.slab_stats));
       12:  719:        memset(&threads[ii].stats.lru_hits, 0,
        -:  720:                sizeof(uint64_t) * POWER_LARGEST);
        -:  721:
       12:  722:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  723:    }
        3:  724:}
------------------
threadlocal_stats_reset:
        3:  706:void threadlocal_stats_reset(void) {
        3:  707:    int ii;
       15:  708:    for (ii = 0; ii < settings.num_threads; ++ii) {
       12:  709:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  710:#define X(name) threads[ii].stats.name = 0;
       12:  711:        THREAD_STATS_FIELDS
        -:  712:#ifdef EXTSTORE
        -:  713:        EXTSTORE_THREAD_STATS_FIELDS
        -:  714:#endif
        -:  715:#undef X
        -:  716:
       12:  717:        memset(&threads[ii].stats.slab_stats, 0,
        -:  718:                sizeof(threads[ii].stats.slab_stats));
       12:  719:        memset(&threads[ii].stats.lru_hits, 0,
        -:  720:                sizeof(uint64_t) * POWER_LARGEST);
        -:  721:
       12:  722:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  723:    }
        3:  724:}
------------------
threadlocal_stats_reset:
        3:  706:void threadlocal_stats_reset(void) {
        3:  707:    int ii;
       15:  708:    for (ii = 0; ii < settings.num_threads; ++ii) {
       12:  709:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  710:#define X(name) threads[ii].stats.name = 0;
       12:  711:        THREAD_STATS_FIELDS
        -:  712:#ifdef EXTSTORE
        -:  713:        EXTSTORE_THREAD_STATS_FIELDS
        -:  714:#endif
        -:  715:#undef X
        -:  716:
       12:  717:        memset(&threads[ii].stats.slab_stats, 0,
        -:  718:                sizeof(threads[ii].stats.slab_stats));
       12:  719:        memset(&threads[ii].stats.lru_hits, 0,
        -:  720:                sizeof(uint64_t) * POWER_LARGEST);
        -:  721:
       12:  722:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  723:    }
        3:  724:}
------------------
        -:  725:
     8091:  726:void threadlocal_stats_aggregate(struct thread_stats *stats) {
     8091:  727:    int ii, sid;
        -:  728:
        -:  729:    /* The struct has a mutex, but we can safely set the whole thing
        -:  730:     * to zero since it is unused when aggregating. */
     8091:  731:    memset(stats, 0, sizeof(*stats));
        -:  732:
    40455:  733:    for (ii = 0; ii < settings.num_threads; ++ii) {
    32364:  734:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  735:#define X(name) stats->name += threads[ii].stats.name;
    32364:  736:        THREAD_STATS_FIELDS
        -:  737:#ifdef EXTSTORE
        -:  738:        EXTSTORE_THREAD_STATS_FIELDS
        -:  739:#endif
        -:  740:#undef X
        -:  741:
  2103660:  742:        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  743:#define X(name) stats->slab_stats[sid].name += \
        -:  744:            threads[ii].stats.slab_stats[sid].name;
  2071296:  745:            SLAB_STATS_FIELDS
        -:  746:#undef X
        -:  747:        }
        -:  748:
  8317548:  749:        for (sid = 0; sid < POWER_LARGEST; sid++) {
 16570368:  750:            stats->lru_hits[sid] +=
  8285184:  751:                threads[ii].stats.lru_hits[sid];
 16570368:  752:            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
  8285184:  753:                threads[ii].stats.lru_hits[sid];
        -:  754:        }
        -:  755:
    32364:  756:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  757:    }
     8091:  758:}
------------------
threadlocal_stats_aggregate:
     2697:  726:void threadlocal_stats_aggregate(struct thread_stats *stats) {
     2697:  727:    int ii, sid;
        -:  728:
        -:  729:    /* The struct has a mutex, but we can safely set the whole thing
        -:  730:     * to zero since it is unused when aggregating. */
     2697:  731:    memset(stats, 0, sizeof(*stats));
        -:  732:
    13485:  733:    for (ii = 0; ii < settings.num_threads; ++ii) {
    10788:  734:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  735:#define X(name) stats->name += threads[ii].stats.name;
    10788:  736:        THREAD_STATS_FIELDS
        -:  737:#ifdef EXTSTORE
        -:  738:        EXTSTORE_THREAD_STATS_FIELDS
        -:  739:#endif
        -:  740:#undef X
        -:  741:
   701220:  742:        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  743:#define X(name) stats->slab_stats[sid].name += \
        -:  744:            threads[ii].stats.slab_stats[sid].name;
   690432:  745:            SLAB_STATS_FIELDS
        -:  746:#undef X
        -:  747:        }
        -:  748:
  2772516:  749:        for (sid = 0; sid < POWER_LARGEST; sid++) {
  5523456:  750:            stats->lru_hits[sid] +=
  2761728:  751:                threads[ii].stats.lru_hits[sid];
  5523456:  752:            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
  2761728:  753:                threads[ii].stats.lru_hits[sid];
        -:  754:        }
        -:  755:
    10788:  756:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  757:    }
     2697:  758:}
------------------
threadlocal_stats_aggregate:
     2697:  726:void threadlocal_stats_aggregate(struct thread_stats *stats) {
     2697:  727:    int ii, sid;
        -:  728:
        -:  729:    /* The struct has a mutex, but we can safely set the whole thing
        -:  730:     * to zero since it is unused when aggregating. */
     2697:  731:    memset(stats, 0, sizeof(*stats));
        -:  732:
    13485:  733:    for (ii = 0; ii < settings.num_threads; ++ii) {
    10788:  734:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  735:#define X(name) stats->name += threads[ii].stats.name;
    10788:  736:        THREAD_STATS_FIELDS
        -:  737:#ifdef EXTSTORE
        -:  738:        EXTSTORE_THREAD_STATS_FIELDS
        -:  739:#endif
        -:  740:#undef X
        -:  741:
   701220:  742:        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  743:#define X(name) stats->slab_stats[sid].name += \
        -:  744:            threads[ii].stats.slab_stats[sid].name;
   690432:  745:            SLAB_STATS_FIELDS
        -:  746:#undef X
        -:  747:        }
        -:  748:
  2772516:  749:        for (sid = 0; sid < POWER_LARGEST; sid++) {
  5523456:  750:            stats->lru_hits[sid] +=
  2761728:  751:                threads[ii].stats.lru_hits[sid];
  5523456:  752:            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
  2761728:  753:                threads[ii].stats.lru_hits[sid];
        -:  754:        }
        -:  755:
    10788:  756:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  757:    }
     2697:  758:}
------------------
threadlocal_stats_aggregate:
     2697:  726:void threadlocal_stats_aggregate(struct thread_stats *stats) {
     2697:  727:    int ii, sid;
        -:  728:
        -:  729:    /* The struct has a mutex, but we can safely set the whole thing
        -:  730:     * to zero since it is unused when aggregating. */
     2697:  731:    memset(stats, 0, sizeof(*stats));
        -:  732:
    13485:  733:    for (ii = 0; ii < settings.num_threads; ++ii) {
    10788:  734:        pthread_mutex_lock(&threads[ii].stats.mutex);
        -:  735:#define X(name) stats->name += threads[ii].stats.name;
    10788:  736:        THREAD_STATS_FIELDS
        -:  737:#ifdef EXTSTORE
        -:  738:        EXTSTORE_THREAD_STATS_FIELDS
        -:  739:#endif
        -:  740:#undef X
        -:  741:
   701220:  742:        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  743:#define X(name) stats->slab_stats[sid].name += \
        -:  744:            threads[ii].stats.slab_stats[sid].name;
   690432:  745:            SLAB_STATS_FIELDS
        -:  746:#undef X
        -:  747:        }
        -:  748:
  2772516:  749:        for (sid = 0; sid < POWER_LARGEST; sid++) {
  5523456:  750:            stats->lru_hits[sid] +=
  2761728:  751:                threads[ii].stats.lru_hits[sid];
  5523456:  752:            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
  2761728:  753:                threads[ii].stats.lru_hits[sid];
        -:  754:        }
        -:  755:
    10788:  756:        pthread_mutex_unlock(&threads[ii].stats.mutex);
        -:  757:    }
     2697:  758:}
------------------
        -:  759:
     7980:  760:void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {
     7980:  761:    int sid;
        -:  762:
     7980:  763:    memset(out, 0, sizeof(*out));
        -:  764:
   518700:  765:    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  766:#define X(name) out->name += stats->slab_stats[sid].name;
   510720:  767:        SLAB_STATS_FIELDS
        -:  768:#undef X
        -:  769:    }
     7980:  770:}
------------------
slab_stats_aggregate:
     2660:  760:void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {
     2660:  761:    int sid;
        -:  762:
     2660:  763:    memset(out, 0, sizeof(*out));
        -:  764:
   172900:  765:    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  766:#define X(name) out->name += stats->slab_stats[sid].name;
   170240:  767:        SLAB_STATS_FIELDS
        -:  768:#undef X
        -:  769:    }
     2660:  770:}
------------------
slab_stats_aggregate:
     2660:  760:void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {
     2660:  761:    int sid;
        -:  762:
     2660:  763:    memset(out, 0, sizeof(*out));
        -:  764:
   172900:  765:    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  766:#define X(name) out->name += stats->slab_stats[sid].name;
   170240:  767:        SLAB_STATS_FIELDS
        -:  768:#undef X
        -:  769:    }
     2660:  770:}
------------------
slab_stats_aggregate:
     2660:  760:void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {
     2660:  761:    int sid;
        -:  762:
     2660:  763:    memset(out, 0, sizeof(*out));
        -:  764:
   172900:  765:    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
        -:  766:#define X(name) out->name += stats->slab_stats[sid].name;
   170240:  767:        SLAB_STATS_FIELDS
        -:  768:#undef X
        -:  769:    }
     2660:  770:}
------------------
        -:  771:
        -:  772:/*
        -:  773: * Initializes the thread subsystem, creating various worker threads.
        -:  774: *
        -:  775: * nthreads  Number of worker event handler threads to spawn
        -:  776: */
      288:  777:void memcached_thread_init(int nthreads, void *arg) {
      288:  778:    int         i;
      288:  779:    int         power;
        -:  780:
    74016:  781:    for (i = 0; i < POWER_LARGEST; i++) {
    73728:  782:        pthread_mutex_init(&lru_locks[i], NULL);
        -:  783:    }
      288:  784:    pthread_mutex_init(&worker_hang_lock, NULL);
        -:  785:
      288:  786:    pthread_mutex_init(&init_lock, NULL);
      288:  787:    pthread_cond_init(&init_cond, NULL);
        -:  788:
      288:  789:    pthread_mutex_init(&cqi_freelist_lock, NULL);
      288:  790:    cqi_freelist = NULL;
        -:  791:
        -:  792:    /* Want a wide lock table, but don't waste memory */
      288:  793:    if (nthreads < 3) {
        -:  794:        power = 10;
      288:  795:    } else if (nthreads < 4) {
        -:  796:        power = 11;
      288:  797:    } else if (nthreads < 5) {
        -:  798:        power = 12;
    #####:  799:    } else if (nthreads <= 10) {
        -:  800:        power = 13;
    #####:  801:    } else if (nthreads <= 20) {
        -:  802:        power = 14;
        -:  803:    } else {
        -:  804:        /* 32k buckets. just under the hashpower default. */
    #####:  805:        power = 15;
        -:  806:    }
        -:  807:
      288:  808:    if (power >= hashpower) {
    #####:  809:        fprintf(stderr, "Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n", hashpower, power);
    #####:  810:        fprintf(stderr, "Item lock table grows with `-t N` (worker threadcount)\n");
    #####:  811:        fprintf(stderr, "Hash table grows with `-o hashpower=N` \n");
    #####:  812:        exit(1);
        -:  813:    }
        -:  814:
      288:  815:    item_lock_count = hashsize(power);
      288:  816:    item_lock_hashpower = power;
        -:  817:
      288:  818:    item_locks = calloc(item_lock_count, sizeof(pthread_mutex_t));
      288:  819:    if (! item_locks) {
    #####:  820:        perror("Can't allocate item locks");
    #####:  821:        exit(1);
        -:  822:    }
  1179936:  823:    for (i = 0; i < item_lock_count; i++) {
  1179648:  824:        pthread_mutex_init(&item_locks[i], NULL);
        -:  825:    }
        -:  826:
      288:  827:    threads = calloc(nthreads, sizeof(LIBEVENT_THREAD));
      288:  828:    if (! threads) {
    #####:  829:        perror("Can't allocate thread descriptors");
    #####:  830:        exit(1);
        -:  831:    }
        -:  832:
     1440:  833:    for (i = 0; i < nthreads; i++) {
     1152:  834:        int fds[2];
     1152:  835:        if (pipe(fds)) {
    #####:  836:            perror("Can't create notify pipe");
    #####:  837:            exit(1);
        -:  838:        }
        -:  839:
     1152:  840:        threads[i].notify_receive_fd = fds[0];
     1152:  841:        threads[i].notify_send_fd = fds[1];
        -:  842:#ifdef EXTSTORE
        -:  843:        threads[i].storage = arg;
        -:  844:#endif
     1152:  845:        setup_thread(&threads[i]);
        -:  846:        /* Reserve three fds for the libevent base, and two for the pipe */
     1152:  847:        stats_state.reserved_fds += 5;
        -:  848:    }
        -:  849:
        -:  850:    /* Create threads after we've done all the libevent setup. */
     1440:  851:    for (i = 0; i < nthreads; i++) {
     1152:  852:        create_worker(worker_libevent, &threads[i]);
        -:  853:    }
        -:  854:
        -:  855:    /* Wait for all the threads to set themselves up before returning. */
      288:  856:    pthread_mutex_lock(&init_lock);
      288:  857:    wait_for_thread_registration(nthreads);
      288:  858:    pthread_mutex_unlock(&init_lock);
      288:  859:}
------------------
memcached_thread_init:
       96:  777:void memcached_thread_init(int nthreads, void *arg) {
       96:  778:    int         i;
       96:  779:    int         power;
        -:  780:
    24672:  781:    for (i = 0; i < POWER_LARGEST; i++) {
    24576:  782:        pthread_mutex_init(&lru_locks[i], NULL);
        -:  783:    }
       96:  784:    pthread_mutex_init(&worker_hang_lock, NULL);
        -:  785:
       96:  786:    pthread_mutex_init(&init_lock, NULL);
       96:  787:    pthread_cond_init(&init_cond, NULL);
        -:  788:
       96:  789:    pthread_mutex_init(&cqi_freelist_lock, NULL);
       96:  790:    cqi_freelist = NULL;
        -:  791:
        -:  792:    /* Want a wide lock table, but don't waste memory */
       96:  793:    if (nthreads < 3) {
        -:  794:        power = 10;
       96:  795:    } else if (nthreads < 4) {
        -:  796:        power = 11;
       96:  797:    } else if (nthreads < 5) {
        -:  798:        power = 12;
    #####:  799:    } else if (nthreads <= 10) {
        -:  800:        power = 13;
    #####:  801:    } else if (nthreads <= 20) {
        -:  802:        power = 14;
        -:  803:    } else {
        -:  804:        /* 32k buckets. just under the hashpower default. */
    #####:  805:        power = 15;
        -:  806:    }
        -:  807:
       96:  808:    if (power >= hashpower) {
    #####:  809:        fprintf(stderr, "Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n", hashpower, power);
    #####:  810:        fprintf(stderr, "Item lock table grows with `-t N` (worker threadcount)\n");
    #####:  811:        fprintf(stderr, "Hash table grows with `-o hashpower=N` \n");
    #####:  812:        exit(1);
        -:  813:    }
        -:  814:
       96:  815:    item_lock_count = hashsize(power);
       96:  816:    item_lock_hashpower = power;
        -:  817:
       96:  818:    item_locks = calloc(item_lock_count, sizeof(pthread_mutex_t));
       96:  819:    if (! item_locks) {
    #####:  820:        perror("Can't allocate item locks");
    #####:  821:        exit(1);
        -:  822:    }
   393312:  823:    for (i = 0; i < item_lock_count; i++) {
   393216:  824:        pthread_mutex_init(&item_locks[i], NULL);
        -:  825:    }
        -:  826:
       96:  827:    threads = calloc(nthreads, sizeof(LIBEVENT_THREAD));
       96:  828:    if (! threads) {
    #####:  829:        perror("Can't allocate thread descriptors");
    #####:  830:        exit(1);
        -:  831:    }
        -:  832:
      480:  833:    for (i = 0; i < nthreads; i++) {
      384:  834:        int fds[2];
      384:  835:        if (pipe(fds)) {
    #####:  836:            perror("Can't create notify pipe");
    #####:  837:            exit(1);
        -:  838:        }
        -:  839:
      384:  840:        threads[i].notify_receive_fd = fds[0];
      384:  841:        threads[i].notify_send_fd = fds[1];
        -:  842:#ifdef EXTSTORE
        -:  843:        threads[i].storage = arg;
        -:  844:#endif
      384:  845:        setup_thread(&threads[i]);
        -:  846:        /* Reserve three fds for the libevent base, and two for the pipe */
      384:  847:        stats_state.reserved_fds += 5;
        -:  848:    }
        -:  849:
        -:  850:    /* Create threads after we've done all the libevent setup. */
      480:  851:    for (i = 0; i < nthreads; i++) {
      384:  852:        create_worker(worker_libevent, &threads[i]);
        -:  853:    }
        -:  854:
        -:  855:    /* Wait for all the threads to set themselves up before returning. */
       96:  856:    pthread_mutex_lock(&init_lock);
       96:  857:    wait_for_thread_registration(nthreads);
       96:  858:    pthread_mutex_unlock(&init_lock);
       96:  859:}
------------------
memcached_thread_init:
       96:  777:void memcached_thread_init(int nthreads, void *arg) {
       96:  778:    int         i;
       96:  779:    int         power;
        -:  780:
    24672:  781:    for (i = 0; i < POWER_LARGEST; i++) {
    24576:  782:        pthread_mutex_init(&lru_locks[i], NULL);
        -:  783:    }
       96:  784:    pthread_mutex_init(&worker_hang_lock, NULL);
        -:  785:
       96:  786:    pthread_mutex_init(&init_lock, NULL);
       96:  787:    pthread_cond_init(&init_cond, NULL);
        -:  788:
       96:  789:    pthread_mutex_init(&cqi_freelist_lock, NULL);
       96:  790:    cqi_freelist = NULL;
        -:  791:
        -:  792:    /* Want a wide lock table, but don't waste memory */
       96:  793:    if (nthreads < 3) {
        -:  794:        power = 10;
       96:  795:    } else if (nthreads < 4) {
        -:  796:        power = 11;
       96:  797:    } else if (nthreads < 5) {
        -:  798:        power = 12;
    #####:  799:    } else if (nthreads <= 10) {
        -:  800:        power = 13;
    #####:  801:    } else if (nthreads <= 20) {
        -:  802:        power = 14;
        -:  803:    } else {
        -:  804:        /* 32k buckets. just under the hashpower default. */
    #####:  805:        power = 15;
        -:  806:    }
        -:  807:
       96:  808:    if (power >= hashpower) {
    #####:  809:        fprintf(stderr, "Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n", hashpower, power);
    #####:  810:        fprintf(stderr, "Item lock table grows with `-t N` (worker threadcount)\n");
    #####:  811:        fprintf(stderr, "Hash table grows with `-o hashpower=N` \n");
    #####:  812:        exit(1);
        -:  813:    }
        -:  814:
       96:  815:    item_lock_count = hashsize(power);
       96:  816:    item_lock_hashpower = power;
        -:  817:
       96:  818:    item_locks = calloc(item_lock_count, sizeof(pthread_mutex_t));
       96:  819:    if (! item_locks) {
    #####:  820:        perror("Can't allocate item locks");
    #####:  821:        exit(1);
        -:  822:    }
   393312:  823:    for (i = 0; i < item_lock_count; i++) {
   393216:  824:        pthread_mutex_init(&item_locks[i], NULL);
        -:  825:    }
        -:  826:
       96:  827:    threads = calloc(nthreads, sizeof(LIBEVENT_THREAD));
       96:  828:    if (! threads) {
    #####:  829:        perror("Can't allocate thread descriptors");
    #####:  830:        exit(1);
        -:  831:    }
        -:  832:
      480:  833:    for (i = 0; i < nthreads; i++) {
      384:  834:        int fds[2];
      384:  835:        if (pipe(fds)) {
    #####:  836:            perror("Can't create notify pipe");
    #####:  837:            exit(1);
        -:  838:        }
        -:  839:
      384:  840:        threads[i].notify_receive_fd = fds[0];
      384:  841:        threads[i].notify_send_fd = fds[1];
        -:  842:#ifdef EXTSTORE
        -:  843:        threads[i].storage = arg;
        -:  844:#endif
      384:  845:        setup_thread(&threads[i]);
        -:  846:        /* Reserve three fds for the libevent base, and two for the pipe */
      384:  847:        stats_state.reserved_fds += 5;
        -:  848:    }
        -:  849:
        -:  850:    /* Create threads after we've done all the libevent setup. */
      480:  851:    for (i = 0; i < nthreads; i++) {
      384:  852:        create_worker(worker_libevent, &threads[i]);
        -:  853:    }
        -:  854:
        -:  855:    /* Wait for all the threads to set themselves up before returning. */
       96:  856:    pthread_mutex_lock(&init_lock);
       96:  857:    wait_for_thread_registration(nthreads);
       96:  858:    pthread_mutex_unlock(&init_lock);
       96:  859:}
------------------
memcached_thread_init:
       96:  777:void memcached_thread_init(int nthreads, void *arg) {
       96:  778:    int         i;
       96:  779:    int         power;
        -:  780:
    24672:  781:    for (i = 0; i < POWER_LARGEST; i++) {
    24576:  782:        pthread_mutex_init(&lru_locks[i], NULL);
        -:  783:    }
       96:  784:    pthread_mutex_init(&worker_hang_lock, NULL);
        -:  785:
       96:  786:    pthread_mutex_init(&init_lock, NULL);
       96:  787:    pthread_cond_init(&init_cond, NULL);
        -:  788:
       96:  789:    pthread_mutex_init(&cqi_freelist_lock, NULL);
       96:  790:    cqi_freelist = NULL;
        -:  791:
        -:  792:    /* Want a wide lock table, but don't waste memory */
       96:  793:    if (nthreads < 3) {
        -:  794:        power = 10;
       96:  795:    } else if (nthreads < 4) {
        -:  796:        power = 11;
       96:  797:    } else if (nthreads < 5) {
        -:  798:        power = 12;
    #####:  799:    } else if (nthreads <= 10) {
        -:  800:        power = 13;
    #####:  801:    } else if (nthreads <= 20) {
        -:  802:        power = 14;
        -:  803:    } else {
        -:  804:        /* 32k buckets. just under the hashpower default. */
    #####:  805:        power = 15;
        -:  806:    }
        -:  807:
       96:  808:    if (power >= hashpower) {
    #####:  809:        fprintf(stderr, "Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n", hashpower, power);
    #####:  810:        fprintf(stderr, "Item lock table grows with `-t N` (worker threadcount)\n");
    #####:  811:        fprintf(stderr, "Hash table grows with `-o hashpower=N` \n");
    #####:  812:        exit(1);
        -:  813:    }
        -:  814:
       96:  815:    item_lock_count = hashsize(power);
       96:  816:    item_lock_hashpower = power;
        -:  817:
       96:  818:    item_locks = calloc(item_lock_count, sizeof(pthread_mutex_t));
       96:  819:    if (! item_locks) {
    #####:  820:        perror("Can't allocate item locks");
    #####:  821:        exit(1);
        -:  822:    }
   393312:  823:    for (i = 0; i < item_lock_count; i++) {
   393216:  824:        pthread_mutex_init(&item_locks[i], NULL);
        -:  825:    }
        -:  826:
       96:  827:    threads = calloc(nthreads, sizeof(LIBEVENT_THREAD));
       96:  828:    if (! threads) {
    #####:  829:        perror("Can't allocate thread descriptors");
    #####:  830:        exit(1);
        -:  831:    }
        -:  832:
      480:  833:    for (i = 0; i < nthreads; i++) {
      384:  834:        int fds[2];
      384:  835:        if (pipe(fds)) {
    #####:  836:            perror("Can't create notify pipe");
    #####:  837:            exit(1);
        -:  838:        }
        -:  839:
      384:  840:        threads[i].notify_receive_fd = fds[0];
      384:  841:        threads[i].notify_send_fd = fds[1];
        -:  842:#ifdef EXTSTORE
        -:  843:        threads[i].storage = arg;
        -:  844:#endif
      384:  845:        setup_thread(&threads[i]);
        -:  846:        /* Reserve three fds for the libevent base, and two for the pipe */
      384:  847:        stats_state.reserved_fds += 5;
        -:  848:    }
        -:  849:
        -:  850:    /* Create threads after we've done all the libevent setup. */
      480:  851:    for (i = 0; i < nthreads; i++) {
      384:  852:        create_worker(worker_libevent, &threads[i]);
        -:  853:    }
        -:  854:
        -:  855:    /* Wait for all the threads to set themselves up before returning. */
       96:  856:    pthread_mutex_lock(&init_lock);
       96:  857:    wait_for_thread_registration(nthreads);
       96:  858:    pthread_mutex_unlock(&init_lock);
       96:  859:}
------------------
        -:  860:
