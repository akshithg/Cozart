        -:    0:Source:slab_automove.c
        -:    0:Programs:54
        -:    0:Source is newer than graph
        -:    1:/*  Copyright 2017 Facebook.
        -:    2: *
        -:    3: *  Use and distribution licensed under the BSD license.  See
        -:    4: *  the LICENSE file for full text.
        -:    5: */
        -:    6:
        -:    7:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    8:#include "memcached.h"
        -:    9:#include "slab_automove.h"
        -:   10:#include <stdlib.h>
        -:   11:#include <string.h>
        -:   12:
        -:   13:#define MIN_PAGES_FOR_SOURCE 2
        -:   14:#define MIN_PAGES_FOR_RECLAIM 2.5
        -:   15:
        -:   16:struct window_data {
        -:   17:    uint64_t age;
        -:   18:    uint64_t dirty;
        -:   19:    uint64_t evicted;
        -:   20:};
        -:   21:
        -:   22:typedef struct {
        -:   23:    struct window_data *window_data;
        -:   24:    uint32_t window_size;
        -:   25:    uint32_t window_cur;
        -:   26:    double max_age_ratio;
        -:   27:    item_stats_automove iam_before[MAX_NUMBER_OF_SLAB_CLASSES];
        -:   28:    item_stats_automove iam_after[MAX_NUMBER_OF_SLAB_CLASSES];
        -:   29:    slab_stats_automove sam_before[MAX_NUMBER_OF_SLAB_CLASSES];
        -:   30:    slab_stats_automove sam_after[MAX_NUMBER_OF_SLAB_CLASSES];
        -:   31:} slab_automove;
        -:   32:
      261:   33:void *slab_automove_init(struct settings *settings) {
      261:   34:    uint32_t window_size = settings->slab_automove_window;
      261:   35:    double max_age_ratio = settings->slab_automove_ratio;
      261:   36:    slab_automove *a = calloc(1, sizeof(slab_automove));
      261:   37:    if (a == NULL)
        -:   38:        return NULL;
      261:   39:    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
      261:   40:    a->window_size = window_size;
      261:   41:    a->max_age_ratio = max_age_ratio;
      261:   42:    if (a->window_data == NULL) {
    #####:   43:        free(a);
    #####:   44:        return NULL;
        -:   45:    }
        -:   46:
        -:   47:    // do a dry run to fill the before structs
      261:   48:    fill_item_stats_automove(a->iam_before);
      261:   49:    fill_slab_stats_automove(a->sam_before);
        -:   50:
      261:   51:    return (void *)a;
        -:   52:}
------------------
slab_automove_init:
       87:   33:void *slab_automove_init(struct settings *settings) {
       87:   34:    uint32_t window_size = settings->slab_automove_window;
       87:   35:    double max_age_ratio = settings->slab_automove_ratio;
       87:   36:    slab_automove *a = calloc(1, sizeof(slab_automove));
       87:   37:    if (a == NULL)
        -:   38:        return NULL;
       87:   39:    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
       87:   40:    a->window_size = window_size;
       87:   41:    a->max_age_ratio = max_age_ratio;
       87:   42:    if (a->window_data == NULL) {
    #####:   43:        free(a);
    #####:   44:        return NULL;
        -:   45:    }
        -:   46:
        -:   47:    // do a dry run to fill the before structs
       87:   48:    fill_item_stats_automove(a->iam_before);
       87:   49:    fill_slab_stats_automove(a->sam_before);
        -:   50:
       87:   51:    return (void *)a;
        -:   52:}
------------------
slab_automove_init:
       87:   33:void *slab_automove_init(struct settings *settings) {
       87:   34:    uint32_t window_size = settings->slab_automove_window;
       87:   35:    double max_age_ratio = settings->slab_automove_ratio;
       87:   36:    slab_automove *a = calloc(1, sizeof(slab_automove));
       87:   37:    if (a == NULL)
        -:   38:        return NULL;
       87:   39:    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
       87:   40:    a->window_size = window_size;
       87:   41:    a->max_age_ratio = max_age_ratio;
       87:   42:    if (a->window_data == NULL) {
    #####:   43:        free(a);
    #####:   44:        return NULL;
        -:   45:    }
        -:   46:
        -:   47:    // do a dry run to fill the before structs
       87:   48:    fill_item_stats_automove(a->iam_before);
       87:   49:    fill_slab_stats_automove(a->sam_before);
        -:   50:
       87:   51:    return (void *)a;
        -:   52:}
------------------
slab_automove_init:
       87:   33:void *slab_automove_init(struct settings *settings) {
       87:   34:    uint32_t window_size = settings->slab_automove_window;
       87:   35:    double max_age_ratio = settings->slab_automove_ratio;
       87:   36:    slab_automove *a = calloc(1, sizeof(slab_automove));
       87:   37:    if (a == NULL)
        -:   38:        return NULL;
       87:   39:    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
       87:   40:    a->window_size = window_size;
       87:   41:    a->max_age_ratio = max_age_ratio;
       87:   42:    if (a->window_data == NULL) {
    #####:   43:        free(a);
    #####:   44:        return NULL;
        -:   45:    }
        -:   46:
        -:   47:    // do a dry run to fill the before structs
       87:   48:    fill_item_stats_automove(a->iam_before);
       87:   49:    fill_slab_stats_automove(a->sam_before);
        -:   50:
       87:   51:    return (void *)a;
        -:   52:}
------------------
        -:   53:
    #####:   54:void slab_automove_free(void *arg) {
    #####:   55:    slab_automove *a = (slab_automove *)arg;
    #####:   56:    free(a->window_data);
    #####:   57:    free(a);
    #####:   58:}
------------------
slab_automove_free:
    #####:   54:void slab_automove_free(void *arg) {
    #####:   55:    slab_automove *a = (slab_automove *)arg;
    #####:   56:    free(a->window_data);
    #####:   57:    free(a);
    #####:   58:}
------------------
slab_automove_free:
    #####:   54:void slab_automove_free(void *arg) {
    #####:   55:    slab_automove *a = (slab_automove *)arg;
    #####:   56:    free(a->window_data);
    #####:   57:    free(a);
    #####:   58:}
------------------
slab_automove_free:
    #####:   54:void slab_automove_free(void *arg) {
    #####:   55:    slab_automove *a = (slab_automove *)arg;
    #####:   56:    free(a->window_data);
    #####:   57:    free(a);
    #####:   58:}
------------------
        -:   59:
        -:   60:static void window_sum(struct window_data *wd, struct window_data *w, uint32_t size) {
        -:   61:    int x;
  1034499:   62:    for (x = 0; x < size; x++) {
   993321:   63:        struct window_data *d = &wd[x];
   993321:   64:        w->age += d->age;
   993321:   65:        w->dirty += d->dirty;
   993321:   66:        w->evicted += d->evicted;
        -:   67:    }
        -:   68:}
        -:   69:
        -:   70:// TODO: if oldest is dirty, find next oldest.
        -:   71:// still need to base ratio off of absolute age
      831:   72:void slab_automove_run(void *arg, int *src, int *dst) {
      831:   73:    slab_automove *a = (slab_automove *)arg;
      831:   74:    int n;
      831:   75:    struct window_data w_sum;
      831:   76:    int oldest = -1;
      831:   77:    uint64_t oldest_age = 0;
      831:   78:    int youngest = -1;
      831:   79:    uint64_t youngest_age = ~0;
      831:   80:    bool youngest_evicting = false;
      831:   81:    *src = -1;
      831:   82:    *dst = -1;
        -:   83:
        -:   84:    // fill after structs
      831:   85:    fill_item_stats_automove(a->iam_after);
      831:   86:    fill_slab_stats_automove(a->sam_after);
      828:   87:    a->window_cur++;
        -:   88:
        -:   89:    // iterate slabs
    41733:   90:    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
    41178:   91:        int w_offset = n * a->window_size;
    41178:   92:        struct window_data *wd = &a->window_data[w_offset + (a->window_cur % a->window_size)];
    41178:   93:        memset(wd, 0, sizeof(struct window_data));
        -:   94:        // summarize the window-up-to-now.
    41178:   95:        memset(&w_sum, 0, sizeof(struct window_data));
    41178:   96:        window_sum(&a->window_data[w_offset], &w_sum, a->window_size);
        -:   97:
        -:   98:        // if page delta, or evicted delta, mark window dirty
        -:   99:        // (or outofmemory)
    41178:  100:        if (a->iam_after[n].evicted - a->iam_before[n].evicted > 0 ||
    41148:  101:            a->iam_after[n].outofmemory - a->iam_before[n].outofmemory > 0) {
       30:  102:            wd->evicted = 1;
       30:  103:            wd->dirty = 1;
        -:  104:        }
    41178:  105:        if (a->sam_after[n].total_pages - a->sam_before[n].total_pages > 0) {
      225:  106:            wd->dirty = 1;
        -:  107:        }
        -:  108:
        -:  109:        // set age into window
    41178:  110:        wd->age = a->iam_after[n].age;
        -:  111:
        -:  112:        // grab age as average of window total
    41178:  113:        uint64_t age = w_sum.age / a->window_size;
        -:  114:
        -:  115:        // if > N free chunks and not dirty, make decision.
    41178:  116:        if (a->sam_after[n].free_chunks > a->sam_after[n].chunks_per_page * MIN_PAGES_FOR_RECLAIM) {
      294:  117:            if (w_sum.dirty == 0) {
      273:  118:                *src = n;
      273:  119:                *dst = 0;
      273:  120:                break;
        -:  121:            }
        -:  122:        }
        -:  123:
        -:  124:        // if oldest and have enough pages, is oldest
    40905:  125:        if (age > oldest_age && a->sam_after[n].total_pages > MIN_PAGES_FOR_SOURCE) {
       72:  126:            oldest = n;
       72:  127:            oldest_age = age;
        -:  128:        }
        -:  129:
        -:  130:        // grab evicted count from window
        -:  131:        // if > half the window and youngest, mark as youngest
    40905:  132:        if (age < youngest_age && w_sum.evicted > a->window_size / 2) {
    #####:  133:            youngest = n;
    #####:  134:            youngest_age = age;
    #####:  135:            youngest_evicting = wd->evicted ? true : false;
        -:  136:        }
        -:  137:    }
        -:  138:
      828:  139:    memcpy(a->iam_before, a->iam_after,
        -:  140:            sizeof(item_stats_automove) * MAX_NUMBER_OF_SLAB_CLASSES);
      828:  141:    memcpy(a->sam_before, a->sam_after,
        -:  142:            sizeof(slab_stats_automove) * MAX_NUMBER_OF_SLAB_CLASSES);
        -:  143:    // if we have a youngest and oldest, and oldest is outside the ratio,
        -:  144:    // also, only make decisions if window has filled once.
     828*:  145:    if (youngest != -1 && oldest != -1 && a->window_cur > a->window_size) {
    #####:  146:        if (youngest_age < ((double)oldest_age * a->max_age_ratio) && youngest_evicting) {
    #####:  147:            *src = oldest;
    #####:  148:            *dst = youngest;
        -:  149:        }
        -:  150:    }
      828:  151:    return;
        -:  152:}
