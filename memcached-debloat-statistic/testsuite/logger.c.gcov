        -:    0:Source:logger.c
        -:    0:Programs:72
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:
        -:    3:#include <stdlib.h>
        -:    4:#include <stdio.h>
        -:    5:#include <string.h>
        -:    6:#include <errno.h>
        -:    7:#include <poll.h>
        -:    8:#include <ctype.h>
        -:    9:#include <stdarg.h>
        -:   10:
        -:   11:#if defined(__sun)
        -:   12:#include <atomic.h>
        -:   13:#endif
        -:   14:
        -:   15:#include "memcached.h"
        -:   16:#include "bipbuffer.h"
        -:   17:
        -:   18:#ifdef LOGGER_DEBUG
        -:   19:#define L_DEBUG(...) \
        -:   20:    do { \
        -:   21:        fprintf(stderr, __VA_ARGS__); \
        -:   22:    } while (0)
        -:   23:#else
        -:   24:#define L_DEBUG(...)
        -:   25:#endif
        -:   26:
        -:   27:
        -:   28:/* TODO: put this in a struct and ditch the global vars. */
        -:   29:static logger *logger_stack_head = NULL;
        -:   30:static logger *logger_stack_tail = NULL;
        -:   31:static unsigned int logger_count = 0;
        -:   32:static volatile int do_run_logger_thread = 1;
        -:   33:static pthread_t logger_tid;
        -:   34:pthread_mutex_t logger_stack_lock = PTHREAD_MUTEX_INITIALIZER;
        -:   35:
        -:   36:pthread_key_t logger_key;
        -:   37:
        -:   38:#if !defined(HAVE_GCC_64ATOMICS) && !defined(__sun)
        -:   39:pthread_mutex_t logger_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;
        -:   40:#endif
        -:   41:
        -:   42:#define WATCHER_LIMIT 20
        -:   43:logger_watcher *watchers[20];
        -:   44:struct pollfd watchers_pollfds[20];
        -:   45:int watcher_count = 0;
        -:   46:
        -:   47:/* Should this go somewhere else? */
        -:   48:static const entry_details default_entries[] = {
        -:   49:    [LOGGER_ASCII_CMD] = {LOGGER_TEXT_ENTRY, 512, LOG_RAWCMDS, "<%d %s"},
        -:   50:    [LOGGER_EVICTION] = {LOGGER_EVICTION_ENTRY, 512, LOG_EVICTIONS, NULL},
        -:   51:    [LOGGER_ITEM_GET] = {LOGGER_ITEM_GET_ENTRY, 512, LOG_FETCHERS, NULL},
        -:   52:    [LOGGER_ITEM_STORE] = {LOGGER_ITEM_STORE_ENTRY, 512, LOG_MUTATIONS, NULL},
        -:   53:    [LOGGER_CRAWLER_STATUS] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   54:        "type=lru_crawler crawler=%d lru=%s low_mark=%llu next_reclaims=%llu since_run=%u next_run=%d elapsed=%u examined=%llu reclaimed=%llu"
        -:   55:    },
        -:   56:    [LOGGER_SLAB_MOVE] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   57:        "type=slab_move src=%d dst=%d"
        -:   58:    },
        -:   59:#ifdef EXTSTORE
        -:   60:    [LOGGER_EXTSTORE_WRITE] = {LOGGER_EXT_WRITE_ENTRY, 512, LOG_EVICTIONS, NULL},
        -:   61:    [LOGGER_COMPACT_START] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   62:        "type=compact_start id=%lu version=%llu"
        -:   63:    },
        -:   64:    [LOGGER_COMPACT_ABORT] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   65:        "type=compact_abort id=%lu"
        -:   66:    },
        -:   67:    [LOGGER_COMPACT_READ_START] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   68:        "type=compact_read_start id=%lu offset=%llu"
        -:   69:    },
        -:   70:    [LOGGER_COMPACT_READ_END] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   71:        "type=compact_read_end id=%lu offset=%llu rescues=%lu lost=%lu skipped=%lu"
        -:   72:    },
        -:   73:    [LOGGER_COMPACT_END] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   74:        "type=compact_end id=%lu"
        -:   75:    },
        -:   76:    [LOGGER_COMPACT_FRAGINFO] = {LOGGER_TEXT_ENTRY, 512, LOG_SYSEVENTS,
        -:   77:        "type=compact_fraginfo ratio=%.2f bytes=%lu"
        -:   78:    },
        -:   79:#endif
        -:   80:};
        -:   81:
        -:   82:#define WATCHER_ALL -1
        -:   83:static int logger_thread_poll_watchers(int force_poll, int watcher);
        -:   84:
        -:   85:/*************************
        -:   86: * Util functions shared between bg thread and workers
        -:   87: *************************/
        -:   88:
        -:   89:/* Logger GID's can be used by watchers to put logs back into strict order
        -:   90: */
        -:   91:static uint64_t logger_get_gid(void) {
   292380:   92:    static uint64_t logger_gid = 0;
        -:   93:#ifdef HAVE_GCC_64ATOMICS
   292380:   94:    return __sync_add_and_fetch(&logger_gid, 1);
        -:   95:#elif defined(__sun)
        -:   96:    return atomic_inc_64_nv(&logger_gid);
        -:   97:#else
        -:   98:    mutex_lock(&logger_atomics_mutex);
        -:   99:    uint64_t res = ++logger_gid;
        -:  100:    mutex_unlock(&logger_atomics_mutex);
        -:  101:    return res;
        -:  102:#endif
        -:  103:}
        -:  104:
        -:  105:/* TODO: genericize lists. would be nice to import queue.h if the impact is
        -:  106: * studied... otherwise can just write a local one.
        -:  107: */
        -:  108:/* Add to the list of threads with a logger object */
     1888:  109:static void logger_link_q(logger *l) {
     1888:  110:    pthread_mutex_lock(&logger_stack_lock);
    1888*:  111:    assert(l != logger_stack_head);
        -:  112:
     1888:  113:    l->prev = 0;
     1888:  114:    l->next = logger_stack_head;
     1888:  115:    if (l->next) l->next->prev = l;
     1888:  116:    logger_stack_head = l;
     1888:  117:    if (logger_stack_tail == 0) logger_stack_tail = l;
     1888:  118:    logger_count++;
     1888:  119:    pthread_mutex_unlock(&logger_stack_lock);
     1888:  120:    return;
        -:  121:}
------------------
logger_link_q:
      472:  109:static void logger_link_q(logger *l) {
      472:  110:    pthread_mutex_lock(&logger_stack_lock);
     472*:  111:    assert(l != logger_stack_head);
        -:  112:
      472:  113:    l->prev = 0;
      472:  114:    l->next = logger_stack_head;
      472:  115:    if (l->next) l->next->prev = l;
      472:  116:    logger_stack_head = l;
      472:  117:    if (logger_stack_tail == 0) logger_stack_tail = l;
      472:  118:    logger_count++;
      472:  119:    pthread_mutex_unlock(&logger_stack_lock);
      472:  120:    return;
        -:  121:}
------------------
logger_link_q:
      472:  109:static void logger_link_q(logger *l) {
      472:  110:    pthread_mutex_lock(&logger_stack_lock);
     472*:  111:    assert(l != logger_stack_head);
        -:  112:
      472:  113:    l->prev = 0;
      472:  114:    l->next = logger_stack_head;
      472:  115:    if (l->next) l->next->prev = l;
      472:  116:    logger_stack_head = l;
      472:  117:    if (logger_stack_tail == 0) logger_stack_tail = l;
      472:  118:    logger_count++;
      472:  119:    pthread_mutex_unlock(&logger_stack_lock);
      472:  120:    return;
        -:  121:}
------------------
logger_link_q:
      472:  109:static void logger_link_q(logger *l) {
      472:  110:    pthread_mutex_lock(&logger_stack_lock);
     472*:  111:    assert(l != logger_stack_head);
        -:  112:
      472:  113:    l->prev = 0;
      472:  114:    l->next = logger_stack_head;
      472:  115:    if (l->next) l->next->prev = l;
      472:  116:    logger_stack_head = l;
      472:  117:    if (logger_stack_tail == 0) logger_stack_tail = l;
      472:  118:    logger_count++;
      472:  119:    pthread_mutex_unlock(&logger_stack_lock);
      472:  120:    return;
        -:  121:}
------------------
logger_link_q:
      472:  109:static void logger_link_q(logger *l) {
      472:  110:    pthread_mutex_lock(&logger_stack_lock);
     472*:  111:    assert(l != logger_stack_head);
        -:  112:
      472:  113:    l->prev = 0;
      472:  114:    l->next = logger_stack_head;
      472:  115:    if (l->next) l->next->prev = l;
      472:  116:    logger_stack_head = l;
      472:  117:    if (logger_stack_tail == 0) logger_stack_tail = l;
      472:  118:    logger_count++;
      472:  119:    pthread_mutex_unlock(&logger_stack_lock);
      472:  120:    return;
        -:  121:}
------------------
        -:  122:
        -:  123:/* Remove from the list of threads with a logger object */
        -:  124:/*static void logger_unlink_q(logger *l) {
        -:  125:    pthread_mutex_lock(&logger_stack_lock);
        -:  126:    if (logger_stack_head == l) {
        -:  127:        assert(l->prev == 0);
        -:  128:        logger_stack_head = l->next;
        -:  129:    }
        -:  130:    if (logger_stack_tail == l) {
        -:  131:        assert(l->next == 0);
        -:  132:        logger_stack_tail = l->prev;
        -:  133:    }
        -:  134:    assert(l->next != l);
        -:  135:    assert(l->prev != l);
        -:  136:
        -:  137:    if (l->next) l->next->prev = l->prev;
        -:  138:    if (l->prev) l->prev->next = l->next;
        -:  139:    logger_count--;
        -:  140:    pthread_mutex_unlock(&logger_stack_lock);
        -:  141:    return;
        -:  142:}*/
        -:  143:
        -:  144:/* Called with logger stack locked.
        -:  145: * Iterates over every watcher collecting enabled flags.
        -:  146: */
       24:  147:static void logger_set_flags(void) {
       24:  148:    logger *l = NULL;
       24:  149:    int x = 0;
       24:  150:    uint16_t f = 0; /* logger eflags */
        -:  151:
      504:  152:    for (x = 0; x < WATCHER_LIMIT; x++) {
      480:  153:        logger_watcher *w = watchers[x];
      480:  154:        if (w == NULL)
        -:  155:            continue;
        -:  156:
       28:  157:        f |= w->eflags;
        -:  158:    }
      144:  159:    for (l = logger_stack_head; l != NULL; l=l->next) {
      120:  160:        pthread_mutex_lock(&l->mutex);
      120:  161:        l->eflags = f;
      120:  162:        pthread_mutex_unlock(&l->mutex);
        -:  163:    }
       24:  164:    return;
        -:  165:}
------------------
logger_set_flags:
        6:  147:static void logger_set_flags(void) {
        6:  148:    logger *l = NULL;
        6:  149:    int x = 0;
        6:  150:    uint16_t f = 0; /* logger eflags */
        -:  151:
      126:  152:    for (x = 0; x < WATCHER_LIMIT; x++) {
      120:  153:        logger_watcher *w = watchers[x];
      120:  154:        if (w == NULL)
        -:  155:            continue;
        -:  156:
        7:  157:        f |= w->eflags;
        -:  158:    }
       36:  159:    for (l = logger_stack_head; l != NULL; l=l->next) {
       30:  160:        pthread_mutex_lock(&l->mutex);
       30:  161:        l->eflags = f;
       30:  162:        pthread_mutex_unlock(&l->mutex);
        -:  163:    }
        6:  164:    return;
        -:  165:}
------------------
logger_set_flags:
        6:  147:static void logger_set_flags(void) {
        6:  148:    logger *l = NULL;
        6:  149:    int x = 0;
        6:  150:    uint16_t f = 0; /* logger eflags */
        -:  151:
      126:  152:    for (x = 0; x < WATCHER_LIMIT; x++) {
      120:  153:        logger_watcher *w = watchers[x];
      120:  154:        if (w == NULL)
        -:  155:            continue;
        -:  156:
        7:  157:        f |= w->eflags;
        -:  158:    }
       36:  159:    for (l = logger_stack_head; l != NULL; l=l->next) {
       30:  160:        pthread_mutex_lock(&l->mutex);
       30:  161:        l->eflags = f;
       30:  162:        pthread_mutex_unlock(&l->mutex);
        -:  163:    }
        6:  164:    return;
        -:  165:}
------------------
logger_set_flags:
        6:  147:static void logger_set_flags(void) {
        6:  148:    logger *l = NULL;
        6:  149:    int x = 0;
        6:  150:    uint16_t f = 0; /* logger eflags */
        -:  151:
      126:  152:    for (x = 0; x < WATCHER_LIMIT; x++) {
      120:  153:        logger_watcher *w = watchers[x];
      120:  154:        if (w == NULL)
        -:  155:            continue;
        -:  156:
        7:  157:        f |= w->eflags;
        -:  158:    }
       36:  159:    for (l = logger_stack_head; l != NULL; l=l->next) {
       30:  160:        pthread_mutex_lock(&l->mutex);
       30:  161:        l->eflags = f;
       30:  162:        pthread_mutex_unlock(&l->mutex);
        -:  163:    }
        6:  164:    return;
        -:  165:}
------------------
logger_set_flags:
        6:  147:static void logger_set_flags(void) {
        6:  148:    logger *l = NULL;
        6:  149:    int x = 0;
        6:  150:    uint16_t f = 0; /* logger eflags */
        -:  151:
      126:  152:    for (x = 0; x < WATCHER_LIMIT; x++) {
      120:  153:        logger_watcher *w = watchers[x];
      120:  154:        if (w == NULL)
        -:  155:            continue;
        -:  156:
        7:  157:        f |= w->eflags;
        -:  158:    }
       36:  159:    for (l = logger_stack_head; l != NULL; l=l->next) {
       30:  160:        pthread_mutex_lock(&l->mutex);
       30:  161:        l->eflags = f;
       30:  162:        pthread_mutex_unlock(&l->mutex);
        -:  163:    }
        6:  164:    return;
        -:  165:}
------------------
        -:  166:
        -:  167:/*************************
        -:  168: * Logger background thread functions. Aggregates per-worker buffers and
        -:  169: * writes to any watchers.
        -:  170: *************************/
        -:  171:
        -:  172:#define LOGGER_PARSE_SCRATCH 4096
        -:  173:
      340:  174:static int _logger_thread_parse_ise(logentry *e, char *scratch) {
      340:  175:    int total;
      340:  176:    const char *cmd = "na";
      340:  177:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
      340:  178:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
      340:  179:    const char * const status_map[] = {
        -:  180:        "not_stored", "stored", "exists", "not_found", "too_large", "no_memory" };
      340:  181:    const char * const cmd_map[] = {
        -:  182:        "null", "add", "set", "replace", "append", "prepend", "cas" };
        -:  183:
      340:  184:    if (le->cmd <= 5)
      340:  185:        cmd = cmd_map[le->cmd];
        -:  186:
      340:  187:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
     2040:  188:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  189:            "ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u\n",
      680:  190:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
      680:  191:            keybuf, status_map[le->status], cmd, le->ttl, le->clsid);
      340:  192:    return total;
        -:  193:}
------------------
_logger_thread_parse_ise:
       85:  174:static int _logger_thread_parse_ise(logentry *e, char *scratch) {
       85:  175:    int total;
       85:  176:    const char *cmd = "na";
       85:  177:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       85:  178:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
       85:  179:    const char * const status_map[] = {
        -:  180:        "not_stored", "stored", "exists", "not_found", "too_large", "no_memory" };
       85:  181:    const char * const cmd_map[] = {
        -:  182:        "null", "add", "set", "replace", "append", "prepend", "cas" };
        -:  183:
       85:  184:    if (le->cmd <= 5)
       85:  185:        cmd = cmd_map[le->cmd];
        -:  186:
       85:  187:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      510:  188:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  189:            "ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u\n",
      170:  190:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
      170:  191:            keybuf, status_map[le->status], cmd, le->ttl, le->clsid);
       85:  192:    return total;
        -:  193:}
------------------
_logger_thread_parse_ise:
       85:  174:static int _logger_thread_parse_ise(logentry *e, char *scratch) {
       85:  175:    int total;
       85:  176:    const char *cmd = "na";
       85:  177:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       85:  178:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
       85:  179:    const char * const status_map[] = {
        -:  180:        "not_stored", "stored", "exists", "not_found", "too_large", "no_memory" };
       85:  181:    const char * const cmd_map[] = {
        -:  182:        "null", "add", "set", "replace", "append", "prepend", "cas" };
        -:  183:
       85:  184:    if (le->cmd <= 5)
       85:  185:        cmd = cmd_map[le->cmd];
        -:  186:
       85:  187:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      510:  188:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  189:            "ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u\n",
      170:  190:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
      170:  191:            keybuf, status_map[le->status], cmd, le->ttl, le->clsid);
       85:  192:    return total;
        -:  193:}
------------------
_logger_thread_parse_ise:
       85:  174:static int _logger_thread_parse_ise(logentry *e, char *scratch) {
       85:  175:    int total;
       85:  176:    const char *cmd = "na";
       85:  177:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       85:  178:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
       85:  179:    const char * const status_map[] = {
        -:  180:        "not_stored", "stored", "exists", "not_found", "too_large", "no_memory" };
       85:  181:    const char * const cmd_map[] = {
        -:  182:        "null", "add", "set", "replace", "append", "prepend", "cas" };
        -:  183:
       85:  184:    if (le->cmd <= 5)
       85:  185:        cmd = cmd_map[le->cmd];
        -:  186:
       85:  187:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      510:  188:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  189:            "ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u\n",
      170:  190:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
      170:  191:            keybuf, status_map[le->status], cmd, le->ttl, le->clsid);
       85:  192:    return total;
        -:  193:}
------------------
_logger_thread_parse_ise:
       85:  174:static int _logger_thread_parse_ise(logentry *e, char *scratch) {
       85:  175:    int total;
       85:  176:    const char *cmd = "na";
       85:  177:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
       85:  178:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
       85:  179:    const char * const status_map[] = {
        -:  180:        "not_stored", "stored", "exists", "not_found", "too_large", "no_memory" };
       85:  181:    const char * const cmd_map[] = {
        -:  182:        "null", "add", "set", "replace", "append", "prepend", "cas" };
        -:  183:
       85:  184:    if (le->cmd <= 5)
       85:  185:        cmd = cmd_map[le->cmd];
        -:  186:
       85:  187:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
      510:  188:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  189:            "ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u\n",
      170:  190:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
      170:  191:            keybuf, status_map[le->status], cmd, le->ttl, le->clsid);
       85:  192:    return total;
        -:  193:}
------------------
        -:  194:
   290444:  195:static int _logger_thread_parse_ige(logentry *e, char *scratch) {
   290444:  196:    int total;
   290444:  197:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
   290444:  198:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
   290444:  199:    const char * const was_found_map[] = {
        -:  200:        "not_found", "found", "flushed", "expired" };
        -:  201:
   290444:  202:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
  1742664:  203:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  204:            "ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u\n",
   580888:  205:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
   580888:  206:            keybuf, was_found_map[le->was_found], le->clsid);
   290444:  207:    return total;
        -:  208:}
------------------
_logger_thread_parse_ige:
    72611:  195:static int _logger_thread_parse_ige(logentry *e, char *scratch) {
    72611:  196:    int total;
    72611:  197:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    72611:  198:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    72611:  199:    const char * const was_found_map[] = {
        -:  200:        "not_found", "found", "flushed", "expired" };
        -:  201:
    72611:  202:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
   435666:  203:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  204:            "ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u\n",
   145222:  205:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
   145222:  206:            keybuf, was_found_map[le->was_found], le->clsid);
    72611:  207:    return total;
        -:  208:}
------------------
_logger_thread_parse_ige:
    72611:  195:static int _logger_thread_parse_ige(logentry *e, char *scratch) {
    72611:  196:    int total;
    72611:  197:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    72611:  198:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    72611:  199:    const char * const was_found_map[] = {
        -:  200:        "not_found", "found", "flushed", "expired" };
        -:  201:
    72611:  202:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
   435666:  203:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  204:            "ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u\n",
   145222:  205:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
   145222:  206:            keybuf, was_found_map[le->was_found], le->clsid);
    72611:  207:    return total;
        -:  208:}
------------------
_logger_thread_parse_ige:
    72611:  195:static int _logger_thread_parse_ige(logentry *e, char *scratch) {
    72611:  196:    int total;
    72611:  197:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    72611:  198:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    72611:  199:    const char * const was_found_map[] = {
        -:  200:        "not_found", "found", "flushed", "expired" };
        -:  201:
    72611:  202:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
   435666:  203:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  204:            "ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u\n",
   145222:  205:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
   145222:  206:            keybuf, was_found_map[le->was_found], le->clsid);
    72611:  207:    return total;
        -:  208:}
------------------
_logger_thread_parse_ige:
    72611:  195:static int _logger_thread_parse_ige(logentry *e, char *scratch) {
    72611:  196:    int total;
    72611:  197:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    72611:  198:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    72611:  199:    const char * const was_found_map[] = {
        -:  200:        "not_found", "found", "flushed", "expired" };
        -:  201:
    72611:  202:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
   435666:  203:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  204:            "ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u\n",
   145222:  205:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
   145222:  206:            keybuf, was_found_map[le->was_found], le->clsid);
    72611:  207:    return total;
        -:  208:}
------------------
        -:  209:
        4:  210:static int _logger_thread_parse_ee(logentry *e, char *scratch) {
        4:  211:    int total;
        4:  212:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        4:  213:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
        4:  214:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
       24:  215:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  216:            "ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u\n",
        8:  217:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        4:  218:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
        4:  219:            (long long int)le->exptime, le->latime, le->clsid);
        -:  220:
        4:  221:    return total;
        -:  222:}
------------------
_logger_thread_parse_ee:
        1:  210:static int _logger_thread_parse_ee(logentry *e, char *scratch) {
        1:  211:    int total;
        1:  212:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        1:  213:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
        1:  214:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        6:  215:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  216:            "ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u\n",
        2:  217:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        1:  218:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
        1:  219:            (long long int)le->exptime, le->latime, le->clsid);
        -:  220:
        1:  221:    return total;
        -:  222:}
------------------
_logger_thread_parse_ee:
        1:  210:static int _logger_thread_parse_ee(logentry *e, char *scratch) {
        1:  211:    int total;
        1:  212:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        1:  213:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
        1:  214:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        6:  215:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  216:            "ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u\n",
        2:  217:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        1:  218:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
        1:  219:            (long long int)le->exptime, le->latime, le->clsid);
        -:  220:
        1:  221:    return total;
        -:  222:}
------------------
_logger_thread_parse_ee:
        1:  210:static int _logger_thread_parse_ee(logentry *e, char *scratch) {
        1:  211:    int total;
        1:  212:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        1:  213:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
        1:  214:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        6:  215:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  216:            "ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u\n",
        2:  217:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        1:  218:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
        1:  219:            (long long int)le->exptime, le->latime, le->clsid);
        -:  220:
        1:  221:    return total;
        -:  222:}
------------------
_logger_thread_parse_ee:
        1:  210:static int _logger_thread_parse_ee(logentry *e, char *scratch) {
        1:  211:    int total;
        1:  212:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        1:  213:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
        1:  214:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        6:  215:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  216:            "ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u\n",
        2:  217:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        1:  218:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
        1:  219:            (long long int)le->exptime, le->latime, le->clsid);
        -:  220:
        1:  221:    return total;
        -:  222:}
------------------
        -:  223:#ifdef EXTSTORE
        -:  224:static int _logger_thread_parse_extw(logentry *e, char *scratch) {
        -:  225:    int total;
        -:  226:    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
        -:  227:    struct logentry_ext_write *le = (struct logentry_ext_write *) e->data;
        -:  228:    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
        -:  229:    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
        -:  230:            "ts=%d.%d gid=%llu type=extwrite key=%s fetch=%s ttl=%lld la=%d clsid=%u bucket=%u\n",
        -:  231:            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
        -:  232:            keybuf, (le->it_flags & ITEM_FETCHED) ? "yes" : "no",
        -:  233:            (long long int)le->exptime, le->latime, le->clsid, le->bucket);
        -:  234:
        -:  235:    return total;
        -:  236:}
        -:  237:#endif
        -:  238:/* Completes rendering of log line. */
    #####:  239:static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        -:  240:        char *scratch, int *scratch_len) {
    #####:  241:    int total = 0;
        -:  242:
    #####:  243:    switch (e->event) {
    #####:  244:        case LOGGER_TEXT_ENTRY:
    #####:  245:            total = snprintf(scratch, LOGGER_PARSE_SCRATCH, "ts=%d.%d gid=%llu %s\n",
    #####:  246:                        (int)e->tv.tv_sec, (int)e->tv.tv_usec,
    #####:  247:                        (unsigned long long) e->gid, (char *) e->data);
    #####:  248:            break;
    #####:  249:        case LOGGER_EVICTION_ENTRY:
    #####:  250:            total = _logger_thread_parse_ee(e, scratch);
    #####:  251:            break;
        -:  252:#ifdef EXTSTORE
        -:  253:        case LOGGER_EXT_WRITE_ENTRY:
        -:  254:            total = _logger_thread_parse_extw(e, scratch);
        -:  255:            break;
        -:  256:#endif
    #####:  257:        case LOGGER_ITEM_GET_ENTRY:
    #####:  258:            total = _logger_thread_parse_ige(e, scratch);
    #####:  259:            break;
    #####:  260:        case LOGGER_ITEM_STORE_ENTRY:
    #####:  261:            total = _logger_thread_parse_ise(e, scratch);
    #####:  262:            break;
        -:  263:
        -:  264:    }
        -:  265:
    #####:  266:    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
    #####:  267:        L_DEBUG("LOGGER: Failed to flatten log entry!\n");
    #####:  268:        return LOGGER_PARSE_ENTRY_FAILED;
        -:  269:    } else {
    #####:  270:        *scratch_len = total;
        -:  271:    }
        -:  272:
    #####:  273:    return LOGGER_PARSE_ENTRY_OK;
        -:  274:}
------------------
logger_thread_parse_entry:
    #####:  239:static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        -:  240:        char *scratch, int *scratch_len) {
    #####:  241:    int total = 0;
        -:  242:
    #####:  243:    switch (e->event) {
    #####:  244:        case LOGGER_TEXT_ENTRY:
    #####:  245:            total = snprintf(scratch, LOGGER_PARSE_SCRATCH, "ts=%d.%d gid=%llu %s\n",
    #####:  246:                        (int)e->tv.tv_sec, (int)e->tv.tv_usec,
    #####:  247:                        (unsigned long long) e->gid, (char *) e->data);
    #####:  248:            break;
    #####:  249:        case LOGGER_EVICTION_ENTRY:
    #####:  250:            total = _logger_thread_parse_ee(e, scratch);
    #####:  251:            break;
        -:  252:#ifdef EXTSTORE
        -:  253:        case LOGGER_EXT_WRITE_ENTRY:
        -:  254:            total = _logger_thread_parse_extw(e, scratch);
        -:  255:            break;
        -:  256:#endif
    #####:  257:        case LOGGER_ITEM_GET_ENTRY:
    #####:  258:            total = _logger_thread_parse_ige(e, scratch);
    #####:  259:            break;
    #####:  260:        case LOGGER_ITEM_STORE_ENTRY:
    #####:  261:            total = _logger_thread_parse_ise(e, scratch);
    #####:  262:            break;
        -:  263:
        -:  264:    }
        -:  265:
    #####:  266:    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
    #####:  267:        L_DEBUG("LOGGER: Failed to flatten log entry!\n");
    #####:  268:        return LOGGER_PARSE_ENTRY_FAILED;
        -:  269:    } else {
    #####:  270:        *scratch_len = total;
        -:  271:    }
        -:  272:
    #####:  273:    return LOGGER_PARSE_ENTRY_OK;
        -:  274:}
------------------
logger_thread_parse_entry:
    #####:  239:static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        -:  240:        char *scratch, int *scratch_len) {
    #####:  241:    int total = 0;
        -:  242:
    #####:  243:    switch (e->event) {
    #####:  244:        case LOGGER_TEXT_ENTRY:
    #####:  245:            total = snprintf(scratch, LOGGER_PARSE_SCRATCH, "ts=%d.%d gid=%llu %s\n",
    #####:  246:                        (int)e->tv.tv_sec, (int)e->tv.tv_usec,
    #####:  247:                        (unsigned long long) e->gid, (char *) e->data);
    #####:  248:            break;
    #####:  249:        case LOGGER_EVICTION_ENTRY:
    #####:  250:            total = _logger_thread_parse_ee(e, scratch);
    #####:  251:            break;
        -:  252:#ifdef EXTSTORE
        -:  253:        case LOGGER_EXT_WRITE_ENTRY:
        -:  254:            total = _logger_thread_parse_extw(e, scratch);
        -:  255:            break;
        -:  256:#endif
    #####:  257:        case LOGGER_ITEM_GET_ENTRY:
    #####:  258:            total = _logger_thread_parse_ige(e, scratch);
    #####:  259:            break;
    #####:  260:        case LOGGER_ITEM_STORE_ENTRY:
    #####:  261:            total = _logger_thread_parse_ise(e, scratch);
    #####:  262:            break;
        -:  263:
        -:  264:    }
        -:  265:
    #####:  266:    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
    #####:  267:        L_DEBUG("LOGGER: Failed to flatten log entry!\n");
    #####:  268:        return LOGGER_PARSE_ENTRY_FAILED;
        -:  269:    } else {
    #####:  270:        *scratch_len = total;
        -:  271:    }
        -:  272:
    #####:  273:    return LOGGER_PARSE_ENTRY_OK;
        -:  274:}
------------------
logger_thread_parse_entry:
    #####:  239:static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        -:  240:        char *scratch, int *scratch_len) {
    #####:  241:    int total = 0;
        -:  242:
    #####:  243:    switch (e->event) {
    #####:  244:        case LOGGER_TEXT_ENTRY:
    #####:  245:            total = snprintf(scratch, LOGGER_PARSE_SCRATCH, "ts=%d.%d gid=%llu %s\n",
    #####:  246:                        (int)e->tv.tv_sec, (int)e->tv.tv_usec,
    #####:  247:                        (unsigned long long) e->gid, (char *) e->data);
    #####:  248:            break;
    #####:  249:        case LOGGER_EVICTION_ENTRY:
    #####:  250:            total = _logger_thread_parse_ee(e, scratch);
    #####:  251:            break;
        -:  252:#ifdef EXTSTORE
        -:  253:        case LOGGER_EXT_WRITE_ENTRY:
        -:  254:            total = _logger_thread_parse_extw(e, scratch);
        -:  255:            break;
        -:  256:#endif
    #####:  257:        case LOGGER_ITEM_GET_ENTRY:
    #####:  258:            total = _logger_thread_parse_ige(e, scratch);
    #####:  259:            break;
    #####:  260:        case LOGGER_ITEM_STORE_ENTRY:
    #####:  261:            total = _logger_thread_parse_ise(e, scratch);
    #####:  262:            break;
        -:  263:
        -:  264:    }
        -:  265:
    #####:  266:    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
    #####:  267:        L_DEBUG("LOGGER: Failed to flatten log entry!\n");
    #####:  268:        return LOGGER_PARSE_ENTRY_FAILED;
        -:  269:    } else {
    #####:  270:        *scratch_len = total;
        -:  271:    }
        -:  272:
    #####:  273:    return LOGGER_PARSE_ENTRY_OK;
        -:  274:}
------------------
logger_thread_parse_entry:
    #####:  239:static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        -:  240:        char *scratch, int *scratch_len) {
    #####:  241:    int total = 0;
        -:  242:
    #####:  243:    switch (e->event) {
    #####:  244:        case LOGGER_TEXT_ENTRY:
    #####:  245:            total = snprintf(scratch, LOGGER_PARSE_SCRATCH, "ts=%d.%d gid=%llu %s\n",
    #####:  246:                        (int)e->tv.tv_sec, (int)e->tv.tv_usec,
    #####:  247:                        (unsigned long long) e->gid, (char *) e->data);
    #####:  248:            break;
    #####:  249:        case LOGGER_EVICTION_ENTRY:
    #####:  250:            total = _logger_thread_parse_ee(e, scratch);
    #####:  251:            break;
        -:  252:#ifdef EXTSTORE
        -:  253:        case LOGGER_EXT_WRITE_ENTRY:
        -:  254:            total = _logger_thread_parse_extw(e, scratch);
        -:  255:            break;
        -:  256:#endif
    #####:  257:        case LOGGER_ITEM_GET_ENTRY:
    #####:  258:            total = _logger_thread_parse_ige(e, scratch);
    #####:  259:            break;
    #####:  260:        case LOGGER_ITEM_STORE_ENTRY:
    #####:  261:            total = _logger_thread_parse_ise(e, scratch);
    #####:  262:            break;
        -:  263:
        -:  264:    }
        -:  265:
    #####:  266:    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
    #####:  267:        L_DEBUG("LOGGER: Failed to flatten log entry!\n");
    #####:  268:        return LOGGER_PARSE_ENTRY_FAILED;
        -:  269:    } else {
    #####:  270:        *scratch_len = total;
        -:  271:    }
        -:  272:
    #####:  273:    return LOGGER_PARSE_ENTRY_OK;
        -:  274:}
------------------
        -:  275:
        -:  276:/* Writes flattened entry to available watchers */
    #####:  277:static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        -:  278:        char *scratch, int scratch_len) {
    #####:  279:    int x, total;
        -:  280:    /* Write the line into available watchers with matching flags */
    #####:  281:    for (x = 0; x < WATCHER_LIMIT; x++) {
    #####:  282:        logger_watcher *w = watchers[x];
    #####:  283:        char *skip_scr = NULL;
    #####:  284:        if (w == NULL || (e->eflags & w->eflags) == 0)
    #####:  285:            continue;
        -:  286:
        -:  287:         /* Avoid poll()'ing constantly when buffer is full by resetting a
        -:  288:         * flag periodically.
        -:  289:         */
    #####:  290:        while (!w->failed_flush &&
    #####:  291:                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
    #####:  292:            if (logger_thread_poll_watchers(0, x) <= 0) {
    #####:  293:                L_DEBUG("LOGGER: Watcher had no free space for line of size (%d)\n", scratch_len + 128);
    #####:  294:                w->failed_flush = true;
        -:  295:            }
        -:  296:        }
        -:  297:
    #####:  298:        if (w->failed_flush) {
    #####:  299:            L_DEBUG("LOGGER: Fast skipped for watcher [%d] due to failed_flush\n", w->sfd);
    #####:  300:            w->skipped++;
    #####:  301:            ls->watcher_skipped++;
    #####:  302:            continue;
        -:  303:        }
        -:  304:
    #####:  305:        if (w->skipped > 0) {
    #####:  306:            total = snprintf(skip_scr, 128, "skipped=%llu\n", (unsigned long long) w->skipped);
    #####:  307:            if (total >= 128 || total <= 0) {
    #####:  308:                L_DEBUG("LOGGER: Failed to flatten skipped message into watcher [%d]\n", w->sfd);
    #####:  309:                w->skipped++;
    #####:  310:                ls->watcher_skipped++;
    #####:  311:                continue;
        -:  312:            }
    #####:  313:            bipbuf_push(w->buf, total);
    #####:  314:            w->skipped = 0;
        -:  315:        }
        -:  316:        /* Can't fail because bipbuf_request succeeded. */
    #####:  317:        bipbuf_offer(w->buf, (unsigned char *) scratch, scratch_len);
    #####:  318:        ls->watcher_sent++;
        -:  319:    }
    #####:  320:}
------------------
logger_thread_write_entry:
    #####:  277:static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        -:  278:        char *scratch, int scratch_len) {
    #####:  279:    int x, total;
        -:  280:    /* Write the line into available watchers with matching flags */
    #####:  281:    for (x = 0; x < WATCHER_LIMIT; x++) {
    #####:  282:        logger_watcher *w = watchers[x];
    #####:  283:        char *skip_scr = NULL;
    #####:  284:        if (w == NULL || (e->eflags & w->eflags) == 0)
    #####:  285:            continue;
        -:  286:
        -:  287:         /* Avoid poll()'ing constantly when buffer is full by resetting a
        -:  288:         * flag periodically.
        -:  289:         */
    #####:  290:        while (!w->failed_flush &&
    #####:  291:                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
    #####:  292:            if (logger_thread_poll_watchers(0, x) <= 0) {
    #####:  293:                L_DEBUG("LOGGER: Watcher had no free space for line of size (%d)\n", scratch_len + 128);
    #####:  294:                w->failed_flush = true;
        -:  295:            }
        -:  296:        }
        -:  297:
    #####:  298:        if (w->failed_flush) {
    #####:  299:            L_DEBUG("LOGGER: Fast skipped for watcher [%d] due to failed_flush\n", w->sfd);
    #####:  300:            w->skipped++;
    #####:  301:            ls->watcher_skipped++;
    #####:  302:            continue;
        -:  303:        }
        -:  304:
    #####:  305:        if (w->skipped > 0) {
    #####:  306:            total = snprintf(skip_scr, 128, "skipped=%llu\n", (unsigned long long) w->skipped);
    #####:  307:            if (total >= 128 || total <= 0) {
    #####:  308:                L_DEBUG("LOGGER: Failed to flatten skipped message into watcher [%d]\n", w->sfd);
    #####:  309:                w->skipped++;
    #####:  310:                ls->watcher_skipped++;
    #####:  311:                continue;
        -:  312:            }
    #####:  313:            bipbuf_push(w->buf, total);
    #####:  314:            w->skipped = 0;
        -:  315:        }
        -:  316:        /* Can't fail because bipbuf_request succeeded. */
    #####:  317:        bipbuf_offer(w->buf, (unsigned char *) scratch, scratch_len);
    #####:  318:        ls->watcher_sent++;
        -:  319:    }
    #####:  320:}
------------------
logger_thread_write_entry:
    #####:  277:static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        -:  278:        char *scratch, int scratch_len) {
    #####:  279:    int x, total;
        -:  280:    /* Write the line into available watchers with matching flags */
    #####:  281:    for (x = 0; x < WATCHER_LIMIT; x++) {
    #####:  282:        logger_watcher *w = watchers[x];
    #####:  283:        char *skip_scr = NULL;
    #####:  284:        if (w == NULL || (e->eflags & w->eflags) == 0)
    #####:  285:            continue;
        -:  286:
        -:  287:         /* Avoid poll()'ing constantly when buffer is full by resetting a
        -:  288:         * flag periodically.
        -:  289:         */
    #####:  290:        while (!w->failed_flush &&
    #####:  291:                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
    #####:  292:            if (logger_thread_poll_watchers(0, x) <= 0) {
    #####:  293:                L_DEBUG("LOGGER: Watcher had no free space for line of size (%d)\n", scratch_len + 128);
    #####:  294:                w->failed_flush = true;
        -:  295:            }
        -:  296:        }
        -:  297:
    #####:  298:        if (w->failed_flush) {
    #####:  299:            L_DEBUG("LOGGER: Fast skipped for watcher [%d] due to failed_flush\n", w->sfd);
    #####:  300:            w->skipped++;
    #####:  301:            ls->watcher_skipped++;
    #####:  302:            continue;
        -:  303:        }
        -:  304:
    #####:  305:        if (w->skipped > 0) {
    #####:  306:            total = snprintf(skip_scr, 128, "skipped=%llu\n", (unsigned long long) w->skipped);
    #####:  307:            if (total >= 128 || total <= 0) {
    #####:  308:                L_DEBUG("LOGGER: Failed to flatten skipped message into watcher [%d]\n", w->sfd);
    #####:  309:                w->skipped++;
    #####:  310:                ls->watcher_skipped++;
    #####:  311:                continue;
        -:  312:            }
    #####:  313:            bipbuf_push(w->buf, total);
    #####:  314:            w->skipped = 0;
        -:  315:        }
        -:  316:        /* Can't fail because bipbuf_request succeeded. */
    #####:  317:        bipbuf_offer(w->buf, (unsigned char *) scratch, scratch_len);
    #####:  318:        ls->watcher_sent++;
        -:  319:    }
    #####:  320:}
------------------
logger_thread_write_entry:
    #####:  277:static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        -:  278:        char *scratch, int scratch_len) {
    #####:  279:    int x, total;
        -:  280:    /* Write the line into available watchers with matching flags */
    #####:  281:    for (x = 0; x < WATCHER_LIMIT; x++) {
    #####:  282:        logger_watcher *w = watchers[x];
    #####:  283:        char *skip_scr = NULL;
    #####:  284:        if (w == NULL || (e->eflags & w->eflags) == 0)
    #####:  285:            continue;
        -:  286:
        -:  287:         /* Avoid poll()'ing constantly when buffer is full by resetting a
        -:  288:         * flag periodically.
        -:  289:         */
    #####:  290:        while (!w->failed_flush &&
    #####:  291:                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
    #####:  292:            if (logger_thread_poll_watchers(0, x) <= 0) {
    #####:  293:                L_DEBUG("LOGGER: Watcher had no free space for line of size (%d)\n", scratch_len + 128);
    #####:  294:                w->failed_flush = true;
        -:  295:            }
        -:  296:        }
        -:  297:
    #####:  298:        if (w->failed_flush) {
    #####:  299:            L_DEBUG("LOGGER: Fast skipped for watcher [%d] due to failed_flush\n", w->sfd);
    #####:  300:            w->skipped++;
    #####:  301:            ls->watcher_skipped++;
    #####:  302:            continue;
        -:  303:        }
        -:  304:
    #####:  305:        if (w->skipped > 0) {
    #####:  306:            total = snprintf(skip_scr, 128, "skipped=%llu\n", (unsigned long long) w->skipped);
    #####:  307:            if (total >= 128 || total <= 0) {
    #####:  308:                L_DEBUG("LOGGER: Failed to flatten skipped message into watcher [%d]\n", w->sfd);
    #####:  309:                w->skipped++;
    #####:  310:                ls->watcher_skipped++;
    #####:  311:                continue;
        -:  312:            }
    #####:  313:            bipbuf_push(w->buf, total);
    #####:  314:            w->skipped = 0;
        -:  315:        }
        -:  316:        /* Can't fail because bipbuf_request succeeded. */
    #####:  317:        bipbuf_offer(w->buf, (unsigned char *) scratch, scratch_len);
    #####:  318:        ls->watcher_sent++;
        -:  319:    }
    #####:  320:}
------------------
logger_thread_write_entry:
    #####:  277:static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        -:  278:        char *scratch, int scratch_len) {
    #####:  279:    int x, total;
        -:  280:    /* Write the line into available watchers with matching flags */
    #####:  281:    for (x = 0; x < WATCHER_LIMIT; x++) {
    #####:  282:        logger_watcher *w = watchers[x];
    #####:  283:        char *skip_scr = NULL;
    #####:  284:        if (w == NULL || (e->eflags & w->eflags) == 0)
    #####:  285:            continue;
        -:  286:
        -:  287:         /* Avoid poll()'ing constantly when buffer is full by resetting a
        -:  288:         * flag periodically.
        -:  289:         */
    #####:  290:        while (!w->failed_flush &&
    #####:  291:                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
    #####:  292:            if (logger_thread_poll_watchers(0, x) <= 0) {
    #####:  293:                L_DEBUG("LOGGER: Watcher had no free space for line of size (%d)\n", scratch_len + 128);
    #####:  294:                w->failed_flush = true;
        -:  295:            }
        -:  296:        }
        -:  297:
    #####:  298:        if (w->failed_flush) {
    #####:  299:            L_DEBUG("LOGGER: Fast skipped for watcher [%d] due to failed_flush\n", w->sfd);
    #####:  300:            w->skipped++;
    #####:  301:            ls->watcher_skipped++;
    #####:  302:            continue;
        -:  303:        }
        -:  304:
    #####:  305:        if (w->skipped > 0) {
    #####:  306:            total = snprintf(skip_scr, 128, "skipped=%llu\n", (unsigned long long) w->skipped);
    #####:  307:            if (total >= 128 || total <= 0) {
    #####:  308:                L_DEBUG("LOGGER: Failed to flatten skipped message into watcher [%d]\n", w->sfd);
    #####:  309:                w->skipped++;
    #####:  310:                ls->watcher_skipped++;
    #####:  311:                continue;
        -:  312:            }
    #####:  313:            bipbuf_push(w->buf, total);
    #####:  314:            w->skipped = 0;
        -:  315:        }
        -:  316:        /* Can't fail because bipbuf_request succeeded. */
    #####:  317:        bipbuf_offer(w->buf, (unsigned char *) scratch, scratch_len);
    #####:  318:        ls->watcher_sent++;
        -:  319:    }
    #####:  320:}
------------------
        -:  321:
        -:  322:/* Called with logger stack locked.
        -:  323: * Releases every chunk associated with a watcher and closes the connection.
        -:  324: * We can't presently send a connection back to the worker for further
        -:  325: * processing.
        -:  326: */
        8:  327:static void logger_thread_close_watcher(logger_watcher *w) {
        8:  328:    L_DEBUG("LOGGER: Closing dead watcher\n");
        8:  329:    watchers[w->id] = NULL;
        8:  330:    sidethread_conn_close(w->c);
        8:  331:    watcher_count--;
        8:  332:    bipbuf_free(w->buf);
        8:  333:    free(w);
        8:  334:    logger_set_flags();
        8:  335:}
------------------
logger_thread_close_watcher:
        2:  327:static void logger_thread_close_watcher(logger_watcher *w) {
        2:  328:    L_DEBUG("LOGGER: Closing dead watcher\n");
        2:  329:    watchers[w->id] = NULL;
        2:  330:    sidethread_conn_close(w->c);
        2:  331:    watcher_count--;
        2:  332:    bipbuf_free(w->buf);
        2:  333:    free(w);
        2:  334:    logger_set_flags();
        2:  335:}
------------------
logger_thread_close_watcher:
        2:  327:static void logger_thread_close_watcher(logger_watcher *w) {
        2:  328:    L_DEBUG("LOGGER: Closing dead watcher\n");
        2:  329:    watchers[w->id] = NULL;
        2:  330:    sidethread_conn_close(w->c);
        2:  331:    watcher_count--;
        2:  332:    bipbuf_free(w->buf);
        2:  333:    free(w);
        2:  334:    logger_set_flags();
        2:  335:}
------------------
logger_thread_close_watcher:
        2:  327:static void logger_thread_close_watcher(logger_watcher *w) {
        2:  328:    L_DEBUG("LOGGER: Closing dead watcher\n");
        2:  329:    watchers[w->id] = NULL;
        2:  330:    sidethread_conn_close(w->c);
        2:  331:    watcher_count--;
        2:  332:    bipbuf_free(w->buf);
        2:  333:    free(w);
        2:  334:    logger_set_flags();
        2:  335:}
------------------
logger_thread_close_watcher:
        2:  327:static void logger_thread_close_watcher(logger_watcher *w) {
        2:  328:    L_DEBUG("LOGGER: Closing dead watcher\n");
        2:  329:    watchers[w->id] = NULL;
        2:  330:    sidethread_conn_close(w->c);
        2:  331:    watcher_count--;
        2:  332:    bipbuf_free(w->buf);
        2:  333:    free(w);
        2:  334:    logger_set_flags();
        2:  335:}
------------------
        -:  336:
        -:  337:/* Reads a particular worker thread's available bipbuf bytes. Parses each log
        -:  338: * entry into the watcher buffers.
        -:  339: */
   134688:  340:static int logger_thread_read(logger *l, struct logger_stats *ls) {
   134688:  341:    unsigned int size;
   134688:  342:    unsigned int pos = 0;
   134688:  343:    unsigned char *data;
   134688:  344:    char scratch[LOGGER_PARSE_SCRATCH];
   134688:  345:    logentry *e;
   134688:  346:    pthread_mutex_lock(&l->mutex);
   134688:  347:    data = bipbuf_peek_all(l->buf, &size);
   134688:  348:    pthread_mutex_unlock(&l->mutex);
        -:  349:
   134688:  350:    if (data == NULL) {
        -:  351:        return 0;
        -:  352:    }
        -:  353:    L_DEBUG("LOGGER: Got %d bytes from bipbuffer\n", size);
        -:  354:
        -:  355:    /* parse buffer */
   296896:  356:    while (pos < size && watcher_count > 0) {
   290788:  357:        enum logger_parse_entry_ret ret;
   290788:  358:        int scratch_len = 0;
   290788:  359:        e = (logentry *) (data + pos);
   290788:  360:        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
   290788:  361:        if (ret != LOGGER_PARSE_ENTRY_OK) {
        -:  362:            /* TODO: stats counter */
    #####:  363:            fprintf(stderr, "LOGGER: Failed to parse log entry\n");
        -:  364:        } else {
   290788:  365:            logger_thread_write_entry(e, ls, scratch, scratch_len);
        -:  366:        }
   290788:  367:        pos += sizeof(logentry) + e->size + e->pad;
        -:  368:    }
    6108*:  369:    assert(pos <= size);
        -:  370:
     6108:  371:    pthread_mutex_lock(&l->mutex);
     6108:  372:    data = bipbuf_poll(l->buf, size);
     6108:  373:    ls->worker_written += l->written;
     6108:  374:    ls->worker_dropped += l->dropped;
     6108:  375:    l->written = 0;
     6108:  376:    l->dropped = 0;
     6108:  377:    pthread_mutex_unlock(&l->mutex);
     6108:  378:    if (data == NULL) {
    #####:  379:        fprintf(stderr, "LOGGER: unexpectedly couldn't advance buf pointer\n");
    #####:  380:        assert(0);
        -:  381:    }
     6108:  382:    return size; /* maybe the count of objects iterated? */
        -:  383:}
------------------
logger_thread_read:
    33672:  340:static int logger_thread_read(logger *l, struct logger_stats *ls) {
    33672:  341:    unsigned int size;
    33672:  342:    unsigned int pos = 0;
    33672:  343:    unsigned char *data;
    33672:  344:    char scratch[LOGGER_PARSE_SCRATCH];
    33672:  345:    logentry *e;
    33672:  346:    pthread_mutex_lock(&l->mutex);
    33672:  347:    data = bipbuf_peek_all(l->buf, &size);
    33672:  348:    pthread_mutex_unlock(&l->mutex);
        -:  349:
    33672:  350:    if (data == NULL) {
        -:  351:        return 0;
        -:  352:    }
        -:  353:    L_DEBUG("LOGGER: Got %d bytes from bipbuffer\n", size);
        -:  354:
        -:  355:    /* parse buffer */
    74224:  356:    while (pos < size && watcher_count > 0) {
    72697:  357:        enum logger_parse_entry_ret ret;
    72697:  358:        int scratch_len = 0;
    72697:  359:        e = (logentry *) (data + pos);
    72697:  360:        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
    72697:  361:        if (ret != LOGGER_PARSE_ENTRY_OK) {
        -:  362:            /* TODO: stats counter */
    #####:  363:            fprintf(stderr, "LOGGER: Failed to parse log entry\n");
        -:  364:        } else {
    72697:  365:            logger_thread_write_entry(e, ls, scratch, scratch_len);
        -:  366:        }
    72697:  367:        pos += sizeof(logentry) + e->size + e->pad;
        -:  368:    }
    1527*:  369:    assert(pos <= size);
        -:  370:
     1527:  371:    pthread_mutex_lock(&l->mutex);
     1527:  372:    data = bipbuf_poll(l->buf, size);
     1527:  373:    ls->worker_written += l->written;
     1527:  374:    ls->worker_dropped += l->dropped;
     1527:  375:    l->written = 0;
     1527:  376:    l->dropped = 0;
     1527:  377:    pthread_mutex_unlock(&l->mutex);
     1527:  378:    if (data == NULL) {
    #####:  379:        fprintf(stderr, "LOGGER: unexpectedly couldn't advance buf pointer\n");
    #####:  380:        assert(0);
        -:  381:    }
     1527:  382:    return size; /* maybe the count of objects iterated? */
        -:  383:}
------------------
logger_thread_read:
    33672:  340:static int logger_thread_read(logger *l, struct logger_stats *ls) {
    33672:  341:    unsigned int size;
    33672:  342:    unsigned int pos = 0;
    33672:  343:    unsigned char *data;
    33672:  344:    char scratch[LOGGER_PARSE_SCRATCH];
    33672:  345:    logentry *e;
    33672:  346:    pthread_mutex_lock(&l->mutex);
    33672:  347:    data = bipbuf_peek_all(l->buf, &size);
    33672:  348:    pthread_mutex_unlock(&l->mutex);
        -:  349:
    33672:  350:    if (data == NULL) {
        -:  351:        return 0;
        -:  352:    }
        -:  353:    L_DEBUG("LOGGER: Got %d bytes from bipbuffer\n", size);
        -:  354:
        -:  355:    /* parse buffer */
    74224:  356:    while (pos < size && watcher_count > 0) {
    72697:  357:        enum logger_parse_entry_ret ret;
    72697:  358:        int scratch_len = 0;
    72697:  359:        e = (logentry *) (data + pos);
    72697:  360:        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
    72697:  361:        if (ret != LOGGER_PARSE_ENTRY_OK) {
        -:  362:            /* TODO: stats counter */
    #####:  363:            fprintf(stderr, "LOGGER: Failed to parse log entry\n");
        -:  364:        } else {
    72697:  365:            logger_thread_write_entry(e, ls, scratch, scratch_len);
        -:  366:        }
    72697:  367:        pos += sizeof(logentry) + e->size + e->pad;
        -:  368:    }
    1527*:  369:    assert(pos <= size);
        -:  370:
     1527:  371:    pthread_mutex_lock(&l->mutex);
     1527:  372:    data = bipbuf_poll(l->buf, size);
     1527:  373:    ls->worker_written += l->written;
     1527:  374:    ls->worker_dropped += l->dropped;
     1527:  375:    l->written = 0;
     1527:  376:    l->dropped = 0;
     1527:  377:    pthread_mutex_unlock(&l->mutex);
     1527:  378:    if (data == NULL) {
    #####:  379:        fprintf(stderr, "LOGGER: unexpectedly couldn't advance buf pointer\n");
    #####:  380:        assert(0);
        -:  381:    }
     1527:  382:    return size; /* maybe the count of objects iterated? */
        -:  383:}
------------------
logger_thread_read:
    33672:  340:static int logger_thread_read(logger *l, struct logger_stats *ls) {
    33672:  341:    unsigned int size;
    33672:  342:    unsigned int pos = 0;
    33672:  343:    unsigned char *data;
    33672:  344:    char scratch[LOGGER_PARSE_SCRATCH];
    33672:  345:    logentry *e;
    33672:  346:    pthread_mutex_lock(&l->mutex);
    33672:  347:    data = bipbuf_peek_all(l->buf, &size);
    33672:  348:    pthread_mutex_unlock(&l->mutex);
        -:  349:
    33672:  350:    if (data == NULL) {
        -:  351:        return 0;
        -:  352:    }
        -:  353:    L_DEBUG("LOGGER: Got %d bytes from bipbuffer\n", size);
        -:  354:
        -:  355:    /* parse buffer */
    74224:  356:    while (pos < size && watcher_count > 0) {
    72697:  357:        enum logger_parse_entry_ret ret;
    72697:  358:        int scratch_len = 0;
    72697:  359:        e = (logentry *) (data + pos);
    72697:  360:        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
    72697:  361:        if (ret != LOGGER_PARSE_ENTRY_OK) {
        -:  362:            /* TODO: stats counter */
    #####:  363:            fprintf(stderr, "LOGGER: Failed to parse log entry\n");
        -:  364:        } else {
    72697:  365:            logger_thread_write_entry(e, ls, scratch, scratch_len);
        -:  366:        }
    72697:  367:        pos += sizeof(logentry) + e->size + e->pad;
        -:  368:    }
    1527*:  369:    assert(pos <= size);
        -:  370:
     1527:  371:    pthread_mutex_lock(&l->mutex);
     1527:  372:    data = bipbuf_poll(l->buf, size);
     1527:  373:    ls->worker_written += l->written;
     1527:  374:    ls->worker_dropped += l->dropped;
     1527:  375:    l->written = 0;
     1527:  376:    l->dropped = 0;
     1527:  377:    pthread_mutex_unlock(&l->mutex);
     1527:  378:    if (data == NULL) {
    #####:  379:        fprintf(stderr, "LOGGER: unexpectedly couldn't advance buf pointer\n");
    #####:  380:        assert(0);
        -:  381:    }
     1527:  382:    return size; /* maybe the count of objects iterated? */
        -:  383:}
------------------
logger_thread_read:
    33672:  340:static int logger_thread_read(logger *l, struct logger_stats *ls) {
    33672:  341:    unsigned int size;
    33672:  342:    unsigned int pos = 0;
    33672:  343:    unsigned char *data;
    33672:  344:    char scratch[LOGGER_PARSE_SCRATCH];
    33672:  345:    logentry *e;
    33672:  346:    pthread_mutex_lock(&l->mutex);
    33672:  347:    data = bipbuf_peek_all(l->buf, &size);
    33672:  348:    pthread_mutex_unlock(&l->mutex);
        -:  349:
    33672:  350:    if (data == NULL) {
        -:  351:        return 0;
        -:  352:    }
        -:  353:    L_DEBUG("LOGGER: Got %d bytes from bipbuffer\n", size);
        -:  354:
        -:  355:    /* parse buffer */
    74224:  356:    while (pos < size && watcher_count > 0) {
    72697:  357:        enum logger_parse_entry_ret ret;
    72697:  358:        int scratch_len = 0;
    72697:  359:        e = (logentry *) (data + pos);
    72697:  360:        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
    72697:  361:        if (ret != LOGGER_PARSE_ENTRY_OK) {
        -:  362:            /* TODO: stats counter */
    #####:  363:            fprintf(stderr, "LOGGER: Failed to parse log entry\n");
        -:  364:        } else {
    72697:  365:            logger_thread_write_entry(e, ls, scratch, scratch_len);
        -:  366:        }
    72697:  367:        pos += sizeof(logentry) + e->size + e->pad;
        -:  368:    }
    1527*:  369:    assert(pos <= size);
        -:  370:
     1527:  371:    pthread_mutex_lock(&l->mutex);
     1527:  372:    data = bipbuf_poll(l->buf, size);
     1527:  373:    ls->worker_written += l->written;
     1527:  374:    ls->worker_dropped += l->dropped;
     1527:  375:    l->written = 0;
     1527:  376:    l->dropped = 0;
     1527:  377:    pthread_mutex_unlock(&l->mutex);
     1527:  378:    if (data == NULL) {
    #####:  379:        fprintf(stderr, "LOGGER: unexpectedly couldn't advance buf pointer\n");
    #####:  380:        assert(0);
        -:  381:    }
     1527:  382:    return size; /* maybe the count of objects iterated? */
        -:  383:}
------------------
        -:  384:
        -:  385:/* Since the event loop code isn't reusable without a refactor, and we have a
        -:  386: * limited number of potential watchers, we run our own poll loop.
        -:  387: * This calls poll() unnecessarily during write flushes, should be possible to
        -:  388: * micro-optimize later.
        -:  389: *
        -:  390: * This flushes buffers attached to watchers, iterating through the bytes set
        -:  391: * to each worker. Also checks for readability in case client connection was
        -:  392: * closed.
        -:  393: *
        -:  394: * Allows a specific watcher to be flushed (if buf full)
        -:  395: */
    34008:  396:static int logger_thread_poll_watchers(int force_poll, int watcher) {
    34008:  397:    int x;
    34008:  398:    int nfd = 0;
    34008:  399:    unsigned char *data;
    34008:  400:    unsigned int data_size = 0;
    34008:  401:    int flushed = 0;
        -:  402:
   714168:  403:    for (x = 0; x < WATCHER_LIMIT; x++) {
   680160:  404:        logger_watcher *w = watchers[x];
   680160:  405:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
        -:  406:            continue;
        -:  407:
    18472:  408:        data = bipbuf_peek_all(w->buf, &data_size);
    18472:  409:        if (data != NULL) {
    18468:  410:            watchers_pollfds[nfd].fd = w->sfd;
    18468:  411:            watchers_pollfds[nfd].events = POLLOUT;
    18468:  412:            nfd++;
        4:  413:        } else if (force_poll) {
        4:  414:            watchers_pollfds[nfd].fd = w->sfd;
        4:  415:            watchers_pollfds[nfd].events = POLLIN;
        4:  416:            nfd++;
        -:  417:        }
        -:  418:        /* This gets set after a call to poll, and should be used to gate on
        -:  419:         * calling poll again.
        -:  420:         */
    18472:  421:        w->failed_flush = false;
        -:  422:    }
        -:  423:
    34008:  424:    if (nfd == 0)
        -:  425:        return 0;
        -:  426:
        -:  427:    //L_DEBUG("LOGGER: calling poll() [data_size: %d]\n", data_size);
    18456:  428:    int ret = poll(watchers_pollfds, nfd, 0);
        -:  429:
    18456:  430:    if (ret < 0) {
    #####:  431:        perror("something failed with logger thread watcher fd polling");
    #####:  432:        return -1;
        -:  433:    }
        -:  434:
        -:  435:    nfd = 0;
   387576:  436:    for (x = 0; x < WATCHER_LIMIT; x++) {
   369120:  437:        logger_watcher *w = watchers[x];
   369120:  438:        if (w == NULL)
        -:  439:            continue;
        -:  440:
    18476:  441:        data_size = 0;
        -:  442:        /* Early detection of a disconnect. Otherwise we have to wait until
        -:  443:         * the next write
        -:  444:         */
    18476:  445:        if (watchers_pollfds[nfd].revents & POLLIN) {
    #####:  446:            char buf[1];
    #####:  447:            int res = ((conn*)w->c)->read(w->c, buf, 1);
    #####:  448:            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  449:                L_DEBUG("LOGGER: watcher closed remotely\n");
    #####:  450:                logger_thread_close_watcher(w);
    #####:  451:                nfd++;
    #####:  452:                continue;
        -:  453:            }
        -:  454:        }
    18476:  455:        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
    18472:  456:            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
        4:  457:                L_DEBUG("LOGGER: watcher closed during poll() call\n");
        4:  458:                logger_thread_close_watcher(w);
    18468:  459:            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
       72:  460:                int total = 0;
        -:  461:
        -:  462:                /* We can write a bit. */
       72:  463:                switch (w->t) {
    #####:  464:                    case LOGGER_WATCHER_STDERR:
    #####:  465:                        total = fwrite(data, 1, data_size, stderr);
    #####:  466:                        break;
       72:  467:                    case LOGGER_WATCHER_CLIENT:
       72:  468:                        total = ((conn*)w->c)->write(w->c, data, data_size);
       72:  469:                        break;
        -:  470:                }
        -:  471:
        -:  472:                L_DEBUG("LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n", total, w->sfd,
       72:  473:                        data_size, bipbuf_used(w->buf));
       72:  474:                if (total == -1) {
        4:  475:                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
        4:  476:                        logger_thread_close_watcher(w);
        -:  477:                    }
        -:  478:                    L_DEBUG("LOGGER: watcher hit EAGAIN\n");
       68:  479:                } else if (total == 0) {
    #####:  480:                    logger_thread_close_watcher(w);
        -:  481:                } else {
       68:  482:                    bipbuf_poll(w->buf, total);
       68:  483:                    flushed += total;
        -:  484:                }
        -:  485:            }
        -:  486:        }
    18476:  487:        nfd++;
        -:  488:    }
        -:  489:    return flushed;
        -:  490:}
------------------
logger_thread_poll_watchers:
     8502:  396:static int logger_thread_poll_watchers(int force_poll, int watcher) {
     8502:  397:    int x;
     8502:  398:    int nfd = 0;
     8502:  399:    unsigned char *data;
     8502:  400:    unsigned int data_size = 0;
     8502:  401:    int flushed = 0;
        -:  402:
   178542:  403:    for (x = 0; x < WATCHER_LIMIT; x++) {
   170040:  404:        logger_watcher *w = watchers[x];
   170040:  405:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
        -:  406:            continue;
        -:  407:
     4618:  408:        data = bipbuf_peek_all(w->buf, &data_size);
     4618:  409:        if (data != NULL) {
     4617:  410:            watchers_pollfds[nfd].fd = w->sfd;
     4617:  411:            watchers_pollfds[nfd].events = POLLOUT;
     4617:  412:            nfd++;
        1:  413:        } else if (force_poll) {
        1:  414:            watchers_pollfds[nfd].fd = w->sfd;
        1:  415:            watchers_pollfds[nfd].events = POLLIN;
        1:  416:            nfd++;
        -:  417:        }
        -:  418:        /* This gets set after a call to poll, and should be used to gate on
        -:  419:         * calling poll again.
        -:  420:         */
     4618:  421:        w->failed_flush = false;
        -:  422:    }
        -:  423:
     8502:  424:    if (nfd == 0)
        -:  425:        return 0;
        -:  426:
        -:  427:    //L_DEBUG("LOGGER: calling poll() [data_size: %d]\n", data_size);
     4614:  428:    int ret = poll(watchers_pollfds, nfd, 0);
        -:  429:
     4614:  430:    if (ret < 0) {
    #####:  431:        perror("something failed with logger thread watcher fd polling");
    #####:  432:        return -1;
        -:  433:    }
        -:  434:
        -:  435:    nfd = 0;
    96894:  436:    for (x = 0; x < WATCHER_LIMIT; x++) {
    92280:  437:        logger_watcher *w = watchers[x];
    92280:  438:        if (w == NULL)
        -:  439:            continue;
        -:  440:
     4619:  441:        data_size = 0;
        -:  442:        /* Early detection of a disconnect. Otherwise we have to wait until
        -:  443:         * the next write
        -:  444:         */
     4619:  445:        if (watchers_pollfds[nfd].revents & POLLIN) {
    #####:  446:            char buf[1];
    #####:  447:            int res = ((conn*)w->c)->read(w->c, buf, 1);
    #####:  448:            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  449:                L_DEBUG("LOGGER: watcher closed remotely\n");
    #####:  450:                logger_thread_close_watcher(w);
    #####:  451:                nfd++;
    #####:  452:                continue;
        -:  453:            }
        -:  454:        }
     4619:  455:        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
     4618:  456:            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
        1:  457:                L_DEBUG("LOGGER: watcher closed during poll() call\n");
        1:  458:                logger_thread_close_watcher(w);
     4617:  459:            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
       18:  460:                int total = 0;
        -:  461:
        -:  462:                /* We can write a bit. */
       18:  463:                switch (w->t) {
    #####:  464:                    case LOGGER_WATCHER_STDERR:
    #####:  465:                        total = fwrite(data, 1, data_size, stderr);
    #####:  466:                        break;
       18:  467:                    case LOGGER_WATCHER_CLIENT:
       18:  468:                        total = ((conn*)w->c)->write(w->c, data, data_size);
       18:  469:                        break;
        -:  470:                }
        -:  471:
        -:  472:                L_DEBUG("LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n", total, w->sfd,
       18:  473:                        data_size, bipbuf_used(w->buf));
       18:  474:                if (total == -1) {
        1:  475:                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
        1:  476:                        logger_thread_close_watcher(w);
        -:  477:                    }
        -:  478:                    L_DEBUG("LOGGER: watcher hit EAGAIN\n");
       17:  479:                } else if (total == 0) {
    #####:  480:                    logger_thread_close_watcher(w);
        -:  481:                } else {
       17:  482:                    bipbuf_poll(w->buf, total);
       17:  483:                    flushed += total;
        -:  484:                }
        -:  485:            }
        -:  486:        }
     4619:  487:        nfd++;
        -:  488:    }
        -:  489:    return flushed;
        -:  490:}
------------------
logger_thread_poll_watchers:
     8502:  396:static int logger_thread_poll_watchers(int force_poll, int watcher) {
     8502:  397:    int x;
     8502:  398:    int nfd = 0;
     8502:  399:    unsigned char *data;
     8502:  400:    unsigned int data_size = 0;
     8502:  401:    int flushed = 0;
        -:  402:
   178542:  403:    for (x = 0; x < WATCHER_LIMIT; x++) {
   170040:  404:        logger_watcher *w = watchers[x];
   170040:  405:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
        -:  406:            continue;
        -:  407:
     4618:  408:        data = bipbuf_peek_all(w->buf, &data_size);
     4618:  409:        if (data != NULL) {
     4617:  410:            watchers_pollfds[nfd].fd = w->sfd;
     4617:  411:            watchers_pollfds[nfd].events = POLLOUT;
     4617:  412:            nfd++;
        1:  413:        } else if (force_poll) {
        1:  414:            watchers_pollfds[nfd].fd = w->sfd;
        1:  415:            watchers_pollfds[nfd].events = POLLIN;
        1:  416:            nfd++;
        -:  417:        }
        -:  418:        /* This gets set after a call to poll, and should be used to gate on
        -:  419:         * calling poll again.
        -:  420:         */
     4618:  421:        w->failed_flush = false;
        -:  422:    }
        -:  423:
     8502:  424:    if (nfd == 0)
        -:  425:        return 0;
        -:  426:
        -:  427:    //L_DEBUG("LOGGER: calling poll() [data_size: %d]\n", data_size);
     4614:  428:    int ret = poll(watchers_pollfds, nfd, 0);
        -:  429:
     4614:  430:    if (ret < 0) {
    #####:  431:        perror("something failed with logger thread watcher fd polling");
    #####:  432:        return -1;
        -:  433:    }
        -:  434:
        -:  435:    nfd = 0;
    96894:  436:    for (x = 0; x < WATCHER_LIMIT; x++) {
    92280:  437:        logger_watcher *w = watchers[x];
    92280:  438:        if (w == NULL)
        -:  439:            continue;
        -:  440:
     4619:  441:        data_size = 0;
        -:  442:        /* Early detection of a disconnect. Otherwise we have to wait until
        -:  443:         * the next write
        -:  444:         */
     4619:  445:        if (watchers_pollfds[nfd].revents & POLLIN) {
    #####:  446:            char buf[1];
    #####:  447:            int res = ((conn*)w->c)->read(w->c, buf, 1);
    #####:  448:            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  449:                L_DEBUG("LOGGER: watcher closed remotely\n");
    #####:  450:                logger_thread_close_watcher(w);
    #####:  451:                nfd++;
    #####:  452:                continue;
        -:  453:            }
        -:  454:        }
     4619:  455:        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
     4618:  456:            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
        1:  457:                L_DEBUG("LOGGER: watcher closed during poll() call\n");
        1:  458:                logger_thread_close_watcher(w);
     4617:  459:            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
       18:  460:                int total = 0;
        -:  461:
        -:  462:                /* We can write a bit. */
       18:  463:                switch (w->t) {
    #####:  464:                    case LOGGER_WATCHER_STDERR:
    #####:  465:                        total = fwrite(data, 1, data_size, stderr);
    #####:  466:                        break;
       18:  467:                    case LOGGER_WATCHER_CLIENT:
       18:  468:                        total = ((conn*)w->c)->write(w->c, data, data_size);
       18:  469:                        break;
        -:  470:                }
        -:  471:
        -:  472:                L_DEBUG("LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n", total, w->sfd,
       18:  473:                        data_size, bipbuf_used(w->buf));
       18:  474:                if (total == -1) {
        1:  475:                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
        1:  476:                        logger_thread_close_watcher(w);
        -:  477:                    }
        -:  478:                    L_DEBUG("LOGGER: watcher hit EAGAIN\n");
       17:  479:                } else if (total == 0) {
    #####:  480:                    logger_thread_close_watcher(w);
        -:  481:                } else {
       17:  482:                    bipbuf_poll(w->buf, total);
       17:  483:                    flushed += total;
        -:  484:                }
        -:  485:            }
        -:  486:        }
     4619:  487:        nfd++;
        -:  488:    }
        -:  489:    return flushed;
        -:  490:}
------------------
logger_thread_poll_watchers:
     8502:  396:static int logger_thread_poll_watchers(int force_poll, int watcher) {
     8502:  397:    int x;
     8502:  398:    int nfd = 0;
     8502:  399:    unsigned char *data;
     8502:  400:    unsigned int data_size = 0;
     8502:  401:    int flushed = 0;
        -:  402:
   178542:  403:    for (x = 0; x < WATCHER_LIMIT; x++) {
   170040:  404:        logger_watcher *w = watchers[x];
   170040:  405:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
        -:  406:            continue;
        -:  407:
     4618:  408:        data = bipbuf_peek_all(w->buf, &data_size);
     4618:  409:        if (data != NULL) {
     4617:  410:            watchers_pollfds[nfd].fd = w->sfd;
     4617:  411:            watchers_pollfds[nfd].events = POLLOUT;
     4617:  412:            nfd++;
        1:  413:        } else if (force_poll) {
        1:  414:            watchers_pollfds[nfd].fd = w->sfd;
        1:  415:            watchers_pollfds[nfd].events = POLLIN;
        1:  416:            nfd++;
        -:  417:        }
        -:  418:        /* This gets set after a call to poll, and should be used to gate on
        -:  419:         * calling poll again.
        -:  420:         */
     4618:  421:        w->failed_flush = false;
        -:  422:    }
        -:  423:
     8502:  424:    if (nfd == 0)
        -:  425:        return 0;
        -:  426:
        -:  427:    //L_DEBUG("LOGGER: calling poll() [data_size: %d]\n", data_size);
     4614:  428:    int ret = poll(watchers_pollfds, nfd, 0);
        -:  429:
     4614:  430:    if (ret < 0) {
    #####:  431:        perror("something failed with logger thread watcher fd polling");
    #####:  432:        return -1;
        -:  433:    }
        -:  434:
        -:  435:    nfd = 0;
    96894:  436:    for (x = 0; x < WATCHER_LIMIT; x++) {
    92280:  437:        logger_watcher *w = watchers[x];
    92280:  438:        if (w == NULL)
        -:  439:            continue;
        -:  440:
     4619:  441:        data_size = 0;
        -:  442:        /* Early detection of a disconnect. Otherwise we have to wait until
        -:  443:         * the next write
        -:  444:         */
     4619:  445:        if (watchers_pollfds[nfd].revents & POLLIN) {
    #####:  446:            char buf[1];
    #####:  447:            int res = ((conn*)w->c)->read(w->c, buf, 1);
    #####:  448:            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  449:                L_DEBUG("LOGGER: watcher closed remotely\n");
    #####:  450:                logger_thread_close_watcher(w);
    #####:  451:                nfd++;
    #####:  452:                continue;
        -:  453:            }
        -:  454:        }
     4619:  455:        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
     4618:  456:            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
        1:  457:                L_DEBUG("LOGGER: watcher closed during poll() call\n");
        1:  458:                logger_thread_close_watcher(w);
     4617:  459:            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
       18:  460:                int total = 0;
        -:  461:
        -:  462:                /* We can write a bit. */
       18:  463:                switch (w->t) {
    #####:  464:                    case LOGGER_WATCHER_STDERR:
    #####:  465:                        total = fwrite(data, 1, data_size, stderr);
    #####:  466:                        break;
       18:  467:                    case LOGGER_WATCHER_CLIENT:
       18:  468:                        total = ((conn*)w->c)->write(w->c, data, data_size);
       18:  469:                        break;
        -:  470:                }
        -:  471:
        -:  472:                L_DEBUG("LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n", total, w->sfd,
       18:  473:                        data_size, bipbuf_used(w->buf));
       18:  474:                if (total == -1) {
        1:  475:                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
        1:  476:                        logger_thread_close_watcher(w);
        -:  477:                    }
        -:  478:                    L_DEBUG("LOGGER: watcher hit EAGAIN\n");
       17:  479:                } else if (total == 0) {
    #####:  480:                    logger_thread_close_watcher(w);
        -:  481:                } else {
       17:  482:                    bipbuf_poll(w->buf, total);
       17:  483:                    flushed += total;
        -:  484:                }
        -:  485:            }
        -:  486:        }
     4619:  487:        nfd++;
        -:  488:    }
        -:  489:    return flushed;
        -:  490:}
------------------
logger_thread_poll_watchers:
     8502:  396:static int logger_thread_poll_watchers(int force_poll, int watcher) {
     8502:  397:    int x;
     8502:  398:    int nfd = 0;
     8502:  399:    unsigned char *data;
     8502:  400:    unsigned int data_size = 0;
     8502:  401:    int flushed = 0;
        -:  402:
   178542:  403:    for (x = 0; x < WATCHER_LIMIT; x++) {
   170040:  404:        logger_watcher *w = watchers[x];
   170040:  405:        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
        -:  406:            continue;
        -:  407:
     4618:  408:        data = bipbuf_peek_all(w->buf, &data_size);
     4618:  409:        if (data != NULL) {
     4617:  410:            watchers_pollfds[nfd].fd = w->sfd;
     4617:  411:            watchers_pollfds[nfd].events = POLLOUT;
     4617:  412:            nfd++;
        1:  413:        } else if (force_poll) {
        1:  414:            watchers_pollfds[nfd].fd = w->sfd;
        1:  415:            watchers_pollfds[nfd].events = POLLIN;
        1:  416:            nfd++;
        -:  417:        }
        -:  418:        /* This gets set after a call to poll, and should be used to gate on
        -:  419:         * calling poll again.
        -:  420:         */
     4618:  421:        w->failed_flush = false;
        -:  422:    }
        -:  423:
     8502:  424:    if (nfd == 0)
        -:  425:        return 0;
        -:  426:
        -:  427:    //L_DEBUG("LOGGER: calling poll() [data_size: %d]\n", data_size);
     4614:  428:    int ret = poll(watchers_pollfds, nfd, 0);
        -:  429:
     4614:  430:    if (ret < 0) {
    #####:  431:        perror("something failed with logger thread watcher fd polling");
    #####:  432:        return -1;
        -:  433:    }
        -:  434:
        -:  435:    nfd = 0;
    96894:  436:    for (x = 0; x < WATCHER_LIMIT; x++) {
    92280:  437:        logger_watcher *w = watchers[x];
    92280:  438:        if (w == NULL)
        -:  439:            continue;
        -:  440:
     4619:  441:        data_size = 0;
        -:  442:        /* Early detection of a disconnect. Otherwise we have to wait until
        -:  443:         * the next write
        -:  444:         */
     4619:  445:        if (watchers_pollfds[nfd].revents & POLLIN) {
    #####:  446:            char buf[1];
    #####:  447:            int res = ((conn*)w->c)->read(w->c, buf, 1);
    #####:  448:            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
    #####:  449:                L_DEBUG("LOGGER: watcher closed remotely\n");
    #####:  450:                logger_thread_close_watcher(w);
    #####:  451:                nfd++;
    #####:  452:                continue;
        -:  453:            }
        -:  454:        }
     4619:  455:        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
     4618:  456:            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
        1:  457:                L_DEBUG("LOGGER: watcher closed during poll() call\n");
        1:  458:                logger_thread_close_watcher(w);
     4617:  459:            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
       18:  460:                int total = 0;
        -:  461:
        -:  462:                /* We can write a bit. */
       18:  463:                switch (w->t) {
    #####:  464:                    case LOGGER_WATCHER_STDERR:
    #####:  465:                        total = fwrite(data, 1, data_size, stderr);
    #####:  466:                        break;
       18:  467:                    case LOGGER_WATCHER_CLIENT:
       18:  468:                        total = ((conn*)w->c)->write(w->c, data, data_size);
       18:  469:                        break;
        -:  470:                }
        -:  471:
        -:  472:                L_DEBUG("LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n", total, w->sfd,
       18:  473:                        data_size, bipbuf_used(w->buf));
       18:  474:                if (total == -1) {
        1:  475:                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
        1:  476:                        logger_thread_close_watcher(w);
        -:  477:                    }
        -:  478:                    L_DEBUG("LOGGER: watcher hit EAGAIN\n");
       17:  479:                } else if (total == 0) {
    #####:  480:                    logger_thread_close_watcher(w);
        -:  481:                } else {
       17:  482:                    bipbuf_poll(w->buf, total);
       17:  483:                    flushed += total;
        -:  484:                }
        -:  485:            }
        -:  486:        }
     4619:  487:        nfd++;
        -:  488:    }
        -:  489:    return flushed;
        -:  490:}
------------------
        -:  491:
    27888:  492:static void logger_thread_sum_stats(struct logger_stats *ls) {
    27888:  493:    STATS_LOCK();
    27888:  494:    stats.log_worker_dropped  += ls->worker_dropped;
    27888:  495:    stats.log_worker_written  += ls->worker_written;
    27888:  496:    stats.log_watcher_skipped += ls->watcher_skipped;
    27888:  497:    stats.log_watcher_sent    += ls->watcher_sent;
    27888:  498:    STATS_UNLOCK();
    27888:  499:}
------------------
logger_thread_sum_stats:
     6972:  492:static void logger_thread_sum_stats(struct logger_stats *ls) {
     6972:  493:    STATS_LOCK();
     6972:  494:    stats.log_worker_dropped  += ls->worker_dropped;
     6972:  495:    stats.log_worker_written  += ls->worker_written;
     6972:  496:    stats.log_watcher_skipped += ls->watcher_skipped;
     6972:  497:    stats.log_watcher_sent    += ls->watcher_sent;
     6972:  498:    STATS_UNLOCK();
     6972:  499:}
------------------
logger_thread_sum_stats:
     6972:  492:static void logger_thread_sum_stats(struct logger_stats *ls) {
     6972:  493:    STATS_LOCK();
     6972:  494:    stats.log_worker_dropped  += ls->worker_dropped;
     6972:  495:    stats.log_worker_written  += ls->worker_written;
     6972:  496:    stats.log_watcher_skipped += ls->watcher_skipped;
     6972:  497:    stats.log_watcher_sent    += ls->watcher_sent;
     6972:  498:    STATS_UNLOCK();
     6972:  499:}
------------------
logger_thread_sum_stats:
     6972:  492:static void logger_thread_sum_stats(struct logger_stats *ls) {
     6972:  493:    STATS_LOCK();
     6972:  494:    stats.log_worker_dropped  += ls->worker_dropped;
     6972:  495:    stats.log_worker_written  += ls->worker_written;
     6972:  496:    stats.log_watcher_skipped += ls->watcher_skipped;
     6972:  497:    stats.log_watcher_sent    += ls->watcher_sent;
     6972:  498:    STATS_UNLOCK();
     6972:  499:}
------------------
logger_thread_sum_stats:
     6972:  492:static void logger_thread_sum_stats(struct logger_stats *ls) {
     6972:  493:    STATS_LOCK();
     6972:  494:    stats.log_worker_dropped  += ls->worker_dropped;
     6972:  495:    stats.log_worker_written  += ls->worker_written;
     6972:  496:    stats.log_watcher_skipped += ls->watcher_skipped;
     6972:  497:    stats.log_watcher_sent    += ls->watcher_sent;
     6972:  498:    STATS_UNLOCK();
     6972:  499:}
------------------
        -:  500:
        -:  501:#define MAX_LOGGER_SLEEP 1000000
        -:  502:#define MIN_LOGGER_SLEEP 1000
        -:  503:
        -:  504:/* Primary logger thread routine */
      384:  505:static void *logger_thread(void *arg) {
      384:  506:    useconds_t to_sleep = MIN_LOGGER_SLEEP;
      384:  507:    L_DEBUG("LOGGER: Starting logger thread\n");
    28272:  508:    while (do_run_logger_thread) {
    28272:  509:        int found_logs = 0;
    28272:  510:        logger *l;
    28272:  511:        struct logger_stats ls;
    28272:  512:        memset(&ls, 0, sizeof(struct logger_stats));
        -:  513:
        -:  514:        /* only sleep if we're *above* the minimum */
    28272:  515:        if (to_sleep > MIN_LOGGER_SLEEP)
    21828:  516:            usleep(to_sleep);
        -:  517:
        -:  518:        /* Call function to iterate each logger. */
    27888:  519:        pthread_mutex_lock(&logger_stack_lock);
   162576:  520:        for (l = logger_stack_head; l != NULL; l=l->next) {
        -:  521:            /* lock logger, call function to manipulate it */
   134688:  522:            found_logs += logger_thread_read(l, &ls);
        -:  523:        }
        -:  524:
    27888:  525:        logger_thread_poll_watchers(1, WATCHER_ALL);
    27888:  526:        pthread_mutex_unlock(&logger_stack_lock);
        -:  527:
        -:  528:        /* TODO: abstract into a function and share with lru_crawler */
    27888:  529:        if (!found_logs) {
    21780:  530:            if (to_sleep < MAX_LOGGER_SLEEP)
    21708:  531:                to_sleep += to_sleep / 8;
    21780:  532:            if (to_sleep > MAX_LOGGER_SLEEP)
       16:  533:                to_sleep = MAX_LOGGER_SLEEP;
        -:  534:        } else {
     6108:  535:            to_sleep /= 2;
     6108:  536:            if (to_sleep < MIN_LOGGER_SLEEP)
     6060:  537:                to_sleep = MIN_LOGGER_SLEEP;
        -:  538:        }
    27888:  539:        logger_thread_sum_stats(&ls);
        -:  540:    }
        -:  541:
    #####:  542:    return NULL;
        -:  543:}
------------------
logger_thread:
       96:  505:static void *logger_thread(void *arg) {
       96:  506:    useconds_t to_sleep = MIN_LOGGER_SLEEP;
       96:  507:    L_DEBUG("LOGGER: Starting logger thread\n");
     7068:  508:    while (do_run_logger_thread) {
     7068:  509:        int found_logs = 0;
     7068:  510:        logger *l;
     7068:  511:        struct logger_stats ls;
     7068:  512:        memset(&ls, 0, sizeof(struct logger_stats));
        -:  513:
        -:  514:        /* only sleep if we're *above* the minimum */
     7068:  515:        if (to_sleep > MIN_LOGGER_SLEEP)
     5457:  516:            usleep(to_sleep);
        -:  517:
        -:  518:        /* Call function to iterate each logger. */
     6972:  519:        pthread_mutex_lock(&logger_stack_lock);
    40644:  520:        for (l = logger_stack_head; l != NULL; l=l->next) {
        -:  521:            /* lock logger, call function to manipulate it */
    33672:  522:            found_logs += logger_thread_read(l, &ls);
        -:  523:        }
        -:  524:
     6972:  525:        logger_thread_poll_watchers(1, WATCHER_ALL);
     6972:  526:        pthread_mutex_unlock(&logger_stack_lock);
        -:  527:
        -:  528:        /* TODO: abstract into a function and share with lru_crawler */
     6972:  529:        if (!found_logs) {
     5445:  530:            if (to_sleep < MAX_LOGGER_SLEEP)
     5427:  531:                to_sleep += to_sleep / 8;
     5445:  532:            if (to_sleep > MAX_LOGGER_SLEEP)
        4:  533:                to_sleep = MAX_LOGGER_SLEEP;
        -:  534:        } else {
     1527:  535:            to_sleep /= 2;
     1527:  536:            if (to_sleep < MIN_LOGGER_SLEEP)
     1515:  537:                to_sleep = MIN_LOGGER_SLEEP;
        -:  538:        }
     6972:  539:        logger_thread_sum_stats(&ls);
        -:  540:    }
        -:  541:
    #####:  542:    return NULL;
        -:  543:}
------------------
logger_thread:
       96:  505:static void *logger_thread(void *arg) {
       96:  506:    useconds_t to_sleep = MIN_LOGGER_SLEEP;
       96:  507:    L_DEBUG("LOGGER: Starting logger thread\n");
     7068:  508:    while (do_run_logger_thread) {
     7068:  509:        int found_logs = 0;
     7068:  510:        logger *l;
     7068:  511:        struct logger_stats ls;
     7068:  512:        memset(&ls, 0, sizeof(struct logger_stats));
        -:  513:
        -:  514:        /* only sleep if we're *above* the minimum */
     7068:  515:        if (to_sleep > MIN_LOGGER_SLEEP)
     5457:  516:            usleep(to_sleep);
        -:  517:
        -:  518:        /* Call function to iterate each logger. */
     6972:  519:        pthread_mutex_lock(&logger_stack_lock);
    40644:  520:        for (l = logger_stack_head; l != NULL; l=l->next) {
        -:  521:            /* lock logger, call function to manipulate it */
    33672:  522:            found_logs += logger_thread_read(l, &ls);
        -:  523:        }
        -:  524:
     6972:  525:        logger_thread_poll_watchers(1, WATCHER_ALL);
     6972:  526:        pthread_mutex_unlock(&logger_stack_lock);
        -:  527:
        -:  528:        /* TODO: abstract into a function and share with lru_crawler */
     6972:  529:        if (!found_logs) {
     5445:  530:            if (to_sleep < MAX_LOGGER_SLEEP)
     5427:  531:                to_sleep += to_sleep / 8;
     5445:  532:            if (to_sleep > MAX_LOGGER_SLEEP)
        4:  533:                to_sleep = MAX_LOGGER_SLEEP;
        -:  534:        } else {
     1527:  535:            to_sleep /= 2;
     1527:  536:            if (to_sleep < MIN_LOGGER_SLEEP)
     1515:  537:                to_sleep = MIN_LOGGER_SLEEP;
        -:  538:        }
     6972:  539:        logger_thread_sum_stats(&ls);
        -:  540:    }
        -:  541:
    #####:  542:    return NULL;
        -:  543:}
------------------
logger_thread:
       96:  505:static void *logger_thread(void *arg) {
       96:  506:    useconds_t to_sleep = MIN_LOGGER_SLEEP;
       96:  507:    L_DEBUG("LOGGER: Starting logger thread\n");
     7068:  508:    while (do_run_logger_thread) {
     7068:  509:        int found_logs = 0;
     7068:  510:        logger *l;
     7068:  511:        struct logger_stats ls;
     7068:  512:        memset(&ls, 0, sizeof(struct logger_stats));
        -:  513:
        -:  514:        /* only sleep if we're *above* the minimum */
     7068:  515:        if (to_sleep > MIN_LOGGER_SLEEP)
     5457:  516:            usleep(to_sleep);
        -:  517:
        -:  518:        /* Call function to iterate each logger. */
     6972:  519:        pthread_mutex_lock(&logger_stack_lock);
    40644:  520:        for (l = logger_stack_head; l != NULL; l=l->next) {
        -:  521:            /* lock logger, call function to manipulate it */
    33672:  522:            found_logs += logger_thread_read(l, &ls);
        -:  523:        }
        -:  524:
     6972:  525:        logger_thread_poll_watchers(1, WATCHER_ALL);
     6972:  526:        pthread_mutex_unlock(&logger_stack_lock);
        -:  527:
        -:  528:        /* TODO: abstract into a function and share with lru_crawler */
     6972:  529:        if (!found_logs) {
     5445:  530:            if (to_sleep < MAX_LOGGER_SLEEP)
     5427:  531:                to_sleep += to_sleep / 8;
     5445:  532:            if (to_sleep > MAX_LOGGER_SLEEP)
        4:  533:                to_sleep = MAX_LOGGER_SLEEP;
        -:  534:        } else {
     1527:  535:            to_sleep /= 2;
     1527:  536:            if (to_sleep < MIN_LOGGER_SLEEP)
     1515:  537:                to_sleep = MIN_LOGGER_SLEEP;
        -:  538:        }
     6972:  539:        logger_thread_sum_stats(&ls);
        -:  540:    }
        -:  541:
    #####:  542:    return NULL;
        -:  543:}
------------------
logger_thread:
       96:  505:static void *logger_thread(void *arg) {
       96:  506:    useconds_t to_sleep = MIN_LOGGER_SLEEP;
       96:  507:    L_DEBUG("LOGGER: Starting logger thread\n");
     7068:  508:    while (do_run_logger_thread) {
     7068:  509:        int found_logs = 0;
     7068:  510:        logger *l;
     7068:  511:        struct logger_stats ls;
     7068:  512:        memset(&ls, 0, sizeof(struct logger_stats));
        -:  513:
        -:  514:        /* only sleep if we're *above* the minimum */
     7068:  515:        if (to_sleep > MIN_LOGGER_SLEEP)
     5457:  516:            usleep(to_sleep);
        -:  517:
        -:  518:        /* Call function to iterate each logger. */
     6972:  519:        pthread_mutex_lock(&logger_stack_lock);
    40644:  520:        for (l = logger_stack_head; l != NULL; l=l->next) {
        -:  521:            /* lock logger, call function to manipulate it */
    33672:  522:            found_logs += logger_thread_read(l, &ls);
        -:  523:        }
        -:  524:
     6972:  525:        logger_thread_poll_watchers(1, WATCHER_ALL);
     6972:  526:        pthread_mutex_unlock(&logger_stack_lock);
        -:  527:
        -:  528:        /* TODO: abstract into a function and share with lru_crawler */
     6972:  529:        if (!found_logs) {
     5445:  530:            if (to_sleep < MAX_LOGGER_SLEEP)
     5427:  531:                to_sleep += to_sleep / 8;
     5445:  532:            if (to_sleep > MAX_LOGGER_SLEEP)
        4:  533:                to_sleep = MAX_LOGGER_SLEEP;
        -:  534:        } else {
     1527:  535:            to_sleep /= 2;
     1527:  536:            if (to_sleep < MIN_LOGGER_SLEEP)
     1515:  537:                to_sleep = MIN_LOGGER_SLEEP;
        -:  538:        }
     6972:  539:        logger_thread_sum_stats(&ls);
        -:  540:    }
        -:  541:
    #####:  542:    return NULL;
        -:  543:}
------------------
        -:  544:
      384:  545:static int start_logger_thread(void) {
      384:  546:    int ret;
      384:  547:    do_run_logger_thread = 1;
      384:  548:    if ((ret = pthread_create(&logger_tid, NULL,
        -:  549:                              logger_thread, NULL)) != 0) {
    #####:  550:        fprintf(stderr, "Can't start logger thread: %s\n", strerror(ret));
    #####:  551:        return -1;
        -:  552:    }
        -:  553:    return 0;
        -:  554:}
------------------
start_logger_thread:
       96:  545:static int start_logger_thread(void) {
       96:  546:    int ret;
       96:  547:    do_run_logger_thread = 1;
       96:  548:    if ((ret = pthread_create(&logger_tid, NULL,
        -:  549:                              logger_thread, NULL)) != 0) {
    #####:  550:        fprintf(stderr, "Can't start logger thread: %s\n", strerror(ret));
    #####:  551:        return -1;
        -:  552:    }
        -:  553:    return 0;
        -:  554:}
------------------
start_logger_thread:
       96:  545:static int start_logger_thread(void) {
       96:  546:    int ret;
       96:  547:    do_run_logger_thread = 1;
       96:  548:    if ((ret = pthread_create(&logger_tid, NULL,
        -:  549:                              logger_thread, NULL)) != 0) {
    #####:  550:        fprintf(stderr, "Can't start logger thread: %s\n", strerror(ret));
    #####:  551:        return -1;
        -:  552:    }
        -:  553:    return 0;
        -:  554:}
------------------
start_logger_thread:
       96:  545:static int start_logger_thread(void) {
       96:  546:    int ret;
       96:  547:    do_run_logger_thread = 1;
       96:  548:    if ((ret = pthread_create(&logger_tid, NULL,
        -:  549:                              logger_thread, NULL)) != 0) {
    #####:  550:        fprintf(stderr, "Can't start logger thread: %s\n", strerror(ret));
    #####:  551:        return -1;
        -:  552:    }
        -:  553:    return 0;
        -:  554:}
------------------
start_logger_thread:
       96:  545:static int start_logger_thread(void) {
       96:  546:    int ret;
       96:  547:    do_run_logger_thread = 1;
       96:  548:    if ((ret = pthread_create(&logger_tid, NULL,
        -:  549:                              logger_thread, NULL)) != 0) {
    #####:  550:        fprintf(stderr, "Can't start logger thread: %s\n", strerror(ret));
    #####:  551:        return -1;
        -:  552:    }
        -:  553:    return 0;
        -:  554:}
------------------
        -:  555:
        -:  556:// future.
        -:  557:/*static int stop_logger_thread(void) {
        -:  558:    do_run_logger_thread = 0;
        -:  559:    pthread_join(logger_tid, NULL);
        -:  560:    return 0;
        -:  561:}*/
        -:  562:
        -:  563:/*************************
        -:  564: * Public functions for submitting logs and starting loggers from workers.
        -:  565: *************************/
        -:  566:
        -:  567:/* Global logger thread start/init */
      384:  568:void logger_init(void) {
        -:  569:    /* TODO: auto destructor when threads exit */
        -:  570:    /* TODO: error handling */
        -:  571:
        -:  572:    /* init stack for iterating loggers */
      384:  573:    logger_stack_head = 0;
      384:  574:    logger_stack_tail = 0;
      384:  575:    pthread_key_create(&logger_key, NULL);
        -:  576:
      384:  577:    if (start_logger_thread() != 0) {
    #####:  578:        abort();
        -:  579:    }
        -:  580:
        -:  581:    /* This can be removed once the global stats initializer is improved */
      384:  582:    STATS_LOCK();
      384:  583:    stats.log_worker_dropped = 0;
      384:  584:    stats.log_worker_written = 0;
      384:  585:    stats.log_watcher_skipped = 0;
      384:  586:    stats.log_watcher_sent = 0;
      384:  587:    STATS_UNLOCK();
        -:  588:    /* This is what adding a STDERR watcher looks like. should replace old
        -:  589:     * "verbose" settings. */
        -:  590:    //logger_add_watcher(NULL, 0);
      384:  591:    return;
        -:  592:}
------------------
logger_init:
       96:  568:void logger_init(void) {
        -:  569:    /* TODO: auto destructor when threads exit */
        -:  570:    /* TODO: error handling */
        -:  571:
        -:  572:    /* init stack for iterating loggers */
       96:  573:    logger_stack_head = 0;
       96:  574:    logger_stack_tail = 0;
       96:  575:    pthread_key_create(&logger_key, NULL);
        -:  576:
       96:  577:    if (start_logger_thread() != 0) {
    #####:  578:        abort();
        -:  579:    }
        -:  580:
        -:  581:    /* This can be removed once the global stats initializer is improved */
       96:  582:    STATS_LOCK();
       96:  583:    stats.log_worker_dropped = 0;
       96:  584:    stats.log_worker_written = 0;
       96:  585:    stats.log_watcher_skipped = 0;
       96:  586:    stats.log_watcher_sent = 0;
       96:  587:    STATS_UNLOCK();
        -:  588:    /* This is what adding a STDERR watcher looks like. should replace old
        -:  589:     * "verbose" settings. */
        -:  590:    //logger_add_watcher(NULL, 0);
       96:  591:    return;
        -:  592:}
------------------
logger_init:
       96:  568:void logger_init(void) {
        -:  569:    /* TODO: auto destructor when threads exit */
        -:  570:    /* TODO: error handling */
        -:  571:
        -:  572:    /* init stack for iterating loggers */
       96:  573:    logger_stack_head = 0;
       96:  574:    logger_stack_tail = 0;
       96:  575:    pthread_key_create(&logger_key, NULL);
        -:  576:
       96:  577:    if (start_logger_thread() != 0) {
    #####:  578:        abort();
        -:  579:    }
        -:  580:
        -:  581:    /* This can be removed once the global stats initializer is improved */
       96:  582:    STATS_LOCK();
       96:  583:    stats.log_worker_dropped = 0;
       96:  584:    stats.log_worker_written = 0;
       96:  585:    stats.log_watcher_skipped = 0;
       96:  586:    stats.log_watcher_sent = 0;
       96:  587:    STATS_UNLOCK();
        -:  588:    /* This is what adding a STDERR watcher looks like. should replace old
        -:  589:     * "verbose" settings. */
        -:  590:    //logger_add_watcher(NULL, 0);
       96:  591:    return;
        -:  592:}
------------------
logger_init:
       96:  568:void logger_init(void) {
        -:  569:    /* TODO: auto destructor when threads exit */
        -:  570:    /* TODO: error handling */
        -:  571:
        -:  572:    /* init stack for iterating loggers */
       96:  573:    logger_stack_head = 0;
       96:  574:    logger_stack_tail = 0;
       96:  575:    pthread_key_create(&logger_key, NULL);
        -:  576:
       96:  577:    if (start_logger_thread() != 0) {
    #####:  578:        abort();
        -:  579:    }
        -:  580:
        -:  581:    /* This can be removed once the global stats initializer is improved */
       96:  582:    STATS_LOCK();
       96:  583:    stats.log_worker_dropped = 0;
       96:  584:    stats.log_worker_written = 0;
       96:  585:    stats.log_watcher_skipped = 0;
       96:  586:    stats.log_watcher_sent = 0;
       96:  587:    STATS_UNLOCK();
        -:  588:    /* This is what adding a STDERR watcher looks like. should replace old
        -:  589:     * "verbose" settings. */
        -:  590:    //logger_add_watcher(NULL, 0);
       96:  591:    return;
        -:  592:}
------------------
logger_init:
       96:  568:void logger_init(void) {
        -:  569:    /* TODO: auto destructor when threads exit */
        -:  570:    /* TODO: error handling */
        -:  571:
        -:  572:    /* init stack for iterating loggers */
       96:  573:    logger_stack_head = 0;
       96:  574:    logger_stack_tail = 0;
       96:  575:    pthread_key_create(&logger_key, NULL);
        -:  576:
       96:  577:    if (start_logger_thread() != 0) {
    #####:  578:        abort();
        -:  579:    }
        -:  580:
        -:  581:    /* This can be removed once the global stats initializer is improved */
       96:  582:    STATS_LOCK();
       96:  583:    stats.log_worker_dropped = 0;
       96:  584:    stats.log_worker_written = 0;
       96:  585:    stats.log_watcher_skipped = 0;
       96:  586:    stats.log_watcher_sent = 0;
       96:  587:    STATS_UNLOCK();
        -:  588:    /* This is what adding a STDERR watcher looks like. should replace old
        -:  589:     * "verbose" settings. */
        -:  590:    //logger_add_watcher(NULL, 0);
       96:  591:    return;
        -:  592:}
------------------
        -:  593:
        -:  594:/* called *from* the thread using a logger.
        -:  595: * initializes the per-thread bipbuf, links it into the list of loggers
        -:  596: */
     1888:  597:logger *logger_create(void) {
     1888:  598:    L_DEBUG("LOGGER: Creating and linking new logger instance\n");
     1888:  599:    logger *l = calloc(1, sizeof(logger));
     1888:  600:    if (l == NULL) {
        -:  601:        return NULL;
        -:  602:    }
        -:  603:
     1888:  604:    l->buf = bipbuf_new(settings.logger_buf_size);
     1888:  605:    if (l->buf == NULL) {
    #####:  606:        free(l);
    #####:  607:        return NULL;
        -:  608:    }
        -:  609:
     1888:  610:    l->entry_map = default_entries;
        -:  611:
     1888:  612:    pthread_mutex_init(&l->mutex, NULL);
     1888:  613:    pthread_setspecific(logger_key, l);
        -:  614:
        -:  615:    /* add to list of loggers */
     1888:  616:    logger_link_q(l);
     1888:  617:    return l;
        -:  618:}
------------------
logger_create:
      472:  597:logger *logger_create(void) {
      472:  598:    L_DEBUG("LOGGER: Creating and linking new logger instance\n");
      472:  599:    logger *l = calloc(1, sizeof(logger));
      472:  600:    if (l == NULL) {
        -:  601:        return NULL;
        -:  602:    }
        -:  603:
      472:  604:    l->buf = bipbuf_new(settings.logger_buf_size);
      472:  605:    if (l->buf == NULL) {
    #####:  606:        free(l);
    #####:  607:        return NULL;
        -:  608:    }
        -:  609:
      472:  610:    l->entry_map = default_entries;
        -:  611:
      472:  612:    pthread_mutex_init(&l->mutex, NULL);
      472:  613:    pthread_setspecific(logger_key, l);
        -:  614:
        -:  615:    /* add to list of loggers */
      472:  616:    logger_link_q(l);
      472:  617:    return l;
        -:  618:}
------------------
logger_create:
      472:  597:logger *logger_create(void) {
      472:  598:    L_DEBUG("LOGGER: Creating and linking new logger instance\n");
      472:  599:    logger *l = calloc(1, sizeof(logger));
      472:  600:    if (l == NULL) {
        -:  601:        return NULL;
        -:  602:    }
        -:  603:
      472:  604:    l->buf = bipbuf_new(settings.logger_buf_size);
      472:  605:    if (l->buf == NULL) {
    #####:  606:        free(l);
    #####:  607:        return NULL;
        -:  608:    }
        -:  609:
      472:  610:    l->entry_map = default_entries;
        -:  611:
      472:  612:    pthread_mutex_init(&l->mutex, NULL);
      472:  613:    pthread_setspecific(logger_key, l);
        -:  614:
        -:  615:    /* add to list of loggers */
      472:  616:    logger_link_q(l);
      472:  617:    return l;
        -:  618:}
------------------
logger_create:
      472:  597:logger *logger_create(void) {
      472:  598:    L_DEBUG("LOGGER: Creating and linking new logger instance\n");
      472:  599:    logger *l = calloc(1, sizeof(logger));
      472:  600:    if (l == NULL) {
        -:  601:        return NULL;
        -:  602:    }
        -:  603:
      472:  604:    l->buf = bipbuf_new(settings.logger_buf_size);
      472:  605:    if (l->buf == NULL) {
    #####:  606:        free(l);
    #####:  607:        return NULL;
        -:  608:    }
        -:  609:
      472:  610:    l->entry_map = default_entries;
        -:  611:
      472:  612:    pthread_mutex_init(&l->mutex, NULL);
      472:  613:    pthread_setspecific(logger_key, l);
        -:  614:
        -:  615:    /* add to list of loggers */
      472:  616:    logger_link_q(l);
      472:  617:    return l;
        -:  618:}
------------------
logger_create:
      472:  597:logger *logger_create(void) {
      472:  598:    L_DEBUG("LOGGER: Creating and linking new logger instance\n");
      472:  599:    logger *l = calloc(1, sizeof(logger));
      472:  600:    if (l == NULL) {
        -:  601:        return NULL;
        -:  602:    }
        -:  603:
      472:  604:    l->buf = bipbuf_new(settings.logger_buf_size);
      472:  605:    if (l->buf == NULL) {
    #####:  606:        free(l);
    #####:  607:        return NULL;
        -:  608:    }
        -:  609:
      472:  610:    l->entry_map = default_entries;
        -:  611:
      472:  612:    pthread_mutex_init(&l->mutex, NULL);
      472:  613:    pthread_setspecific(logger_key, l);
        -:  614:
        -:  615:    /* add to list of loggers */
      472:  616:    logger_link_q(l);
      472:  617:    return l;
        -:  618:}
------------------
        -:  619:
        -:  620:/* helpers for logger_log */
        -:  621:
        4:  622:static void _logger_log_evictions(logentry *e, item *it) {
        4:  623:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
       4*:  624:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
        4:  625:    le->latime = current_time - it->time;
        4:  626:    le->it_flags = it->it_flags;
        4:  627:    le->nkey = it->nkey;
        4:  628:    le->clsid = ITEM_clsid(it);
        8:  629:    memcpy(le->key, ITEM_key(it), it->nkey);
        4:  630:    e->size = sizeof(struct logentry_eviction) + le->nkey;
        4:  631:}
------------------
_logger_log_evictions:
        1:  622:static void _logger_log_evictions(logentry *e, item *it) {
        1:  623:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
       1*:  624:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
        1:  625:    le->latime = current_time - it->time;
        1:  626:    le->it_flags = it->it_flags;
        1:  627:    le->nkey = it->nkey;
        1:  628:    le->clsid = ITEM_clsid(it);
        2:  629:    memcpy(le->key, ITEM_key(it), it->nkey);
        1:  630:    e->size = sizeof(struct logentry_eviction) + le->nkey;
        1:  631:}
------------------
_logger_log_evictions:
        1:  622:static void _logger_log_evictions(logentry *e, item *it) {
        1:  623:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
       1*:  624:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
        1:  625:    le->latime = current_time - it->time;
        1:  626:    le->it_flags = it->it_flags;
        1:  627:    le->nkey = it->nkey;
        1:  628:    le->clsid = ITEM_clsid(it);
        2:  629:    memcpy(le->key, ITEM_key(it), it->nkey);
        1:  630:    e->size = sizeof(struct logentry_eviction) + le->nkey;
        1:  631:}
------------------
_logger_log_evictions:
        1:  622:static void _logger_log_evictions(logentry *e, item *it) {
        1:  623:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
       1*:  624:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
        1:  625:    le->latime = current_time - it->time;
        1:  626:    le->it_flags = it->it_flags;
        1:  627:    le->nkey = it->nkey;
        1:  628:    le->clsid = ITEM_clsid(it);
        2:  629:    memcpy(le->key, ITEM_key(it), it->nkey);
        1:  630:    e->size = sizeof(struct logentry_eviction) + le->nkey;
        1:  631:}
------------------
_logger_log_evictions:
        1:  622:static void _logger_log_evictions(logentry *e, item *it) {
        1:  623:    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
       1*:  624:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
        1:  625:    le->latime = current_time - it->time;
        1:  626:    le->it_flags = it->it_flags;
        1:  627:    le->nkey = it->nkey;
        1:  628:    le->clsid = ITEM_clsid(it);
        2:  629:    memcpy(le->key, ITEM_key(it), it->nkey);
        1:  630:    e->size = sizeof(struct logentry_eviction) + le->nkey;
        1:  631:}
------------------
        -:  632:#ifdef EXTSTORE
        -:  633:/* TODO: When more logging endpoints are done and the extstore API has matured
        -:  634: * more, this could be merged with above and print different types of
        -:  635: * expulsion events.
        -:  636: */
        -:  637:static void _logger_log_ext_write(logentry *e, item *it, uint8_t bucket) {
        -:  638:    struct logentry_ext_write *le = (struct logentry_ext_write *) e->data;
        -:  639:    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
        -:  640:    le->latime = current_time - it->time;
        -:  641:    le->it_flags = it->it_flags;
        -:  642:    le->nkey = it->nkey;
        -:  643:    le->clsid = ITEM_clsid(it);
        -:  644:    le->bucket = bucket;
        -:  645:    memcpy(le->key, ITEM_key(it), it->nkey);
        -:  646:    e->size = sizeof(struct logentry_ext_write) + le->nkey;
        -:  647:}
        -:  648:#endif
        -:  649:/* 0 == nf, 1 == found. 2 == flushed. 3 == expired.
        -:  650: * might be useful to store/print the flags an item has?
        -:  651: * could also collapse this and above code into an "item status" struct. wait
        -:  652: * for more endpoints to be written before making it generic, though.
        -:  653: * TODO: This and below should track and reprint the client fd.
        -:  654: */
        -:  655:static void _logger_log_item_get(logentry *e, const int was_found, const char *key,
        -:  656:        const int nkey, const uint8_t clsid) {
   291240:  657:    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
   291240:  658:    le->was_found = was_found;
   291240:  659:    le->nkey = nkey;
   291240:  660:    le->clsid = clsid;
   582480:  661:    memcpy(le->key, key, nkey);
   291240:  662:    e->size = sizeof(struct logentry_item_get) + nkey;
        -:  663:}
        -:  664:
        -:  665:static void _logger_log_item_store(logentry *e, const enum store_item_type status,
        -:  666:        const int comm, char *key, const int nkey, rel_time_t ttl, const uint8_t clsid) {
     1136:  667:    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
     1136:  668:    le->status = status;
     1136:  669:    le->cmd = comm;
     1136:  670:    le->nkey = nkey;
     1136:  671:    le->clsid = clsid;
     1136:  672:    if (ttl != 0) {
    #####:  673:        le->ttl = ttl - current_time;
        -:  674:    } else {
     1136:  675:        le->ttl = 0;
        -:  676:    }
     1136:  677:    memcpy(le->key, key, nkey);
     1136:  678:    e->size = sizeof(struct logentry_item_store) + nkey;
        -:  679:}
        -:  680:
        -:  681:/* Public function for logging an entry.
        -:  682: * Tries to encapsulate as much of the formatting as possible to simplify the
        -:  683: * caller's code.
        -:  684: */
   322292:  685:enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
   322292:  686:    bipbuf_t *buf = l->buf;
   322292:  687:    bool nospace = false;
   322292:  688:    va_list ap;
   322292:  689:    int total = 0;
   322292:  690:    logentry *e;
        -:  691:
   322292:  692:    const entry_details *d = &l->entry_map[event];
   322292:  693:    int reqlen = d->reqlen;
        -:  694:
   322292:  695:    pthread_mutex_lock(&l->mutex);
        -:  696:    /* Request a maximum length of data to write to */
   322292:  697:    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
   322292:  698:    if (e == NULL) {
    29912:  699:        pthread_mutex_unlock(&l->mutex);
    29912:  700:        l->dropped++;
    29912:  701:        return LOGGER_RET_NOSPACE;
        -:  702:    }
   292380:  703:    e->event = d->subtype;
   292380:  704:    e->pad = 0;
   584760:  705:    e->gid = logger_get_gid();
        -:  706:    /* TODO: Could pass this down as an argument now that we're using
        -:  707:     * LOGGER_LOG() macro.
        -:  708:     */
   292380:  709:    e->eflags = d->eflags;
        -:  710:    /* Noting time isn't optional. A feature may be added to avoid rendering
        -:  711:     * time and/or gid to a logger.
        -:  712:     */
   292380:  713:    gettimeofday(&e->tv, NULL);
        -:  714:
   292380:  715:    switch (d->subtype) {
    #####:  716:        case LOGGER_TEXT_ENTRY:
    #####:  717:            va_start(ap, entry);
    #####:  718:            total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    #####:  719:            va_end(ap);
    #####:  720:            if (total >= reqlen || total <= 0) {
    #####:  721:                fprintf(stderr, "LOGGER: Failed to vsnprintf a text entry: (total) %d\n", total);
        -:  722:                break;
        -:  723:            }
    #####:  724:            e->size = total + 1; /* null byte */
        -:  725:
    #####:  726:            break;
        4:  727:        case LOGGER_EVICTION_ENTRY:
        4:  728:            _logger_log_evictions(e, (item *)entry);
        4:  729:            break;
        -:  730:#ifdef EXTSTORE
        -:  731:        case LOGGER_EXT_WRITE_ENTRY:
        -:  732:            va_start(ap, entry);
        -:  733:            int ew_bucket = va_arg(ap, int);
        -:  734:            va_end(ap);
        -:  735:            _logger_log_ext_write(e, (item *)entry, ew_bucket);
        -:  736:            break;
        -:  737:#endif
   291240:  738:        case LOGGER_ITEM_GET_ENTRY:
   291240:  739:            va_start(ap, entry);
   291240:  740:            int was_found = va_arg(ap, int);
   291240:  741:            char *key = va_arg(ap, char *);
   291240:  742:            size_t nkey = va_arg(ap, size_t);
   291240:  743:            uint8_t gclsid = va_arg(ap, int);
   291240:  744:            _logger_log_item_get(e, was_found, key, nkey, gclsid);
   291240:  745:            va_end(ap);
   291240:  746:            break;
     1136:  747:        case LOGGER_ITEM_STORE_ENTRY:
     1136:  748:            va_start(ap, entry);
     1136:  749:            enum store_item_type status = va_arg(ap, enum store_item_type);
     1136:  750:            int comm = va_arg(ap, int);
     1136:  751:            char *skey = va_arg(ap, char *);
     1136:  752:            size_t snkey = va_arg(ap, size_t);
     1136:  753:            rel_time_t sttl = va_arg(ap, rel_time_t);
     1136:  754:            uint8_t sclsid = va_arg(ap, int);
     1136:  755:            _logger_log_item_store(e, status, comm, skey, snkey, sttl, sclsid);
     1136:  756:            va_end(ap);
     1136:  757:            break;
        -:  758:    }
        -:  759:
        -:  760:#ifdef NEED_ALIGN
        -:  761:    /* Need to ensure *next* request is aligned. */
        -:  762:    if (sizeof(logentry) + e->size % 8 != 0) {
        -:  763:        e->pad = 8 - (sizeof(logentry) + e->size % 8);
        -:  764:    }
        -:  765:#endif
        -:  766:
        -:  767:    /* Push pointer forward by the actual amount required */
   292380:  768:    if (bipbuf_push(buf, (sizeof(logentry) + e->size + e->pad)) == 0) {
    #####:  769:        fprintf(stderr, "LOGGER: Failed to bipbuf push a text entry\n");
    #####:  770:        pthread_mutex_unlock(&l->mutex);
    #####:  771:        return LOGGER_RET_ERR;
        -:  772:    }
   292380:  773:    l->written++;
        -:  774:    L_DEBUG("LOGGER: Requested %d bytes, wrote %lu bytes\n", reqlen,
   292380:  775:            (sizeof(logentry) + e->size));
        -:  776:
   292380:  777:    pthread_mutex_unlock(&l->mutex);
        -:  778:
   292380:  779:    if (nospace) {
        -:  780:        return LOGGER_RET_NOSPACE;
        -:  781:    } else {
   292380:  782:        return LOGGER_RET_OK;
        -:  783:    }
        -:  784:}
------------------
logger_log:
    80573:  685:enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    80573:  686:    bipbuf_t *buf = l->buf;
    80573:  687:    bool nospace = false;
    80573:  688:    va_list ap;
    80573:  689:    int total = 0;
    80573:  690:    logentry *e;
        -:  691:
    80573:  692:    const entry_details *d = &l->entry_map[event];
    80573:  693:    int reqlen = d->reqlen;
        -:  694:
    80573:  695:    pthread_mutex_lock(&l->mutex);
        -:  696:    /* Request a maximum length of data to write to */
    80573:  697:    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    80573:  698:    if (e == NULL) {
     7478:  699:        pthread_mutex_unlock(&l->mutex);
     7478:  700:        l->dropped++;
     7478:  701:        return LOGGER_RET_NOSPACE;
        -:  702:    }
    73095:  703:    e->event = d->subtype;
    73095:  704:    e->pad = 0;
   146190:  705:    e->gid = logger_get_gid();
        -:  706:    /* TODO: Could pass this down as an argument now that we're using
        -:  707:     * LOGGER_LOG() macro.
        -:  708:     */
    73095:  709:    e->eflags = d->eflags;
        -:  710:    /* Noting time isn't optional. A feature may be added to avoid rendering
        -:  711:     * time and/or gid to a logger.
        -:  712:     */
    73095:  713:    gettimeofday(&e->tv, NULL);
        -:  714:
    73095:  715:    switch (d->subtype) {
    #####:  716:        case LOGGER_TEXT_ENTRY:
    #####:  717:            va_start(ap, entry);
    #####:  718:            total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    #####:  719:            va_end(ap);
    #####:  720:            if (total >= reqlen || total <= 0) {
    #####:  721:                fprintf(stderr, "LOGGER: Failed to vsnprintf a text entry: (total) %d\n", total);
        -:  722:                break;
        -:  723:            }
    #####:  724:            e->size = total + 1; /* null byte */
        -:  725:
    #####:  726:            break;
        1:  727:        case LOGGER_EVICTION_ENTRY:
        1:  728:            _logger_log_evictions(e, (item *)entry);
        1:  729:            break;
        -:  730:#ifdef EXTSTORE
        -:  731:        case LOGGER_EXT_WRITE_ENTRY:
        -:  732:            va_start(ap, entry);
        -:  733:            int ew_bucket = va_arg(ap, int);
        -:  734:            va_end(ap);
        -:  735:            _logger_log_ext_write(e, (item *)entry, ew_bucket);
        -:  736:            break;
        -:  737:#endif
    72810:  738:        case LOGGER_ITEM_GET_ENTRY:
    72810:  739:            va_start(ap, entry);
    72810:  740:            int was_found = va_arg(ap, int);
    72810:  741:            char *key = va_arg(ap, char *);
    72810:  742:            size_t nkey = va_arg(ap, size_t);
    72810:  743:            uint8_t gclsid = va_arg(ap, int);
    72810:  744:            _logger_log_item_get(e, was_found, key, nkey, gclsid);
    72810:  745:            va_end(ap);
    72810:  746:            break;
      284:  747:        case LOGGER_ITEM_STORE_ENTRY:
      284:  748:            va_start(ap, entry);
      284:  749:            enum store_item_type status = va_arg(ap, enum store_item_type);
      284:  750:            int comm = va_arg(ap, int);
      284:  751:            char *skey = va_arg(ap, char *);
      284:  752:            size_t snkey = va_arg(ap, size_t);
      284:  753:            rel_time_t sttl = va_arg(ap, rel_time_t);
      284:  754:            uint8_t sclsid = va_arg(ap, int);
      284:  755:            _logger_log_item_store(e, status, comm, skey, snkey, sttl, sclsid);
      284:  756:            va_end(ap);
      284:  757:            break;
        -:  758:    }
        -:  759:
        -:  760:#ifdef NEED_ALIGN
        -:  761:    /* Need to ensure *next* request is aligned. */
        -:  762:    if (sizeof(logentry) + e->size % 8 != 0) {
        -:  763:        e->pad = 8 - (sizeof(logentry) + e->size % 8);
        -:  764:    }
        -:  765:#endif
        -:  766:
        -:  767:    /* Push pointer forward by the actual amount required */
    73095:  768:    if (bipbuf_push(buf, (sizeof(logentry) + e->size + e->pad)) == 0) {
    #####:  769:        fprintf(stderr, "LOGGER: Failed to bipbuf push a text entry\n");
    #####:  770:        pthread_mutex_unlock(&l->mutex);
    #####:  771:        return LOGGER_RET_ERR;
        -:  772:    }
    73095:  773:    l->written++;
        -:  774:    L_DEBUG("LOGGER: Requested %d bytes, wrote %lu bytes\n", reqlen,
    73095:  775:            (sizeof(logentry) + e->size));
        -:  776:
    73095:  777:    pthread_mutex_unlock(&l->mutex);
        -:  778:
    73095:  779:    if (nospace) {
        -:  780:        return LOGGER_RET_NOSPACE;
        -:  781:    } else {
    73095:  782:        return LOGGER_RET_OK;
        -:  783:    }
        -:  784:}
------------------
logger_log:
    80573:  685:enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    80573:  686:    bipbuf_t *buf = l->buf;
    80573:  687:    bool nospace = false;
    80573:  688:    va_list ap;
    80573:  689:    int total = 0;
    80573:  690:    logentry *e;
        -:  691:
    80573:  692:    const entry_details *d = &l->entry_map[event];
    80573:  693:    int reqlen = d->reqlen;
        -:  694:
    80573:  695:    pthread_mutex_lock(&l->mutex);
        -:  696:    /* Request a maximum length of data to write to */
    80573:  697:    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    80573:  698:    if (e == NULL) {
     7478:  699:        pthread_mutex_unlock(&l->mutex);
     7478:  700:        l->dropped++;
     7478:  701:        return LOGGER_RET_NOSPACE;
        -:  702:    }
    73095:  703:    e->event = d->subtype;
    73095:  704:    e->pad = 0;
   146190:  705:    e->gid = logger_get_gid();
        -:  706:    /* TODO: Could pass this down as an argument now that we're using
        -:  707:     * LOGGER_LOG() macro.
        -:  708:     */
    73095:  709:    e->eflags = d->eflags;
        -:  710:    /* Noting time isn't optional. A feature may be added to avoid rendering
        -:  711:     * time and/or gid to a logger.
        -:  712:     */
    73095:  713:    gettimeofday(&e->tv, NULL);
        -:  714:
    73095:  715:    switch (d->subtype) {
    #####:  716:        case LOGGER_TEXT_ENTRY:
    #####:  717:            va_start(ap, entry);
    #####:  718:            total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    #####:  719:            va_end(ap);
    #####:  720:            if (total >= reqlen || total <= 0) {
    #####:  721:                fprintf(stderr, "LOGGER: Failed to vsnprintf a text entry: (total) %d\n", total);
        -:  722:                break;
        -:  723:            }
    #####:  724:            e->size = total + 1; /* null byte */
        -:  725:
    #####:  726:            break;
        1:  727:        case LOGGER_EVICTION_ENTRY:
        1:  728:            _logger_log_evictions(e, (item *)entry);
        1:  729:            break;
        -:  730:#ifdef EXTSTORE
        -:  731:        case LOGGER_EXT_WRITE_ENTRY:
        -:  732:            va_start(ap, entry);
        -:  733:            int ew_bucket = va_arg(ap, int);
        -:  734:            va_end(ap);
        -:  735:            _logger_log_ext_write(e, (item *)entry, ew_bucket);
        -:  736:            break;
        -:  737:#endif
    72810:  738:        case LOGGER_ITEM_GET_ENTRY:
    72810:  739:            va_start(ap, entry);
    72810:  740:            int was_found = va_arg(ap, int);
    72810:  741:            char *key = va_arg(ap, char *);
    72810:  742:            size_t nkey = va_arg(ap, size_t);
    72810:  743:            uint8_t gclsid = va_arg(ap, int);
    72810:  744:            _logger_log_item_get(e, was_found, key, nkey, gclsid);
    72810:  745:            va_end(ap);
    72810:  746:            break;
      284:  747:        case LOGGER_ITEM_STORE_ENTRY:
      284:  748:            va_start(ap, entry);
      284:  749:            enum store_item_type status = va_arg(ap, enum store_item_type);
      284:  750:            int comm = va_arg(ap, int);
      284:  751:            char *skey = va_arg(ap, char *);
      284:  752:            size_t snkey = va_arg(ap, size_t);
      284:  753:            rel_time_t sttl = va_arg(ap, rel_time_t);
      284:  754:            uint8_t sclsid = va_arg(ap, int);
      284:  755:            _logger_log_item_store(e, status, comm, skey, snkey, sttl, sclsid);
      284:  756:            va_end(ap);
      284:  757:            break;
        -:  758:    }
        -:  759:
        -:  760:#ifdef NEED_ALIGN
        -:  761:    /* Need to ensure *next* request is aligned. */
        -:  762:    if (sizeof(logentry) + e->size % 8 != 0) {
        -:  763:        e->pad = 8 - (sizeof(logentry) + e->size % 8);
        -:  764:    }
        -:  765:#endif
        -:  766:
        -:  767:    /* Push pointer forward by the actual amount required */
    73095:  768:    if (bipbuf_push(buf, (sizeof(logentry) + e->size + e->pad)) == 0) {
    #####:  769:        fprintf(stderr, "LOGGER: Failed to bipbuf push a text entry\n");
    #####:  770:        pthread_mutex_unlock(&l->mutex);
    #####:  771:        return LOGGER_RET_ERR;
        -:  772:    }
    73095:  773:    l->written++;
        -:  774:    L_DEBUG("LOGGER: Requested %d bytes, wrote %lu bytes\n", reqlen,
    73095:  775:            (sizeof(logentry) + e->size));
        -:  776:
    73095:  777:    pthread_mutex_unlock(&l->mutex);
        -:  778:
    73095:  779:    if (nospace) {
        -:  780:        return LOGGER_RET_NOSPACE;
        -:  781:    } else {
    73095:  782:        return LOGGER_RET_OK;
        -:  783:    }
        -:  784:}
------------------
logger_log:
    80573:  685:enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    80573:  686:    bipbuf_t *buf = l->buf;
    80573:  687:    bool nospace = false;
    80573:  688:    va_list ap;
    80573:  689:    int total = 0;
    80573:  690:    logentry *e;
        -:  691:
    80573:  692:    const entry_details *d = &l->entry_map[event];
    80573:  693:    int reqlen = d->reqlen;
        -:  694:
    80573:  695:    pthread_mutex_lock(&l->mutex);
        -:  696:    /* Request a maximum length of data to write to */
    80573:  697:    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    80573:  698:    if (e == NULL) {
     7478:  699:        pthread_mutex_unlock(&l->mutex);
     7478:  700:        l->dropped++;
     7478:  701:        return LOGGER_RET_NOSPACE;
        -:  702:    }
    73095:  703:    e->event = d->subtype;
    73095:  704:    e->pad = 0;
   146190:  705:    e->gid = logger_get_gid();
        -:  706:    /* TODO: Could pass this down as an argument now that we're using
        -:  707:     * LOGGER_LOG() macro.
        -:  708:     */
    73095:  709:    e->eflags = d->eflags;
        -:  710:    /* Noting time isn't optional. A feature may be added to avoid rendering
        -:  711:     * time and/or gid to a logger.
        -:  712:     */
    73095:  713:    gettimeofday(&e->tv, NULL);
        -:  714:
    73095:  715:    switch (d->subtype) {
    #####:  716:        case LOGGER_TEXT_ENTRY:
    #####:  717:            va_start(ap, entry);
    #####:  718:            total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    #####:  719:            va_end(ap);
    #####:  720:            if (total >= reqlen || total <= 0) {
    #####:  721:                fprintf(stderr, "LOGGER: Failed to vsnprintf a text entry: (total) %d\n", total);
        -:  722:                break;
        -:  723:            }
    #####:  724:            e->size = total + 1; /* null byte */
        -:  725:
    #####:  726:            break;
        1:  727:        case LOGGER_EVICTION_ENTRY:
        1:  728:            _logger_log_evictions(e, (item *)entry);
        1:  729:            break;
        -:  730:#ifdef EXTSTORE
        -:  731:        case LOGGER_EXT_WRITE_ENTRY:
        -:  732:            va_start(ap, entry);
        -:  733:            int ew_bucket = va_arg(ap, int);
        -:  734:            va_end(ap);
        -:  735:            _logger_log_ext_write(e, (item *)entry, ew_bucket);
        -:  736:            break;
        -:  737:#endif
    72810:  738:        case LOGGER_ITEM_GET_ENTRY:
    72810:  739:            va_start(ap, entry);
    72810:  740:            int was_found = va_arg(ap, int);
    72810:  741:            char *key = va_arg(ap, char *);
    72810:  742:            size_t nkey = va_arg(ap, size_t);
    72810:  743:            uint8_t gclsid = va_arg(ap, int);
    72810:  744:            _logger_log_item_get(e, was_found, key, nkey, gclsid);
    72810:  745:            va_end(ap);
    72810:  746:            break;
      284:  747:        case LOGGER_ITEM_STORE_ENTRY:
      284:  748:            va_start(ap, entry);
      284:  749:            enum store_item_type status = va_arg(ap, enum store_item_type);
      284:  750:            int comm = va_arg(ap, int);
      284:  751:            char *skey = va_arg(ap, char *);
      284:  752:            size_t snkey = va_arg(ap, size_t);
      284:  753:            rel_time_t sttl = va_arg(ap, rel_time_t);
      284:  754:            uint8_t sclsid = va_arg(ap, int);
      284:  755:            _logger_log_item_store(e, status, comm, skey, snkey, sttl, sclsid);
      284:  756:            va_end(ap);
      284:  757:            break;
        -:  758:    }
        -:  759:
        -:  760:#ifdef NEED_ALIGN
        -:  761:    /* Need to ensure *next* request is aligned. */
        -:  762:    if (sizeof(logentry) + e->size % 8 != 0) {
        -:  763:        e->pad = 8 - (sizeof(logentry) + e->size % 8);
        -:  764:    }
        -:  765:#endif
        -:  766:
        -:  767:    /* Push pointer forward by the actual amount required */
    73095:  768:    if (bipbuf_push(buf, (sizeof(logentry) + e->size + e->pad)) == 0) {
    #####:  769:        fprintf(stderr, "LOGGER: Failed to bipbuf push a text entry\n");
    #####:  770:        pthread_mutex_unlock(&l->mutex);
    #####:  771:        return LOGGER_RET_ERR;
        -:  772:    }
    73095:  773:    l->written++;
        -:  774:    L_DEBUG("LOGGER: Requested %d bytes, wrote %lu bytes\n", reqlen,
    73095:  775:            (sizeof(logentry) + e->size));
        -:  776:
    73095:  777:    pthread_mutex_unlock(&l->mutex);
        -:  778:
    73095:  779:    if (nospace) {
        -:  780:        return LOGGER_RET_NOSPACE;
        -:  781:    } else {
    73095:  782:        return LOGGER_RET_OK;
        -:  783:    }
        -:  784:}
------------------
logger_log:
    80573:  685:enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    80573:  686:    bipbuf_t *buf = l->buf;
    80573:  687:    bool nospace = false;
    80573:  688:    va_list ap;
    80573:  689:    int total = 0;
    80573:  690:    logentry *e;
        -:  691:
    80573:  692:    const entry_details *d = &l->entry_map[event];
    80573:  693:    int reqlen = d->reqlen;
        -:  694:
    80573:  695:    pthread_mutex_lock(&l->mutex);
        -:  696:    /* Request a maximum length of data to write to */
    80573:  697:    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    80573:  698:    if (e == NULL) {
     7478:  699:        pthread_mutex_unlock(&l->mutex);
     7478:  700:        l->dropped++;
     7478:  701:        return LOGGER_RET_NOSPACE;
        -:  702:    }
    73095:  703:    e->event = d->subtype;
    73095:  704:    e->pad = 0;
   146190:  705:    e->gid = logger_get_gid();
        -:  706:    /* TODO: Could pass this down as an argument now that we're using
        -:  707:     * LOGGER_LOG() macro.
        -:  708:     */
    73095:  709:    e->eflags = d->eflags;
        -:  710:    /* Noting time isn't optional. A feature may be added to avoid rendering
        -:  711:     * time and/or gid to a logger.
        -:  712:     */
    73095:  713:    gettimeofday(&e->tv, NULL);
        -:  714:
    73095:  715:    switch (d->subtype) {
    #####:  716:        case LOGGER_TEXT_ENTRY:
    #####:  717:            va_start(ap, entry);
    #####:  718:            total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    #####:  719:            va_end(ap);
    #####:  720:            if (total >= reqlen || total <= 0) {
    #####:  721:                fprintf(stderr, "LOGGER: Failed to vsnprintf a text entry: (total) %d\n", total);
        -:  722:                break;
        -:  723:            }
    #####:  724:            e->size = total + 1; /* null byte */
        -:  725:
    #####:  726:            break;
        1:  727:        case LOGGER_EVICTION_ENTRY:
        1:  728:            _logger_log_evictions(e, (item *)entry);
        1:  729:            break;
        -:  730:#ifdef EXTSTORE
        -:  731:        case LOGGER_EXT_WRITE_ENTRY:
        -:  732:            va_start(ap, entry);
        -:  733:            int ew_bucket = va_arg(ap, int);
        -:  734:            va_end(ap);
        -:  735:            _logger_log_ext_write(e, (item *)entry, ew_bucket);
        -:  736:            break;
        -:  737:#endif
    72810:  738:        case LOGGER_ITEM_GET_ENTRY:
    72810:  739:            va_start(ap, entry);
    72810:  740:            int was_found = va_arg(ap, int);
    72810:  741:            char *key = va_arg(ap, char *);
    72810:  742:            size_t nkey = va_arg(ap, size_t);
    72810:  743:            uint8_t gclsid = va_arg(ap, int);
    72810:  744:            _logger_log_item_get(e, was_found, key, nkey, gclsid);
    72810:  745:            va_end(ap);
    72810:  746:            break;
      284:  747:        case LOGGER_ITEM_STORE_ENTRY:
      284:  748:            va_start(ap, entry);
      284:  749:            enum store_item_type status = va_arg(ap, enum store_item_type);
      284:  750:            int comm = va_arg(ap, int);
      284:  751:            char *skey = va_arg(ap, char *);
      284:  752:            size_t snkey = va_arg(ap, size_t);
      284:  753:            rel_time_t sttl = va_arg(ap, rel_time_t);
      284:  754:            uint8_t sclsid = va_arg(ap, int);
      284:  755:            _logger_log_item_store(e, status, comm, skey, snkey, sttl, sclsid);
      284:  756:            va_end(ap);
      284:  757:            break;
        -:  758:    }
        -:  759:
        -:  760:#ifdef NEED_ALIGN
        -:  761:    /* Need to ensure *next* request is aligned. */
        -:  762:    if (sizeof(logentry) + e->size % 8 != 0) {
        -:  763:        e->pad = 8 - (sizeof(logentry) + e->size % 8);
        -:  764:    }
        -:  765:#endif
        -:  766:
        -:  767:    /* Push pointer forward by the actual amount required */
    73095:  768:    if (bipbuf_push(buf, (sizeof(logentry) + e->size + e->pad)) == 0) {
    #####:  769:        fprintf(stderr, "LOGGER: Failed to bipbuf push a text entry\n");
    #####:  770:        pthread_mutex_unlock(&l->mutex);
    #####:  771:        return LOGGER_RET_ERR;
        -:  772:    }
    73095:  773:    l->written++;
        -:  774:    L_DEBUG("LOGGER: Requested %d bytes, wrote %lu bytes\n", reqlen,
    73095:  775:            (sizeof(logentry) + e->size));
        -:  776:
    73095:  777:    pthread_mutex_unlock(&l->mutex);
        -:  778:
    73095:  779:    if (nospace) {
        -:  780:        return LOGGER_RET_NOSPACE;
        -:  781:    } else {
    73095:  782:        return LOGGER_RET_OK;
        -:  783:    }
        -:  784:}
------------------
        -:  785:
        -:  786:/* Passes a client connection socket from a primary worker thread to the
        -:  787: * logger thread. Caller *must* event_del() the client before handing it over.
        -:  788: * Presently there's no way to hand the client back to the worker thread.
        -:  789: */
       16:  790:enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f) {
       16:  791:    int x;
       16:  792:    logger_watcher *w = NULL;
       16:  793:    pthread_mutex_lock(&logger_stack_lock);
       16:  794:    if (watcher_count >= WATCHER_LIMIT) {
        -:  795:        return LOGGER_ADD_WATCHER_TOO_MANY;
        -:  796:    }
        -:  797:
       24:  798:    for (x = 0; x < WATCHER_LIMIT-1; x++) {
       24:  799:        if (watchers[x] == NULL)
        -:  800:            break;
        -:  801:    }
        -:  802:
       16:  803:    w = calloc(1, sizeof(logger_watcher));
       16:  804:    if (w == NULL) {
    #####:  805:        pthread_mutex_unlock(&logger_stack_lock);
    #####:  806:        return LOGGER_ADD_WATCHER_FAILED;
        -:  807:    }
       16:  808:    w->c = c;
       16:  809:    w->sfd = sfd;
       16:  810:    if (sfd == 0 && c == NULL) {
    #####:  811:        w->t = LOGGER_WATCHER_STDERR;
        -:  812:    } else {
       16:  813:        w->t = LOGGER_WATCHER_CLIENT;
        -:  814:    }
       16:  815:    w->id = x;
       16:  816:    w->eflags = f;
       16:  817:    w->buf = bipbuf_new(settings.logger_watcher_buf_size);
       16:  818:    if (w->buf == NULL) {
    #####:  819:        free(w);
    #####:  820:        pthread_mutex_unlock(&logger_stack_lock);
    #####:  821:        return LOGGER_ADD_WATCHER_FAILED;
        -:  822:    }
       16:  823:    bipbuf_offer(w->buf, (unsigned char *) "OK\r\n", 4);
        -:  824:
       16:  825:    watchers[x] = w;
       16:  826:    watcher_count++;
        -:  827:    /* Update what flags the global logs will watch */
       16:  828:    logger_set_flags();
        -:  829:
       16:  830:    pthread_mutex_unlock(&logger_stack_lock);
       16:  831:    return LOGGER_ADD_WATCHER_OK;
        -:  832:}
